/**
 * Trace Serializer - Constructs and appends Agent Trace records
 * Implements the Agent Trace specification for intent-code traceability
 */

import * as fs from "fs/promises"
import * as path from "path"
import { v4 as uuidv4 } from "uuid"
import { AgentTraceRecord, AgentTraceFile, AgentTraceConversation, AgentTraceRange } from "./types"
import { ContentHasher } from "./ContentHasher"

export class TraceSerializer {
	private workspaceRoot: string
	private orchestrationDir: string

	constructor(workspaceRoot: string) {
		this.workspaceRoot = workspaceRoot
		this.orchestrationDir = path.join(workspaceRoot, ".orchestration")
	}

	/**
	 * Create and append a trace record to agent_trace.jsonl
	 * @param params Trace record parameters
	 */
	async appendTrace(params: {
		sessionId: string
		intentId: string
		filePath: string
		startLine: number
		endLine: number
		contentHash: string
		modelIdentifier: string
		mutationClass: "AST_REFACTOR" | "INTENT_EVOLUTION" | "BUG_FIX"
	}): Promise<string> {
		const traceId = uuidv4()
		const timestamp = new Date().toISOString()

		// Get git revision if available
		const gitRevision = await this.getGitRevision()

		// Convert to relative path
		const relativePath = path.relative(this.workspaceRoot, params.filePath).replace(/\\/g, "/")

		const range: AgentTraceRange = {
			start_line: params.startLine,
			end_line: params.endLine,
			content_hash: params.contentHash,
		}

		const conversation: AgentTraceConversation = {
			url: params.sessionId,
			contributor: {
				entity_type: "AI",
				model_identifier: params.modelIdentifier,
			},
			ranges: [range],
			related: [
				{
					type: "specification",
					value: params.intentId,
				},
			],
		}

		const file: AgentTraceFile = {
			relative_path: relativePath,
			conversations: [conversation],
		}

		const record: AgentTraceRecord = {
			id: traceId,
			timestamp,
			mutation_class: params.mutationClass,
			vcs: {
				type: "git",
				revision_id: gitRevision,
			},
			session_id: params.sessionId,
			files: [file],
		}

		// Append to JSONL file (one JSON object per line)
		const jsonlPath = path.join(this.orchestrationDir, "agent_trace.jsonl")
		const jsonLine = JSON.stringify(record) + "\n"

		try {
			await fs.appendFile(jsonlPath, jsonLine, "utf8")
		} catch (error) {
			// If file doesn't exist, create it
			await fs.writeFile(jsonlPath, jsonLine, "utf8")
		}

		return traceId
	}

	/**
	 * Read all trace records from agent_trace.jsonl
	 * @returns Array of trace records
	 */
	async readTraces(): Promise<AgentTraceRecord[]> {
		try {
			const jsonlPath = path.join(this.orchestrationDir, "agent_trace.jsonl")
			const content = await fs.readFile(jsonlPath, "utf8")

			const lines = content.trim().split("\n")
			return lines.filter((line) => line.trim()).map((line) => JSON.parse(line) as AgentTraceRecord)
		} catch {
			return []
		}
	}

	/**
	 * Get traces for a specific intent
	 * @param intentId The intent ID
	 * @returns Array of trace records
	 */
	async getTracesForIntent(intentId: string): Promise<AgentTraceRecord[]> {
		const allTraces = await this.readTraces()

		return allTraces.filter((trace) => {
			return trace.files.some((file) => {
				return file.conversations.some((conv) => {
					return conv.related.some((rel) => rel.type === "specification" && rel.value === intentId)
				})
			})
		})
	}

	/**
	 * Get traces for a specific file
	 * @param filePath Absolute or relative file path
	 * @returns Array of trace records
	 */
	async getTracesForFile(filePath: string): Promise<AgentTraceRecord[]> {
		const allTraces = await this.readTraces()
		const relativePath = path.relative(this.workspaceRoot, filePath).replace(/\\/g, "/")

		return allTraces.filter((trace) => {
			return trace.files.some((file) => file.relative_path === relativePath)
		})
	}

	/**
	 * Update intent_map.md with new trace entry
	 * @param intentId The intent ID
	 * @param filePath The file path
	 * @param contentHash The content hash
	 * @param traceId The trace record ID
	 */
	async updateIntentMap(intentId: string, filePath: string, contentHash: string, traceId: string): Promise<void> {
		const mapPath = path.join(this.orchestrationDir, "intent_map.md")
		const relativePath = path.relative(this.workspaceRoot, filePath).replace(/\\/g, "/")
		const timestamp = new Date().toISOString()

		// For now, append to the file (full implementation would parse and update)
		const entry = `| \`${relativePath}\` | Line 1-End | \`${contentHash.substring(0, 16)}...\` | \`${timestamp}\` | \`${traceId.substring(0, 8)}\` |\n`

		try {
			await fs.appendFile(mapPath, entry, "utf8")
		} catch {
			// Create file with header
			const header = `# Intent Spatial Map\n\n_Auto-generated by HookEngine PostToolUse. Do not edit manually._\n\n## ${intentId}\n\n| File | AST Anchor | Last Content Hash | Last Modified | Trace ID |\n|------|------------|-------------------|---------------|----------|\n`
			await fs.writeFile(mapPath, header + entry, "utf8")
		}
	}

	/**
	 * Get current git revision
	 * @returns Git SHA or "unknown"
	 */
	private async getGitRevision(): Promise<string> {
		try {
			const { execFile } = await import("child_process")
			const { promisify } = await import("util")
			const execFileAsync = promisify(execFile)

			const { stdout } = await execFileAsync("git", ["rev-parse", "HEAD"], {
				cwd: this.workspaceRoot,
			})

			return stdout.trim()
		} catch {
			return "unknown"
		}
	}
}
