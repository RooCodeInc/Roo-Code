/**
 * post/IntentMapUpdater.ts
 * ─────────────────────────────────────────────────────────────
 * POST-HOOK #2 — The Spatial Map Updater
 *
 * Maintains .orchestration/intent_map.md — a human-readable
 * map that answers: "Where is the [feature] logic?"
 *
 * Updated whenever an INTENT_EVOLUTION is detected (new feature
 * or API surface change). Refactors do not update the map
 * because the intent-to-file mapping hasn't changed.
 *
 * Format: Markdown table with Intent → Files → Last Updated
 * ─────────────────────────────────────────────────────────────
 */

import * as fs from 'fs';
import * as path from 'path';
import { ToolContext } from '../HookEngine';
import { findIntent } from '../utils/intentStore';
import { toRelativePath } from '../utils/gitUtils';

const MAP_FILE = path.join('.orchestration', 'intent_map.md');

interface IntentMapEntry {
  intentId: string;
  intentName: string;
  files: string[];
  lastUpdated: string;
  mutationCount: number;
}

export async function intentMapUpdater(ctx: ToolContext): Promise<ToolContext> {
  // Only update map on file writes
  const WRITE_TOOLS = new Set(['write_file', 'write_to_file', 'create_file', 'apply_diff', 'replace_in_file']);
  if (!WRITE_TOOLS.has(ctx.toolName)) return ctx;
  if (!ctx.intentId) return ctx;

  const targetPath = ctx.params['path'] as string ?? ctx.params['file_path'] as string;
  if (!targetPath) return ctx;

  const relativePath = toRelativePath(ctx.workspacePath, path.resolve(ctx.workspacePath, targetPath));
  const intent = findIntent(ctx.workspacePath, ctx.intentId);
  const intentName = intent?.name ?? ctx.intentId;

  const mapPath = path.join(ctx.workspacePath, MAP_FILE);
  const existingMap = loadMap(mapPath);

  // Get or create entry for this intent
  let entry = existingMap.find(e => e.intentId === ctx.intentId);
  if (!entry) {
    entry = {
      intentId: ctx.intentId,
      intentName,
      files: [],
      lastUpdated: new Date().toISOString(),
      mutationCount: 0,
    };
    existingMap.push(entry);
  }

  // Add file if not already tracked
  if (!entry.files.includes(relativePath)) {
    entry.files.push(relativePath);
  }

  entry.lastUpdated = new Date().toISOString();
  entry.mutationCount += 1;

  // Write the updated map
  fs.mkdirSync(path.dirname(mapPath), { recursive: true });
  fs.writeFileSync(mapPath, renderMap(existingMap), 'utf8');

  return ctx;
}

// ── Map serialization ──────────────────────────────────────────

function loadMap(mapPath: string): IntentMapEntry[] {
  if (!fs.existsSync(mapPath)) return [];

  try {
    const content = fs.readFileSync(mapPath, 'utf8');
    // Parse the HTML comment data block we embed in the file
    const match = content.match(/<!--DATA:([\s\S]+?)-->/);
    if (match) {
      return JSON.parse(match[1]);
    }
  } catch {
    // If parse fails, start fresh
  }
  return [];
}

function renderMap(entries: IntentMapEntry[]): string {
  const rows = entries
    .sort((a, b) => a.intentId.localeCompare(b.intentId))
    .map(e => {
      const fileLinks = e.files.map(f => `\`${f}\``).join(', ');
      const date = new Date(e.lastUpdated).toLocaleString('en-US', { dateStyle: 'short', timeStyle: 'short' });
      return `| ${e.intentId} | ${e.intentName} | ${fileLinks} | ${e.mutationCount} | ${date} |`;
    })
    .join('\n');

  return `# Intent Map
> Auto-generated by the Hook System. Do not edit manually.
> Last regenerated: ${new Date().toISOString()}

| Intent ID | Intent Name | Files | Mutations | Last Updated |
|-----------|-------------|-------|-----------|--------------|
${rows}

<!--DATA:${JSON.stringify(entries)}-->
`;
}