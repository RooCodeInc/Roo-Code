/**
 * DockerSandboxExecutor - Executes Python code in an isolated Docker container.
 *
 * This executor manages the lifecycle of Docker containers used for programmatic
 * tool calling. It handles:
 * - Container creation with resource limits
 * - Mounting the Python tool SDK
 * - IPC communication between the container and Roo Code
 * - Tool call routing and approval
 * - Execution timeout and cleanup
 */

import { spawn } from "child_process"
import { EventEmitter } from "events"
import * as fs from "fs/promises"
import * as path from "path"
import * as os from "os"

import type { CodeExecutionResult, SandboxConfig, SandboxToolCall, SandboxToolResult } from "./types"
import { DEFAULT_SANDBOX_CONFIG, isSupportedProgrammaticTool } from "./types"
import { generatePythonSDK, generateExecutionScript } from "./ToolBridge"

/**
 * Callback type for requesting tool approval from the user.
 * Returns true if the tool call is approved, false otherwise.
 */
export type ToolApprovalCallback = (toolCall: SandboxToolCall) => Promise<boolean>

/**
 * Callback type for executing an approved tool call.
 * Returns the tool result.
 */
export type ToolExecutorCallback = (toolCall: SandboxToolCall) => Promise<SandboxToolResult>

interface ExecutorOptions {
	config?: Partial<SandboxConfig>
	onToolApproval: ToolApprovalCallback
	onToolExecute: ToolExecutorCallback
}

/**
 * DockerSandboxExecutor manages the execution of Python code in a Docker container
 * with IPC-based tool calling support.
 */
export class DockerSandboxExecutor extends EventEmitter {
	private config: SandboxConfig
	private onToolApproval: ToolApprovalCallback
	private onToolExecute: ToolExecutorCallback

	constructor(options: ExecutorOptions) {
		super()
		this.config = { ...DEFAULT_SANDBOX_CONFIG, ...options.config }
		this.onToolApproval = options.onToolApproval
		this.onToolExecute = options.onToolExecute
	}

	/**
	 * Check if Docker is available on the system.
	 */
	async isDockerAvailable(): Promise<boolean> {
		return new Promise((resolve) => {
			const proc = spawn("docker", ["info"], {
				stdio: ["ignore", "ignore", "ignore"],
			})
			proc.on("close", (code) => resolve(code === 0))
			proc.on("error", () => resolve(false))
		})
	}

	/**
	 * Execute Python code in a Docker sandbox with tool calling support.
	 *
	 * @param code - The Python code to execute (generated by the model)
	 * @returns The execution result including stdout, stderr, and tool call history
	 */
	async execute(code: string): Promise<CodeExecutionResult> {
		const startTime = Date.now()
		const toolCalls: Array<{ call: SandboxToolCall; result: SandboxToolResult }> = []

		// Create a temporary directory for mounting the SDK and script
		const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), "roo-sandbox-"))

		try {
			// Write the Python SDK module
			const sdkCode = generatePythonSDK()
			await fs.writeFile(path.join(tmpDir, "roo_tools.py"), sdkCode, "utf-8")

			// Write the execution script
			const scriptCode = generateExecutionScript(code)
			await fs.writeFile(path.join(tmpDir, "run.py"), scriptCode, "utf-8")

			// Build Docker run arguments
			const dockerArgs = this.buildDockerArgs(tmpDir)

			return await new Promise<CodeExecutionResult>((resolve) => {
				let stdout = ""
				let stderr = ""
				let resolved = false

				const proc = spawn("docker", dockerArgs, {
					stdio: ["pipe", "pipe", "pipe"],
				})

				// Set up timeout
				const timeoutId = setTimeout(() => {
					if (!resolved) {
						resolved = true
						proc.kill("SIGKILL")
						resolve({
							success: false,
							stdout,
							stderr,
							toolCalls,
							error: `Execution timed out after ${this.config.timeoutMs}ms`,
							durationMs: Date.now() - startTime,
						})
					}
				}, this.config.timeoutMs)

				// Handle stdout (IPC messages from the sandbox)
				let stdoutBuffer = ""
				proc.stdout!.on("data", (data: Buffer) => {
					stdoutBuffer += data.toString()

					// Process complete lines (JSON messages)
					const lines = stdoutBuffer.split("\n")
					stdoutBuffer = lines.pop() ?? "" // Keep incomplete line in buffer

					for (const line of lines) {
						if (!line.trim()) {
							continue
						}
						this.handleSandboxMessage(line, proc, toolCalls).catch((err) => {
							stderr += `IPC error: ${err.message}\n`
						})
					}
				})

				// Collect stderr
				proc.stderr!.on("data", (data: Buffer) => {
					stderr += data.toString()
				})

				// Handle process exit
				proc.on("close", (exitCode) => {
					clearTimeout(timeoutId)
					if (!resolved) {
						resolved = true

						// Process any remaining stdout
						if (stdoutBuffer.trim()) {
							// Try to parse last message as completion
							try {
								const msg = JSON.parse(stdoutBuffer)
								if (msg.type === "complete") {
									resolve({
										success: msg.success ?? false,
										stdout,
										stderr,
										toolCalls,
										error: msg.error,
										durationMs: Date.now() - startTime,
									})
									return
								}
							} catch {
								// Not valid JSON, treat as regular output
								stdout += stdoutBuffer
							}
						}

						resolve({
							success: exitCode === 0,
							stdout,
							stderr,
							toolCalls,
							error: exitCode !== 0 ? `Process exited with code ${exitCode}` : undefined,
							durationMs: Date.now() - startTime,
						})
					}
				})

				proc.on("error", (err) => {
					clearTimeout(timeoutId)
					if (!resolved) {
						resolved = true
						resolve({
							success: false,
							stdout,
							stderr,
							toolCalls,
							error: `Failed to start Docker container: ${err.message}`,
							durationMs: Date.now() - startTime,
						})
					}
				})
			})
		} finally {
			// Clean up temporary directory
			await fs.rm(tmpDir, { recursive: true, force: true }).catch(() => {
				// Ignore cleanup errors
			})
		}
	}

	/**
	 * Build the Docker run command arguments.
	 */
	private buildDockerArgs(tmpDir: string): string[] {
		const args = [
			"run",
			"--rm",
			// Resource limits
			`--memory=${this.config.memoryLimit}`,
			`--cpus=${this.config.cpuLimit}`,
			// Security: read-only root filesystem, no new privileges
			"--read-only",
			"--security-opt=no-new-privileges",
			// Disable network unless explicitly enabled
			...(this.config.networkEnabled ? [] : ["--network=none"]),
			// Mount the SDK and script as read-only
			`-v=${tmpDir}:/workspace:ro`,
			// Working directory
			"-w=/workspace",
			// Interactive mode for stdin/stdout IPC
			"-i",
			// Image
			this.config.image,
			// Command
			"python",
			"/workspace/run.py",
		]
		return args
	}

	/**
	 * Handle a JSON message from the sandbox process.
	 */
	private async handleSandboxMessage(
		line: string,
		proc: ReturnType<typeof spawn>,
		toolCalls: Array<{ call: SandboxToolCall; result: SandboxToolResult }>,
	): Promise<void> {
		let message: Record<string, unknown>
		try {
			message = JSON.parse(line)
		} catch {
			// Not a JSON message, treat as regular stdout output
			this.emit("stdout", line)
			return
		}

		switch (message.type) {
			case "ready":
				// Container is ready, send start signal
				proc.stdin!.write(JSON.stringify({ type: "start" }) + "\n")
				break

			case "tool_request": {
				const toolCall: SandboxToolCall = {
					tool: message.tool as string,
					args: message.args as Record<string, unknown>,
				}

				let result: SandboxToolResult

				// Validate tool is supported
				if (!isSupportedProgrammaticTool(toolCall.tool)) {
					result = {
						success: false,
						error: `Tool '${toolCall.tool}' is not supported in programmatic tool calling`,
					}
				} else {
					// Request approval from the user
					const approved = await this.onToolApproval(toolCall)

					if (approved) {
						// Execute the tool
						result = await this.onToolExecute(toolCall)
					} else {
						result = {
							success: false,
							error: `Tool '${toolCall.tool}' was not approved by the user`,
						}
					}
				}

				toolCalls.push({ call: toolCall, result })

				// Send response back to the sandbox
				const response = {
					requestId: message.requestId,
					result,
				}
				proc.stdin!.write(JSON.stringify(response) + "\n")
				break
			}

			case "complete":
				// Code execution completed - handled in the close event
				break

			default:
				// Unknown message type, emit as stdout
				this.emit("stdout", line)
				break
		}
	}
}
