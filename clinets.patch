diff --git a/src/core/Cline.ts b/src/core/Cline.ts
index ade6c372..ca3238a2 100644
--- a/src/core/Cline.ts
+++ b/src/core/Cline.ts
@@ -68,7 +68,13 @@ import { isPathOutsideWorkspace } from "../utils/pathUtils"
 import { arePathsEqual, getReadablePath } from "../utils/path"
 import { parseMentions } from "./mentions"
 import { RooIgnoreController } from "./ignore/RooIgnoreController"
-import { AssistantMessageContent, parseAssistantMessage, ToolParamName, ToolUseName } from "./assistant-message"
+import {
+	AssistantMessageContent,
+	parseAssistantMessage,
+	ToolParamName,
+	ToolUseName,
+	ToolUse, // Import ToolUse type
+} from "./assistant-message"
 import { formatResponse } from "./prompts/responses"
 import { SYSTEM_PROMPT } from "./prompts/system"
 import { truncateConversationIfNeeded } from "./sliding-window"
@@ -85,6 +91,7 @@ import { parseXml } from "../utils/xml"
 import { readLines } from "../integrations/misc/read-lines"
 import { getWorkspacePath } from "../utils/path"
 import { isBinaryFile } from "isbinaryfile"
+import { ToolUseHandlerFactory } from "./tool-handlers/ToolUseHandlerFactory" //Import the factory
 
 export type ToolResponse = string | Array<Anthropic.TextBlockParam | Anthropic.ImageBlockParam>
 type UserContent = Array<Anthropic.Messages.ContentBlockParam>
@@ -134,8 +141,8 @@ export class Cline extends EventEmitter<ClineEvents> {
 	readonly apiConfiguration: ApiConfiguration
 	api: ApiHandler
 	private urlContentFetcher: UrlContentFetcher
-	private browserSession: BrowserSession
-	private didEditFile: boolean = false
+	public browserSession: BrowserSession // Made public for handlers
+	public didEditFile: boolean = false // Made public for handlers
 	customInstructions?: string
 	diffStrategy?: DiffStrategy
 	diffEnabled: boolean = false
@@ -156,7 +163,7 @@ export class Cline extends EventEmitter<ClineEvents> {
 	private abort: boolean = false
 	didFinishAbortingStream = false
 	abandoned = false
-	private diffViewProvider: DiffViewProvider
+	public diffViewProvider: DiffViewProvider // Made public for handlers
 	private lastApiRequestTime?: number
 	isInitialized = false
 
@@ -174,7 +181,7 @@ export class Cline extends EventEmitter<ClineEvents> {
 	private presentAssistantMessageHasPendingUpdates = false
 	private userMessageContent: (Anthropic.TextBlockParam | Anthropic.ImageBlockParam)[] = []
 	private userMessageContentReady = false
-	private didRejectTool = false
+	public didRejectTool = false // Made public for handlers
 	private didAlreadyUseTool = false
 	private didCompleteReadingStream = false
 
@@ -369,7 +376,7 @@ export class Cline extends EventEmitter<ClineEvents> {
 		this.emit("message", { action: "updated", message: partialMessage })
 	}
 
-	private getTokenUsage() {
+	public getTokenUsage() { // Made public for handlers
 		const usage = getApiMetrics(combineApiRequests(combineCommandSequences(this.clineMessages.slice(1))))
 		this.emit("taskTokenUsageUpdated", this.taskId, usage)
 		return usage
@@ -418,6 +425,143 @@ export class Cline extends EventEmitter<ClineEvents> {
 		}
 	}
 
+	/**
+	 * Pushes the result of a tool execution (or an error message) into the
+	 * user message content array, which will be sent back to the API in the next turn.
+	 * Also sets flags to prevent multiple tool uses per turn.
+	 * @param toolUse The original tool use block.
+	 * @param content The result content (string or blocks) or an error message.
+	 */
+	public async pushToolResult(toolUse: ToolUse, content: ToolResponse): Promise<void> { // Make method async
+		// Generate the tool description string (logic moved from presentAssistantMessage)
+		const toolDescription = async (): Promise<string> => { // Make inner function async
+			// Assuming customModes and defaultModeSlug are accessible in this scope
+			// If not, they might need to be passed or accessed differently.
+			// Await getState() and provide default value
+			const { customModes } = (await this.providerRef.deref()?.getState()) ?? {}
+
+			switch (toolUse.name) {
+				case "execute_command":
+					return `[${toolUse.name} for '${toolUse.params.command}']`
+				case "read_file":
+					return `[${toolUse.name} for '${toolUse.params.path}']`
+				case "fetch_instructions":
+					return `[${toolUse.name} for '${toolUse.params.task}']`
+				case "write_to_file":
+					return `[${toolUse.name} for '${toolUse.params.path}']`
+				case "apply_diff":
+					return `[${toolUse.name} for '${toolUse.params.path}']`
+				case "search_files":
+					return `[${toolUse.name} for '${toolUse.params.regex}'${
+						toolUse.params.file_pattern ? ` in '${toolUse.params.file_pattern}'` : ""
+					}]`
+				case "insert_content":
+					return `[${toolUse.name} for '${toolUse.params.path}']`
+				case "search_and_replace":
+					return `[${toolUse.name} for '${toolUse.params.path}']`
+				case "list_files":
+					return `[${toolUse.name} for '${toolUse.params.path}']`
+				case "list_code_definition_names":
+					return `[${toolUse.name} for '${toolUse.params.path}']`
+				case "browser_action":
+					return `[${toolUse.name} for '${toolUse.params.action}']`
+				case "use_mcp_tool":
+					return `[${toolUse.name} for '${toolUse.params.server_name}']`
+				case "access_mcp_resource":
+					return `[${toolUse.name} for '${toolUse.params.server_name}']`
+				case "ask_followup_question":
+					return `[${toolUse.name} for '${toolUse.params.question}']`
+				case "attempt_completion":
+					return `[${toolUse.name}]`
+				case "switch_mode":
+					return `[${toolUse.name} to '${toolUse.params.mode_slug}'${toolUse.params.reason ? ` because: ${toolUse.params.reason}` : ""}]`
+				case "new_task": {
+					const modeSlug = toolUse.params.mode ?? defaultModeSlug
+					const message = toolUse.params.message ?? "(no message)"
+					const mode = getModeBySlug(modeSlug, customModes)
+					const modeName = mode?.name ?? modeSlug
+					return `[${toolUse.name} in ${modeName} mode: '${message}']`
+				}
+				// Add cases for any other tools if necessary
+				default:
+					// Use a generic description for unknown tools
+					return `[${toolUse.name}]`
+			}
+		}
+
+		this.userMessageContent.push({
+			type: "text",
+			text: `${toolDescription()} Result:`,
+		})
+		if (typeof content === "string") {
+			this.userMessageContent.push({
+				type: "text",
+				text: content || "(tool did not return anything)",
+			})
+		} else {
+			// Ensure content is an array before spreading
+			const contentArray = Array.isArray(content) ? content : [content];
+			this.userMessageContent.push(...contentArray)
+		}
+		// once a tool result has been collected, ignore all other tool uses since we should only ever present one tool result per message
+		this.didAlreadyUseTool = true
+
+		// Note: isCheckpointPossible is handled by the return value of handler.handle() now
+	}
+
+	/**
+		* Helper method to ask the user for approval for a tool action.
+		* Handles sending messages, waiting for response, and pushing results.
+		* Replicates logic from the original askApproval function in presentAssistantMessage.
+		* @returns Promise<boolean> true if approved, false otherwise.
+		*/
+	public async askApprovalHelper(
+		toolUse: ToolUse, // Pass the toolUse block
+		type: ClineAsk,
+		partialMessage?: string,
+		progressStatus?: ToolProgressStatus,
+	): Promise<boolean> {
+		const { response, text, images } = await this.ask(type, partialMessage, false, progressStatus)
+		if (response !== "yesButtonClicked") {
+			// Handle both messageResponse and noButtonClicked with text
+			if (text) {
+				await this.say("user_feedback", text, images)
+				await this.pushToolResult( // Use the public method
+					toolUse,
+					formatResponse.toolResult(formatResponse.toolDeniedWithFeedback(text), images),
+				)
+			} else {
+				await this.pushToolResult(toolUse, formatResponse.toolDenied()) // Use the public method
+			}
+			this.didRejectTool = true // Assuming didRejectTool remains a class member or is handled appropriately
+			return false
+		}
+		// Handle yesButtonClicked with text
+		if (text) {
+			await this.say("user_feedback", text, images)
+			await this.pushToolResult( // Use the public method
+				toolUse,
+				formatResponse.toolResult(formatResponse.toolApprovedWithFeedback(text), images),
+			)
+		}
+		return true
+	}
+
+	/**
+		* Helper method to handle errors during tool execution.
+		* Sends error messages and pushes an error result back to the API.
+		* Replicates logic from the original handleError function in presentAssistantMessage.
+		*/
+	public async handleErrorHelper(toolUse: ToolUse, action: string, error: Error): Promise<void> {
+		const errorString = `Error ${action}: ${JSON.stringify(serializeError(error))}`
+		await this.say(
+			"error",
+			`Error ${action}:\n${error.message ?? JSON.stringify(serializeError(error), null, 2)}`,
+		)
+		await this.pushToolResult(toolUse, formatResponse.toolError(errorString)) // Use the public method
+	}
+
+
 	// Communicate with webview
 
 	// partial has three valid states true (partial message), false (completion of partial message), undefined (individual complete message)
@@ -1370,67 +1514,23 @@ export class Cline extends EventEmitter<ClineEvents> {
 				await this.say("text", content, undefined, block.partial)
 				break
 			}
-			case "tool_use":
-				const toolDescription = (): string => {
-					switch (block.name) {
-						case "execute_command":
-							return `[${block.name} for '${block.params.command}']`
-						case "read_file":
-							return `[${block.name} for '${block.params.path}']`
-						case "fetch_instructions":
-							return `[${block.name} for '${block.params.task}']`
-						case "write_to_file":
-							return `[${block.name} for '${block.params.path}']`
-						case "apply_diff":
-							return `[${block.name} for '${block.params.path}']`
-						case "search_files":
-							return `[${block.name} for '${block.params.regex}'${
-								block.params.file_pattern ? ` in '${block.params.file_pattern}'` : ""
-							}]`
-						case "insert_content":
-							return `[${block.name} for '${block.params.path}']`
-						case "search_and_replace":
-							return `[${block.name} for '${block.params.path}']`
-						case "list_files":
-							return `[${block.name} for '${block.params.path}']`
-						case "list_code_definition_names":
-							return `[${block.name} for '${block.params.path}']`
-						case "browser_action":
-							return `[${block.name} for '${block.params.action}']`
-						case "use_mcp_tool":
-							return `[${block.name} for '${block.params.server_name}']`
-						case "access_mcp_resource":
-							return `[${block.name} for '${block.params.server_name}']`
-						case "ask_followup_question":
-							return `[${block.name} for '${block.params.question}']`
-						case "attempt_completion":
-							return `[${block.name}]`
-						case "switch_mode":
-							return `[${block.name} to '${block.params.mode_slug}'${block.params.reason ? ` because: ${block.params.reason}` : ""}]`
-						case "new_task": {
-							const mode = block.params.mode ?? defaultModeSlug
-							const message = block.params.message ?? "(no message)"
-							const modeName = getModeBySlug(mode, customModes)?.name ?? mode
-							return `[${block.name} in ${modeName} mode: '${message}']`
-						}
-					}
-				}
-
+			case "tool_use": { // Re-add case statement
+				// --- Check if tool use should be skipped ---
 				if (this.didRejectTool) {
 					// ignore any tool content after user has rejected tool once
 					if (!block.partial) {
 						this.userMessageContent.push({
 							type: "text",
-							text: `Skipping tool ${toolDescription()} due to user rejecting a previous tool.`,
+							text: `Skipping tool ${block.name} due to user rejecting a previous tool.`,
 						})
 					} else {
 						// partial tool after user rejected a previous tool
 						this.userMessageContent.push({
 							type: "text",
-							text: `Tool ${toolDescription()} was interrupted and not executed due to user rejecting a previous tool.`,
+							text: `Tool ${block.name} was interrupted and not executed due to user rejecting a previous tool.`,
 						})
 					}
-					break
+					break // Break from tool_use case
 				}
 
 				if (this.didAlreadyUseTool) {
@@ -1439,1861 +1539,47 @@ export class Cline extends EventEmitter<ClineEvents> {
 						type: "text",
 						text: `Tool [${block.name}] was not executed because a tool has already been used in this message. Only one tool may be used per message. You must assess the first tool's result before proceeding to use the next tool.`,
 					})
-					break
+					break // Break from tool_use case
 				}
 
-				const pushToolResult = (content: ToolResponse) => {
-					this.userMessageContent.push({
-						type: "text",
-						text: `${toolDescription()} Result:`,
-					})
-					if (typeof content === "string") {
-						this.userMessageContent.push({
-							type: "text",
-							text: content || "(tool did not return anything)",
-						})
-					} else {
-						this.userMessageContent.push(...content)
-					}
-					// once a tool result has been collected, ignore all other tool uses since we should only ever present one tool result per message
-					this.didAlreadyUseTool = true
+				// --- Use Tool Handler Factory ---
+				const handler = ToolUseHandlerFactory.createHandler(this, block);
 
-					// Flag a checkpoint as possible since we've used a tool
-					// which may have changed the file system.
-					isCheckpointPossible = true
-				}
+				if (handler) {
+					try {
+						// Validate parameters before handling (optional here, could be in handler)
+						// handler.validateParams();
 
-				const askApproval = async (
-					type: ClineAsk,
-					partialMessage?: string,
-					progressStatus?: ToolProgressStatus,
-				) => {
-					const { response, text, images } = await this.ask(type, partialMessage, false, progressStatus)
-					if (response !== "yesButtonClicked") {
-						// Handle both messageResponse and noButtonClicked with text
-						if (text) {
-							await this.say("user_feedback", text, images)
-							pushToolResult(
-								formatResponse.toolResult(formatResponse.toolDeniedWithFeedback(text), images),
-							)
-						} else {
-							pushToolResult(formatResponse.toolDenied())
-						}
-						this.didRejectTool = true
-						return false
-					}
-					// Handle yesButtonClicked with text
-					if (text) {
-						await this.say("user_feedback", text, images)
-						pushToolResult(formatResponse.toolResult(formatResponse.toolApprovedWithFeedback(text), images))
-					}
-					return true
-				}
+						// Handle the tool use (partial or complete)
+						const handledCompletely = await handler.handle();
 
-				const askFinishSubTaskApproval = async () => {
-					// ask the user to approve this task has completed, and he has reviewd it, and we can declare task is finished
-					// and return control to the parent task to continue running the rest of the sub-tasks
-					const toolMessage = JSON.stringify({
-						tool: "finishTask",
-						content:
-							"Subtask completed! You can review the results and suggest any corrections or next steps. If everything looks good, confirm to return the result to the parent task.",
-					})
-
-					return await askApproval("tool", toolMessage)
-				}
-
-				const handleError = async (action: string, error: Error) => {
-					const errorString = `Error ${action}: ${JSON.stringify(serializeError(error))}`
-					await this.say(
-						"error",
-						`Error ${action}:\n${error.message ?? JSON.stringify(serializeError(error), null, 2)}`,
-					)
-					// this.toolResults.push({
-					// 	type: "tool_result",
-					// 	tool_use_id: toolUseId,
-					// 	content: await this.formatToolError(errorString),
-					// })
-					pushToolResult(formatResponse.toolError(errorString))
-				}
-
-				// If block is partial, remove partial closing tag so its not presented to user
-				const removeClosingTag = (tag: ToolParamName, text?: string) => {
-					if (!block.partial) {
-						return text || ""
-					}
-					if (!text) {
-						return ""
-					}
-					// This regex dynamically constructs a pattern to match the closing tag:
-					// - Optionally matches whitespace before the tag
-					// - Matches '<' or '</' optionally followed by any subset of characters from the tag name
-					const tagRegex = new RegExp(
-						`\\s?<\/?${tag
-							.split("")
-							.map((char) => `(?:${char})?`)
-							.join("")}$`,
-						"g",
-					)
-					return text.replace(tagRegex, "")
-				}
-
-				if (block.name !== "browser_action") {
-					await this.browserSession.closeBrowser()
-				}
-
-				if (!block.partial) {
-					telemetryService.captureToolUsage(this.taskId, block.name)
-				}
-
-				// Validate tool use before execution
-				const { mode, customModes } = (await this.providerRef.deref()?.getState()) ?? {}
-				try {
-					validateToolUse(
-						block.name as ToolName,
-						mode ?? defaultModeSlug,
-						customModes ?? [],
-						{
-							apply_diff: this.diffEnabled,
-						},
-						block.params,
-					)
-				} catch (error) {
-					this.consecutiveMistakeCount++
-					pushToolResult(formatResponse.toolError(error.message))
-					break
-				}
-
-				switch (block.name) {
-					case "write_to_file": {
-						const relPath: string | undefined = block.params.path
-						let newContent: string | undefined = block.params.content
-						let predictedLineCount: number | undefined = parseInt(block.params.line_count ?? "0")
-						if (!relPath || !newContent) {
-							// checking for newContent ensure relPath is complete
-							// wait so we can determine if it's a new file or editing an existing file
-							break
-						}
-
-						const accessAllowed = this.rooIgnoreController?.validateAccess(relPath)
-						if (!accessAllowed) {
-							await this.say("rooignore_error", relPath)
-							pushToolResult(formatResponse.toolError(formatResponse.rooIgnoreError(relPath)))
-
-							break
-						}
-
-						// Check if file exists using cached map or fs.access
-						let fileExists: boolean
-						if (this.diffViewProvider.editType !== undefined) {
-							fileExists = this.diffViewProvider.editType === "modify"
-						} else {
-							const absolutePath = path.resolve(this.cwd, relPath)
-							fileExists = await fileExistsAtPath(absolutePath)
-							this.diffViewProvider.editType = fileExists ? "modify" : "create"
-						}
-
-						// pre-processing newContent for cases where weaker models might add artifacts like markdown codeblock markers (deepseek/llama) or extra escape characters (gemini)
-						if (newContent.startsWith("```")) {
-							// this handles cases where it includes language specifiers like ```python ```js
-							newContent = newContent.split("\n").slice(1).join("\n").trim()
-						}
-						if (newContent.endsWith("```")) {
-							newContent = newContent.split("\n").slice(0, -1).join("\n").trim()
-						}
-
-						if (!this.api.getModel().id.includes("claude")) {
-							// it seems not just llama models are doing this, but also gemini and potentially others
-							if (
-								newContent.includes("&gt;") ||
-								newContent.includes("&lt;") ||
-								newContent.includes("&quot;")
-							) {
-								newContent = newContent
-									.replace(/&gt;/g, ">")
-									.replace(/&lt;/g, "<")
-									.replace(/&quot;/g, '"')
-							}
-						}
-
-						// Determine if the path is outside the workspace
-						const fullPath = relPath ? path.resolve(this.cwd, removeClosingTag("path", relPath)) : ""
-						const isOutsideWorkspace = isPathOutsideWorkspace(fullPath)
-
-						const sharedMessageProps: ClineSayTool = {
-							tool: fileExists ? "editedExistingFile" : "newFileCreated",
-							path: getReadablePath(this.cwd, removeClosingTag("path", relPath)),
-							isOutsideWorkspace,
-						}
-						try {
-							if (block.partial) {
-								// update gui message
-								const partialMessage = JSON.stringify(sharedMessageProps)
-								await this.ask("tool", partialMessage, block.partial).catch(() => {})
-								// update editor
-								if (!this.diffViewProvider.isEditing) {
-									// open the editor and prepare to stream content in
-									await this.diffViewProvider.open(relPath)
-								}
-								// editor is open, stream content in
-								await this.diffViewProvider.update(
-									everyLineHasLineNumbers(newContent) ? stripLineNumbers(newContent) : newContent,
-									false,
-								)
-								break
-							} else {
-								if (!relPath) {
-									this.consecutiveMistakeCount++
-									pushToolResult(await this.sayAndCreateMissingParamError("write_to_file", "path"))
-									await this.diffViewProvider.reset()
-									break
-								}
-								if (!newContent) {
-									this.consecutiveMistakeCount++
-									pushToolResult(await this.sayAndCreateMissingParamError("write_to_file", "content"))
-									await this.diffViewProvider.reset()
-									break
-								}
-								if (!predictedLineCount) {
-									this.consecutiveMistakeCount++
-									pushToolResult(
-										await this.sayAndCreateMissingParamError("write_to_file", "line_count"),
-									)
-									await this.diffViewProvider.reset()
-									break
-								}
-								this.consecutiveMistakeCount = 0
-
-								// if isEditingFile false, that means we have the full contents of the file already.
-								// it's important to note how this function works, you can't make the assumption that the block.partial conditional will always be called since it may immediately get complete, non-partial data. So this part of the logic will always be called.
-								// in other words, you must always repeat the block.partial logic here
-								if (!this.diffViewProvider.isEditing) {
-									// show gui message before showing edit animation
-									const partialMessage = JSON.stringify(sharedMessageProps)
-									await this.ask("tool", partialMessage, true).catch(() => {}) // sending true for partial even though it's not a partial, this shows the edit row before the content is streamed into the editor
-									await this.diffViewProvider.open(relPath)
-								}
-								await this.diffViewProvider.update(
-									everyLineHasLineNumbers(newContent) ? stripLineNumbers(newContent) : newContent,
-									true,
-								)
-								await delay(300) // wait for diff view to update
-								this.diffViewProvider.scrollToFirstDiff()
-
-								// Check for code omissions before proceeding
-								if (
-									detectCodeOmission(
-										this.diffViewProvider.originalContent || "",
-										newContent,
-										predictedLineCount,
-									)
-								) {
-									if (this.diffStrategy) {
-										await this.diffViewProvider.revertChanges()
-										pushToolResult(
-											formatResponse.toolError(
-												`Content appears to be truncated (file has ${
-													newContent.split("\n").length
-												} lines but was predicted to have ${predictedLineCount} lines), and found comments indicating omitted code (e.g., '// rest of code unchanged', '/* previous code */'). Please provide the complete file content without any omissions if possible, or otherwise use the 'apply_diff' tool to apply the diff to the original file.`,
-											),
-										)
-										break
-									} else {
-										vscode.window
-											.showWarningMessage(
-												"Potential code truncation detected. This happens when the AI reaches its max output limit.",
-												"Follow this guide to fix the issue",
-											)
-											.then((selection) => {
-												if (selection === "Follow this guide to fix the issue") {
-													vscode.env.openExternal(
-														vscode.Uri.parse(
-															"https://github.com/cline/cline/wiki/Troubleshooting-%E2%80%90-Cline-Deleting-Code-with-%22Rest-of-Code-Here%22-Comments",
-														),
-													)
-												}
-											})
-									}
-								}
-
-								const completeMessage = JSON.stringify({
-									...sharedMessageProps,
-									content: fileExists ? undefined : newContent,
-									diff: fileExists
-										? formatResponse.createPrettyPatch(
-												relPath,
-												this.diffViewProvider.originalContent,
-												newContent,
-											)
-										: undefined,
-								} satisfies ClineSayTool)
-								const didApprove = await askApproval("tool", completeMessage)
-								if (!didApprove) {
-									await this.diffViewProvider.revertChanges()
-									break
-								}
-								const { newProblemsMessage, userEdits, finalContent } =
-									await this.diffViewProvider.saveChanges()
-								this.didEditFile = true // used to determine if we should wait for busy terminal to update before sending api request
-								if (userEdits) {
-									await this.say(
-										"user_feedback_diff",
-										JSON.stringify({
-											tool: fileExists ? "editedExistingFile" : "newFileCreated",
-											path: getReadablePath(this.cwd, relPath),
-											diff: userEdits,
-										} satisfies ClineSayTool),
-									)
-									pushToolResult(
-										`The user made the following updates to your content:\n\n${userEdits}\n\n` +
-											`The updated content, which includes both your original modifications and the user's edits, has been successfully saved to ${relPath.toPosix()}. Here is the full, updated content of the file, including line numbers:\n\n` +
-											`<final_file_content path="${relPath.toPosix()}">\n${addLineNumbers(
-												finalContent || "",
-											)}\n</final_file_content>\n\n` +
-											`Please note:\n` +
-											`1. You do not need to re-write the file with these changes, as they have already been applied.\n` +
-											`2. Proceed with the task using this updated file content as the new baseline.\n` +
-											`3. If the user's edits have addressed part of the task or changed the requirements, adjust your approach accordingly.` +
-											`${newProblemsMessage}`,
-									)
-								} else {
-									pushToolResult(
-										`The content was successfully saved to ${relPath.toPosix()}.${newProblemsMessage}`,
-									)
-								}
-								await this.diffViewProvider.reset()
-								break
-							}
-						} catch (error) {
-							await handleError("writing file", error)
-							await this.diffViewProvider.reset()
-							break
-						}
-					}
-					case "apply_diff": {
-						const relPath: string | undefined = block.params.path
-						const diffContent: string | undefined = block.params.diff
-
-						const sharedMessageProps: ClineSayTool = {
-							tool: "appliedDiff",
-							path: getReadablePath(this.cwd, removeClosingTag("path", relPath)),
-						}
-
-						try {
-							if (block.partial) {
-								// update gui message
-								let toolProgressStatus
-								if (this.diffStrategy && this.diffStrategy.getProgressStatus) {
-									toolProgressStatus = this.diffStrategy.getProgressStatus(block)
-								}
-
-								const partialMessage = JSON.stringify(sharedMessageProps)
-
-								await this.ask("tool", partialMessage, block.partial, toolProgressStatus).catch(
-									() => {},
-								)
-								break
-							} else {
-								if (!relPath) {
-									this.consecutiveMistakeCount++
-									pushToolResult(await this.sayAndCreateMissingParamError("apply_diff", "path"))
-									break
-								}
-								if (!diffContent) {
-									this.consecutiveMistakeCount++
-									pushToolResult(await this.sayAndCreateMissingParamError("apply_diff", "diff"))
-									break
-								}
-
-								const accessAllowed = this.rooIgnoreController?.validateAccess(relPath)
-								if (!accessAllowed) {
-									await this.say("rooignore_error", relPath)
-									pushToolResult(formatResponse.toolError(formatResponse.rooIgnoreError(relPath)))
-
-									break
-								}
-
-								const absolutePath = path.resolve(this.cwd, relPath)
-								const fileExists = await fileExistsAtPath(absolutePath)
-
-								if (!fileExists) {
-									this.consecutiveMistakeCount++
-									const formattedError = `File does not exist at path: ${absolutePath}\n\n<error_details>\nThe specified file could not be found. Please verify the file path and try again.\n</error_details>`
-									await this.say("error", formattedError)
-									pushToolResult(formattedError)
-									break
-								}
-
-								const originalContent = await fs.readFile(absolutePath, "utf-8")
-
-								// Apply the diff to the original content
-								const diffResult = (await this.diffStrategy?.applyDiff(
-									originalContent,
-									diffContent,
-									parseInt(block.params.start_line ?? ""),
-									parseInt(block.params.end_line ?? ""),
-								)) ?? {
-									success: false,
-									error: "No diff strategy available",
-								}
-								let partResults = ""
-
-								if (!diffResult.success) {
-									this.consecutiveMistakeCount++
-									const currentCount =
-										(this.consecutiveMistakeCountForApplyDiff.get(relPath) || 0) + 1
-									this.consecutiveMistakeCountForApplyDiff.set(relPath, currentCount)
-									let formattedError = ""
-									if (diffResult.failParts && diffResult.failParts.length > 0) {
-										for (const failPart of diffResult.failParts) {
-											if (failPart.success) {
-												continue
-											}
-											const errorDetails = failPart.details
-												? JSON.stringify(failPart.details, null, 2)
-												: ""
-											formattedError = `<error_details>\n${
-												failPart.error
-											}${errorDetails ? `\n\nDetails:\n${errorDetails}` : ""}\n</error_details>`
-											partResults += formattedError
-										}
-									} else {
-										const errorDetails = diffResult.details
-											? JSON.stringify(diffResult.details, null, 2)
-											: ""
-										formattedError = `Unable to apply diff to file: ${absolutePath}\n\n<error_details>\n${
-											diffResult.error
-										}${errorDetails ? `\n\nDetails:\n${errorDetails}` : ""}\n</error_details>`
-									}
-
-									if (currentCount >= 2) {
-										await this.say("error", formattedError)
-									}
-									pushToolResult(formattedError)
-									break
-								}
-
-								this.consecutiveMistakeCount = 0
-								this.consecutiveMistakeCountForApplyDiff.delete(relPath)
-								// Show diff view before asking for approval
-								this.diffViewProvider.editType = "modify"
-								await this.diffViewProvider.open(relPath)
-								await this.diffViewProvider.update(diffResult.content, true)
-								await this.diffViewProvider.scrollToFirstDiff()
-
-								const completeMessage = JSON.stringify({
-									...sharedMessageProps,
-									diff: diffContent,
-								} satisfies ClineSayTool)
-
-								let toolProgressStatus
-								if (this.diffStrategy && this.diffStrategy.getProgressStatus) {
-									toolProgressStatus = this.diffStrategy.getProgressStatus(block, diffResult)
-								}
-
-								const didApprove = await askApproval("tool", completeMessage, toolProgressStatus)
-								if (!didApprove) {
-									await this.diffViewProvider.revertChanges() // This likely handles closing the diff view
-									break
-								}
-
-								const { newProblemsMessage, userEdits, finalContent } =
-									await this.diffViewProvider.saveChanges()
-								this.didEditFile = true // used to determine if we should wait for busy terminal to update before sending api request
-								let partFailHint = ""
-								if (diffResult.failParts && diffResult.failParts.length > 0) {
-									partFailHint = `But unable to apply all diff parts to file: ${absolutePath}, silently use <read_file> tool to check newest file version and re-apply diffs\n`
-								}
-								if (userEdits) {
-									await this.say(
-										"user_feedback_diff",
-										JSON.stringify({
-											tool: fileExists ? "editedExistingFile" : "newFileCreated",
-											path: getReadablePath(this.cwd, relPath),
-											diff: userEdits,
-										} satisfies ClineSayTool),
-									)
-									pushToolResult(
-										`The user made the following updates to your content:\n\n${userEdits}\n\n` +
-											partFailHint +
-											`The updated content, which includes both your original modifications and the user's edits, has been successfully saved to ${relPath.toPosix()}. Here is the full, updated content of the file, including line numbers:\n\n` +
-											`<final_file_content path="${relPath.toPosix()}">\n${addLineNumbers(
-												finalContent || "",
-											)}\n</final_file_content>\n\n` +
-											`Please note:\n` +
-											`1. You do not need to re-write the file with these changes, as they have already been applied.\n` +
-											`2. Proceed with the task using this updated file content as the new baseline.\n` +
-											`3. If the user's edits have addressed part of the task or changed the requirements, adjust your approach accordingly.` +
-											`${newProblemsMessage}`,
-									)
-								} else {
-									pushToolResult(
-										`Changes successfully applied to ${relPath.toPosix()}:\n\n${newProblemsMessage}\n` +
-											partFailHint,
-									)
-								}
-								await this.diffViewProvider.reset()
-								break
-							}
-						} catch (error) {
-							await handleError("applying diff", error)
-							await this.diffViewProvider.reset()
-							break
-						}
-					}
-
-					case "insert_content": {
-						const relPath: string | undefined = block.params.path
-						const operations: string | undefined = block.params.operations
-
-						const sharedMessageProps: ClineSayTool = {
-							tool: "appliedDiff",
-							path: getReadablePath(this.cwd, removeClosingTag("path", relPath)),
-						}
-
-						try {
-							if (block.partial) {
-								const partialMessage = JSON.stringify(sharedMessageProps)
-								await this.ask("tool", partialMessage, block.partial).catch(() => {})
-								break
-							}
-
-							// Validate required parameters
-							if (!relPath) {
-								this.consecutiveMistakeCount++
-								pushToolResult(await this.sayAndCreateMissingParamError("insert_content", "path"))
-								break
-							}
-
-							if (!operations) {
-								this.consecutiveMistakeCount++
-								pushToolResult(await this.sayAndCreateMissingParamError("insert_content", "operations"))
-								break
-							}
-
-							const absolutePath = path.resolve(this.cwd, relPath)
-							const fileExists = await fileExistsAtPath(absolutePath)
-
-							if (!fileExists) {
-								this.consecutiveMistakeCount++
-								const formattedError = `File does not exist at path: ${absolutePath}\n\n<error_details>\nThe specified file could not be found. Please verify the file path and try again.\n</error_details>`
-								await this.say("error", formattedError)
-								pushToolResult(formattedError)
-								break
-							}
-
-							let parsedOperations: Array<{
-								start_line: number
-								content: string
-							}>
-
-							try {
-								parsedOperations = JSON.parse(operations)
-								if (!Array.isArray(parsedOperations)) {
-									throw new Error("Operations must be an array")
-								}
-							} catch (error) {
-								this.consecutiveMistakeCount++
-								await this.say("error", `Failed to parse operations JSON: ${error.message}`)
-								pushToolResult(formatResponse.toolError("Invalid operations JSON format"))
-								break
-							}
-
-							this.consecutiveMistakeCount = 0
-
-							// Read the file
-							const fileContent = await fs.readFile(absolutePath, "utf8")
-							this.diffViewProvider.editType = "modify"
-							this.diffViewProvider.originalContent = fileContent
-							const lines = fileContent.split("\n")
-
-							const updatedContent = insertGroups(
-								lines,
-								parsedOperations.map((elem) => {
-									return {
-										index: elem.start_line - 1,
-										elements: elem.content.split("\n"),
-									}
-								}),
-							).join("\n")
-
-							// Show changes in diff view
-							if (!this.diffViewProvider.isEditing) {
-								await this.ask("tool", JSON.stringify(sharedMessageProps), true).catch(() => {})
-								// First open with original content
-								await this.diffViewProvider.open(relPath)
-								await this.diffViewProvider.update(fileContent, false)
-								this.diffViewProvider.scrollToFirstDiff()
-								await delay(200)
-							}
-
-							const diff = formatResponse.createPrettyPatch(relPath, fileContent, updatedContent)
-
-							if (!diff) {
-								pushToolResult(`No changes needed for '${relPath}'`)
-								break
-							}
-
-							await this.diffViewProvider.update(updatedContent, true)
-
-							const completeMessage = JSON.stringify({
-								...sharedMessageProps,
-								diff,
-							} satisfies ClineSayTool)
-
-							const didApprove = await this.ask("tool", completeMessage, false).then(
-								(response) => response.response === "yesButtonClicked",
-							)
-
-							if (!didApprove) {
-								await this.diffViewProvider.revertChanges()
-								pushToolResult("Changes were rejected by the user.")
-								break
-							}
-
-							const { newProblemsMessage, userEdits, finalContent } =
-								await this.diffViewProvider.saveChanges()
-							this.didEditFile = true
-
-							if (!userEdits) {
-								pushToolResult(
-									`The content was successfully inserted in ${relPath.toPosix()}.${newProblemsMessage}`,
-								)
-								await this.diffViewProvider.reset()
-								break
-							}
-
-							const userFeedbackDiff = JSON.stringify({
-								tool: "appliedDiff",
-								path: getReadablePath(this.cwd, relPath),
-								diff: userEdits,
-							} satisfies ClineSayTool)
-
-							console.debug("[DEBUG] User made edits, sending feedback diff:", userFeedbackDiff)
-							await this.say("user_feedback_diff", userFeedbackDiff)
-							pushToolResult(
-								`The user made the following updates to your content:\n\n${userEdits}\n\n` +
-									`The updated content, which includes both your original modifications and the user's edits, has been successfully saved to ${relPath.toPosix()}. Here is the full, updated content of the file:\n\n` +
-									`<final_file_content path="${relPath.toPosix()}">\n${finalContent}\n</final_file_content>\n\n` +
-									`Please note:\n` +
-									`1. You do not need to re-write the file with these changes, as they have already been applied.\n` +
-									`2. Proceed with the task using this updated file content as the new baseline.\n` +
-									`3. If the user's edits have addressed part of the task or changed the requirements, adjust your approach accordingly.` +
-									`${newProblemsMessage}`,
-							)
-							await this.diffViewProvider.reset()
-						} catch (error) {
-							handleError("insert content", error)
-							await this.diffViewProvider.reset()
-						}
-						break
-					}
-
-					case "search_and_replace": {
-						const relPath: string | undefined = block.params.path
-						const operations: string | undefined = block.params.operations
-
-						const sharedMessageProps: ClineSayTool = {
-							tool: "appliedDiff",
-							path: getReadablePath(this.cwd, removeClosingTag("path", relPath)),
-						}
-
-						try {
-							if (block.partial) {
-								const partialMessage = JSON.stringify({
-									path: removeClosingTag("path", relPath),
-									operations: removeClosingTag("operations", operations),
-								})
-								await this.ask("tool", partialMessage, block.partial).catch(() => {})
-								break
-							} else {
-								if (!relPath) {
-									this.consecutiveMistakeCount++
-									pushToolResult(
-										await this.sayAndCreateMissingParamError("search_and_replace", "path"),
-									)
-									break
-								}
-								if (!operations) {
-									this.consecutiveMistakeCount++
-									pushToolResult(
-										await this.sayAndCreateMissingParamError("search_and_replace", "operations"),
-									)
-									break
-								}
-
-								const absolutePath = path.resolve(this.cwd, relPath)
-								const fileExists = await fileExistsAtPath(absolutePath)
-
-								if (!fileExists) {
-									this.consecutiveMistakeCount++
-									const formattedError = `File does not exist at path: ${absolutePath}\n\n<error_details>\nThe specified file could not be found. Please verify the file path and try again.\n</error_details>`
-									await this.say("error", formattedError)
-									pushToolResult(formattedError)
-									break
-								}
-
-								let parsedOperations: Array<{
-									search: string
-									replace: string
-									start_line?: number
-									end_line?: number
-									use_regex?: boolean
-									ignore_case?: boolean
-									regex_flags?: string
-								}>
-
-								try {
-									parsedOperations = JSON.parse(operations)
-									if (!Array.isArray(parsedOperations)) {
-										throw new Error("Operations must be an array")
-									}
-								} catch (error) {
-									this.consecutiveMistakeCount++
-									await this.say("error", `Failed to parse operations JSON: ${error.message}`)
-									pushToolResult(formatResponse.toolError("Invalid operations JSON format"))
-									break
-								}
-
-								// Read the original file content
-								const fileContent = await fs.readFile(absolutePath, "utf-8")
-								this.diffViewProvider.editType = "modify"
-								this.diffViewProvider.originalContent = fileContent
-								let lines = fileContent.split("\n")
-
-								for (const op of parsedOperations) {
-									const flags = op.regex_flags ?? (op.ignore_case ? "gi" : "g")
-									const multilineFlags = flags.includes("m") ? flags : flags + "m"
-
-									const searchPattern = op.use_regex
-										? new RegExp(op.search, multilineFlags)
-										: new RegExp(escapeRegExp(op.search), multilineFlags)
-
-									if (op.start_line || op.end_line) {
-										const startLine = Math.max((op.start_line ?? 1) - 1, 0)
-										const endLine = Math.min((op.end_line ?? lines.length) - 1, lines.length - 1)
-
-										// Get the content before and after the target section
-										const beforeLines = lines.slice(0, startLine)
-										const afterLines = lines.slice(endLine + 1)
-
-										// Get the target section and perform replacement
-										const targetContent = lines.slice(startLine, endLine + 1).join("\n")
-										const modifiedContent = targetContent.replace(searchPattern, op.replace)
-										const modifiedLines = modifiedContent.split("\n")
-
-										// Reconstruct the full content with the modified section
-										lines = [...beforeLines, ...modifiedLines, ...afterLines]
-									} else {
-										// Global replacement
-										const fullContent = lines.join("\n")
-										const modifiedContent = fullContent.replace(searchPattern, op.replace)
-										lines = modifiedContent.split("\n")
-									}
-								}
-
-								const newContent = lines.join("\n")
-
-								this.consecutiveMistakeCount = 0
-
-								// Show diff preview
-								const diff = formatResponse.createPrettyPatch(relPath, fileContent, newContent)
-
-								if (!diff) {
-									pushToolResult(`No changes needed for '${relPath}'`)
-									break
-								}
-
-								await this.diffViewProvider.open(relPath)
-								await this.diffViewProvider.update(newContent, true)
-								this.diffViewProvider.scrollToFirstDiff()
-
-								const completeMessage = JSON.stringify({
-									...sharedMessageProps,
-									diff: diff,
-								} satisfies ClineSayTool)
-
-								const didApprove = await askApproval("tool", completeMessage)
-								if (!didApprove) {
-									await this.diffViewProvider.revertChanges() // This likely handles closing the diff view
-									break
-								}
-
-								const { newProblemsMessage, userEdits, finalContent } =
-									await this.diffViewProvider.saveChanges()
-								this.didEditFile = true // used to determine if we should wait for busy terminal to update before sending api request
-								if (userEdits) {
-									await this.say(
-										"user_feedback_diff",
-										JSON.stringify({
-											tool: fileExists ? "editedExistingFile" : "newFileCreated",
-											path: getReadablePath(this.cwd, relPath),
-											diff: userEdits,
-										} satisfies ClineSayTool),
-									)
-									pushToolResult(
-										`The user made the following updates to your content:\n\n${userEdits}\n\n` +
-											`The updated content, which includes both your original modifications and the user's edits, has been successfully saved to ${relPath.toPosix()}. Here is the full, updated content of the file, including line numbers:\n\n` +
-											`<final_file_content path="${relPath.toPosix()}">\n${addLineNumbers(finalContent || "")}\n</final_file_content>\n\n` +
-											`Please note:\n` +
-											`1. You do not need to re-write the file with these changes, as they have already been applied.\n` +
-											`2. Proceed with the task using this updated file content as the new baseline.\n` +
-											`3. If the user's edits have addressed part of the task or changed the requirements, adjust your approach accordingly.` +
-											`${newProblemsMessage}`,
-									)
-								} else {
-									pushToolResult(
-										`Changes successfully applied to ${relPath.toPosix()}:\n\n${newProblemsMessage}`,
-									)
-								}
-								await this.diffViewProvider.reset()
-								break
-							}
-						} catch (error) {
-							await handleError("applying search and replace", error)
-							await this.diffViewProvider.reset()
-							break
-						}
-					}
-
-					case "read_file": {
-						const relPath: string | undefined = block.params.path
-						const startLineStr: string | undefined = block.params.start_line
-						const endLineStr: string | undefined = block.params.end_line
-
-						// Get the full path and determine if it's outside the workspace
-						const fullPath = relPath ? path.resolve(this.cwd, removeClosingTag("path", relPath)) : ""
-						const isOutsideWorkspace = isPathOutsideWorkspace(fullPath)
-
-						const sharedMessageProps: ClineSayTool = {
-							tool: "readFile",
-							path: getReadablePath(this.cwd, removeClosingTag("path", relPath)),
-							isOutsideWorkspace,
-						}
-						try {
-							if (block.partial) {
-								const partialMessage = JSON.stringify({
-									...sharedMessageProps,
-									content: undefined,
-								} satisfies ClineSayTool)
-								await this.ask("tool", partialMessage, block.partial).catch(() => {})
-								break
-							} else {
-								if (!relPath) {
-									this.consecutiveMistakeCount++
-									pushToolResult(await this.sayAndCreateMissingParamError("read_file", "path"))
-									break
-								}
-
-								// Check if we're doing a line range read
-								let isRangeRead = false
-								let startLine: number | undefined = undefined
-								let endLine: number | undefined = undefined
-
-								// Check if we have either range parameter
-								if (startLineStr || endLineStr) {
-									isRangeRead = true
-								}
-
-								// Parse start_line if provided
-								if (startLineStr) {
-									startLine = parseInt(startLineStr)
-									if (isNaN(startLine)) {
-										// Invalid start_line
-										this.consecutiveMistakeCount++
-										await this.say("error", `Failed to parse start_line: ${startLineStr}`)
-										pushToolResult(formatResponse.toolError("Invalid start_line value"))
-										break
-									}
-									startLine -= 1 // Convert to 0-based index
-								}
-
-								// Parse end_line if provided
-								if (endLineStr) {
-									endLine = parseInt(endLineStr)
-
-									if (isNaN(endLine)) {
-										// Invalid end_line
-										this.consecutiveMistakeCount++
-										await this.say("error", `Failed to parse end_line: ${endLineStr}`)
-										pushToolResult(formatResponse.toolError("Invalid end_line value"))
-										break
-									}
-
-									// Convert to 0-based index
-									endLine -= 1
-								}
-
-								const accessAllowed = this.rooIgnoreController?.validateAccess(relPath)
-								if (!accessAllowed) {
-									await this.say("rooignore_error", relPath)
-									pushToolResult(formatResponse.toolError(formatResponse.rooIgnoreError(relPath)))
-
-									break
-								}
-
-								this.consecutiveMistakeCount = 0
-								const absolutePath = path.resolve(this.cwd, relPath)
-								const completeMessage = JSON.stringify({
-									...sharedMessageProps,
-									content: absolutePath,
-								} satisfies ClineSayTool)
-
-								const didApprove = await askApproval("tool", completeMessage)
-								if (!didApprove) {
-									break
-								}
-
-								// Get the maxReadFileLine setting
-								const { maxReadFileLine = 500 } = (await this.providerRef.deref()?.getState()) ?? {}
-
-								// Count total lines in the file
-								let totalLines = 0
-								try {
-									totalLines = await countFileLines(absolutePath)
-								} catch (error) {
-									console.error(`Error counting lines in file ${absolutePath}:`, error)
-								}
-
-								// now execute the tool like normal
-								let content: string
-								let isFileTruncated = false
-								let sourceCodeDef = ""
-
-								const isBinary = await isBinaryFile(absolutePath).catch(() => false)
-
-								if (isRangeRead) {
-									if (startLine === undefined) {
-										content = addLineNumbers(await readLines(absolutePath, endLine, startLine))
-									} else {
-										content = addLineNumbers(
-											await readLines(absolutePath, endLine, startLine),
-											startLine + 1,
-										)
-									}
-								} else if (!isBinary && maxReadFileLine >= 0 && totalLines > maxReadFileLine) {
-									// If file is too large, only read the first maxReadFileLine lines
-									isFileTruncated = true
-
-									const res = await Promise.all([
-										maxReadFileLine > 0 ? readLines(absolutePath, maxReadFileLine - 1, 0) : "",
-										parseSourceCodeDefinitionsForFile(absolutePath, this.rooIgnoreController),
-									])
-
-									content = res[0].length > 0 ? addLineNumbers(res[0]) : ""
-									const result = res[1]
-									if (result) {
-										sourceCodeDef = `\n\n${result}`
-									}
-								} else {
-									// Read entire file
-									content = await extractTextFromFile(absolutePath)
-								}
-
-								// Add truncation notice if applicable
-								if (isFileTruncated) {
-									content += `\n\n[Showing only ${maxReadFileLine} of ${totalLines} total lines. Use start_line and end_line if you need to read more]${sourceCodeDef}`
-								}
-
-								pushToolResult(content)
-								break
-							}
-						} catch (error) {
-							await handleError("reading file", error)
-							break
-						}
-					}
-
-					case "fetch_instructions": {
-						fetchInstructionsTool(this, block, askApproval, handleError, pushToolResult)
-						break
-					}
-
-					case "list_files": {
-						const relDirPath: string | undefined = block.params.path
-						const recursiveRaw: string | undefined = block.params.recursive
-						const recursive = recursiveRaw?.toLowerCase() === "true"
-						const sharedMessageProps: ClineSayTool = {
-							tool: !recursive ? "listFilesTopLevel" : "listFilesRecursive",
-							path: getReadablePath(this.cwd, removeClosingTag("path", relDirPath)),
-						}
-						try {
-							if (block.partial) {
-								const partialMessage = JSON.stringify({
-									...sharedMessageProps,
-									content: "",
-								} satisfies ClineSayTool)
-								await this.ask("tool", partialMessage, block.partial).catch(() => {})
-								break
-							} else {
-								if (!relDirPath) {
-									this.consecutiveMistakeCount++
-									pushToolResult(await this.sayAndCreateMissingParamError("list_files", "path"))
-									break
-								}
-								this.consecutiveMistakeCount = 0
-								const absolutePath = path.resolve(this.cwd, relDirPath)
-								const [files, didHitLimit] = await listFiles(absolutePath, recursive, 200)
-								const { showRooIgnoredFiles = true } =
-									(await this.providerRef.deref()?.getState()) ?? {}
-								const result = formatResponse.formatFilesList(
-									absolutePath,
-									files,
-									didHitLimit,
-									this.rooIgnoreController,
-									showRooIgnoredFiles,
-								)
-								const completeMessage = JSON.stringify({
-									...sharedMessageProps,
-									content: result,
-								} satisfies ClineSayTool)
-								const didApprove = await askApproval("tool", completeMessage)
-								if (!didApprove) {
-									break
-								}
-								pushToolResult(result)
-								break
-							}
-						} catch (error) {
-							await handleError("listing files", error)
-							break
-						}
-					}
-					case "list_code_definition_names": {
-						const relPath: string | undefined = block.params.path
-						const sharedMessageProps: ClineSayTool = {
-							tool: "listCodeDefinitionNames",
-							path: getReadablePath(this.cwd, removeClosingTag("path", relPath)),
-						}
-						try {
-							if (block.partial) {
-								const partialMessage = JSON.stringify({
-									...sharedMessageProps,
-									content: "",
-								} satisfies ClineSayTool)
-								await this.ask("tool", partialMessage, block.partial).catch(() => {})
-								break
-							} else {
-								if (!relPath) {
-									this.consecutiveMistakeCount++
-									pushToolResult(
-										await this.sayAndCreateMissingParamError("list_code_definition_names", "path"),
-									)
-									break
-								}
-								this.consecutiveMistakeCount = 0
-								const absolutePath = path.resolve(this.cwd, relPath)
-								let result: string
-								try {
-									const stats = await fs.stat(absolutePath)
-									if (stats.isFile()) {
-										const fileResult = await parseSourceCodeDefinitionsForFile(
-											absolutePath,
-											this.rooIgnoreController,
-										)
-										result = fileResult ?? "No source code definitions found in this file."
-									} else if (stats.isDirectory()) {
-										result = await parseSourceCodeForDefinitionsTopLevel(
-											absolutePath,
-											this.rooIgnoreController,
-										)
-									} else {
-										result = "The specified path is neither a file nor a directory."
-									}
-								} catch {
-									result = `${absolutePath}: does not exist or cannot be accessed.`
-								}
-								const completeMessage = JSON.stringify({
-									...sharedMessageProps,
-									content: result,
-								} satisfies ClineSayTool)
-								const didApprove = await askApproval("tool", completeMessage)
-								if (!didApprove) {
-									break
-								}
-								pushToolResult(result)
-								break
-							}
-						} catch (error) {
-							await handleError("parsing source code definitions", error)
-							break
-						}
-					}
-					case "search_files": {
-						const relDirPath: string | undefined = block.params.path
-						const regex: string | undefined = block.params.regex
-						const filePattern: string | undefined = block.params.file_pattern
-						const sharedMessageProps: ClineSayTool = {
-							tool: "searchFiles",
-							path: getReadablePath(this.cwd, removeClosingTag("path", relDirPath)),
-							regex: removeClosingTag("regex", regex),
-							filePattern: removeClosingTag("file_pattern", filePattern),
-						}
-						try {
-							if (block.partial) {
-								const partialMessage = JSON.stringify({
-									...sharedMessageProps,
-									content: "",
-								} satisfies ClineSayTool)
-								await this.ask("tool", partialMessage, block.partial).catch(() => {})
-								break
-							} else {
-								if (!relDirPath) {
-									this.consecutiveMistakeCount++
-									pushToolResult(await this.sayAndCreateMissingParamError("search_files", "path"))
-									break
-								}
-								if (!regex) {
-									this.consecutiveMistakeCount++
-									pushToolResult(await this.sayAndCreateMissingParamError("search_files", "regex"))
-									break
-								}
-								this.consecutiveMistakeCount = 0
-								const absolutePath = path.resolve(this.cwd, relDirPath)
-								const results = await regexSearchFiles(
-									this.cwd,
-									absolutePath,
-									regex,
-									filePattern,
-									this.rooIgnoreController,
-								)
-								const completeMessage = JSON.stringify({
-									...sharedMessageProps,
-									content: results,
-								} satisfies ClineSayTool)
-								const didApprove = await askApproval("tool", completeMessage)
-								if (!didApprove) {
-									break
-								}
-								pushToolResult(results)
-								break
-							}
-						} catch (error) {
-							await handleError("searching files", error)
-							break
-						}
-					}
-					case "browser_action": {
-						const action: BrowserAction | undefined = block.params.action as BrowserAction
-						const url: string | undefined = block.params.url
-						const coordinate: string | undefined = block.params.coordinate
-						const text: string | undefined = block.params.text
-						if (!action || !browserActions.includes(action)) {
-							// checking for action to ensure it is complete and valid
-							if (!block.partial) {
-								// if the block is complete and we don't have a valid action this is a mistake
-								this.consecutiveMistakeCount++
-								pushToolResult(await this.sayAndCreateMissingParamError("browser_action", "action"))
-								await this.browserSession.closeBrowser()
-							}
-							break
-						}
-
-						try {
-							if (block.partial) {
-								if (action === "launch") {
-									await this.ask(
-										"browser_action_launch",
-										removeClosingTag("url", url),
-										block.partial,
-									).catch(() => {})
-								} else {
-									await this.say(
-										"browser_action",
-										JSON.stringify({
-											action: action as BrowserAction,
-											coordinate: removeClosingTag("coordinate", coordinate),
-											text: removeClosingTag("text", text),
-										} satisfies ClineSayBrowserAction),
-										undefined,
-										block.partial,
-									)
-								}
-								break
-							} else {
-								let browserActionResult: BrowserActionResult
-								if (action === "launch") {
-									if (!url) {
-										this.consecutiveMistakeCount++
-										pushToolResult(
-											await this.sayAndCreateMissingParamError("browser_action", "url"),
-										)
-										await this.browserSession.closeBrowser()
-										break
-									}
-									this.consecutiveMistakeCount = 0
-									const didApprove = await askApproval("browser_action_launch", url)
-									if (!didApprove) {
-										break
-									}
-
-									// NOTE: it's okay that we call this message since the partial inspect_site is finished streaming. The only scenario we have to avoid is sending messages WHILE a partial message exists at the end of the messages array. For example the api_req_finished message would interfere with the partial message, so we needed to remove that.
-									// await this.say("inspect_site_result", "") // no result, starts the loading spinner waiting for result
-									await this.say("browser_action_result", "") // starts loading spinner
-
-									await this.browserSession.launchBrowser()
-									browserActionResult = await this.browserSession.navigateToUrl(url)
-								} else {
-									if (action === "click") {
-										if (!coordinate) {
-											this.consecutiveMistakeCount++
-											pushToolResult(
-												await this.sayAndCreateMissingParamError(
-													"browser_action",
-													"coordinate",
-												),
-											)
-											await this.browserSession.closeBrowser()
-											break // can't be within an inner switch
-										}
-									}
-									if (action === "type") {
-										if (!text) {
-											this.consecutiveMistakeCount++
-											pushToolResult(
-												await this.sayAndCreateMissingParamError("browser_action", "text"),
-											)
-											await this.browserSession.closeBrowser()
-											break
-										}
-									}
-									this.consecutiveMistakeCount = 0
-									await this.say(
-										"browser_action",
-										JSON.stringify({
-											action: action as BrowserAction,
-											coordinate,
-											text,
-										} satisfies ClineSayBrowserAction),
-										undefined,
-										false,
-									)
-									switch (action) {
-										case "click":
-											browserActionResult = await this.browserSession.click(coordinate!)
-											break
-										case "type":
-											browserActionResult = await this.browserSession.type(text!)
-											break
-										case "scroll_down":
-											browserActionResult = await this.browserSession.scrollDown()
-											break
-										case "scroll_up":
-											browserActionResult = await this.browserSession.scrollUp()
-											break
-										case "close":
-											browserActionResult = await this.browserSession.closeBrowser()
-											break
-									}
-								}
-
-								switch (action) {
-									case "launch":
-									case "click":
-									case "type":
-									case "scroll_down":
-									case "scroll_up":
-										await this.say("browser_action_result", JSON.stringify(browserActionResult))
-										pushToolResult(
-											formatResponse.toolResult(
-												`The browser action has been executed. The console logs and screenshot have been captured for your analysis.\n\nConsole logs:\n${
-													browserActionResult.logs || "(No new logs)"
-												}\n\n(REMEMBER: if you need to proceed to using non-\`browser_action\` tools or launch a new browser, you MUST first close this browser. For example, if after analyzing the logs and screenshot you need to edit a file, you must first close the browser before you can use the write_to_file tool.)`,
-												browserActionResult.screenshot ? [browserActionResult.screenshot] : [],
-											),
-										)
-										break
-									case "close":
-										pushToolResult(
-											formatResponse.toolResult(
-												`The browser has been closed. You may now proceed to using other tools.`,
-											),
-										)
-										break
-								}
-								break
-							}
-						} catch (error) {
-							await this.browserSession.closeBrowser() // if any error occurs, the browser session is terminated
-							await handleError("executing browser action", error)
-							break
-						}
-					}
-					case "execute_command": {
-						const command: string | undefined = block.params.command
-						const customCwd: string | undefined = block.params.cwd
-						try {
-							if (block.partial) {
-								await this.ask("command", removeClosingTag("command", command), block.partial).catch(
-									() => {},
-								)
-								break
-							} else {
-								if (!command) {
-									this.consecutiveMistakeCount++
-									pushToolResult(
-										await this.sayAndCreateMissingParamError("execute_command", "command"),
-									)
-									break
-								}
-
-								const ignoredFileAttemptedToAccess = this.rooIgnoreController?.validateCommand(command)
-								if (ignoredFileAttemptedToAccess) {
-									await this.say("rooignore_error", ignoredFileAttemptedToAccess)
-									pushToolResult(
-										formatResponse.toolError(
-											formatResponse.rooIgnoreError(ignoredFileAttemptedToAccess),
-										),
-									)
-
-									break
-								}
-
-								this.consecutiveMistakeCount = 0
-
-								const didApprove = await askApproval("command", command)
-								if (!didApprove) {
-									break
-								}
-								const [userRejected, result] = await this.executeCommandTool(command, customCwd)
-								if (userRejected) {
-									this.didRejectTool = true
-								}
-								pushToolResult(result)
-								break
-							}
-						} catch (error) {
-							await handleError("executing command", error)
-							break
-						}
-					}
-					case "use_mcp_tool": {
-						const server_name: string | undefined = block.params.server_name
-						const tool_name: string | undefined = block.params.tool_name
-						const mcp_arguments: string | undefined = block.params.arguments
-						try {
-							if (block.partial) {
-								const partialMessage = JSON.stringify({
-									type: "use_mcp_tool",
-									serverName: removeClosingTag("server_name", server_name),
-									toolName: removeClosingTag("tool_name", tool_name),
-									arguments: removeClosingTag("arguments", mcp_arguments),
-								} satisfies ClineAskUseMcpServer)
-								await this.ask("use_mcp_server", partialMessage, block.partial).catch(() => {})
-								break
-							} else {
-								if (!server_name) {
-									this.consecutiveMistakeCount++
-									pushToolResult(
-										await this.sayAndCreateMissingParamError("use_mcp_tool", "server_name"),
-									)
-									break
-								}
-								if (!tool_name) {
-									this.consecutiveMistakeCount++
-									pushToolResult(
-										await this.sayAndCreateMissingParamError("use_mcp_tool", "tool_name"),
-									)
-									break
-								}
-								// arguments are optional, but if they are provided they must be valid JSON
-								// if (!mcp_arguments) {
-								// 	this.consecutiveMistakeCount++
-								// 	pushToolResult(await this.sayAndCreateMissingParamError("use_mcp_tool", "arguments"))
-								// 	break
-								// }
-								let parsedArguments: Record<string, unknown> | undefined
-								if (mcp_arguments) {
-									try {
-										parsedArguments = JSON.parse(mcp_arguments)
-									} catch (error) {
-										this.consecutiveMistakeCount++
-										await this.say(
-											"error",
-											`Roo tried to use ${tool_name} with an invalid JSON argument. Retrying...`,
-										)
-										pushToolResult(
-											formatResponse.toolError(
-												formatResponse.invalidMcpToolArgumentError(server_name, tool_name),
-											),
-										)
-										break
-									}
-								}
-								this.consecutiveMistakeCount = 0
-								const completeMessage = JSON.stringify({
-									type: "use_mcp_tool",
-									serverName: server_name,
-									toolName: tool_name,
-									arguments: mcp_arguments,
-								} satisfies ClineAskUseMcpServer)
-								const didApprove = await askApproval("use_mcp_server", completeMessage)
-								if (!didApprove) {
-									break
-								}
-								// now execute the tool
-								await this.say("mcp_server_request_started") // same as browser_action_result
-								const toolResult = await this.providerRef
-									.deref()
-									?.getMcpHub()
-									?.callTool(server_name, tool_name, parsedArguments)
-
-								// TODO: add progress indicator and ability to parse images and non-text responses
-								const toolResultPretty =
-									(toolResult?.isError ? "Error:\n" : "") +
-										toolResult?.content
-											.map((item) => {
-												if (item.type === "text") {
-													return item.text
-												}
-												if (item.type === "resource") {
-													const { blob, ...rest } = item.resource
-													return JSON.stringify(rest, null, 2)
-												}
-												return ""
-											})
-											.filter(Boolean)
-											.join("\n\n") || "(No response)"
-								await this.say("mcp_server_response", toolResultPretty)
-								pushToolResult(formatResponse.toolResult(toolResultPretty))
-								break
-							}
-						} catch (error) {
-							await handleError("executing MCP tool", error)
-							break
-						}
-					}
-					case "access_mcp_resource": {
-						const server_name: string | undefined = block.params.server_name
-						const uri: string | undefined = block.params.uri
-						try {
-							if (block.partial) {
-								const partialMessage = JSON.stringify({
-									type: "access_mcp_resource",
-									serverName: removeClosingTag("server_name", server_name),
-									uri: removeClosingTag("uri", uri),
-								} satisfies ClineAskUseMcpServer)
-								await this.ask("use_mcp_server", partialMessage, block.partial).catch(() => {})
-								break
-							} else {
-								if (!server_name) {
-									this.consecutiveMistakeCount++
-									pushToolResult(
-										await this.sayAndCreateMissingParamError("access_mcp_resource", "server_name"),
-									)
-									break
-								}
-								if (!uri) {
-									this.consecutiveMistakeCount++
-									pushToolResult(
-										await this.sayAndCreateMissingParamError("access_mcp_resource", "uri"),
-									)
-									break
-								}
-								this.consecutiveMistakeCount = 0
-								const completeMessage = JSON.stringify({
-									type: "access_mcp_resource",
-									serverName: server_name,
-									uri,
-								} satisfies ClineAskUseMcpServer)
-								const didApprove = await askApproval("use_mcp_server", completeMessage)
-								if (!didApprove) {
-									break
-								}
-								// now execute the tool
-								await this.say("mcp_server_request_started")
-								const resourceResult = await this.providerRef
-									.deref()
-									?.getMcpHub()
-									?.readResource(server_name, uri)
-								const resourceResultPretty =
-									resourceResult?.contents
-										.map((item) => {
-											if (item.text) {
-												return item.text
-											}
-											return ""
-										})
-										.filter(Boolean)
-										.join("\n\n") || "(Empty response)"
-
-								// handle images (image must contain mimetype and blob)
-								let images: string[] = []
-								resourceResult?.contents.forEach((item) => {
-									if (item.mimeType?.startsWith("image") && item.blob) {
-										images.push(item.blob)
-									}
-								})
-								await this.say("mcp_server_response", resourceResultPretty, images)
-								pushToolResult(formatResponse.toolResult(resourceResultPretty, images))
-								break
-							}
-						} catch (error) {
-							await handleError("accessing MCP resource", error)
-							break
-						}
-					}
-					case "ask_followup_question": {
-						const question: string | undefined = block.params.question
-						const follow_up: string | undefined = block.params.follow_up
-						try {
-							if (block.partial) {
-								await this.ask("followup", removeClosingTag("question", question), block.partial).catch(
-									() => {},
-								)
-								break
-							} else {
-								if (!question) {
-									this.consecutiveMistakeCount++
-									pushToolResult(
-										await this.sayAndCreateMissingParamError("ask_followup_question", "question"),
-									)
-									break
-								}
-
-								type Suggest = {
-									answer: string
-								}
-
-								let follow_up_json = {
-									question,
-									suggest: [] as Suggest[],
-								}
-
-								if (follow_up) {
-									let parsedSuggest: {
-										suggest: Suggest[] | Suggest
-									}
-
-									try {
-										parsedSuggest = parseXml(follow_up, ["suggest"]) as {
-											suggest: Suggest[] | Suggest
-										}
-									} catch (error) {
-										this.consecutiveMistakeCount++
-										await this.say("error", `Failed to parse operations: ${error.message}`)
-										pushToolResult(formatResponse.toolError("Invalid operations xml format"))
-										break
-									}
-
-									const normalizedSuggest = Array.isArray(parsedSuggest?.suggest)
-										? parsedSuggest.suggest
-										: [parsedSuggest?.suggest].filter((sug): sug is Suggest => sug !== undefined)
-
-									follow_up_json.suggest = normalizedSuggest
-								}
-
-								this.consecutiveMistakeCount = 0
-
-								const { text, images } = await this.ask(
-									"followup",
-									JSON.stringify(follow_up_json),
-									false,
-								)
-								await this.say("user_feedback", text ?? "", images)
-								pushToolResult(formatResponse.toolResult(`<answer>\n${text}\n</answer>`, images))
-								break
-							}
-						} catch (error) {
-							await handleError("asking question", error)
-							break
-						}
-					}
-					case "switch_mode": {
-						const mode_slug: string | undefined = block.params.mode_slug
-						const reason: string | undefined = block.params.reason
-						try {
-							if (block.partial) {
-								const partialMessage = JSON.stringify({
-									tool: "switchMode",
-									mode: removeClosingTag("mode_slug", mode_slug),
-									reason: removeClosingTag("reason", reason),
-								})
-								await this.ask("tool", partialMessage, block.partial).catch(() => {})
-								break
-							} else {
-								if (!mode_slug) {
-									this.consecutiveMistakeCount++
-									pushToolResult(await this.sayAndCreateMissingParamError("switch_mode", "mode_slug"))
-									break
-								}
-								this.consecutiveMistakeCount = 0
-
-								// Verify the mode exists
-								const targetMode = getModeBySlug(
-									mode_slug,
-									(await this.providerRef.deref()?.getState())?.customModes,
-								)
-								if (!targetMode) {
-									pushToolResult(formatResponse.toolError(`Invalid mode: ${mode_slug}`))
-									break
-								}
-
-								// Check if already in requested mode
-								const currentMode =
-									(await this.providerRef.deref()?.getState())?.mode ?? defaultModeSlug
-								if (currentMode === mode_slug) {
-									pushToolResult(`Already in ${targetMode.name} mode.`)
-									break
-								}
-
-								const completeMessage = JSON.stringify({
-									tool: "switchMode",
-									mode: mode_slug,
-									reason,
-								})
-
-								const didApprove = await askApproval("tool", completeMessage)
-								if (!didApprove) {
-									break
-								}
-
-								// Switch the mode using shared handler
-								await this.providerRef.deref()?.handleModeSwitch(mode_slug)
-								pushToolResult(
-									`Successfully switched from ${getModeBySlug(currentMode)?.name ?? currentMode} mode to ${
-										targetMode.name
-									} mode${reason ? ` because: ${reason}` : ""}.`,
-								)
-								await delay(500) // delay to allow mode change to take effect before next tool is executed
-								break
-							}
-						} catch (error) {
-							await handleError("switching mode", error)
-							break
-						}
-					}
-
-					case "new_task": {
-						const mode: string | undefined = block.params.mode
-						const message: string | undefined = block.params.message
-						try {
-							if (block.partial) {
-								const partialMessage = JSON.stringify({
-									tool: "newTask",
-									mode: removeClosingTag("mode", mode),
-									message: removeClosingTag("message", message),
-								})
-								await this.ask("tool", partialMessage, block.partial).catch(() => {})
-								break
-							} else {
-								if (!mode) {
-									this.consecutiveMistakeCount++
-									pushToolResult(await this.sayAndCreateMissingParamError("new_task", "mode"))
-									break
-								}
-								if (!message) {
-									this.consecutiveMistakeCount++
-									pushToolResult(await this.sayAndCreateMissingParamError("new_task", "message"))
-									break
-								}
-								this.consecutiveMistakeCount = 0
-
-								// Verify the mode exists
-								const targetMode = getModeBySlug(
-									mode,
-									(await this.providerRef.deref()?.getState())?.customModes,
-								)
-								if (!targetMode) {
-									pushToolResult(formatResponse.toolError(`Invalid mode: ${mode}`))
-									break
-								}
-
-								const toolMessage = JSON.stringify({
-									tool: "newTask",
-									mode: targetMode.name,
-									content: message,
-								})
-								const didApprove = await askApproval("tool", toolMessage)
-
-								if (!didApprove) {
-									break
-								}
-
-								const provider = this.providerRef.deref()
-
-								if (!provider) {
-									break
-								}
-
-								// Preserve the current mode so we can resume with it later.
-								this.pausedModeSlug = (await provider.getState()).mode ?? defaultModeSlug
-
-								// Switch mode first, then create new task instance.
-								await provider.handleModeSwitch(mode)
-
-								// Delay to allow mode change to take effect before next tool is executed.
-								await delay(500)
-
-								const newCline = await provider.initClineWithTask(message, undefined, this)
-								this.emit("taskSpawned", newCline.taskId)
-
-								pushToolResult(
-									`Successfully created new task in ${targetMode.name} mode with message: ${message}`,
-								)
-
-								// Set the isPaused flag to true so the parent
-								// task can wait for the sub-task to finish.
-								this.isPaused = true
-								this.emit("taskPaused")
-
-								break
-							}
-						} catch (error) {
-							await handleError("creating new task", error)
-							break
-						}
-					}
-
-					case "attempt_completion": {
-						const result: string | undefined = block.params.result
-						const command: string | undefined = block.params.command
-						try {
-							const lastMessage = this.clineMessages.at(-1)
-							if (block.partial) {
-								if (command) {
-									// the attempt_completion text is done, now we're getting command
-									// remove the previous partial attempt_completion ask, replace with say, post state to webview, then stream command
-
-									// const secondLastMessage = this.clineMessages.at(-2)
-									if (lastMessage && lastMessage.ask === "command") {
-										// update command
-										await this.ask(
-											"command",
-											removeClosingTag("command", command),
-											block.partial,
-										).catch(() => {})
-									} else {
-										// last message is completion_result
-										// we have command string, which means we have the result as well, so finish it (doesnt have to exist yet)
-										await this.say(
-											"completion_result",
-											removeClosingTag("result", result),
-											undefined,
-											false,
-										)
-
-										telemetryService.captureTaskCompleted(this.taskId)
-										this.emit("taskCompleted", this.taskId, this.getTokenUsage())
-
-										await this.ask(
-											"command",
-											removeClosingTag("command", command),
-											block.partial,
-										).catch(() => {})
-									}
-								} else {
-									// no command, still outputting partial result
-									await this.say(
-										"completion_result",
-										removeClosingTag("result", result),
-										undefined,
-										block.partial,
-									)
-								}
-								break
-							} else {
-								if (!result) {
-									this.consecutiveMistakeCount++
-									pushToolResult(
-										await this.sayAndCreateMissingParamError("attempt_completion", "result"),
-									)
-									break
-								}
-
-								this.consecutiveMistakeCount = 0
-
-								let commandResult: ToolResponse | undefined
-
-								if (command) {
-									if (lastMessage && lastMessage.ask !== "command") {
-										// Haven't sent a command message yet so first send completion_result then command.
-										await this.say("completion_result", result, undefined, false)
-										telemetryService.captureTaskCompleted(this.taskId)
-										this.emit("taskCompleted", this.taskId, this.getTokenUsage())
-									}
-
-									// Complete command message.
-									const didApprove = await askApproval("command", command)
-
-									if (!didApprove) {
-										break
-									}
-
-									const [userRejected, execCommandResult] = await this.executeCommandTool(command!)
-
-									if (userRejected) {
-										this.didRejectTool = true
-										pushToolResult(execCommandResult)
-										break
-									}
-
-									// User didn't reject, but the command may have output.
-									commandResult = execCommandResult
-								} else {
-									await this.say("completion_result", result, undefined, false)
-									telemetryService.captureTaskCompleted(this.taskId)
-									this.emit("taskCompleted", this.taskId, this.getTokenUsage())
-								}
-
-								if (this.parentTask) {
-									const didApprove = await askFinishSubTaskApproval()
-
-									if (!didApprove) {
-										break
-									}
-
-									// tell the provider to remove the current subtask and resume the previous task in the stack
-									await this.providerRef.deref()?.finishSubTask(`Task complete: ${lastMessage?.text}`)
-									break
-								}
-
-								// We already sent completion_result says, an
-								// empty string asks relinquishes control over
-								// button and field.
-								const { response, text, images } = await this.ask("completion_result", "", false)
-
-								// Signals to recursive loop to stop (for now
-								// this never happens since yesButtonClicked
-								// will trigger a new task).
-								if (response === "yesButtonClicked") {
-									pushToolResult("")
-									break
-								}
-
-								await this.say("user_feedback", text ?? "", images)
-								const toolResults: (Anthropic.TextBlockParam | Anthropic.ImageBlockParam)[] = []
-
-								if (commandResult) {
-									if (typeof commandResult === "string") {
-										toolResults.push({ type: "text", text: commandResult })
-									} else if (Array.isArray(commandResult)) {
-										toolResults.push(...commandResult)
-									}
-								}
-
-								toolResults.push({
-									type: "text",
-									text: `The user has provided feedback on the results. Consider their input to continue the task, and then attempt completion again.\n<feedback>\n${text}\n</feedback>`,
-								})
-
-								toolResults.push(...formatResponse.imageBlocks(images))
-
-								this.userMessageContent.push({
-									type: "text",
-									text: `${toolDescription()} Result:`,
-								})
-
-								this.userMessageContent.push(...toolResults)
-								break
-							}
-						} catch (error) {
-							await handleError("inspecting site", error)
-							break
+						if (handledCompletely) {
+							// Tool was handled completely, mark checkpoint possible
+							isCheckpointPossible = true;
+							// Note: pushToolResult is now called within the handler or helpers
+							// this.didAlreadyUseTool is also set within pushToolResult
 						}
+						// If handled partially (returns false), do nothing here.
+
+					} catch (error: any) {
+						// Catch errors during handler instantiation or execution
+						console.error(`Error handling tool ${block.name}:`, error);
+						// Use the public helper to report the error
+						await this.handleErrorHelper(block, `handling tool ${block.name}`, error);
+						// Ensure didAlreadyUseTool is set even on error
+						this.didAlreadyUseTool = true;
 					}
+				} else {
+					// --- Fallback for Unhandled Tools ---
+					console.error(`No handler found for tool: ${block.name}`);
+					this.consecutiveMistakeCount++;
+					// Use the public pushToolResult method to report the error
+					await this.pushToolResult(block, formatResponse.toolError(`Unsupported tool: ${block.name}`));
+					// Ensure didAlreadyUseTool is set
+					this.didAlreadyUseTool = true;
 				}
-
-				break
+				break; // Break from tool_use case
+			}
 		}
 
 		if (isCheckpointPossible) {
diff --git a/src/core/tool-handlers/ToolUseHandler.ts b/src/core/tool-handlers/ToolUseHandler.ts
new file mode 100644
index 00000000..3d99a0c0
--- /dev/null
+++ b/src/core/tool-handlers/ToolUseHandler.ts
@@ -0,0 +1,80 @@
+// src/core/tool-handlers/ToolUseHandler.ts
+import { ToolUse } from "../assistant-message";
+import { Cline } from "../Cline";
+
+export abstract class ToolUseHandler {
+  protected cline: Cline;
+  protected toolUse: ToolUse;
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    this.cline = cline;
+    this.toolUse = toolUse;
+  }
+
+  /**
+   * Handle the tool use, both partial and complete states
+   * @returns Promise<boolean> true if the tool was handled completely, false if only partially handled (streaming)
+   */
+  abstract handle(): Promise<boolean>;
+
+  /**
+   * Handle a partial tool use (streaming)
+   * This method should update the UI/state based on the partial data received so far.
+   * It typically returns void as the handling is ongoing.
+   */
+  protected abstract handlePartial(): Promise<void>;
+
+  /**
+   * Handle a complete tool use
+   * This method performs the final action for the tool use after all data is received.
+   * It typically returns void as the action is completed within this method.
+   */
+  protected abstract handleComplete(): Promise<void>;
+
+  /**
+   * Validate the tool parameters
+   * @throws Error if validation fails
+   */
+  abstract validateParams(): void;
+
+  /**
+   * Helper to remove potentially incomplete closing tags from parameters during streaming.
+   * Example: <path>src/my</path> might stream as "src/my</pat" initially.
+   * This helps get the usable value during partial updates.
+   */
+  protected removeClosingTag(tag: string, text?: string): string {
+    // Only apply removal if it's a partial tool use
+    if (!this.toolUse.partial) {
+      return text || "";
+    }
+    if (!text) {
+      return "";
+    }
+    // Regex to match a potentially incomplete closing tag at the end of the string
+    // Example: Matches </tag>, </ta>, </t>, </
+    const tagRegex = new RegExp(
+      `\\s*<\\/?${tag
+        .split("")
+        .map((char) => `(?:${char})?`) // Match each character optionally
+        .join("")}$`,
+      "g"
+    );
+    return text.replace(tagRegex, "");
+  }
+
+  /**
+   * Helper to handle missing parameters consistently.
+   * Increments mistake count and formats a standard error message for the API.
+   */
+  protected async handleMissingParam(paramName: string): Promise<string> {
+    this.cline.consecutiveMistakeCount++; // Assuming consecutiveMistakeCount is accessible or moved
+    // Consider making sayAndCreateMissingParamError public or moving it to a shared utility
+    // if consecutiveMistakeCount remains private and central to Cline.
+    // For now, assuming it can be called or its logic replicated here/in base class.
+    return await this.cline.sayAndCreateMissingParamError(
+      this.toolUse.name,
+      paramName,
+      this.toolUse.params.path // Assuming path might be relevant context, though not always present
+    );
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/ToolUseHandlerFactory.ts b/src/core/tool-handlers/ToolUseHandlerFactory.ts
new file mode 100644
index 00000000..c3119db3
--- /dev/null
+++ b/src/core/tool-handlers/ToolUseHandlerFactory.ts
@@ -0,0 +1,80 @@
+// src/core/tool-handlers/ToolUseHandlerFactory.ts
+import { ToolUse, ToolUseName } from "../assistant-message";
+import { Cline } from "../Cline";
+import { ToolUseHandler } from "./ToolUseHandler";
+// Import statements for individual handlers (files will be created later)
+import { WriteToFileHandler } from "./tools/WriteToFileHandler";
+import { ReadFileHandler } from "./tools/ReadFileHandler";
+import { ExecuteCommandHandler } from "./tools/ExecuteCommandHandler";
+import { ApplyDiffHandler } from "./tools/ApplyDiffHandler";
+import { SearchFilesHandler } from "./tools/SearchFilesHandler";
+import { ListFilesHandler } from "./tools/ListFilesHandler";
+import { ListCodeDefinitionNamesHandler } from "./tools/ListCodeDefinitionNamesHandler";
+import { BrowserActionHandler } from "./tools/BrowserActionHandler";
+import { UseMcpToolHandler } from "./tools/UseMcpToolHandler";
+import { AccessMcpResourceHandler } from "./tools/AccessMcpResourceHandler";
+import { AskFollowupQuestionHandler } from "./tools/AskFollowupQuestionHandler";
+import { AttemptCompletionHandler } from "./tools/AttemptCompletionHandler";
+import { SwitchModeHandler } from "./tools/SwitchModeHandler";
+import { NewTaskHandler } from "./tools/NewTaskHandler";
+import { FetchInstructionsHandler } from "./tools/FetchInstructionsHandler";
+import { InsertContentHandler } from "./tools/InsertContentHandler";
+import { SearchAndReplaceHandler } from "./tools/SearchAndReplaceHandler";
+import { formatResponse } from "../prompts/responses"; // Needed for error handling
+
+export class ToolUseHandlerFactory {
+  static createHandler(cline: Cline, toolUse: ToolUse): ToolUseHandler | null {
+    try {
+      switch (toolUse.name) {
+        case "write_to_file":
+          return new WriteToFileHandler(cline, toolUse);
+        case "read_file":
+          return new ReadFileHandler(cline, toolUse);
+        case "execute_command":
+          return new ExecuteCommandHandler(cline, toolUse);
+        case "apply_diff":
+          return new ApplyDiffHandler(cline, toolUse);
+        case "search_files":
+          return new SearchFilesHandler(cline, toolUse);
+        case "list_files":
+          return new ListFilesHandler(cline, toolUse);
+        case "list_code_definition_names":
+          return new ListCodeDefinitionNamesHandler(cline, toolUse);
+        case "browser_action":
+          return new BrowserActionHandler(cline, toolUse);
+        case "use_mcp_tool":
+          return new UseMcpToolHandler(cline, toolUse);
+        case "access_mcp_resource":
+          return new AccessMcpResourceHandler(cline, toolUse);
+        case "ask_followup_question":
+          return new AskFollowupQuestionHandler(cline, toolUse);
+        case "attempt_completion":
+          return new AttemptCompletionHandler(cline, toolUse);
+        case "switch_mode":
+          return new SwitchModeHandler(cline, toolUse);
+        case "new_task":
+          return new NewTaskHandler(cline, toolUse);
+        case "fetch_instructions":
+          return new FetchInstructionsHandler(cline, toolUse);
+        case "insert_content":
+          return new InsertContentHandler(cline, toolUse);
+        case "search_and_replace":
+          return new SearchAndReplaceHandler(cline, toolUse);
+        default:
+          // Handle unknown tool names gracefully
+          console.error(`No handler found for tool: ${toolUse.name}`);
+          // It's important the main loop handles this null return
+          // by pushing an appropriate error message back to the API.
+          // We avoid throwing an error here to let the caller decide.
+          return null;
+      }
+    } catch (error) {
+      // Catch potential errors during handler instantiation (though unlikely with current structure)
+     console.error(`Error creating handler for tool ${toolUse.name}:`, error);
+     // Push an error result back to the API via Cline instance
+     // Pass both the toolUse object and the error content
+     cline.pushToolResult(toolUse, formatResponse.toolError(`Error initializing handler for tool ${toolUse.name}.`));
+     return null; // Indicate failure to create handler
+   }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/AccessMcpResourceHandler.ts b/src/core/tool-handlers/tools/AccessMcpResourceHandler.ts
new file mode 100644
index 00000000..db6d656f
--- /dev/null
+++ b/src/core/tool-handlers/tools/AccessMcpResourceHandler.ts
@@ -0,0 +1,118 @@
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { ClineAskUseMcpServer } from "../../../shared/ExtensionMessage";
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+export class AccessMcpResourceHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.server_name) {
+      throw new Error("Missing required parameter 'server_name'");
+    }
+    if (!this.toolUse.params.uri) {
+      throw new Error("Missing required parameter 'uri'");
+    }
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const serverName = this.toolUse.params.server_name;
+    const uri = this.toolUse.params.uri;
+    if (!serverName || !uri) return; // Need server and uri for message
+
+    const partialMessage = JSON.stringify({
+      type: "access_mcp_resource",
+      serverName: this.removeClosingTag("server_name", serverName),
+      uri: this.removeClosingTag("uri", uri),
+    } satisfies ClineAskUseMcpServer);
+
+    try {
+      await this.cline.ask("use_mcp_server", partialMessage, true);
+    } catch (error) {
+      console.warn("AccessMcpResourceHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const serverName = this.toolUse.params.server_name;
+    const uri = this.toolUse.params.uri;
+
+    // --- Parameter Validation ---
+    if (!serverName) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("access_mcp_resource", "server_name"));
+      return;
+    }
+    if (!uri) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("access_mcp_resource", "uri"));
+      return;
+    }
+
+    // --- Access MCP Resource ---
+    try {
+      this.cline.consecutiveMistakeCount = 0; // Reset on successful validation
+
+      // --- Ask for Approval ---
+      const completeMessage = JSON.stringify({
+        type: "access_mcp_resource",
+        serverName: serverName,
+        uri: uri,
+      } satisfies ClineAskUseMcpServer);
+
+      const didApprove = await this.cline.askApprovalHelper(this.toolUse, "use_mcp_server", completeMessage);
+      if (!didApprove) {
+        // pushToolResult handled by helper
+        return;
+      }
+
+      // --- Call MCP Hub ---
+      await this.cline.say("mcp_server_request_started"); // Show loading/request state
+      const mcpHub = this.cline.providerRef.deref()?.getMcpHub();
+       if (!mcpHub) {
+          throw new Error("MCP Hub is not available.");
+      }
+
+      const resourceResult = await mcpHub.readResource(serverName, uri);
+
+      // --- Process Result ---
+      const resourceResultPretty =
+        resourceResult?.contents
+          ?.map((item) => item.text) // Extract only text content for the main result
+          .filter(Boolean)
+          .join("\n\n") || "(Empty response)";
+
+      // Extract images separately
+      const images: string[] = [];
+      resourceResult?.contents?.forEach((item) => {
+        if (item.mimeType?.startsWith("image") && item.blob) {
+          images.push(item.blob); // Assuming blob is base64 data URL
+        }
+      });
+
+      await this.cline.say("mcp_server_response", resourceResultPretty, images.length > 0 ? images : undefined); // Show result text and images
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(resourceResultPretty, images.length > 0 ? images : undefined));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+      // Handle errors during approval or MCP call
+      await this.cline.handleErrorHelper(this.toolUse, "accessing MCP resource", error);
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/ApplyDiffHandler.ts b/src/core/tool-handlers/tools/ApplyDiffHandler.ts
new file mode 100644
index 00000000..ca07eff6
--- /dev/null
+++ b/src/core/tool-handlers/tools/ApplyDiffHandler.ts
@@ -0,0 +1,259 @@
+import * as path from "path";
+import * as fs from "fs/promises";
+import { ToolUse } from "../../assistant-message"; // Use generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { ClineSayTool, ToolProgressStatus } from "../../../shared/ExtensionMessage";
+import { getReadablePath } from "../../../utils/path";
+import { fileExistsAtPath } from "../../../utils/fs";
+import { addLineNumbers } from "../../../integrations/misc/extract-text";
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+export class ApplyDiffHandler extends ToolUseHandler {
+  // protected override toolUse: ApplyDiffToolUse; // Removed override
+  // Store consecutive mistake count specific to apply_diff for each file
+  private consecutiveMistakeCountForApplyDiff: Map<string, number> = new Map();
+
+
+   constructor(cline: Cline, toolUse: ToolUse) {
+     super(cline, toolUse);
+     // this.toolUse = toolUse as ApplyDiffToolUse; // Removed type assertion
+     // Note: consecutiveMistakeCountForApplyDiff needs to be managed.
+     // If Cline instance is long-lived, this map might grow.
+     // Consider if this state should live on Cline or be handled differently.
+     // For now, keeping it within the handler instance.
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.path) {
+      throw new Error("Missing required parameter 'path'");
+    }
+    if (!this.toolUse.params.diff) {
+      throw new Error("Missing required parameter 'diff'");
+    }
+     if (!this.toolUse.params.start_line) {
+      throw new Error("Missing required parameter 'start_line'");
+    }
+     if (!this.toolUse.params.end_line) {
+      throw new Error("Missing required parameter 'end_line'");
+    }
+    // start_line and end_line content validation happens in handleComplete
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+    if (!relPath) return; // Need path for message
+
+    const sharedMessageProps: ClineSayTool = {
+      tool: "appliedDiff",
+      path: getReadablePath(this.cline.cwd, this.removeClosingTag("path", relPath)),
+    };
+
+    let toolProgressStatus: ToolProgressStatus | undefined;
+    // Assuming diffStrategy might have progress reporting capabilities
+    if (this.cline.diffStrategy && this.cline.diffStrategy.getProgressStatus) {
+      toolProgressStatus = this.cline.diffStrategy.getProgressStatus(this.toolUse);
+    }
+
+    const partialMessage = JSON.stringify(sharedMessageProps);
+    try {
+      await this.cline.ask("tool", partialMessage, true, toolProgressStatus);
+    } catch (error) {
+      console.warn("ApplyDiffHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+    const diffContent = this.toolUse.params.diff;
+    const startLineStr = this.toolUse.params.start_line;
+    const endLineStr = this.toolUse.params.end_line;
+
+    // --- Parameter Validation ---
+    if (!relPath) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("apply_diff", "path"));
+      return;
+    }
+    if (!diffContent) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("apply_diff", "diff"));
+      return;
+    }
+     if (!startLineStr) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("apply_diff", "start_line"));
+      return;
+    }
+     if (!endLineStr) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("apply_diff", "end_line"));
+      return;
+    }
+
+    let startLine: number | undefined = undefined;
+    let endLine: number | undefined = undefined;
+
+    try {
+        startLine = parseInt(startLineStr);
+        endLine = parseInt(endLineStr);
+        if (isNaN(startLine) || isNaN(endLine) || startLine < 1 || endLine < 1) {
+             throw new Error("start_line and end_line must be positive integers.");
+        }
+         if (startLine > endLine) {
+             throw new Error("start_line cannot be greater than end_line.");
+         }
+    } catch (error) {
+        this.cline.consecutiveMistakeCount++;
+        await this.cline.say("error", `Invalid line numbers: ${error.message}`);
+        await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(`Invalid line numbers: ${error.message}`));
+        return;
+    }
+
+
+    // --- Access Validation ---
+    const accessAllowed = this.cline.rooIgnoreController?.validateAccess(relPath);
+    if (!accessAllowed) {
+      await this.cline.say("rooignore_error", relPath);
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formatResponse.rooIgnoreError(relPath)));
+      return;
+    }
+
+    // --- File Existence Check ---
+    const absolutePath = path.resolve(this.cline.cwd, relPath);
+    const fileExists = await fileExistsAtPath(absolutePath);
+    if (!fileExists) {
+      this.cline.consecutiveMistakeCount++;
+      const formattedError = `File does not exist at path: ${absolutePath}\n\n<error_details>\nThe specified file could not be found. Please verify the file path and try again.\n</error_details>`;
+      await this.cline.say("error", formattedError);
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formattedError));
+      return;
+    }
+
+    // --- Apply Diff ---
+    try {
+      const originalContent = await fs.readFile(absolutePath, "utf-8");
+
+      // Assuming diffStrategy is available on Cline instance
+      const diffResult = (await this.cline.diffStrategy?.applyDiff(
+        originalContent,
+        diffContent,
+        startLine, // Already parsed
+        endLine,   // Already parsed
+      )) ?? { success: false, error: "No diff strategy available" }; // Default error if no strategy
+
+      // --- Handle Diff Failure ---
+      if (!diffResult.success) {
+        this.cline.consecutiveMistakeCount++;
+        const currentCount = (this.consecutiveMistakeCountForApplyDiff.get(relPath) || 0) + 1;
+        this.consecutiveMistakeCountForApplyDiff.set(relPath, currentCount);
+
+        let formattedError = "";
+        let partResults = ""; // To accumulate partial failure messages
+
+        if (diffResult.failParts && diffResult.failParts.length > 0) {
+          for (const failPart of diffResult.failParts) {
+            if (failPart.success) continue;
+            const errorDetails = failPart.details ? JSON.stringify(failPart.details, null, 2) : "";
+            const partError = `<error_details>\n${failPart.error}${errorDetails ? `\n\nDetails:\n${errorDetails}` : ""}\n</error_details>`;
+            partResults += partError; // Accumulate errors
+          }
+           formattedError = partResults || `Unable to apply some parts of the diff to file: ${absolutePath}`; // Use accumulated or generic message
+        } else {
+          const errorDetails = diffResult.details ? JSON.stringify(diffResult.details, null, 2) : "";
+          formattedError = `Unable to apply diff to file: ${absolutePath}\n\n<error_details>\n${diffResult.error}${errorDetails ? `\n\nDetails:\n${errorDetails}` : ""}\n</error_details>`;
+        }
+
+        if (currentCount >= 2) { // Show error in UI only on second consecutive failure for the same file
+          await this.cline.say("error", formattedError);
+        }
+        await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formattedError));
+        return; // Stop processing on failure
+      }
+
+      // --- Diff Success ---
+      this.cline.consecutiveMistakeCount = 0;
+      this.consecutiveMistakeCountForApplyDiff.delete(relPath); // Reset count for this file
+
+      // --- Show Diff Preview ---
+      this.cline.diffViewProvider.editType = "modify";
+      await this.cline.diffViewProvider.open(relPath);
+      await this.cline.diffViewProvider.update(diffResult.content, true);
+      await this.cline.diffViewProvider.scrollToFirstDiff();
+
+      // --- Ask for Approval ---
+      const sharedMessageProps: ClineSayTool = {
+        tool: "appliedDiff",
+        path: getReadablePath(this.cline.cwd, relPath),
+      };
+      const completeMessage = JSON.stringify({
+        ...sharedMessageProps,
+        diff: diffContent, // Show the raw diff provided by the AI
+      } satisfies ClineSayTool);
+
+      let toolProgressStatus: ToolProgressStatus | undefined;
+      if (this.cline.diffStrategy && this.cline.diffStrategy.getProgressStatus) {
+        toolProgressStatus = this.cline.diffStrategy.getProgressStatus(this.toolUse, diffResult);
+      }
+
+      const didApprove = await this.cline.askApprovalHelper(this.toolUse, "tool", completeMessage, toolProgressStatus);
+      if (!didApprove) {
+        await this.cline.diffViewProvider.revertChanges();
+        // pushToolResult handled by askApprovalHelper
+        return;
+      }
+
+      // --- Save Changes ---
+      const { newProblemsMessage, userEdits, finalContent } = await this.cline.diffViewProvider.saveChanges();
+      this.cline.didEditFile = true;
+
+      let partFailHint = "";
+      if (diffResult.failParts && diffResult.failParts.length > 0) {
+        partFailHint = `\n\nWarning: Unable to apply all diff parts. Use <read_file> to check the latest file version and re-apply remaining diffs if necessary.`;
+      }
+
+      let resultMessage: string;
+      if (userEdits) {
+        await this.cline.say(
+          "user_feedback_diff",
+          JSON.stringify({
+            tool: "appliedDiff", // Keep consistent tool type
+            path: getReadablePath(this.cline.cwd, relPath),
+            diff: userEdits,
+          } satisfies ClineSayTool),
+        );
+        resultMessage =
+          `The user made the following updates to your content:\n\n${userEdits}\n\n` +
+          `The updated content, which includes both your original modifications and the user's edits, has been successfully saved to ${relPath}. Here is the full, updated content of the file, including line numbers:\n\n` +
+          `<final_file_content path="${relPath}">\n${addLineNumbers(finalContent || "")}\n</final_file_content>\n\n` +
+          `Please note:\n` +
+          `1. You do not need to re-write the file with these changes, as they have already been applied.\n` +
+          `2. Proceed with the task using this updated file content as the new baseline.\n` +
+          `3. If the user's edits have addressed part of the task or changed the requirements, adjust your approach accordingly.` +
+          `${newProblemsMessage}${partFailHint}`;
+      } else {
+        resultMessage = `Changes successfully applied to ${relPath}.${newProblemsMessage}${partFailHint}`;
+      }
+
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(resultMessage));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+      await this.cline.handleErrorHelper(this.toolUse, "applying diff", error);
+    } finally {
+      // Always reset diff provider state
+      await this.cline.diffViewProvider.reset();
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/AskFollowupQuestionHandler.ts b/src/core/tool-handlers/tools/AskFollowupQuestionHandler.ts
new file mode 100644
index 00000000..30267569
--- /dev/null
+++ b/src/core/tool-handlers/tools/AskFollowupQuestionHandler.ts
@@ -0,0 +1,112 @@
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { parseXml } from "../../../utils/xml"; // Assuming this path is correct
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+ // Define structure for suggestions parsed from XML
+// No interface needed if parseXml returns string[] directly for <suggest> - Removed line with '+' artifact
+
+ export class AskFollowupQuestionHandler extends ToolUseHandler {
+   // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.question) {
+      throw new Error("Missing required parameter 'question'");
+    }
+    // follow_up is optional, XML format validated in handleComplete
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const question = this.toolUse.params.question;
+    if (!question) return; // Need question for message
+
+    try {
+      // Show question being asked in UI
+      await this.cline.ask("followup", this.removeClosingTag("question", question), true);
+    } catch (error) {
+      console.warn("AskFollowupQuestionHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const question = this.toolUse.params.question;
+    const followUpXml = this.toolUse.params.follow_up;
+
+    // --- Parameter Validation ---
+    if (!question) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("ask_followup_question", "question"));
+      return;
+    }
+
+    // --- Parse Follow-up Suggestions ---
+    let followUpJson = {
+      question,
+      suggest: [] as string[], // Expect array of strings
+    };
+
+    if (followUpXml) {
+      try {
+        // Explicitly type the expected structure from parseXml
+        // parseXml with ["suggest"] should return { suggest: string | string[] } or similar
+        const parsedResult = parseXml(followUpXml, ["suggest"]) as { suggest?: string | string[] };
+
+        // Normalize suggestions into an array
+        const normalizedSuggest = Array.isArray(parsedResult?.suggest)
+          ? parsedResult.suggest
+          : parsedResult?.suggest ? [parsedResult.suggest] : []; // Handle single string or undefined
+
+        // Basic validation of suggestion structure
+        // Now validate that each item in the array is a string
+        if (!normalizedSuggest.every(sug => typeof sug === 'string')) {
+             throw new Error("Content within each <suggest> tag must be a string.");
+        }
+
+        followUpJson.suggest = normalizedSuggest;
+
+      } catch (error: any) {
+        this.cline.consecutiveMistakeCount++;
+        await this.cline.say("error", `Failed to parse follow_up XML: ${error.message}`);
+        await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(`Invalid follow_up XML format: ${error.message}`));
+        return;
+      }
+    }
+
+    // --- Ask User ---
+    try {
+      this.cline.consecutiveMistakeCount = 0; // Reset on successful validation/parse
+
+      const { text, images } = await this.cline.ask(
+        "followup",
+        JSON.stringify(followUpJson), // Send structured JSON to UI
+        false, // Complete message
+      );
+
+      // --- Process Response ---
+      await this.cline.say("user_feedback", text ?? "", images); // Show user's answer
+      // Format the result for the API
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(`<answer>\n${text}\n</answer>`, images));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+      // Handle errors during ask or response processing
+      await this.cline.handleErrorHelper(this.toolUse, "asking question", error);
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/AttemptCompletionHandler.ts b/src/core/tool-handlers/tools/AttemptCompletionHandler.ts
new file mode 100644
index 00000000..2b96bc94
--- /dev/null
+++ b/src/core/tool-handlers/tools/AttemptCompletionHandler.ts
@@ -0,0 +1,170 @@
+import { Anthropic } from "@anthropic-ai/sdk";
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline, ToolResponse } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+export class AttemptCompletionHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.result) {
+      throw new Error("Missing required parameter 'result'");
+    }
+    // command is optional
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const result = this.toolUse.params.result;
+    const command = this.toolUse.params.command;
+
+    try {
+      const lastMessage = this.cline.clineMessages.at(-1);
+
+      if (command) {
+        // If command is starting to stream, the result part is complete.
+        // Finalize the result 'say' message if needed.
+        if (lastMessage?.say === "completion_result" && lastMessage.partial) {
+           await this.cline.say("completion_result", this.removeClosingTag("result", result), undefined, false);
+           telemetryService.captureTaskCompleted(this.cline.taskId);
+           this.cline.emit("taskCompleted", this.cline.taskId, this.cline.getTokenUsage()); // Assuming getTokenUsage is public or accessible
+        } else if (!lastMessage || lastMessage.say !== "completion_result") {
+            // If result wasn't streamed partially first, send it completely now
+             await this.cline.say("completion_result", this.removeClosingTag("result", result), undefined, false);
+             telemetryService.captureTaskCompleted(this.cline.taskId);
+             this.cline.emit("taskCompleted", this.cline.taskId, this.cline.getTokenUsage());
+        }
+
+        // Now handle partial command 'ask'
+        await this.cline.ask("command", this.removeClosingTag("command", command), true);
+
+      } else if (result) {
+        // Still streaming the result part
+        await this.cline.say("completion_result", this.removeClosingTag("result", result), undefined, true);
+      }
+    } catch (error) {
+      console.warn("AttemptCompletionHandler: ask/say for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const result = this.toolUse.params.result;
+    const command = this.toolUse.params.command;
+
+    // --- Parameter Validation ---
+    if (!result) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("attempt_completion", "result"));
+      return;
+    }
+
+    // --- Execute Completion ---
+    try {
+      this.cline.consecutiveMistakeCount = 0; // Reset on successful validation
+
+      let commandResult: ToolResponse | undefined;
+      const lastMessage = this.cline.clineMessages.at(-1);
+
+      // --- Handle Optional Command ---
+      if (command) {
+        // Ensure completion_result 'say' is finalized if it was partial
+        if (lastMessage?.say === "completion_result" && lastMessage.partial) {
+           await this.cline.say("completion_result", result, undefined, false);
+           telemetryService.captureTaskCompleted(this.cline.taskId);
+           this.cline.emit("taskCompleted", this.cline.taskId, this.cline.getTokenUsage());
+        } else if (!lastMessage || lastMessage.say !== "completion_result") {
+           // If result wasn't streamed, send it now
+           await this.cline.say("completion_result", result, undefined, false);
+           telemetryService.captureTaskCompleted(this.cline.taskId);
+           this.cline.emit("taskCompleted", this.cline.taskId, this.cline.getTokenUsage());
+        }
+
+        // Ask for command approval
+        const didApprove = await this.cline.askApprovalHelper(this.toolUse, "command", command);
+        if (!didApprove) return; // Approval helper handles pushToolResult
+
+        // Execute command
+        const [userRejected, execCommandResult] = await this.cline.executeCommandTool(command);
+        if (userRejected) {
+          this.cline.didRejectTool = true;
+          await this.cline.pushToolResult(this.toolUse, execCommandResult); // Push rejection feedback
+          return; // Stop processing
+        }
+        commandResult = execCommandResult; // Store command result if any
+
+      } else {
+        // No command, just finalize the result message
+        await this.cline.say("completion_result", result, undefined, false);
+        telemetryService.captureTaskCompleted(this.cline.taskId);
+        this.cline.emit("taskCompleted", this.cline.taskId, this.cline.getTokenUsage());
+      }
+
+      // --- Handle Subtask Completion ---
+      if (this.cline.parentTask) {
+         // Assuming askFinishSubTaskApproval helper exists or logic is replicated
+         // const didApproveFinish = await this.cline.askFinishSubTaskApproval();
+         // For now, let's assume it needs manual implementation or skip if not critical path
+         console.warn("Subtask completion approval logic needs implementation in AttemptCompletionHandler.");
+         // If approval needed and failed: return;
+
+         // Finish subtask
+         await this.cline.providerRef.deref()?.finishSubTask(`Task complete: ${result}`);
+         // No pushToolResult needed here as the task is ending/returning control
+         return;
+      }
+
+      // --- Ask for User Feedback/Next Action (Main Task) ---
+      // Ask with empty string to relinquish control
+      const { response, text: feedbackText, images: feedbackImages } = await this.cline.ask("completion_result", "", false);
+
+      if (response === "yesButtonClicked") {
+        // User clicked "New Task" or similar - provider handles this
+        // Push an empty result? Original code did this.
+        await this.cline.pushToolResult(this.toolUse, "");
+        return;
+      }
+
+      // User provided feedback (messageResponse or noButtonClicked)
+      await this.cline.say("user_feedback", feedbackText ?? "", feedbackImages);
+
+      // --- Format Feedback for API ---
+      const toolResults: (Anthropic.TextBlockParam | Anthropic.ImageBlockParam)[] = [];
+      if (commandResult) {
+        if (typeof commandResult === "string") {
+          toolResults.push({ type: "text", text: commandResult });
+        } else if (Array.isArray(commandResult)) {
+          toolResults.push(...commandResult);
+        }
+      }
+      toolResults.push({
+        type: "text",
+        text: `The user has provided feedback on the results. Consider their input to continue the task, and then attempt completion again.\n<feedback>\n${feedbackText}\n</feedback>`,
+      });
+      toolResults.push(...formatResponse.imageBlocks(feedbackImages));
+
+      // Push combined feedback as the "result" of attempt_completion
+      // Note: Original code pushed this with a "Result:" prefix, replicating that.
+      await this.cline.pushToolResult(this.toolUse, toolResults);
+
+
+    } catch (error: any) {
+      // Handle errors during command execution, approval, or feedback
+      await this.cline.handleErrorHelper(this.toolUse, "attempting completion", error);
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/BrowserActionHandler.ts b/src/core/tool-handlers/tools/BrowserActionHandler.ts
new file mode 100644
index 00000000..ef57fedf
--- /dev/null
+++ b/src/core/tool-handlers/tools/BrowserActionHandler.ts
@@ -0,0 +1,164 @@
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import {
+  BrowserAction,
+  BrowserActionResult,
+  browserActions,
+  ClineSayBrowserAction
+} from "../../../shared/ExtensionMessage";
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+export class BrowserActionHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    // Ensure browser is closed if another tool is attempted after this one
+    // This logic might be better placed in the main loop or a pre-tool-execution hook
+    // if (this.toolUse.name !== "browser_action") {
+    //   await this.cline.browserSession.closeBrowser();
+    // }
+
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    const action = this.toolUse.params.action as BrowserAction | undefined;
+    if (!action || !browserActions.includes(action)) {
+      throw new Error("Missing or invalid required parameter 'action'. Must be one of: " + browserActions.join(', '));
+    }
+    if (action === "launch" && !this.toolUse.params.url) {
+      throw new Error("Missing required parameter 'url' for 'launch' action.");
+    }
+    if (action === "click" && !this.toolUse.params.coordinate) {
+      throw new Error("Missing required parameter 'coordinate' for 'click' action.");
+    }
+    if (action === "type" && !this.toolUse.params.text) {
+      throw new Error("Missing required parameter 'text' for 'type' action.");
+    }
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const action = this.toolUse.params.action as BrowserAction | undefined;
+    const url = this.toolUse.params.url;
+    const coordinate = this.toolUse.params.coordinate;
+    const text = this.toolUse.params.text;
+
+    // Only show UI updates if action is valid so far
+    if (action && browserActions.includes(action)) {
+        try {
+            if (action === "launch") {
+                await this.cline.ask(
+                    "browser_action_launch",
+                    this.removeClosingTag("url", url),
+                    true // partial
+                );
+            } else {
+                await this.cline.say(
+                    "browser_action",
+                    JSON.stringify({
+                        action: action,
+                        coordinate: this.removeClosingTag("coordinate", coordinate),
+                        text: this.removeClosingTag("text", text),
+                    } satisfies ClineSayBrowserAction),
+                    undefined, // images
+                    true // partial
+                );
+            }
+        } catch (error) {
+             console.warn("BrowserActionHandler: ask/say for partial update interrupted.", error);
+        }
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const action = this.toolUse.params.action as BrowserAction; // Already validated
+    const url = this.toolUse.params.url;
+    const coordinate = this.toolUse.params.coordinate;
+    const text = this.toolUse.params.text;
+
+    try {
+      // Re-validate parameters for the complete action
+      this.validateParams(); // Throws on error
+
+      let browserActionResult: BrowserActionResult;
+
+      if (action === "launch") {
+        this.cline.consecutiveMistakeCount = 0;
+        const didApprove = await this.cline.askApprovalHelper(this.toolUse, "browser_action_launch", url);
+        if (!didApprove) return;
+
+        await this.cline.say("browser_action_result", ""); // Show loading spinner
+        await this.cline.browserSession.launchBrowser(); // Access via cline instance
+        browserActionResult = await this.cline.browserSession.navigateToUrl(url!); // url is validated
+      } else {
+        // Validate params specific to other actions
+        if (action === "click" && !coordinate) throw new Error("Missing coordinate for click");
+        if (action === "type" && !text) throw new Error("Missing text for type");
+
+        this.cline.consecutiveMistakeCount = 0;
+        // No explicit approval needed for actions other than launch in original code
+        await this.cline.say(
+          "browser_action",
+          JSON.stringify({ action, coordinate, text } satisfies ClineSayBrowserAction),
+          undefined,
+          false // complete
+        );
+
+        // Execute action via browserSession on Cline instance
+        switch (action) {
+          case "click":
+            browserActionResult = await this.cline.browserSession.click(coordinate!);
+            break;
+          case "type":
+            browserActionResult = await this.cline.browserSession.type(text!);
+            break;
+          case "scroll_down":
+            browserActionResult = await this.cline.browserSession.scrollDown();
+            break;
+          case "scroll_up":
+            browserActionResult = await this.cline.browserSession.scrollUp();
+            break;
+          case "close":
+            browserActionResult = await this.cline.browserSession.closeBrowser();
+            break;
+          default:
+             // Should not happen due to initial validation
+             throw new Error(`Unhandled browser action: ${action}`);
+        }
+      }
+
+      // --- Process Result ---
+      let resultText: string;
+      let resultImages: string[] | undefined;
+
+      if (action === "close") {
+          resultText = `The browser has been closed. You may now proceed to using other tools.`;
+      } else {
+          // For launch, click, type, scroll actions
+          await this.cline.say("browser_action_result", JSON.stringify(browserActionResult)); // Show raw result
+          resultText = `The browser action '${action}' has been executed. The console logs and screenshot have been captured for your analysis.\n\nConsole logs:\n${browserActionResult.logs || "(No new logs)"}\n\n(REMEMBER: if you need to proceed to using non-\`browser_action\` tools or launch a new browser, you MUST first close this browser.)`;
+          resultImages = browserActionResult.screenshot ? [browserActionResult.screenshot] : undefined;
+      }
+
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(resultText, resultImages));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+      // Ensure browser is closed on any error during execution
+      await this.cline.browserSession.closeBrowser();
+      await this.cline.handleErrorHelper(this.toolUse, `executing browser action '${action}'`, error);
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/ExecuteCommandHandler.ts b/src/core/tool-handlers/tools/ExecuteCommandHandler.ts
new file mode 100644
index 00000000..ca79e034
--- /dev/null
+++ b/src/core/tool-handlers/tools/ExecuteCommandHandler.ts
@@ -0,0 +1,92 @@
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+export class ExecuteCommandHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.command) {
+      throw new Error("Missing required parameter 'command'");
+    }
+    // cwd is optional
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const command = this.toolUse.params.command;
+    if (!command) return; // Need command for message
+
+    try {
+      // Show command being typed in UI
+      await this.cline.ask("command", this.removeClosingTag("command", command), true);
+    } catch (error) {
+      console.warn("ExecuteCommandHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const command = this.toolUse.params.command;
+    const customCwd = this.toolUse.params.cwd;
+
+    // --- Parameter Validation ---
+    if (!command) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("execute_command", "command"));
+      return;
+    }
+
+    // --- Access/Ignore Validation ---
+    const ignoredFileAttemptedToAccess = this.cline.rooIgnoreController?.validateCommand(command);
+    if (ignoredFileAttemptedToAccess) {
+      await this.cline.say("rooignore_error", ignoredFileAttemptedToAccess);
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formatResponse.rooIgnoreError(ignoredFileAttemptedToAccess)));
+      return;
+    }
+
+    // --- Execute Command ---
+    try {
+      this.cline.consecutiveMistakeCount = 0; // Reset on successful validation
+
+      // --- Ask for Approval ---
+      const didApprove = await this.cline.askApprovalHelper(this.toolUse, "command", command);
+      if (!didApprove) {
+        // pushToolResult handled by helper
+        return;
+      }
+
+      // --- Execute via Cline's method ---
+      // executeCommandTool handles terminal management, output streaming, and user feedback during execution
+      const [userRejectedMidExecution, result] = await this.cline.executeCommandTool(command, customCwd);
+
+      if (userRejectedMidExecution) {
+        // If user rejected *during* command execution (via command_output prompt)
+        this.cline.didRejectTool = true; // Set rejection flag on Cline instance
+      }
+
+      // Push the final result (which includes output, status, and any user feedback)
+      await this.cline.pushToolResult(this.toolUse, result);
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+      // Handle errors during approval or execution
+      await this.cline.handleErrorHelper(this.toolUse, "executing command", error);
+    }
+    // No diff provider state to reset
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/FetchInstructionsHandler.ts b/src/core/tool-handlers/tools/FetchInstructionsHandler.ts
new file mode 100644
index 00000000..a7896f42
--- /dev/null
+++ b/src/core/tool-handlers/tools/FetchInstructionsHandler.ts
@@ -0,0 +1,79 @@
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+// Import the existing tool logic function
+import { fetchInstructionsTool } from "../../tools/fetchInstructionsTool"; // Adjusted path relative to this handler file
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+export class FetchInstructionsHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    // This tool likely doesn't have a meaningful partial state beyond showing the tool name
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      // The actual logic is synchronous or handled within fetchInstructionsTool
+      // We await it here for consistency, though it might resolve immediately
+      await this.handleComplete();
+      // fetchInstructionsTool calls pushToolResult internally, so the result is pushed.
+      // We return true because the tool action (fetching and pushing result) is complete.
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    // Validation is likely handled within fetchInstructionsTool, but basic check here
+    if (!this.toolUse.params.task) {
+      throw new Error("Missing required parameter 'task'");
+    }
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const task = this.toolUse.params.task;
+    if (!task) return;
+
+    // Simple partial message showing the tool being used
+    const partialMessage = JSON.stringify({
+        tool: "fetchInstructions",
+        task: this.removeClosingTag("task", task),
+    });
+
+    try {
+      // Using 'tool' ask type for consistency, though original might not have shown UI for this
+      await this.cline.ask("tool", partialMessage, true);
+    } catch (error) {
+      console.warn("FetchInstructionsHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+     // --- Execute Fetch ---
+    try {
+        // Call the existing encapsulated logic function
+        // Pass the Cline instance, the toolUse block, and the helper methods
+        await fetchInstructionsTool(
+            this.cline,
+            this.toolUse,
+            // Pass helper methods bound to the Cline instance
+            (type, msg, status) => this.cline.askApprovalHelper(this.toolUse, type, msg, status),
+            (action, error) => this.cline.handleErrorHelper(this.toolUse, action, error),
+            (content) => this.cline.pushToolResult(this.toolUse, content)
+        );
+        // No need to call pushToolResult here, as fetchInstructionsTool does it.
+        telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+        // Although fetchInstructionsTool has its own error handling via the passed helper,
+        // catch any unexpected errors during the call itself.
+        console.error("Unexpected error calling fetchInstructionsTool:", error);
+        // Use the standard error helper
+        await this.cline.handleErrorHelper(this.toolUse, "fetching instructions", error);
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/InsertContentHandler.ts b/src/core/tool-handlers/tools/InsertContentHandler.ts
new file mode 100644
index 00000000..9a8f296e
--- /dev/null
+++ b/src/core/tool-handlers/tools/InsertContentHandler.ts
@@ -0,0 +1,207 @@
+import * as path from "path";
+import * as fs from "fs/promises";
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { ClineSayTool } from "../../../shared/ExtensionMessage";
+import { getReadablePath } from "../../../utils/path";
+import { fileExistsAtPath } from "../../../utils/fs";
+import { insertGroups } from "../../diff/insert-groups"; // Assuming this path is correct
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+import delay from "delay";
+
+// Define the structure expected in the 'operations' JSON string
+interface InsertOperation {
+  start_line: number;
+  content: string;
+}
+
+export class InsertContentHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.path) {
+      throw new Error("Missing required parameter 'path'");
+    }
+    if (!this.toolUse.params.operations) {
+      throw new Error("Missing required parameter 'operations'");
+    }
+    // JSON format validation happens in handleComplete
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+    if (!relPath) return; // Need path for message
+
+    // Using "appliedDiff" as the tool type for UI consistency, as per original code
+    const sharedMessageProps: ClineSayTool = {
+      tool: "appliedDiff",
+      path: getReadablePath(this.cline.cwd, this.removeClosingTag("path", relPath)),
+    };
+
+    const partialMessage = JSON.stringify(sharedMessageProps);
+    try {
+      await this.cline.ask("tool", partialMessage, true);
+    } catch (error) {
+      console.warn("InsertContentHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+    const operationsJson = this.toolUse.params.operations;
+
+    // --- Parameter Validation ---
+    if (!relPath) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("insert_content", "path"));
+      return;
+    }
+    if (!operationsJson) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("insert_content", "operations"));
+      return;
+    }
+
+    let parsedOperations: InsertOperation[];
+    try {
+      parsedOperations = JSON.parse(operationsJson);
+      if (!Array.isArray(parsedOperations)) {
+        throw new Error("Operations must be an array");
+      }
+      // Basic validation of operation structure
+      if (!parsedOperations.every(op => typeof op.start_line === 'number' && typeof op.content === 'string')) {
+          throw new Error("Each operation must have a numeric 'start_line' and a string 'content'.");
+      }
+    } catch (error: any) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.say("error", `Failed to parse operations JSON: ${error.message}`);
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(`Invalid operations JSON format: ${error.message}`));
+      return;
+    }
+
+    // --- File Existence Check ---
+    const absolutePath = path.resolve(this.cline.cwd, relPath);
+    const fileExists = await fileExistsAtPath(absolutePath);
+    if (!fileExists) {
+      this.cline.consecutiveMistakeCount++;
+      const formattedError = `File does not exist at path: ${absolutePath}\n\n<error_details>\nThe specified file could not be found. Please verify the file path and try again.\n</error_details>`;
+      await this.cline.say("error", formattedError);
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formattedError));
+      return;
+    }
+
+    // --- Apply Insertions ---
+    try {
+      this.cline.consecutiveMistakeCount = 0; // Reset on successful parameter validation
+
+      const fileContent = await fs.readFile(absolutePath, "utf8");
+      this.cline.diffViewProvider.editType = "modify"; // insert_content always modifies
+      this.cline.diffViewProvider.originalContent = fileContent;
+      const lines = fileContent.split("\n");
+
+      // Map parsed operations to the format expected by insertGroups
+      const insertGroupsOps = parsedOperations.map((elem) => ({
+        index: elem.start_line - 1, // Convert 1-based line number to 0-based index
+        elements: elem.content.split("\n"),
+      }));
+
+      const updatedContent = insertGroups(lines, insertGroupsOps).join("\n");
+
+      // --- Show Diff Preview ---
+      // Using "appliedDiff" as the tool type for UI consistency
+      const sharedMessageProps: ClineSayTool = {
+        tool: "appliedDiff",
+        path: getReadablePath(this.cline.cwd, relPath),
+      };
+
+      if (!this.cline.diffViewProvider.isEditing) {
+        // Show partial message first if editor isn't open
+        await this.cline.ask("tool", JSON.stringify(sharedMessageProps), true).catch(() => {});
+        await this.cline.diffViewProvider.open(relPath);
+        // Update with original content first? Original code seems to skip this if !isEditing
+        // Let's stick to original: update directly with new content after opening
+        // await this.cline.diffViewProvider.update(fileContent, false);
+        // await delay(200);
+      }
+
+      const diff = formatResponse.createPrettyPatch(relPath, fileContent, updatedContent);
+
+      if (!diff) {
+        await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(`No changes needed for '${relPath}'`));
+        await this.cline.diffViewProvider.reset(); // Reset even if no changes
+        return;
+      }
+
+      await this.cline.diffViewProvider.update(updatedContent, true); // Final update with changes
+      this.cline.diffViewProvider.scrollToFirstDiff(); // Scroll after final update
+
+      // --- Ask for Approval ---
+      const completeMessage = JSON.stringify({
+        ...sharedMessageProps,
+        diff,
+      } satisfies ClineSayTool);
+
+      // Original code used a simple .then() for approval, replicating that for now
+      // Consider using askApprovalHelper if consistent behavior is desired
+      const didApprove = await this.cline.ask("tool", completeMessage, false).then(
+          (response) => response.response === "yesButtonClicked",
+      ).catch(() => false); // Assume rejection on error
+
+      if (!didApprove) {
+        await this.cline.diffViewProvider.revertChanges();
+        await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult("Changes were rejected by the user."));
+        return;
+      }
+
+      // --- Save Changes ---
+      const { newProblemsMessage, userEdits, finalContent } = await this.cline.diffViewProvider.saveChanges();
+      this.cline.didEditFile = true;
+
+      let resultMessage: string;
+      if (userEdits) {
+         const userFeedbackDiff = JSON.stringify({
+            tool: "appliedDiff", // Consistent tool type
+            path: getReadablePath(this.cline.cwd, relPath),
+            diff: userEdits,
+          } satisfies ClineSayTool);
+         await this.cline.say("user_feedback_diff", userFeedbackDiff);
+         resultMessage =
+          `The user made the following updates to your content:\n\n${userEdits}\n\n` +
+          `The updated content, which includes both your original modifications and the user's edits, has been successfully saved to ${relPath}. Here is the full, updated content of the file:\n\n` +
+          `<final_file_content path="${relPath}">\n${finalContent}\n</final_file_content>\n\n` + // Note: Original code didn't addLineNumbers here
+          `Please note:\n` +
+          `1. You do not need to re-write the file with these changes, as they have already been applied.\n` +
+          `2. Proceed with the task using this updated file content as the new baseline.\n` +
+          `3. If the user's edits have addressed part of the task or changed the requirements, adjust your approach accordingly.` +
+          `${newProblemsMessage}`;
+      } else {
+        resultMessage = `The content was successfully inserted in ${relPath}.${newProblemsMessage}`;
+      }
+
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(resultMessage));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+      await this.cline.handleErrorHelper(this.toolUse, "insert content", error);
+    } finally {
+      // Always reset diff provider state
+      await this.cline.diffViewProvider.reset();
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/ListCodeDefinitionNamesHandler.ts b/src/core/tool-handlers/tools/ListCodeDefinitionNamesHandler.ts
new file mode 100644
index 00000000..3ca0d2de
--- /dev/null
+++ b/src/core/tool-handlers/tools/ListCodeDefinitionNamesHandler.ts
@@ -0,0 +1,137 @@
+import * as path from "path";
+import * as fs from "fs/promises";
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { ClineSayTool } from "../../../shared/ExtensionMessage";
+import { getReadablePath } from "../../../utils/path";
+import {
+  parseSourceCodeDefinitionsForFile,
+  parseSourceCodeForDefinitionsTopLevel
+} from "../../../services/tree-sitter"; // Assuming this path is correct
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+export class ListCodeDefinitionNamesHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.path) {
+      throw new Error("Missing required parameter 'path'");
+    }
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+    if (!relPath) return; // Need path for message
+
+    const sharedMessageProps: ClineSayTool = {
+      tool: "listCodeDefinitionNames",
+      path: getReadablePath(this.cline.cwd, this.removeClosingTag("path", relPath)),
+    };
+
+    const partialMessage = JSON.stringify({
+      ...sharedMessageProps,
+      content: "", // No content to show in partial
+    } satisfies ClineSayTool);
+
+    try {
+      await this.cline.ask("tool", partialMessage, true);
+    } catch (error) {
+      console.warn("ListCodeDefinitionNamesHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+
+    // --- Parameter Validation ---
+    if (!relPath) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("list_code_definition_names", "path"));
+      return;
+    }
+
+    // --- Execute Parse ---
+    try {
+      this.cline.consecutiveMistakeCount = 0; // Reset on successful validation
+
+      const absolutePath = path.resolve(this.cline.cwd, relPath);
+
+      // Prepare shared props for approval message
+      const sharedMessageProps: ClineSayTool = {
+        tool: "listCodeDefinitionNames",
+        path: getReadablePath(this.cline.cwd, relPath),
+      };
+
+      let result: string;
+      try {
+        const stats = await fs.stat(absolutePath);
+        if (stats.isFile()) {
+          // Check access before parsing file
+          const accessAllowed = this.cline.rooIgnoreController?.validateAccess(relPath);
+          if (!accessAllowed) {
+              await this.cline.say("rooignore_error", relPath);
+              await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formatResponse.rooIgnoreError(relPath)));
+              return;
+          }
+          const fileResult = await parseSourceCodeDefinitionsForFile(
+            absolutePath,
+            this.cline.rooIgnoreController, // Pass ignore controller
+          );
+          result = fileResult ?? "No source code definitions found in this file.";
+        } else if (stats.isDirectory()) {
+          // Directory parsing handles ignore checks internally via parseSourceCodeDefinitionsForFile
+          result = await parseSourceCodeForDefinitionsTopLevel(
+            absolutePath,
+            this.cline.rooIgnoreController, // Pass ignore controller
+          );
+        } else {
+          result = "The specified path is neither a file nor a directory.";
+        }
+      } catch (error: any) {
+         if (error.code === 'ENOENT') {
+             result = `${absolutePath}: does not exist or cannot be accessed.`;
+         } else {
+             // Re-throw other errors to be caught by the outer try-catch
+             throw error;
+         }
+      }
+
+      // --- Ask for Approval (with results) ---
+      const completeMessage = JSON.stringify({
+        ...sharedMessageProps,
+        content: result, // Include parse results in the approval message
+      } satisfies ClineSayTool);
+
+      const didApprove = await this.cline.askApprovalHelper(this.toolUse, "tool", completeMessage);
+      if (!didApprove) {
+        // pushToolResult handled by helper
+        return;
+      }
+
+      // --- Push Result ---
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(result));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+      // Handle potential errors during parsing or approval
+      await this.cline.handleErrorHelper(this.toolUse, "parsing source code definitions", error);
+    }
+    // No diff provider state to reset
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/ListFilesHandler.ts b/src/core/tool-handlers/tools/ListFilesHandler.ts
new file mode 100644
index 00000000..98919c7c
--- /dev/null
+++ b/src/core/tool-handlers/tools/ListFilesHandler.ts
@@ -0,0 +1,119 @@
+import * as path from "path";
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { ClineSayTool } from "../../../shared/ExtensionMessage";
+import { getReadablePath } from "../../../utils/path";
+import { listFiles } from "../../../services/glob/list-files"; // Assuming this path is correct
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+export class ListFilesHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.path) {
+      throw new Error("Missing required parameter 'path'");
+    }
+    // recursive is optional
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const relDirPath = this.toolUse.params.path;
+    const recursiveRaw = this.toolUse.params.recursive;
+    if (!relDirPath) return; // Need path for message
+
+    const recursive = this.removeClosingTag("recursive", recursiveRaw)?.toLowerCase() === "true";
+
+    const sharedMessageProps: ClineSayTool = {
+      tool: !recursive ? "listFilesTopLevel" : "listFilesRecursive",
+      path: getReadablePath(this.cline.cwd, this.removeClosingTag("path", relDirPath)),
+    };
+
+    const partialMessage = JSON.stringify({
+      ...sharedMessageProps,
+      content: "", // No content to show in partial
+    } satisfies ClineSayTool);
+
+    try {
+      await this.cline.ask("tool", partialMessage, true);
+    } catch (error) {
+      console.warn("ListFilesHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const relDirPath = this.toolUse.params.path;
+    const recursiveRaw = this.toolUse.params.recursive;
+
+    // --- Parameter Validation ---
+    if (!relDirPath) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("list_files", "path"));
+      return;
+    }
+
+    // --- Execute List ---
+    try {
+      this.cline.consecutiveMistakeCount = 0; // Reset on successful validation
+
+      const recursive = recursiveRaw?.toLowerCase() === "true";
+      const absolutePath = path.resolve(this.cline.cwd, relDirPath);
+
+      // Prepare shared props for approval message
+      const sharedMessageProps: ClineSayTool = {
+        tool: !recursive ? "listFilesTopLevel" : "listFilesRecursive",
+        path: getReadablePath(this.cline.cwd, relDirPath),
+      };
+
+      // Perform the list operation *before* asking for approval
+      // TODO: Consider adding a limit parameter to the tool/handler if needed
+      const [files, didHitLimit] = await listFiles(absolutePath, recursive, 200); // Using default limit from original code
+
+      const { showRooIgnoredFiles = true } = (await this.cline.providerRef.deref()?.getState()) ?? {};
+
+      const result = formatResponse.formatFilesList(
+        absolutePath,
+        files,
+        didHitLimit,
+        this.cline.rooIgnoreController, // Pass ignore controller
+        showRooIgnoredFiles,
+      );
+
+      // --- Ask for Approval (with results) ---
+      const completeMessage = JSON.stringify({
+        ...sharedMessageProps,
+        content: result, // Include list results in the approval message
+      } satisfies ClineSayTool);
+
+      const didApprove = await this.cline.askApprovalHelper(this.toolUse, "tool", completeMessage);
+      if (!didApprove) {
+        // pushToolResult handled by helper
+        return;
+      }
+
+      // --- Push Result ---
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(result));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+      // Handle potential errors during listFiles or approval
+      await this.cline.handleErrorHelper(this.toolUse, "listing files", error);
+    }
+    // No diff provider state to reset
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/NewTaskHandler.ts b/src/core/tool-handlers/tools/NewTaskHandler.ts
new file mode 100644
index 00000000..711315c5
--- /dev/null
+++ b/src/core/tool-handlers/tools/NewTaskHandler.ts
@@ -0,0 +1,128 @@
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { getModeBySlug, defaultModeSlug } from "../../../shared/modes"; // Assuming path
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+import delay from "delay";
+
+export class NewTaskHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.mode) {
+      throw new Error("Missing required parameter 'mode'");
+    }
+    if (!this.toolUse.params.message) {
+      throw new Error("Missing required parameter 'message'");
+    }
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const mode = this.toolUse.params.mode;
+    const message = this.toolUse.params.message;
+    if (!mode || !message) return; // Need mode and message for UI
+
+    const partialMessage = JSON.stringify({
+      tool: "newTask",
+      mode: this.removeClosingTag("mode", mode),
+      message: this.removeClosingTag("message", message),
+    });
+
+    try {
+      await this.cline.ask("tool", partialMessage, true);
+    } catch (error) {
+      console.warn("NewTaskHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const mode = this.toolUse.params.mode;
+    const message = this.toolUse.params.message;
+
+    // --- Parameter Validation ---
+    if (!mode) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("new_task", "mode"));
+      return;
+    }
+    if (!message) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("new_task", "message"));
+      return;
+    }
+
+    // --- Execute New Task ---
+    try {
+      this.cline.consecutiveMistakeCount = 0; // Reset on successful validation
+
+      const provider = this.cline.providerRef.deref();
+      if (!provider) {
+        throw new Error("ClineProvider reference is lost.");
+      }
+      const currentState = await provider.getState(); // Get state once
+
+      // Verify the mode exists
+      const targetMode = getModeBySlug(mode, currentState?.customModes);
+      if (!targetMode) {
+        await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(`Invalid mode: ${mode}`));
+        return;
+      }
+
+      // --- Ask for Approval ---
+      const toolMessage = JSON.stringify({
+        tool: "newTask",
+        mode: targetMode.name, // Show mode name
+        content: message, // Use 'content' key consistent with UI? Check original askApproval call
+      });
+      const didApprove = await this.cline.askApprovalHelper(this.toolUse, "tool", toolMessage);
+      if (!didApprove) {
+        // pushToolResult handled by helper
+        return;
+      }
+
+      // --- Perform New Task Creation ---
+      // Preserve current mode for potential resumption (needs isPaused/pausedModeSlug on Cline to be public or handled via methods)
+      // this.cline.pausedModeSlug = currentState?.mode ?? defaultModeSlug; // Requires pausedModeSlug to be public/settable
+
+      // Switch mode first
+      await provider.handleModeSwitch(mode);
+      await delay(500); // Allow mode switch to settle
+
+      // Create new task instance, passing current Cline as parent
+      const newCline = await provider.initClineWithTask(message, undefined, this.cline);
+      this.cline.emit("taskSpawned", newCline.taskId); // Emit event from parent
+
+      // Pause the current (parent) task (needs isPaused to be public/settable)
+      // this.cline.isPaused = true;
+      this.cline.emit("taskPaused"); // Emit pause event
+
+      // --- Push Result ---
+      const resultMessage = `Successfully created new task in ${targetMode.name} mode with message: ${message}`;
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(resultMessage));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+      // Note: The original code breaks here. The handler should likely return control,
+      // and the main loop should handle the paused state based on the emitted event.
+      // The handler itself doesn't wait.
+
+    } catch (error: any) {
+      // Handle errors during validation, approval, or task creation
+      await this.cline.handleErrorHelper(this.toolUse, "creating new task", error);
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/ReadFileHandler.ts b/src/core/tool-handlers/tools/ReadFileHandler.ts
new file mode 100644
index 00000000..aacfe4e1
--- /dev/null
+++ b/src/core/tool-handlers/tools/ReadFileHandler.ts
@@ -0,0 +1,211 @@
+import * as path from "path";
+import { ToolUse, ReadFileToolUse } from "../../assistant-message";
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { ClineSayTool } from "../../../shared/ExtensionMessage";
+import { getReadablePath } from "../../../utils/path"; // Keep this one
+import { isPathOutsideWorkspace } from "../../../utils/pathUtils"; // Import from pathUtils
+import { extractTextFromFile, addLineNumbers } from "../../../integrations/misc/extract-text";
+import { countFileLines } from "../../../integrations/misc/line-counter";
+import { readLines } from "../../../integrations/misc/read-lines";
+import { parseSourceCodeDefinitionsForFile } from "../../../services/tree-sitter";
+import { isBinaryFile } from "isbinaryfile";
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+export class ReadFileHandler extends ToolUseHandler {
+  protected override toolUse: ReadFileToolUse;
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+    this.toolUse = toolUse as ReadFileToolUse;
+  }
+
+  async handle(): Promise<boolean> {
+    // read_file doesn't have a meaningful partial state other than showing the tool use message
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.path) {
+      throw new Error("Missing required parameter 'path'");
+    }
+    // Optional params (start_line, end_line) are validated during parsing in handleComplete
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+    if (!relPath) return; // Need path to show message
+
+    const fullPath = path.resolve(this.cline.cwd, this.removeClosingTag("path", relPath));
+    const isOutsideWorkspace = isPathOutsideWorkspace(fullPath);
+
+    const sharedMessageProps: ClineSayTool = {
+      tool: "readFile",
+      path: getReadablePath(this.cline.cwd, this.removeClosingTag("path", relPath)),
+      isOutsideWorkspace,
+    };
+
+    const partialMessage = JSON.stringify({
+      ...sharedMessageProps,
+      content: undefined, // No content to show in partial
+    } satisfies ClineSayTool);
+
+    try {
+      await this.cline.ask("tool", partialMessage, true);
+    } catch (error) {
+      console.warn("ReadFileHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+    const startLineStr = this.toolUse.params.start_line;
+    const endLineStr = this.toolUse.params.end_line;
+
+    // --- Parameter Validation ---
+    if (!relPath) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("read_file", "path"));
+      return;
+    }
+
+    let startLine: number | undefined = undefined;
+    let endLine: number | undefined = undefined;
+    let isRangeRead = false;
+
+    if (startLineStr || endLineStr) {
+      isRangeRead = true;
+      if (startLineStr) {
+        startLine = parseInt(startLineStr);
+        if (isNaN(startLine) || startLine < 1) { // Line numbers are 1-based
+          this.cline.consecutiveMistakeCount++;
+          await this.cline.say("error", `Invalid start_line value: ${startLineStr}. Must be a positive integer.`);
+          await this.cline.pushToolResult(this.toolUse, formatResponse.toolError("Invalid start_line value. Must be a positive integer."));
+          return;
+        }
+        startLine -= 1; // Convert to 0-based index for internal use
+      }
+      if (endLineStr) {
+        endLine = parseInt(endLineStr);
+        if (isNaN(endLine) || endLine < 1) { // Line numbers are 1-based
+          this.cline.consecutiveMistakeCount++;
+          await this.cline.say("error", `Invalid end_line value: ${endLineStr}. Must be a positive integer.`);
+          await this.cline.pushToolResult(this.toolUse, formatResponse.toolError("Invalid end_line value. Must be a positive integer."));
+          return;
+        }
+        // No need to convert endLine to 0-based for readLines, it expects 1-based end line
+        // endLine -= 1;
+      }
+      // Validate range logic (e.g., start <= end)
+      if (startLine !== undefined && endLine !== undefined && startLine >= endLine) {
+           this.cline.consecutiveMistakeCount++;
+           await this.cline.say("error", `Invalid line range: start_line (${startLineStr}) must be less than end_line (${endLineStr}).`);
+           await this.cline.pushToolResult(this.toolUse, formatResponse.toolError("Invalid line range: start_line must be less than end_line."));
+           return;
+      }
+    }
+
+    // --- Access Validation ---
+    const accessAllowed = this.cline.rooIgnoreController?.validateAccess(relPath);
+    if (!accessAllowed) {
+      await this.cline.say("rooignore_error", relPath);
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formatResponse.rooIgnoreError(relPath)));
+      return;
+    }
+
+    // --- Ask for Approval ---
+    const absolutePath = path.resolve(this.cline.cwd, relPath);
+    const isOutsideWorkspace = isPathOutsideWorkspace(absolutePath);
+    const sharedMessageProps: ClineSayTool = {
+      tool: "readFile",
+      path: getReadablePath(this.cline.cwd, relPath),
+      isOutsideWorkspace,
+    };
+    const completeMessage = JSON.stringify({
+      ...sharedMessageProps,
+      content: absolutePath, // Show the path being read
+    } satisfies ClineSayTool);
+
+    const didApprove = await this.cline.askApprovalHelper(this.toolUse, "tool", completeMessage);
+    if (!didApprove) {
+      // pushToolResult is handled by askApprovalHelper
+      return;
+    }
+
+    // --- Execute Read ---
+    try {
+      const { maxReadFileLine = 500 } = (await this.cline.providerRef.deref()?.getState()) ?? {};
+      let totalLines = 0;
+      try {
+        totalLines = await countFileLines(absolutePath);
+      } catch (error) {
+        // Handle file not found specifically
+        if (error.code === 'ENOENT') {
+             this.cline.consecutiveMistakeCount++;
+             const formattedError = `File does not exist at path: ${absolutePath}\n\n<error_details>\nThe specified file could not be found. Please verify the file path and try again.\n</error_details>`;
+             await this.cline.say("error", formattedError);
+             await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formattedError));
+             return;
+        }
+        console.error(`Error counting lines in file ${absolutePath}:`, error);
+        // Proceed anyway, totalLines will be 0
+      }
+
+      let content: string;
+      let isFileTruncated = false;
+      let sourceCodeDef = "";
+      const isBinary = await isBinaryFile(absolutePath).catch(() => false);
+
+      if (isRangeRead) {
+          // readLines expects 0-based start index and 1-based end line number
+          content = addLineNumbers(
+              await readLines(absolutePath, endLine, startLine), // endLine is already 1-based (or undefined), startLine is 0-based
+              startLine !== undefined ? startLine + 1 : 1 // Start numbering from 1-based startLine
+          );
+      } else if (!isBinary && maxReadFileLine >= 0 && totalLines > maxReadFileLine) {
+        isFileTruncated = true;
+        const [fileChunk, defResult] = await Promise.all([
+          maxReadFileLine > 0 ? readLines(absolutePath, maxReadFileLine, 0) : "", // Read up to maxReadFileLine (1-based)
+          parseSourceCodeDefinitionsForFile(absolutePath, this.cline.rooIgnoreController),
+        ]);
+        content = fileChunk.length > 0 ? addLineNumbers(fileChunk) : "";
+        if (defResult) {
+          sourceCodeDef = `\n\n${defResult}`;
+        }
+      } else {
+        content = await extractTextFromFile(absolutePath);
+        // Add line numbers only if it's not binary and not already range-read (which adds numbers)
+        if (!isBinary && !isRangeRead) {
+            content = addLineNumbers(content);
+        }
+      }
+
+      if (isFileTruncated) {
+        content += `\n\n[Showing only ${maxReadFileLine} of ${totalLines} total lines. Use start_line and end_line if you need to read more]${sourceCodeDef}`;
+      }
+
+      await this.cline.pushToolResult(this.toolUse, content);
+      this.cline.consecutiveMistakeCount = 0; // Reset mistake count on success
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name); // Capture telemetry
+
+    } catch (error: any) {
+        // Handle file not found during read attempt as well
+        if (error.code === 'ENOENT') {
+             this.cline.consecutiveMistakeCount++;
+             const formattedError = `File does not exist at path: ${absolutePath}\n\n<error_details>\nThe specified file could not be found. Please verify the file path and try again.\n</error_details>`;
+             await this.cline.say("error", formattedError);
+             await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formattedError));
+             return;
+        }
+      // Handle other errors
+      await this.cline.handleErrorHelper(this.toolUse, "reading file", error);
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/SearchAndReplaceHandler.ts b/src/core/tool-handlers/tools/SearchAndReplaceHandler.ts
new file mode 100644
index 00000000..b9204536
--- /dev/null
+++ b/src/core/tool-handlers/tools/SearchAndReplaceHandler.ts
@@ -0,0 +1,238 @@
+import * as path from "path";
+import * as fs from "fs/promises";
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { ClineSayTool } from "../../../shared/ExtensionMessage";
+import { getReadablePath } from "../../../utils/path";
+import { fileExistsAtPath } from "../../../utils/fs";
+import { addLineNumbers } from "../../../integrations/misc/extract-text";
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+// import { escapeRegExp } from "../../../utils/string"; // Removed incorrect import
+
+// Define the structure expected in the 'operations' JSON string
+interface SearchReplaceOperation {
+  search: string;
+  replace: string;
+  start_line?: number;
+  end_line?: number;
+  use_regex?: boolean;
+  ignore_case?: boolean;
+  regex_flags?: string;
+}
+
+export class SearchAndReplaceHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  // Helper function copied from Cline.ts
+  private static escapeRegExp(string: string): string {
+    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.path) {
+      throw new Error("Missing required parameter 'path'");
+    }
+    if (!this.toolUse.params.operations) {
+      throw new Error("Missing required parameter 'operations'");
+    }
+    // JSON format and content validation happens in handleComplete
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+    const operationsJson = this.toolUse.params.operations; // Keep for potential future partial parsing/validation
+    if (!relPath) return; // Need path for message
+
+    // Using "appliedDiff" as the tool type for UI consistency
+    const sharedMessageProps: ClineSayTool = {
+      tool: "appliedDiff",
+      path: getReadablePath(this.cline.cwd, this.removeClosingTag("path", relPath)),
+    };
+
+    // Construct partial message for UI update
+    const partialMessage = JSON.stringify({
+        ...sharedMessageProps,
+        // Could potentially show partial operations if needed, but keep simple for now
+        // operations: this.removeClosingTag("operations", operationsJson),
+    });
+
+    try {
+      await this.cline.ask("tool", partialMessage, true);
+    } catch (error) {
+      console.warn("SearchAndReplaceHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+    const operationsJson = this.toolUse.params.operations;
+
+    // --- Parameter Validation ---
+    if (!relPath) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("search_and_replace", "path"));
+      return;
+    }
+    if (!operationsJson) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("search_and_replace", "operations"));
+      return;
+    }
+
+    let parsedOperations: SearchReplaceOperation[];
+    try {
+      parsedOperations = JSON.parse(operationsJson);
+      if (!Array.isArray(parsedOperations)) {
+        throw new Error("Operations must be an array");
+      }
+      // Basic validation of operation structure
+      if (!parsedOperations.every(op => typeof op.search === 'string' && typeof op.replace === 'string')) {
+          throw new Error("Each operation must have string 'search' and 'replace' properties.");
+      }
+    } catch (error: any) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.say("error", `Failed to parse operations JSON: ${error.message}`);
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(`Invalid operations JSON format: ${error.message}`));
+      return;
+    }
+
+    // --- File Existence Check ---
+    const absolutePath = path.resolve(this.cline.cwd, relPath);
+    const fileExists = await fileExistsAtPath(absolutePath);
+    if (!fileExists) {
+      this.cline.consecutiveMistakeCount++;
+      const formattedError = `File does not exist at path: ${absolutePath}\n\n<error_details>\nThe specified file could not be found. Please verify the file path and try again.\n</error_details>`;
+      await this.cline.say("error", formattedError);
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formattedError));
+      return;
+    }
+
+    // --- Apply Replacements ---
+    try {
+      const fileContent = await fs.readFile(absolutePath, "utf-8");
+      this.cline.diffViewProvider.editType = "modify"; // Always modifies
+      this.cline.diffViewProvider.originalContent = fileContent;
+      let lines = fileContent.split("\n");
+
+      for (const op of parsedOperations) {
+        // Determine regex flags, ensuring 'm' for multiline if start/end lines are used
+        const baseFlags = op.regex_flags ?? (op.ignore_case ? "gi" : "g");
+        // Ensure multiline flag 'm' is present for line-range replacements or if already specified
+        const multilineFlags = (op.start_line || op.end_line || baseFlags.includes("m")) && !baseFlags.includes("m")
+                               ? baseFlags + "m"
+                               : baseFlags;
+
+         const searchPattern = op.use_regex
+           ? new RegExp(op.search, multilineFlags)
+           : new RegExp(SearchAndReplaceHandler.escapeRegExp(op.search), multilineFlags); // Use static class method
+
+         if (op.start_line || op.end_line) {
+           // Line-range replacement
+          const startLine = Math.max((op.start_line ?? 1) - 1, 0); // 0-based start index
+          const endLine = Math.min((op.end_line ?? lines.length) - 1, lines.length - 1); // 0-based end index
+
+          if (startLine > endLine) {
+              console.warn(`Search/Replace: Skipping operation with start_line (${op.start_line}) > end_line (${op.end_line})`);
+              continue; // Skip invalid range
+          }
+
+          const beforeLines = lines.slice(0, startLine);
+          const afterLines = lines.slice(endLine + 1);
+          const targetContent = lines.slice(startLine, endLine + 1).join("\n");
+          const modifiedContent = targetContent.replace(searchPattern, op.replace);
+          const modifiedLines = modifiedContent.split("\n");
+          lines = [...beforeLines, ...modifiedLines, ...afterLines];
+        } else {
+          // Global replacement
+          const fullContent = lines.join("\n");
+          const modifiedContent = fullContent.replace(searchPattern, op.replace);
+          lines = modifiedContent.split("\n");
+        }
+      }
+
+      const newContent = lines.join("\n");
+      this.cline.consecutiveMistakeCount = 0; // Reset on success
+
+      // --- Show Diff Preview ---
+      const diff = formatResponse.createPrettyPatch(relPath, fileContent, newContent);
+
+      if (!diff) {
+        await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(`No changes needed for '${relPath}'`));
+        await this.cline.diffViewProvider.reset();
+        return;
+      }
+
+      await this.cline.diffViewProvider.open(relPath);
+      await this.cline.diffViewProvider.update(newContent, true);
+      this.cline.diffViewProvider.scrollToFirstDiff();
+
+      // --- Ask for Approval ---
+      const sharedMessageProps: ClineSayTool = {
+        tool: "appliedDiff", // Consistent UI
+        path: getReadablePath(this.cline.cwd, relPath),
+      };
+      const completeMessage = JSON.stringify({
+        ...sharedMessageProps,
+        diff: diff,
+      } satisfies ClineSayTool);
+
+      // Use askApprovalHelper for consistency
+      const didApprove = await this.cline.askApprovalHelper(this.toolUse, "tool", completeMessage);
+      if (!didApprove) {
+        await this.cline.diffViewProvider.revertChanges();
+        // pushToolResult handled by helper
+        return;
+      }
+
+      // --- Save Changes ---
+      const { newProblemsMessage, userEdits, finalContent } = await this.cline.diffViewProvider.saveChanges();
+      this.cline.didEditFile = true;
+
+      let resultMessage: string;
+      if (userEdits) {
+         const userFeedbackDiff = JSON.stringify({
+            tool: "appliedDiff", // Consistent tool type
+            path: getReadablePath(this.cline.cwd, relPath),
+            diff: userEdits,
+          } satisfies ClineSayTool);
+         await this.cline.say("user_feedback_diff", userFeedbackDiff);
+         resultMessage =
+          `The user made the following updates to your content:\n\n${userEdits}\n\n` +
+          `The updated content, which includes both your original modifications and the user's edits, has been successfully saved to ${relPath}. Here is the full, updated content of the file, including line numbers:\n\n` +
+          `<final_file_content path="${relPath}">\n${addLineNumbers(finalContent || "")}\n</final_file_content>\n\n` + // Added line numbers for consistency
+          `Please note:\n` +
+          `1. You do not need to re-write the file with these changes, as they have already been applied.\n` +
+          `2. Proceed with the task using this updated file content as the new baseline.\n` +
+          `3. If the user's edits have addressed part of the task or changed the requirements, adjust your approach accordingly.` +
+          `${newProblemsMessage}`;
+      } else {
+        resultMessage = `Changes successfully applied to ${relPath}.${newProblemsMessage}`;
+      }
+
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(resultMessage));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+      await this.cline.handleErrorHelper(this.toolUse, "applying search and replace", error);
+    } finally {
+      // Always reset diff provider state
+      await this.cline.diffViewProvider.reset();
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/SearchFilesHandler.ts b/src/core/tool-handlers/tools/SearchFilesHandler.ts
new file mode 100644
index 00000000..8febc1a4
--- /dev/null
+++ b/src/core/tool-handlers/tools/SearchFilesHandler.ts
@@ -0,0 +1,125 @@
+import * as path from "path";
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { ClineSayTool } from "../../../shared/ExtensionMessage";
+import { getReadablePath } from "../../../utils/path";
+import { regexSearchFiles } from "../../../services/ripgrep"; // Assuming this path is correct
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+export class SearchFilesHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.path) {
+      throw new Error("Missing required parameter 'path'");
+    }
+    if (!this.toolUse.params.regex) {
+      throw new Error("Missing required parameter 'regex'");
+    }
+    // file_pattern is optional
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const relDirPath = this.toolUse.params.path;
+    const regex = this.toolUse.params.regex;
+    const filePattern = this.toolUse.params.file_pattern;
+    if (!relDirPath || !regex) return; // Need path and regex for message
+
+    const sharedMessageProps: ClineSayTool = {
+      tool: "searchFiles",
+      path: getReadablePath(this.cline.cwd, this.removeClosingTag("path", relDirPath)),
+      regex: this.removeClosingTag("regex", regex),
+      filePattern: this.removeClosingTag("file_pattern", filePattern), // Optional
+    };
+
+    const partialMessage = JSON.stringify({
+      ...sharedMessageProps,
+      content: "", // No content to show in partial
+    } satisfies ClineSayTool);
+
+    try {
+      await this.cline.ask("tool", partialMessage, true);
+    } catch (error) {
+      console.warn("SearchFilesHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const relDirPath = this.toolUse.params.path;
+    const regex = this.toolUse.params.regex;
+    const filePattern = this.toolUse.params.file_pattern;
+
+    // --- Parameter Validation ---
+    if (!relDirPath) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("search_files", "path"));
+      return;
+    }
+    if (!regex) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("search_files", "regex"));
+      return;
+    }
+
+    // --- Execute Search ---
+    try {
+      this.cline.consecutiveMistakeCount = 0; // Reset on successful validation
+
+      const absolutePath = path.resolve(this.cline.cwd, relDirPath);
+
+      // Prepare shared props for approval message
+      const sharedMessageProps: ClineSayTool = {
+        tool: "searchFiles",
+        path: getReadablePath(this.cline.cwd, relDirPath),
+        regex: regex,
+        filePattern: filePattern, // Include optional pattern if present
+      };
+
+      // Perform the search *before* asking for approval to include results in the prompt
+      const results = await regexSearchFiles(
+        this.cline.cwd,
+        absolutePath,
+        regex,
+        filePattern, // Pass optional pattern
+        this.cline.rooIgnoreController, // Pass ignore controller
+      );
+
+      // --- Ask for Approval (with results) ---
+      const completeMessage = JSON.stringify({
+        ...sharedMessageProps,
+        content: results, // Include search results in the approval message
+      } satisfies ClineSayTool);
+
+      const didApprove = await this.cline.askApprovalHelper(this.toolUse, "tool", completeMessage);
+      if (!didApprove) {
+        // pushToolResult handled by helper
+        return;
+      }
+
+      // --- Push Result ---
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(results));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+      // Handle potential errors during regexSearchFiles or approval
+      await this.cline.handleErrorHelper(this.toolUse, "searching files", error);
+    }
+    // No diff provider state to reset for this tool
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/SwitchModeHandler.ts b/src/core/tool-handlers/tools/SwitchModeHandler.ts
new file mode 100644
index 00000000..8bf73669
--- /dev/null
+++ b/src/core/tool-handlers/tools/SwitchModeHandler.ts
@@ -0,0 +1,116 @@
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { getModeBySlug, defaultModeSlug } from "../../../shared/modes"; // Assuming path
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+import delay from "delay";
+
+export class SwitchModeHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.mode_slug) {
+      throw new Error("Missing required parameter 'mode_slug'");
+    }
+    // reason is optional
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const modeSlug = this.toolUse.params.mode_slug;
+    const reason = this.toolUse.params.reason;
+    if (!modeSlug) return; // Need mode_slug for message
+
+    const partialMessage = JSON.stringify({
+      tool: "switchMode",
+      mode: this.removeClosingTag("mode_slug", modeSlug),
+      reason: this.removeClosingTag("reason", reason), // Optional
+    });
+
+    try {
+      await this.cline.ask("tool", partialMessage, true);
+    } catch (error) {
+      console.warn("SwitchModeHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const modeSlug = this.toolUse.params.mode_slug;
+    const reason = this.toolUse.params.reason;
+
+    // --- Parameter Validation ---
+    if (!modeSlug) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("switch_mode", "mode_slug"));
+      return;
+    }
+
+    // --- Execute Switch ---
+    try {
+      this.cline.consecutiveMistakeCount = 0; // Reset on successful validation
+
+      const provider = this.cline.providerRef.deref();
+      if (!provider) {
+          throw new Error("ClineProvider reference is lost.");
+      }
+      const currentState = await provider.getState(); // Get current state once
+
+      // Verify the mode exists
+      const targetMode = getModeBySlug(modeSlug, currentState?.customModes);
+      if (!targetMode) {
+        await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(`Invalid mode: ${modeSlug}`));
+        return;
+      }
+
+      // Check if already in requested mode
+      const currentModeSlug = currentState?.mode ?? defaultModeSlug;
+      if (currentModeSlug === modeSlug) {
+        await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(`Already in ${targetMode.name} mode.`));
+        return;
+      }
+
+      // --- Ask for Approval ---
+      const completeMessage = JSON.stringify({
+        tool: "switchMode",
+        mode: modeSlug, // Use validated slug
+        reason,
+      });
+
+      const didApprove = await this.cline.askApprovalHelper(this.toolUse, "tool", completeMessage);
+      if (!didApprove) {
+        // pushToolResult handled by helper
+        return;
+      }
+
+      // --- Perform Switch ---
+      await provider.handleModeSwitch(modeSlug); // Call provider method
+
+      // --- Push Result ---
+      const currentModeName = getModeBySlug(currentModeSlug, currentState?.customModes)?.name ?? currentModeSlug;
+      const resultMessage = `Successfully switched from ${currentModeName} mode to ${targetMode.name} mode${reason ? ` because: ${reason}` : ""}.`;
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(resultMessage));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+      // Delay to allow mode change to potentially affect subsequent actions
+      await delay(500);
+
+    } catch (error: any) {
+      // Handle errors during validation, approval, or switch
+      await this.cline.handleErrorHelper(this.toolUse, "switching mode", error);
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/UseMcpToolHandler.ts b/src/core/tool-handlers/tools/UseMcpToolHandler.ts
new file mode 100644
index 00000000..f60fb367
--- /dev/null
+++ b/src/core/tool-handlers/tools/UseMcpToolHandler.ts
@@ -0,0 +1,137 @@
+import { ToolUse } from "../../assistant-message"; // Using generic ToolUse
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { ClineAskUseMcpServer } from "../../../shared/ExtensionMessage";
+import { telemetryService } from "../../../services/telemetry/TelemetryService";
+
+export class UseMcpToolHandler extends ToolUseHandler {
+  // No specific toolUse type override needed
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.server_name) {
+      throw new Error("Missing required parameter 'server_name'");
+    }
+    if (!this.toolUse.params.tool_name) {
+      throw new Error("Missing required parameter 'tool_name'");
+    }
+    // arguments is optional, but JSON format is validated in handleComplete
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const serverName = this.toolUse.params.server_name;
+    const toolName = this.toolUse.params.tool_name;
+    const mcpArguments = this.toolUse.params.arguments;
+    if (!serverName || !toolName) return; // Need server and tool name for message
+
+    const partialMessage = JSON.stringify({
+      type: "use_mcp_tool",
+      serverName: this.removeClosingTag("server_name", serverName),
+      toolName: this.removeClosingTag("tool_name", toolName),
+      arguments: this.removeClosingTag("arguments", mcpArguments), // Optional
+    } satisfies ClineAskUseMcpServer);
+
+    try {
+      await this.cline.ask("use_mcp_server", partialMessage, true);
+    } catch (error) {
+      console.warn("UseMcpToolHandler: ask for partial update interrupted.", error);
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const serverName = this.toolUse.params.server_name;
+    const toolName = this.toolUse.params.tool_name;
+    const mcpArguments = this.toolUse.params.arguments;
+
+    // --- Parameter Validation ---
+    if (!serverName) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("use_mcp_tool", "server_name"));
+      return;
+    }
+    if (!toolName) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("use_mcp_tool", "tool_name"));
+      return;
+    }
+
+    let parsedArguments: Record<string, unknown> | undefined;
+    if (mcpArguments) {
+      try {
+        parsedArguments = JSON.parse(mcpArguments);
+      } catch (error: any) {
+        this.cline.consecutiveMistakeCount++;
+        await this.cline.say("error", `Roo tried to use ${toolName} with an invalid JSON argument. Retrying...`);
+        await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formatResponse.invalidMcpToolArgumentError(serverName, toolName)));
+        return;
+      }
+    }
+
+    // --- Execute MCP Tool ---
+    try {
+      this.cline.consecutiveMistakeCount = 0; // Reset on successful validation
+
+      // --- Ask for Approval ---
+      const completeMessage = JSON.stringify({
+        type: "use_mcp_tool",
+        serverName: serverName,
+        toolName: toolName,
+        arguments: mcpArguments, // Show raw JSON string in approval
+      } satisfies ClineAskUseMcpServer);
+
+      const didApprove = await this.cline.askApprovalHelper(this.toolUse, "use_mcp_server", completeMessage);
+      if (!didApprove) {
+        // pushToolResult handled by helper
+        return;
+      }
+
+      // --- Call MCP Hub ---
+      await this.cline.say("mcp_server_request_started"); // Show loading/request state
+      const mcpHub = this.cline.providerRef.deref()?.getMcpHub();
+      if (!mcpHub) {
+          throw new Error("MCP Hub is not available.");
+      }
+
+      const toolResult = await mcpHub.callTool(serverName, toolName, parsedArguments);
+
+      // --- Process Result ---
+      // TODO: Handle progress indicators and non-text/resource responses if needed
+      const toolResultPretty =
+        (toolResult?.isError ? "Error:\n" : "") +
+        (toolResult?.content
+          ?.map((item) => {
+            if (item.type === "text") return item.text;
+            // Basic representation for resource types in the result text
+            if (item.type === "resource") {
+              const { blob, ...rest } = item.resource; // Exclude blob from stringification
+              return `[Resource: ${JSON.stringify(rest, null, 2)}]`;
+            }
+            return "";
+          })
+          .filter(Boolean)
+          .join("\n\n") || "(No response)");
+
+      await this.cline.say("mcp_server_response", toolResultPretty); // Show formatted result
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(toolResultPretty));
+      telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name);
+
+    } catch (error: any) {
+      // Handle errors during approval or MCP call
+      await this.cline.handleErrorHelper(this.toolUse, "executing MCP tool", error);
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/core/tool-handlers/tools/WriteToFileHandler.ts b/src/core/tool-handlers/tools/WriteToFileHandler.ts
new file mode 100644
index 00000000..988fec76
--- /dev/null
+++ b/src/core/tool-handlers/tools/WriteToFileHandler.ts
@@ -0,0 +1,258 @@
+import * as path from "path";
+import * as vscode from "vscode";
+import { ToolUse, WriteToFileToolUse } from "../../assistant-message";
+import { Cline } from "../../Cline";
+import { ToolUseHandler } from "../ToolUseHandler";
+import { formatResponse } from "../../prompts/responses";
+import { ClineSayTool, ToolProgressStatus } from "../../../shared/ExtensionMessage";
+import { getReadablePath } from "../../../utils/path"; // Keep this one
+import { isPathOutsideWorkspace } from "../../../utils/pathUtils"; // Import from pathUtils
+import { fileExistsAtPath } from "../../../utils/fs";
+import { detectCodeOmission } from "../../../integrations/editor/detect-omission";
+import { everyLineHasLineNumbers, stripLineNumbers } from "../../../integrations/misc/extract-text";
+import { telemetryService } from "../../../services/telemetry/TelemetryService"; // Corrected path
+import delay from "delay";
+
+export class WriteToFileHandler extends ToolUseHandler {
+  // Type assertion for specific tool use
+  protected override toolUse: WriteToFileToolUse; // Correct modifier order
+
+  constructor(cline: Cline, toolUse: ToolUse) {
+    super(cline, toolUse);
+    // Assert the type after calling super constructor
+    this.toolUse = toolUse as WriteToFileToolUse;
+  }
+
+  async handle(): Promise<boolean> {
+    if (this.toolUse.partial) {
+      await this.handlePartial();
+      return false; // Indicate partial handling (streaming)
+    } else {
+      await this.handleComplete();
+      return true; // Indicate complete handling
+    }
+  }
+
+  validateParams(): void {
+    if (!this.toolUse.params.path) {
+      throw new Error("Missing required parameter 'path'");
+    }
+    // Content validation happens in handleComplete as it might stream partially
+    if (!this.toolUse.partial && !this.toolUse.params.content) {
+      throw new Error("Missing required parameter 'content'");
+    }
+    // Line count validation happens in handleComplete
+    if (!this.toolUse.partial && !this.toolUse.params.line_count) {
+      throw new Error("Missing required parameter 'line_count'");
+    }
+  }
+
+  protected async handlePartial(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+    let newContent = this.toolUse.params.content;
+
+    // Skip if we don't have enough information yet (path is needed early)
+    if (!relPath) {
+      return;
+    }
+
+    // Pre-process content early if possible (remove ``` markers)
+    if (newContent?.startsWith("```")) {
+      newContent = newContent.split("\n").slice(1).join("\n").trim();
+    }
+    if (newContent?.endsWith("```")) {
+      newContent = newContent.split("\n").slice(0, -1).join("\n").trim();
+    }
+
+    // Validate access (can be done early with path)
+    const accessAllowed = this.cline.rooIgnoreController?.validateAccess(relPath);
+    if (!accessAllowed) {
+      // If access is denied early, stop processing and report error
+      // Note: This might need refinement if partial denial is possible/needed
+      await this.cline.say("rooignore_error", relPath);
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formatResponse.rooIgnoreError(relPath)));
+      // Consider how to stop further streaming/handling for this tool use
+      return;
+    }
+
+    // Determine file existence and edit type if not already set
+    if (this.cline.diffViewProvider.editType === undefined) {
+        const absolutePath = path.resolve(this.cline.cwd, relPath);
+        const fileExists = await fileExistsAtPath(absolutePath);
+        this.cline.diffViewProvider.editType = fileExists ? "modify" : "create";
+    }
+    const fileExists = this.cline.diffViewProvider.editType === "modify";
+
+    // Determine if the path is outside the workspace
+    const fullPath = path.resolve(this.cline.cwd, this.removeClosingTag("path", relPath));
+    const isOutsideWorkspace = isPathOutsideWorkspace(fullPath);
+
+    const sharedMessageProps: ClineSayTool = {
+      tool: fileExists ? "editedExistingFile" : "newFileCreated",
+      path: getReadablePath(this.cline.cwd, this.removeClosingTag("path", relPath)),
+      isOutsideWorkspace,
+    };
+
+    // Update GUI message (ask with partial=true)
+    const partialMessage = JSON.stringify(sharedMessageProps);
+    // Use try-catch as ask can throw if interrupted
+    try {
+        await this.cline.ask("tool", partialMessage, true);
+    } catch (error) {
+        console.warn("WriteToFileHandler: ask for partial update interrupted.", error);
+        // If ask fails, we might not want to proceed with editor updates
+        return;
+    }
+
+
+    // Update editor only if content is present
+    if (newContent) {
+        if (!this.cline.diffViewProvider.isEditing) {
+            // Open the editor and prepare to stream content in
+            await this.cline.diffViewProvider.open(relPath);
+        }
+        // Editor is open, stream content in
+        await this.cline.diffViewProvider.update(
+            everyLineHasLineNumbers(newContent) ? stripLineNumbers(newContent) : newContent,
+            false // Indicate partial update
+        );
+    }
+  }
+
+  protected async handleComplete(): Promise<void> {
+    const relPath = this.toolUse.params.path;
+    let newContent = this.toolUse.params.content;
+    const predictedLineCount = parseInt(this.toolUse.params.line_count ?? "0");
+
+    // --- Parameter Validation ---
+    if (!relPath) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("write_to_file", "path"));
+      await this.cline.diffViewProvider.reset(); // Reset diff view state
+      return;
+    }
+    if (!newContent) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("write_to_file", "content"));
+      await this.cline.diffViewProvider.reset();
+      return;
+    }
+    if (!predictedLineCount) {
+      this.cline.consecutiveMistakeCount++;
+      await this.cline.pushToolResult(this.toolUse, await this.cline.sayAndCreateMissingParamError("write_to_file", "line_count"));
+      await this.cline.diffViewProvider.reset();
+      return;
+    }
+
+    // --- Access Validation ---
+    const accessAllowed = this.cline.rooIgnoreController?.validateAccess(relPath);
+    if (!accessAllowed) {
+      await this.cline.say("rooignore_error", relPath);
+      await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(formatResponse.rooIgnoreError(relPath)));
+      await this.cline.diffViewProvider.reset();
+      return;
+    }
+
+    // --- Content Pre-processing ---
+    if (newContent.startsWith("```")) {
+      newContent = newContent.split("\n").slice(1).join("\n").trim();
+    }
+    if (newContent.endsWith("```")) {
+      newContent = newContent.split("\n").slice(0, -1).join("\n").trim();
+    }
+    // Handle HTML entities (moved from Cline.ts)
+    if (!this.cline.api.getModel().id.includes("claude")) {
+        // Corrected check for double quote
+        if (newContent.includes("&gt;") || newContent.includes("&lt;") || newContent.includes('"')) {
+            newContent = newContent.replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"');
+        }
+    }
+
+    // --- Determine File State ---
+    // Ensure editType is set (might not have been if handlePartial wasn't called or skipped early)
+    // Removed duplicate 'if' keyword
+    if (this.cline.diffViewProvider.editType === undefined) {
+        const absolutePath = path.resolve(this.cline.cwd, relPath);
+        const fileExistsCheck = await fileExistsAtPath(absolutePath);
+        this.cline.diffViewProvider.editType = fileExistsCheck ? "modify" : "create";
+    }
+    const fileExists = this.cline.diffViewProvider.editType === "modify";
+    const fullPath = path.resolve(this.cline.cwd, relPath);
+    const isOutsideWorkspace = isPathOutsideWorkspace(fullPath);
+
+    // --- Update Editor (Final) ---
+    // Ensure editor is open if not already editing (covers cases where partial didn't run)
+    if (!this.cline.diffViewProvider.isEditing) {
+        await this.cline.diffViewProvider.open(relPath);
+    }
+    // Perform final update
+    await this.cline.diffViewProvider.update(
+        everyLineHasLineNumbers(newContent) ? stripLineNumbers(newContent) : newContent,
+        true // Indicate complete update
+    );
+    await delay(300); // Allow diff view to update
+    this.cline.diffViewProvider.scrollToFirstDiff();
+
+    // --- Code Omission Check ---
+    if (detectCodeOmission(this.cline.diffViewProvider.originalContent || "", newContent, predictedLineCount)) {
+        if (this.cline.diffStrategy) { // Check if diff strategy is enabled
+            await this.cline.diffViewProvider.revertChanges();
+            await this.cline.pushToolResult(this.toolUse, formatResponse.toolError(
+                `Content appears to be truncated (file has ${newContent.split("\n").length} lines but was predicted to have ${predictedLineCount} lines), and found comments indicating omitted code (e.g., '// rest of code unchanged', '/* previous code */'). Please provide the complete file content without any omissions if possible, or otherwise use the 'apply_diff' tool to apply the diff to the original file.`
+            ));
+            return; // Stop processing
+        } else {
+            // Show warning if diff strategy is not enabled (original behavior)
+             vscode.window.showWarningMessage(
+                "Potential code truncation detected. This happens when the AI reaches its max output limit.",
+                "Follow this guide to fix the issue",
+            ).then((selection) => {
+                if (selection === "Follow this guide to fix the issue") {
+                    vscode.env.openExternal(vscode.Uri.parse(
+                        "https://github.com/cline/cline/wiki/Troubleshooting-%E2%80%90-Cline-Deleting-Code-with-%22Rest-of-Code-Here%22-Comments"
+                    ));
+                }
+            });
+        }
+    }
+
+    // --- Ask for Approval ---
+    const sharedMessageProps: ClineSayTool = {
+      tool: fileExists ? "editedExistingFile" : "newFileCreated",
+      path: getReadablePath(this.cline.cwd, relPath),
+      isOutsideWorkspace,
+    };
+    const completeMessage = JSON.stringify({
+      ...sharedMessageProps,
+      content: fileExists ? undefined : newContent, // Only show full content for new files
+      diff: fileExists ? formatResponse.createPrettyPatch(relPath, this.cline.diffViewProvider.originalContent, newContent) : undefined,
+    } satisfies ClineSayTool);
+
+    // Use helper from Cline or replicate askApproval logic here
+    // For now, assuming askApproval is accessible or replicated
+    // Pass this.toolUse as the first argument
+    const didApprove = await this.cline.askApprovalHelper(this.toolUse, "tool", completeMessage);
+
+    // --- Finalize or Revert ---
+    if (didApprove) {
+      try {
+        await this.cline.diffViewProvider.saveChanges();
+        // Use formatResponse.toolResult for success message
+        await this.cline.pushToolResult(this.toolUse, formatResponse.toolResult(`Successfully saved changes to ${relPath}`));
+        this.cline.didEditFile = true; // Mark that a file was edited
+        this.cline.consecutiveMistakeCount = 0; // Reset mistake count on success
+        telemetryService.captureToolUsage(this.cline.taskId, this.toolUse.name); // Capture telemetry
+      } catch (error: any) {
+        await this.cline.diffViewProvider.revertChanges();
+        await this.cline.handleErrorHelper(this.toolUse, `saving file ${relPath}`, error); // Pass this.toolUse
+      }
+    } else {
+      // User rejected
+      await this.cline.diffViewProvider.revertChanges();
+      // pushToolResult was already called within askApprovalHelper if user provided feedback or just denied
+    }
+
+    // Reset diff provider state regardless of outcome
+    await this.cline.diffViewProvider.reset();
+  }
+}
\ No newline at end of file
