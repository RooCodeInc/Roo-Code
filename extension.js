"use strict"
var tke = Object.create
var aI = Object.defineProperty
var rke = Object.getOwnPropertyDescriptor
var nke = Object.getOwnPropertyNames
var ike = Object.getPrototypeOf,
	ske = Object.prototype.hasOwnProperty
var oke = (e, t) => () => (e && (t = e((e = 0))), t)
var x = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
	z2 = (e, t) => {
		for (var r in t) aI(e, r, { get: t[r], enumerable: !0 })
	},
	h$ = (e, t, r, n) => {
		if ((t && typeof t == "object") || typeof t == "function")
			for (let i of nke(t))
				!ske.call(e, i) &&
					i !== r &&
					aI(e, i, {
						get: () => t[i],
						enumerable: !(n = rke(t, i)) || n.enumerable,
					})
		return e
	}
var W = (e, t, r) => (
		(r = e != null ? tke(ike(e)) : {}),
		h$(t || !e || !e.__esModule ? aI(r, "default", { value: e, enumerable: !0 }) : r, e)
	),
	j2 = (e) => h$(aI({}, "__esModule", { value: !0 }), e)
var gd = x((jCt, _$) => {
	"use strict"
	function hke(e) {
		var t = typeof e
		return e != null && (t == "object" || t == "function")
	}
	_$.exports = hke
})
var X2 = x((ZCt, w$) => {
	"use strict"
	var gke = typeof global == "object" && global && global.Object === Object && global
	w$.exports = gke
})
var Ka = x((XCt, I$) => {
	"use strict"
	var pke = X2(),
		Ake = typeof self == "object" && self && self.Object === Object && self,
		mke = pke || Ake || Function("return this")()
	I$.exports = mke
})
var B$ = x((evt, S$) => {
	"use strict"
	var yke = Ka(),
		Cke = function () {
			return yke.Date.now()
		}
	S$.exports = Cke
})
var T$ = x((tvt, D$) => {
	"use strict"
	var vke = /\s/
	function Eke(e) {
		for (var t = e.length; t-- && vke.test(e.charAt(t)); );
		return t
	}
	D$.exports = Eke
})
var k$ = x((rvt, R$) => {
	"use strict"
	var bke = T$(),
		xke = /^\s+/
	function _ke(e) {
		return e && e.slice(0, bke(e) + 1).replace(xke, "")
	}
	R$.exports = _ke
})
var Iv = x((nvt, M$) => {
	"use strict"
	var wke = Ka(),
		Ike = wke.Symbol
	M$.exports = Ike
})
var P$ = x((ivt, N$) => {
	"use strict"
	var F$ = Iv(),
		Q$ = Object.prototype,
		Ske = Q$.hasOwnProperty,
		Bke = Q$.toString,
		Sv = F$ ? F$.toStringTag : void 0
	function Dke(e) {
		var t = Ske.call(e, Sv),
			r = e[Sv]
		try {
			e[Sv] = void 0
			var n = !0
		} catch {}
		var i = Bke.call(e)
		return n && (t ? (e[Sv] = r) : delete e[Sv]), i
	}
	N$.exports = Dke
})
var U$ = x((svt, L$) => {
	"use strict"
	var Tke = Object.prototype,
		Rke = Tke.toString
	function kke(e) {
		return Rke.call(e)
	}
	L$.exports = kke
})
var zA = x((ovt, V$) => {
	"use strict"
	var O$ = Iv(),
		Mke = P$(),
		Fke = U$(),
		Qke = "[object Null]",
		Nke = "[object Undefined]",
		q$ = O$ ? O$.toStringTag : void 0
	function Pke(e) {
		return e == null ? (e === void 0 ? Nke : Qke) : q$ && q$ in Object(e) ? Mke(e) : Fke(e)
	}
	V$.exports = Pke
})
var Tf = x((avt, H$) => {
	"use strict"
	function Lke(e) {
		return e != null && typeof e == "object"
	}
	H$.exports = Lke
})
var G$ = x((lvt, W$) => {
	"use strict"
	var Uke = zA(),
		Oke = Tf(),
		qke = "[object Symbol]"
	function Vke(e) {
		return typeof e == "symbol" || (Oke(e) && Uke(e) == qke)
	}
	W$.exports = Vke
})
var J$ = x((cvt, K$) => {
	"use strict"
	var Hke = k$(),
		$$ = gd(),
		Wke = G$(),
		Y$ = NaN,
		Gke = /^[-+]0x[0-9a-f]+$/i,
		$ke = /^0b[01]+$/i,
		Yke = /^0o[0-7]+$/i,
		Kke = parseInt
	function Jke(e) {
		if (typeof e == "number") return e
		if (Wke(e)) return Y$
		if ($$(e)) {
			var t = typeof e.valueOf == "function" ? e.valueOf() : e
			e = $$(t) ? t + "" : t
		}
		if (typeof e != "string") return e === 0 ? e : +e
		e = Hke(e)
		var r = $ke.test(e)
		return r || Yke.test(e) ? Kke(e.slice(2), r ? 2 : 8) : Gke.test(e) ? Y$ : +e
	}
	K$.exports = Jke
})
var jA = x((uvt, j$) => {
	"use strict"
	var zke = gd(),
		eP = B$(),
		z$ = J$(),
		jke = "Expected a function",
		Zke = Math.max,
		Xke = Math.min
	function eMe(e, t, r) {
		var n,
			i,
			s,
			o,
			a,
			l,
			c = 0,
			u = !1,
			f = !1,
			p = !0
		if (typeof e != "function") throw new TypeError(jke)
		;(t = z$(t) || 0),
			zke(r) &&
				((u = !!r.leading),
				(f = "maxWait" in r),
				(s = f ? Zke(z$(r.maxWait) || 0, t) : s),
				(p = "trailing" in r ? !!r.trailing : p))
		function g(Q) {
			var O = n,
				Y = i
			return (n = i = void 0), (c = Q), (o = e.apply(Y, O)), o
		}
		function m(Q) {
			return (c = Q), (a = setTimeout(v, t)), u ? g(Q) : o
		}
		function y(Q) {
			var O = Q - l,
				Y = Q - c,
				j = t - O
			return f ? Xke(j, s - Y) : j
		}
		function C(Q) {
			var O = Q - l,
				Y = Q - c
			return l === void 0 || O >= t || O < 0 || (f && Y >= s)
		}
		function v() {
			var Q = eP()
			if (C(Q)) return b(Q)
			a = setTimeout(v, y(Q))
		}
		function b(Q) {
			return (a = void 0), p && n ? g(Q) : ((n = i = void 0), o)
		}
		function w() {
			a !== void 0 && clearTimeout(a), (c = 0), (n = l = i = a = void 0)
		}
		function B() {
			return a === void 0 ? o : b(eP())
		}
		function M() {
			var Q = eP(),
				O = C(Q)
			if (((n = arguments), (i = this), (l = Q), O)) {
				if (a === void 0) return m(l)
				if (f) return clearTimeout(a), (a = setTimeout(v, t)), g(l)
			}
			return a === void 0 && (a = setTimeout(v, t)), o
		}
		return (M.cancel = w), (M.flush = B), M
	}
	j$.exports = eMe
})
var ZA = x((dvt, Z$) => {
	"use strict"
	var tMe = jA(),
		rMe = gd(),
		nMe = "Expected a function"
	function iMe(e, t, r) {
		var n = !0,
			i = !0
		if (typeof e != "function") throw new TypeError(nMe)
		return (
			rMe(r) && ((n = "leading" in r ? !!r.leading : n), (i = "trailing" in r ? !!r.trailing : i)),
			tMe(e, t, { leading: n, maxWait: t, trailing: i })
		)
	}
	Z$.exports = iMe
})
var gs = x((um, Uv) => {
	"use strict"
	;(function () {
		var e,
			t = "4.17.21",
			r = 200,
			n = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
			i = "Expected a function",
			s = "Invalid `variable` option passed into `_.template`",
			o = "__lodash_hash_undefined__",
			a = 500,
			l = "__lodash_placeholder__",
			c = 1,
			u = 2,
			f = 4,
			p = 1,
			g = 2,
			m = 1,
			y = 2,
			C = 4,
			v = 8,
			b = 16,
			w = 32,
			B = 64,
			M = 128,
			Q = 256,
			O = 512,
			Y = 30,
			j = "...",
			ne = 800,
			q = 16,
			me = 1,
			Qe = 2,
			N = 3,
			re = 1 / 0,
			K = 9007199254740991,
			se = 17976931348623157e292,
			Ze = NaN,
			It = 4294967295,
			Ce = It - 1,
			Et = It >>> 1,
			jt = [
				["ary", M],
				["bind", m],
				["bindKey", y],
				["curry", v],
				["curryRight", b],
				["flip", O],
				["partial", w],
				["partialRight", B],
				["rearg", Q],
			],
			Ar = "[object Arguments]",
			de = "[object Array]",
			Tr = "[object AsyncFunction]",
			tr = "[object Boolean]",
			Nr = "[object Date]",
			Ve = "[object DOMException]",
			en = "[object Error]",
			Pr = "[object Function]",
			cr = "[object GeneratorFunction]",
			be = "[object Map]",
			Rr = "[object Number]",
			fe = "[object Null]",
			Ee = "[object Object]",
			bt = "[object Promise]",
			sn = "[object Proxy]",
			yn = "[object RegExp]",
			Ei = "[object Set]",
			Js = "[object String]",
			Ju = "[object Symbol]",
			Pc = "[object Undefined]",
			rr = "[object WeakMap]",
			MN = "[object WeakSet]",
			Gi = "[object ArrayBuffer]",
			ra = "[object DataView]",
			zu = "[object Float32Array]",
			ju = "[object Float64Array]",
			VC = "[object Int8Array]",
			na = "[object Int16Array]",
			HC = "[object Int32Array]",
			WC = "[object Uint8Array]",
			mr = "[object Uint8ClampedArray]",
			St = "[object Uint16Array]",
			Cn = "[object Uint32Array]",
			La = /\b__p \+= '';/g,
			Ua = /\b(__p \+=) '' \+/g,
			ug = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
			Ul = /&(?:amp|lt|gt|quot|#39);/g,
			Ct = /[&<>"']/g,
			wA = RegExp(Ul.source),
			GC = RegExp(Ct.source),
			J_ = /<%-([\s\S]+?)%>/g,
			IA = /<%([\s\S]+?)%>/g,
			Af = /<%=([\s\S]+?)%>/g,
			SA = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
			FN = /^\w*$/,
			$C = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
			Fi = /[\\^$.*+?()[\]{}|]/g,
			BA = RegExp(Fi.source),
			YC = /^\s+/,
			QN = /\s/,
			Zu = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
			Ke = /\{\n\/\* \[wrapped with (.+)\] \*/,
			Jt = /,? & /,
			Lc = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
			dg = /[()=,{}\[\]\/\s]/,
			Uc = /\\(\\)?/g,
			KC = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
			z_ = /\w*$/,
			NN = /^[-+]0x[0-9a-f]+$/i,
			j_ = /^0b[01]+$/i,
			PN = /^\[object .+?Constructor\]$/,
			LN = /^0o[0-7]+$/i,
			UN = /^(?:0|[1-9]\d*)$/,
			ON = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
			DA = /($^)/,
			qN = /['\n\r\u2028\u2029\\]/g,
			TA = "\\ud800-\\udfff",
			VN = "\\u0300-\\u036f",
			HN = "\\ufe20-\\ufe2f",
			WN = "\\u20d0-\\u20ff",
			Z_ = VN + HN + WN,
			ia = "\\u2700-\\u27bf",
			X_ = "a-z\\xdf-\\xf6\\xf8-\\xff",
			ew = "\\xac\\xb1\\xd7\\xf7",
			JC = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
			GN = "\\u2000-\\u206f",
			$N =
				" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
			tw = "A-Z\\xc0-\\xd6\\xd8-\\xde",
			Ol = "\\ufe0e\\ufe0f",
			rw = ew + JC + GN + $N,
			zC = "['\u2019]",
			jC = "[" + TA + "]",
			nw = "[" + rw + "]",
			zs = "[" + Z_ + "]",
			RA = "\\d+",
			YN = "[" + ia + "]",
			ZC = "[" + X_ + "]",
			fg = "[^" + TA + rw + RA + ia + X_ + tw + "]",
			mf = "\\ud83c[\\udffb-\\udfff]",
			kA = "(?:" + zs + "|" + mf + ")",
			MA = "[^" + TA + "]",
			Oa = "(?:\\ud83c[\\udde6-\\uddff]){2}",
			yf = "[\\ud800-\\udbff][\\udc00-\\udfff]",
			Xu = "[" + tw + "]",
			iw = "\\u200d",
			sw = "(?:" + ZC + "|" + fg + ")",
			ed = "(?:" + Xu + "|" + fg + ")",
			ow = "(?:" + zC + "(?:d|ll|m|re|s|t|ve))?",
			aw = "(?:" + zC + "(?:D|LL|M|RE|S|T|VE))?",
			lw = kA + "?",
			cw = "[" + Ol + "]?",
			XC = "(?:" + iw + "(?:" + [MA, Oa, yf].join("|") + ")" + cw + lw + ")*",
			FA = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
			KN = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
			uw = cw + lw + XC,
			dw = "(?:" + [YN, Oa, yf].join("|") + ")" + uw,
			ev = "(?:" + [MA + zs + "?", zs, Oa, yf, jC].join("|") + ")",
			fw = RegExp(zC, "g"),
			JN = RegExp(zs, "g"),
			tv = RegExp(mf + "(?=" + mf + ")|" + ev + uw, "g"),
			hw = RegExp(
				[
					Xu + "?" + ZC + "+" + ow + "(?=" + [nw, Xu, "$"].join("|") + ")",
					ed + "+" + aw + "(?=" + [nw, Xu + sw, "$"].join("|") + ")",
					Xu + "?" + sw + "+" + ow,
					Xu + "+" + aw,
					KN,
					FA,
					RA,
					dw,
				].join("|"),
				"g",
			),
			gw = RegExp("[" + iw + TA + Z_ + Ol + "]"),
			pw = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
			zN = [
				"Array",
				"Buffer",
				"DataView",
				"Date",
				"Error",
				"Float32Array",
				"Float64Array",
				"Function",
				"Int8Array",
				"Int16Array",
				"Int32Array",
				"Map",
				"Math",
				"Object",
				"Promise",
				"RegExp",
				"Set",
				"String",
				"Symbol",
				"TypeError",
				"Uint8Array",
				"Uint8ClampedArray",
				"Uint16Array",
				"Uint32Array",
				"WeakMap",
				"_",
				"clearTimeout",
				"isFinite",
				"parseInt",
				"setTimeout",
			],
			jN = -1,
			an = {}
		;(an[zu] = an[ju] = an[VC] = an[na] = an[HC] = an[WC] = an[mr] = an[St] = an[Cn] = !0),
			(an[Ar] =
				an[de] =
				an[Gi] =
				an[tr] =
				an[ra] =
				an[Nr] =
				an[en] =
				an[Pr] =
				an[be] =
				an[Rr] =
				an[Ee] =
				an[yn] =
				an[Ei] =
				an[Js] =
				an[rr] =
					!1)
		var Lr = {}
		;(Lr[Ar] =
			Lr[de] =
			Lr[Gi] =
			Lr[ra] =
			Lr[tr] =
			Lr[Nr] =
			Lr[zu] =
			Lr[ju] =
			Lr[VC] =
			Lr[na] =
			Lr[HC] =
			Lr[be] =
			Lr[Rr] =
			Lr[Ee] =
			Lr[yn] =
			Lr[Ei] =
			Lr[Js] =
			Lr[Ju] =
			Lr[WC] =
			Lr[mr] =
			Lr[St] =
			Lr[Cn] =
				!0),
			(Lr[en] = Lr[Pr] = Lr[rr] = !1)
		var QA = {
				À: "A",
				Á: "A",
				Â: "A",
				Ã: "A",
				Ä: "A",
				Å: "A",
				à: "a",
				á: "a",
				â: "a",
				ã: "a",
				ä: "a",
				å: "a",
				Ç: "C",
				ç: "c",
				Ð: "D",
				ð: "d",
				È: "E",
				É: "E",
				Ê: "E",
				Ë: "E",
				è: "e",
				é: "e",
				ê: "e",
				ë: "e",
				Ì: "I",
				Í: "I",
				Î: "I",
				Ï: "I",
				ì: "i",
				í: "i",
				î: "i",
				ï: "i",
				Ñ: "N",
				ñ: "n",
				Ò: "O",
				Ó: "O",
				Ô: "O",
				Õ: "O",
				Ö: "O",
				Ø: "O",
				ò: "o",
				ó: "o",
				ô: "o",
				õ: "o",
				ö: "o",
				ø: "o",
				Ù: "U",
				Ú: "U",
				Û: "U",
				Ü: "U",
				ù: "u",
				ú: "u",
				û: "u",
				ü: "u",
				Ý: "Y",
				ý: "y",
				ÿ: "y",
				Æ: "Ae",
				æ: "ae",
				Þ: "Th",
				þ: "th",
				ß: "ss",
				Ā: "A",
				Ă: "A",
				Ą: "A",
				ā: "a",
				ă: "a",
				ą: "a",
				Ć: "C",
				Ĉ: "C",
				Ċ: "C",
				Č: "C",
				ć: "c",
				ĉ: "c",
				ċ: "c",
				č: "c",
				Ď: "D",
				Đ: "D",
				ď: "d",
				đ: "d",
				Ē: "E",
				Ĕ: "E",
				Ė: "E",
				Ę: "E",
				Ě: "E",
				ē: "e",
				ĕ: "e",
				ė: "e",
				ę: "e",
				ě: "e",
				Ĝ: "G",
				Ğ: "G",
				Ġ: "G",
				Ģ: "G",
				ĝ: "g",
				ğ: "g",
				ġ: "g",
				ģ: "g",
				Ĥ: "H",
				Ħ: "H",
				ĥ: "h",
				ħ: "h",
				Ĩ: "I",
				Ī: "I",
				Ĭ: "I",
				Į: "I",
				İ: "I",
				ĩ: "i",
				ī: "i",
				ĭ: "i",
				į: "i",
				ı: "i",
				Ĵ: "J",
				ĵ: "j",
				Ķ: "K",
				ķ: "k",
				ĸ: "k",
				Ĺ: "L",
				Ļ: "L",
				Ľ: "L",
				Ŀ: "L",
				Ł: "L",
				ĺ: "l",
				ļ: "l",
				ľ: "l",
				ŀ: "l",
				ł: "l",
				Ń: "N",
				Ņ: "N",
				Ň: "N",
				Ŋ: "N",
				ń: "n",
				ņ: "n",
				ň: "n",
				ŋ: "n",
				Ō: "O",
				Ŏ: "O",
				Ő: "O",
				ō: "o",
				ŏ: "o",
				ő: "o",
				Ŕ: "R",
				Ŗ: "R",
				Ř: "R",
				ŕ: "r",
				ŗ: "r",
				ř: "r",
				Ś: "S",
				Ŝ: "S",
				Ş: "S",
				Š: "S",
				ś: "s",
				ŝ: "s",
				ş: "s",
				š: "s",
				Ţ: "T",
				Ť: "T",
				Ŧ: "T",
				ţ: "t",
				ť: "t",
				ŧ: "t",
				Ũ: "U",
				Ū: "U",
				Ŭ: "U",
				Ů: "U",
				Ű: "U",
				Ų: "U",
				ũ: "u",
				ū: "u",
				ŭ: "u",
				ů: "u",
				ű: "u",
				ų: "u",
				Ŵ: "W",
				ŵ: "w",
				Ŷ: "Y",
				ŷ: "y",
				Ÿ: "Y",
				Ź: "Z",
				Ż: "Z",
				Ž: "Z",
				ź: "z",
				ż: "z",
				ž: "z",
				Ĳ: "IJ",
				ĳ: "ij",
				Œ: "Oe",
				œ: "oe",
				ŉ: "'n",
				ſ: "s",
			},
			Aw = {
				"&": "&amp;",
				"<": "&lt;",
				">": "&gt;",
				'"': "&quot;",
				"'": "&#39;",
			},
			Oc = {
				"&amp;": "&",
				"&lt;": "<",
				"&gt;": ">",
				"&quot;": '"',
				"&#39;": "'",
			},
			rv = {
				"\\": "\\",
				"'": "'",
				"\n": "n",
				"\r": "r",
				"\u2028": "u2028",
				"\u2029": "u2029",
			},
			ZN = parseFloat,
			XN = parseInt,
			Cf = typeof global == "object" && global && global.Object === Object && global,
			mw = typeof self == "object" && self && self.Object === Object && self,
			bi = Cf || mw || Function("return this")(),
			nv = typeof um == "object" && um && !um.nodeType && um,
			td = nv && typeof Uv == "object" && Uv && !Uv.nodeType && Uv,
			yw = td && td.exports === nv,
			iv = yw && Cf.process,
			cs = (function () {
				try {
					var J = td && td.require && td.require("util").types
					return J || (iv && iv.binding && iv.binding("util"))
				} catch {}
			})(),
			qc = cs && cs.isArrayBuffer,
			Cw = cs && cs.isDate,
			sv = cs && cs.isMap,
			hg = cs && cs.isRegExp,
			vn = cs && cs.isSet,
			ov = cs && cs.isTypedArray
		function us(J, le, ie) {
			switch (ie.length) {
				case 0:
					return J.call(le)
				case 1:
					return J.call(le, ie[0])
				case 2:
					return J.call(le, ie[0], ie[1])
				case 3:
					return J.call(le, ie[0], ie[1], ie[2])
			}
			return J.apply(le, ie)
		}
		function it(J, le, ie, Oe) {
			for (var Tt = -1, Ur = J == null ? 0 : J.length; ++Tt < Ur; ) {
				var Ni = J[Tt]
				le(Oe, Ni, ie(Ni), J)
			}
			return Oe
		}
		function ds(J, le) {
			for (var ie = -1, Oe = J == null ? 0 : J.length; ++ie < Oe && le(J[ie], ie, J) !== !1; );
			return J
		}
		function xo(J, le) {
			for (var ie = J == null ? 0 : J.length; ie-- && le(J[ie], ie, J) !== !1; );
			return J
		}
		function vw(J, le) {
			for (var ie = -1, Oe = J == null ? 0 : J.length; ++ie < Oe; ) if (!le(J[ie], ie, J)) return !1
			return !0
		}
		function qa(J, le) {
			for (var ie = -1, Oe = J == null ? 0 : J.length, Tt = 0, Ur = []; ++ie < Oe; ) {
				var Ni = J[ie]
				le(Ni, ie, J) && (Ur[Tt++] = Ni)
			}
			return Ur
		}
		function rd(J, le) {
			var ie = J == null ? 0 : J.length
			return !!ie && nd(J, le, 0) > -1
		}
		function ql(J, le, ie) {
			for (var Oe = -1, Tt = J == null ? 0 : J.length; ++Oe < Tt; ) if (ie(le, J[Oe])) return !0
			return !1
		}
		function Yr(J, le) {
			for (var ie = -1, Oe = J == null ? 0 : J.length, Tt = Array(Oe); ++ie < Oe; ) Tt[ie] = le(J[ie], ie, J)
			return Tt
		}
		function js(J, le) {
			for (var ie = -1, Oe = le.length, Tt = J.length; ++ie < Oe; ) J[Tt + ie] = le[ie]
			return J
		}
		function sa(J, le, ie, Oe) {
			var Tt = -1,
				Ur = J == null ? 0 : J.length
			for (Oe && Ur && (ie = J[++Tt]); ++Tt < Ur; ) ie = le(ie, J[Tt], Tt, J)
			return ie
		}
		function NA(J, le, ie, Oe) {
			var Tt = J == null ? 0 : J.length
			for (Oe && Tt && (ie = J[--Tt]); Tt--; ) ie = le(ie, J[Tt], Tt, J)
			return ie
		}
		function gg(J, le) {
			for (var ie = -1, Oe = J == null ? 0 : J.length; ++ie < Oe; ) if (le(J[ie], ie, J)) return !0
			return !1
		}
		var Ew = te("length")
		function av(J) {
			return J.split("")
		}
		function e2(J) {
			return J.match(Lc) || []
		}
		function bw(J, le, ie) {
			var Oe
			return (
				ie(J, function (Tt, Ur, Ni) {
					if (le(Tt, Ur, Ni)) return (Oe = Ur), !1
				}),
				Oe
			)
		}
		function PA(J, le, ie, Oe) {
			for (var Tt = J.length, Ur = ie + (Oe ? 1 : -1); Oe ? Ur-- : ++Ur < Tt; ) if (le(J[Ur], Ur, J)) return Ur
			return -1
		}
		function nd(J, le, ie) {
			return le === le ? qwe(J, le, ie) : PA(J, I, ie)
		}
		function _(J, le, ie, Oe) {
			for (var Tt = ie - 1, Ur = J.length; ++Tt < Ur; ) if (Oe(J[Tt], le)) return Tt
			return -1
		}
		function I(J) {
			return J !== J
		}
		function L(J, le) {
			var ie = J == null ? 0 : J.length
			return ie ? qt(J, le) / ie : Ze
		}
		function te(J) {
			return function (le) {
				return le == null ? e : le[J]
			}
		}
		function oe(J) {
			return function (le) {
				return J == null ? e : J[le]
			}
		}
		function Be(J, le, ie, Oe, Tt) {
			return (
				Tt(J, function (Ur, Ni, cn) {
					ie = Oe ? ((Oe = !1), Ur) : le(ie, Ur, Ni, cn)
				}),
				ie
			)
		}
		function st(J, le) {
			var ie = J.length
			for (J.sort(le); ie--; ) J[ie] = J[ie].value
			return J
		}
		function qt(J, le) {
			for (var ie, Oe = -1, Tt = J.length; ++Oe < Tt; ) {
				var Ur = le(J[Oe])
				Ur !== e && (ie = ie === e ? Ur : ie + Ur)
			}
			return ie
		}
		function ln(J, le) {
			for (var ie = -1, Oe = Array(J); ++ie < J; ) Oe[ie] = le(ie)
			return Oe
		}
		function Qi(J, le) {
			return Yr(le, function (ie) {
				return [ie, J[ie]]
			})
		}
		function Zs(J) {
			return J && J.slice(0, x6(J) + 1).replace(YC, "")
		}
		function En(J) {
			return function (le) {
				return J(le)
			}
		}
		function Vl(J, le) {
			return Yr(le, function (ie) {
				return J[ie]
			})
		}
		function _o(J, le) {
			return J.has(le)
		}
		function vf(J, le) {
			for (var ie = -1, Oe = J.length; ++ie < Oe && nd(le, J[ie], 0) > -1; );
			return ie
		}
		function xw(J, le) {
			for (var ie = J.length; ie-- && nd(le, J[ie], 0) > -1; );
			return ie
		}
		function Mwe(J, le) {
			for (var ie = J.length, Oe = 0; ie--; ) J[ie] === le && ++Oe
			return Oe
		}
		var Fwe = oe(QA),
			Qwe = oe(Aw)
		function Nwe(J) {
			return "\\" + rv[J]
		}
		function Pwe(J, le) {
			return J == null ? e : J[le]
		}
		function LA(J) {
			return gw.test(J)
		}
		function Lwe(J) {
			return pw.test(J)
		}
		function Uwe(J) {
			for (var le, ie = []; !(le = J.next()).done; ) ie.push(le.value)
			return ie
		}
		function t2(J) {
			var le = -1,
				ie = Array(J.size)
			return (
				J.forEach(function (Oe, Tt) {
					ie[++le] = [Tt, Oe]
				}),
				ie
			)
		}
		function b6(J, le) {
			return function (ie) {
				return J(le(ie))
			}
		}
		function Ef(J, le) {
			for (var ie = -1, Oe = J.length, Tt = 0, Ur = []; ++ie < Oe; ) {
				var Ni = J[ie]
				;(Ni === le || Ni === l) && ((J[ie] = l), (Ur[Tt++] = ie))
			}
			return Ur
		}
		function _w(J) {
			var le = -1,
				ie = Array(J.size)
			return (
				J.forEach(function (Oe) {
					ie[++le] = Oe
				}),
				ie
			)
		}
		function Owe(J) {
			var le = -1,
				ie = Array(J.size)
			return (
				J.forEach(function (Oe) {
					ie[++le] = [Oe, Oe]
				}),
				ie
			)
		}
		function qwe(J, le, ie) {
			for (var Oe = ie - 1, Tt = J.length; ++Oe < Tt; ) if (J[Oe] === le) return Oe
			return -1
		}
		function Vwe(J, le, ie) {
			for (var Oe = ie + 1; Oe--; ) if (J[Oe] === le) return Oe
			return Oe
		}
		function UA(J) {
			return LA(J) ? Wwe(J) : Ew(J)
		}
		function Hl(J) {
			return LA(J) ? Gwe(J) : av(J)
		}
		function x6(J) {
			for (var le = J.length; le-- && QN.test(J.charAt(le)); );
			return le
		}
		var Hwe = oe(Oc)
		function Wwe(J) {
			for (var le = (tv.lastIndex = 0); tv.test(J); ) ++le
			return le
		}
		function Gwe(J) {
			return J.match(tv) || []
		}
		function $we(J) {
			return J.match(hw) || []
		}
		var Ywe = function J(le) {
				le = le == null ? bi : bf.defaults(bi.Object(), le, bf.pick(bi, zN))
				var ie = le.Array,
					Oe = le.Date,
					Tt = le.Error,
					Ur = le.Function,
					Ni = le.Math,
					cn = le.Object,
					r2 = le.RegExp,
					Kwe = le.String,
					Va = le.TypeError,
					ww = ie.prototype,
					Jwe = Ur.prototype,
					OA = cn.prototype,
					Iw = le["__core-js_shared__"],
					Sw = Jwe.toString,
					tn = OA.hasOwnProperty,
					zwe = 0,
					_6 = (function () {
						var d = /[^.]+$/.exec((Iw && Iw.keys && Iw.keys.IE_PROTO) || "")
						return d ? "Symbol(src)_1." + d : ""
					})(),
					Bw = OA.toString,
					jwe = Sw.call(cn),
					Zwe = bi._,
					Xwe = r2(
						"^" +
							Sw.call(tn)
								.replace(Fi, "\\$&")
								.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") +
							"$",
					),
					Dw = yw ? le.Buffer : e,
					xf = le.Symbol,
					Tw = le.Uint8Array,
					w6 = Dw ? Dw.allocUnsafe : e,
					Rw = b6(cn.getPrototypeOf, cn),
					I6 = cn.create,
					S6 = OA.propertyIsEnumerable,
					kw = ww.splice,
					B6 = xf ? xf.isConcatSpreadable : e,
					lv = xf ? xf.iterator : e,
					pg = xf ? xf.toStringTag : e,
					Mw = (function () {
						try {
							var d = vg(cn, "defineProperty")
							return d({}, "", {}), d
						} catch {}
					})(),
					eIe = le.clearTimeout !== bi.clearTimeout && le.clearTimeout,
					tIe = Oe && Oe.now !== bi.Date.now && Oe.now,
					rIe = le.setTimeout !== bi.setTimeout && le.setTimeout,
					Fw = Ni.ceil,
					Qw = Ni.floor,
					n2 = cn.getOwnPropertySymbols,
					nIe = Dw ? Dw.isBuffer : e,
					D6 = le.isFinite,
					iIe = ww.join,
					sIe = b6(cn.keys, cn),
					Pi = Ni.max,
					Rs = Ni.min,
					oIe = Oe.now,
					aIe = le.parseInt,
					T6 = Ni.random,
					lIe = ww.reverse,
					i2 = vg(le, "DataView"),
					cv = vg(le, "Map"),
					s2 = vg(le, "Promise"),
					qA = vg(le, "Set"),
					uv = vg(le, "WeakMap"),
					dv = vg(cn, "create"),
					Nw = uv && new uv(),
					VA = {},
					cIe = Eg(i2),
					uIe = Eg(cv),
					dIe = Eg(s2),
					fIe = Eg(qA),
					hIe = Eg(uv),
					Pw = xf ? xf.prototype : e,
					fv = Pw ? Pw.valueOf : e,
					R6 = Pw ? Pw.toString : e
				function F(d) {
					if (jn(d) && !Rt(d) && !(d instanceof ur)) {
						if (d instanceof Ha) return d
						if (tn.call(d, "__wrapped__")) return k9(d)
					}
					return new Ha(d)
				}
				var HA = (function () {
					function d() {}
					return function (h) {
						if (!Un(h)) return {}
						if (I6) return I6(h)
						d.prototype = h
						var A = new d()
						return (d.prototype = e), A
					}
				})()
				function Lw() {}
				function Ha(d, h) {
					;(this.__wrapped__ = d),
						(this.__actions__ = []),
						(this.__chain__ = !!h),
						(this.__index__ = 0),
						(this.__values__ = e)
				}
				;(F.templateSettings = {
					escape: J_,
					evaluate: IA,
					interpolate: Af,
					variable: "",
					imports: { _: F },
				}),
					(F.prototype = Lw.prototype),
					(F.prototype.constructor = F),
					(Ha.prototype = HA(Lw.prototype)),
					(Ha.prototype.constructor = Ha)
				function ur(d) {
					;(this.__wrapped__ = d),
						(this.__actions__ = []),
						(this.__dir__ = 1),
						(this.__filtered__ = !1),
						(this.__iteratees__ = []),
						(this.__takeCount__ = It),
						(this.__views__ = [])
				}
				function gIe() {
					var d = new ur(this.__wrapped__)
					return (
						(d.__actions__ = wo(this.__actions__)),
						(d.__dir__ = this.__dir__),
						(d.__filtered__ = this.__filtered__),
						(d.__iteratees__ = wo(this.__iteratees__)),
						(d.__takeCount__ = this.__takeCount__),
						(d.__views__ = wo(this.__views__)),
						d
					)
				}
				function pIe() {
					if (this.__filtered__) {
						var d = new ur(this)
						;(d.__dir__ = -1), (d.__filtered__ = !0)
					} else (d = this.clone()), (d.__dir__ *= -1)
					return d
				}
				function AIe() {
					var d = this.__wrapped__.value(),
						h = this.__dir__,
						A = Rt(d),
						E = h < 0,
						S = A ? d.length : 0,
						P = BSe(0, S, this.__views__),
						U = P.start,
						H = P.end,
						Z = H - U,
						ce = E ? H : U - 1,
						ue = this.__iteratees__,
						Ae = ue.length,
						Te = 0,
						Ge = Rs(Z, this.__takeCount__)
					if (!A || (!E && S == Z && Ge == Z)) return t9(d, this.__actions__)
					var dt = []
					e: for (; Z-- && Te < Ge; ) {
						ce += h
						for (var Gt = -1, ft = d[ce]; ++Gt < Ae; ) {
							var nr = ue[Gt],
								yr = nr.iteratee,
								la = nr.type,
								to = yr(ft)
							if (la == Qe) ft = to
							else if (!to) {
								if (la == me) continue e
								break e
							}
						}
						dt[Te++] = ft
					}
					return dt
				}
				;(ur.prototype = HA(Lw.prototype)), (ur.prototype.constructor = ur)
				function Ag(d) {
					var h = -1,
						A = d == null ? 0 : d.length
					for (this.clear(); ++h < A; ) {
						var E = d[h]
						this.set(E[0], E[1])
					}
				}
				function mIe() {
					;(this.__data__ = dv ? dv(null) : {}), (this.size = 0)
				}
				function yIe(d) {
					var h = this.has(d) && delete this.__data__[d]
					return (this.size -= h ? 1 : 0), h
				}
				function CIe(d) {
					var h = this.__data__
					if (dv) {
						var A = h[d]
						return A === o ? e : A
					}
					return tn.call(h, d) ? h[d] : e
				}
				function vIe(d) {
					var h = this.__data__
					return dv ? h[d] !== e : tn.call(h, d)
				}
				function EIe(d, h) {
					var A = this.__data__
					return (this.size += this.has(d) ? 0 : 1), (A[d] = dv && h === e ? o : h), this
				}
				;(Ag.prototype.clear = mIe),
					(Ag.prototype.delete = yIe),
					(Ag.prototype.get = CIe),
					(Ag.prototype.has = vIe),
					(Ag.prototype.set = EIe)
				function id(d) {
					var h = -1,
						A = d == null ? 0 : d.length
					for (this.clear(); ++h < A; ) {
						var E = d[h]
						this.set(E[0], E[1])
					}
				}
				function bIe() {
					;(this.__data__ = []), (this.size = 0)
				}
				function xIe(d) {
					var h = this.__data__,
						A = Uw(h, d)
					if (A < 0) return !1
					var E = h.length - 1
					return A == E ? h.pop() : kw.call(h, A, 1), --this.size, !0
				}
				function _Ie(d) {
					var h = this.__data__,
						A = Uw(h, d)
					return A < 0 ? e : h[A][1]
				}
				function wIe(d) {
					return Uw(this.__data__, d) > -1
				}
				function IIe(d, h) {
					var A = this.__data__,
						E = Uw(A, d)
					return E < 0 ? (++this.size, A.push([d, h])) : (A[E][1] = h), this
				}
				;(id.prototype.clear = bIe),
					(id.prototype.delete = xIe),
					(id.prototype.get = _Ie),
					(id.prototype.has = wIe),
					(id.prototype.set = IIe)
				function sd(d) {
					var h = -1,
						A = d == null ? 0 : d.length
					for (this.clear(); ++h < A; ) {
						var E = d[h]
						this.set(E[0], E[1])
					}
				}
				function SIe() {
					;(this.size = 0),
						(this.__data__ = {
							hash: new Ag(),
							map: new (cv || id)(),
							string: new Ag(),
						})
				}
				function BIe(d) {
					var h = jw(this, d).delete(d)
					return (this.size -= h ? 1 : 0), h
				}
				function DIe(d) {
					return jw(this, d).get(d)
				}
				function TIe(d) {
					return jw(this, d).has(d)
				}
				function RIe(d, h) {
					var A = jw(this, d),
						E = A.size
					return A.set(d, h), (this.size += A.size == E ? 0 : 1), this
				}
				;(sd.prototype.clear = SIe),
					(sd.prototype.delete = BIe),
					(sd.prototype.get = DIe),
					(sd.prototype.has = TIe),
					(sd.prototype.set = RIe)
				function mg(d) {
					var h = -1,
						A = d == null ? 0 : d.length
					for (this.__data__ = new sd(); ++h < A; ) this.add(d[h])
				}
				function kIe(d) {
					return this.__data__.set(d, o), this
				}
				function MIe(d) {
					return this.__data__.has(d)
				}
				;(mg.prototype.add = mg.prototype.push = kIe), (mg.prototype.has = MIe)
				function Wl(d) {
					var h = (this.__data__ = new id(d))
					this.size = h.size
				}
				function FIe() {
					;(this.__data__ = new id()), (this.size = 0)
				}
				function QIe(d) {
					var h = this.__data__,
						A = h.delete(d)
					return (this.size = h.size), A
				}
				function NIe(d) {
					return this.__data__.get(d)
				}
				function PIe(d) {
					return this.__data__.has(d)
				}
				function LIe(d, h) {
					var A = this.__data__
					if (A instanceof id) {
						var E = A.__data__
						if (!cv || E.length < r - 1) return E.push([d, h]), (this.size = ++A.size), this
						A = this.__data__ = new sd(E)
					}
					return A.set(d, h), (this.size = A.size), this
				}
				;(Wl.prototype.clear = FIe),
					(Wl.prototype.delete = QIe),
					(Wl.prototype.get = NIe),
					(Wl.prototype.has = PIe),
					(Wl.prototype.set = LIe)
				function k6(d, h) {
					var A = Rt(d),
						E = !A && bg(d),
						S = !A && !E && Bf(d),
						P = !A && !E && !S && YA(d),
						U = A || E || S || P,
						H = U ? ln(d.length, Kwe) : [],
						Z = H.length
					for (var ce in d)
						(h || tn.call(d, ce)) &&
							!(
								U &&
								(ce == "length" ||
									(S && (ce == "offset" || ce == "parent")) ||
									(P && (ce == "buffer" || ce == "byteLength" || ce == "byteOffset")) ||
									cd(ce, Z))
							) &&
							H.push(ce)
					return H
				}
				function M6(d) {
					var h = d.length
					return h ? d[A2(0, h - 1)] : e
				}
				function UIe(d, h) {
					return Zw(wo(d), yg(h, 0, d.length))
				}
				function OIe(d) {
					return Zw(wo(d))
				}
				function o2(d, h, A) {
					;((A !== e && !Gl(d[h], A)) || (A === e && !(h in d))) && od(d, h, A)
				}
				function hv(d, h, A) {
					var E = d[h]
					;(!(tn.call(d, h) && Gl(E, A)) || (A === e && !(h in d))) && od(d, h, A)
				}
				function Uw(d, h) {
					for (var A = d.length; A--; ) if (Gl(d[A][0], h)) return A
					return -1
				}
				function qIe(d, h, A, E) {
					return (
						_f(d, function (S, P, U) {
							h(E, S, A(S), U)
						}),
						E
					)
				}
				function F6(d, h) {
					return d && Hc(h, $i(h), d)
				}
				function VIe(d, h) {
					return d && Hc(h, So(h), d)
				}
				function od(d, h, A) {
					h == "__proto__" && Mw
						? Mw(d, h, {
								configurable: !0,
								enumerable: !0,
								value: A,
								writable: !0,
							})
						: (d[h] = A)
				}
				function a2(d, h) {
					for (var A = -1, E = h.length, S = ie(E), P = d == null; ++A < E; ) S[A] = P ? e : q2(d, h[A])
					return S
				}
				function yg(d, h, A) {
					return d === d && (A !== e && (d = d <= A ? d : A), h !== e && (d = d >= h ? d : h)), d
				}
				function Wa(d, h, A, E, S, P) {
					var U,
						H = h & c,
						Z = h & u,
						ce = h & f
					if ((A && (U = S ? A(d, E, S, P) : A(d)), U !== e)) return U
					if (!Un(d)) return d
					var ue = Rt(d)
					if (ue) {
						if (((U = TSe(d)), !H)) return wo(d, U)
					} else {
						var Ae = ks(d),
							Te = Ae == Pr || Ae == cr
						if (Bf(d)) return i9(d, H)
						if (Ae == Ee || Ae == Ar || (Te && !S)) {
							if (((U = Z || Te ? {} : x9(d)), !H)) return Z ? CSe(d, VIe(U, d)) : ySe(d, F6(U, d))
						} else {
							if (!Lr[Ae]) return S ? d : {}
							U = RSe(d, Ae, H)
						}
					}
					P || (P = new Wl())
					var Ge = P.get(d)
					if (Ge) return Ge
					P.set(d, U),
						Z9(d)
							? d.forEach(function (ft) {
									U.add(Wa(ft, h, A, ft, d, P))
								})
							: z9(d) &&
								d.forEach(function (ft, nr) {
									U.set(nr, Wa(ft, h, A, nr, d, P))
								})
					var dt = ce ? (Z ? S2 : I2) : Z ? So : $i,
						Gt = ue ? e : dt(d)
					return (
						ds(Gt || d, function (ft, nr) {
							Gt && ((nr = ft), (ft = d[nr])), hv(U, nr, Wa(ft, h, A, nr, d, P))
						}),
						U
					)
				}
				function HIe(d) {
					var h = $i(d)
					return function (A) {
						return Q6(A, d, h)
					}
				}
				function Q6(d, h, A) {
					var E = A.length
					if (d == null) return !E
					for (d = cn(d); E--; ) {
						var S = A[E],
							P = h[S],
							U = d[S]
						if ((U === e && !(S in d)) || !P(U)) return !1
					}
					return !0
				}
				function N6(d, h, A) {
					if (typeof d != "function") throw new Va(i)
					return vv(function () {
						d.apply(e, A)
					}, h)
				}
				function gv(d, h, A, E) {
					var S = -1,
						P = rd,
						U = !0,
						H = d.length,
						Z = [],
						ce = h.length
					if (!H) return Z
					A && (h = Yr(h, En(A))),
						E ? ((P = ql), (U = !1)) : h.length >= r && ((P = _o), (U = !1), (h = new mg(h)))
					e: for (; ++S < H; ) {
						var ue = d[S],
							Ae = A == null ? ue : A(ue)
						if (((ue = E || ue !== 0 ? ue : 0), U && Ae === Ae)) {
							for (var Te = ce; Te--; ) if (h[Te] === Ae) continue e
							Z.push(ue)
						} else P(h, Ae, E) || Z.push(ue)
					}
					return Z
				}
				var _f = c9(Vc),
					P6 = c9(c2, !0)
				function WIe(d, h) {
					var A = !0
					return (
						_f(d, function (E, S, P) {
							return (A = !!h(E, S, P)), A
						}),
						A
					)
				}
				function Ow(d, h, A) {
					for (var E = -1, S = d.length; ++E < S; ) {
						var P = d[E],
							U = h(P)
						if (U != null && (H === e ? U === U && !aa(U) : A(U, H)))
							var H = U,
								Z = P
					}
					return Z
				}
				function GIe(d, h, A, E) {
					var S = d.length
					for (
						A = Vt(A),
							A < 0 && (A = -A > S ? 0 : S + A),
							E = E === e || E > S ? S : Vt(E),
							E < 0 && (E += S),
							E = A > E ? 0 : e$(E);
						A < E;

					)
						d[A++] = h
					return d
				}
				function L6(d, h) {
					var A = []
					return (
						_f(d, function (E, S, P) {
							h(E, S, P) && A.push(E)
						}),
						A
					)
				}
				function fs(d, h, A, E, S) {
					var P = -1,
						U = d.length
					for (A || (A = MSe), S || (S = []); ++P < U; ) {
						var H = d[P]
						h > 0 && A(H) ? (h > 1 ? fs(H, h - 1, A, E, S) : js(S, H)) : E || (S[S.length] = H)
					}
					return S
				}
				var l2 = u9(),
					U6 = u9(!0)
				function Vc(d, h) {
					return d && l2(d, h, $i)
				}
				function c2(d, h) {
					return d && U6(d, h, $i)
				}
				function qw(d, h) {
					return qa(h, function (A) {
						return ud(d[A])
					})
				}
				function Cg(d, h) {
					h = If(h, d)
					for (var A = 0, E = h.length; d != null && A < E; ) d = d[Wc(h[A++])]
					return A && A == E ? d : e
				}
				function O6(d, h, A) {
					var E = h(d)
					return Rt(d) ? E : js(E, A(d))
				}
				function Xs(d) {
					return d == null ? (d === e ? Pc : fe) : pg && pg in cn(d) ? SSe(d) : OSe(d)
				}
				function u2(d, h) {
					return d > h
				}
				function $Ie(d, h) {
					return d != null && tn.call(d, h)
				}
				function YIe(d, h) {
					return d != null && h in cn(d)
				}
				function KIe(d, h, A) {
					return d >= Rs(h, A) && d < Pi(h, A)
				}
				function d2(d, h, A) {
					for (
						var E = A ? ql : rd, S = d[0].length, P = d.length, U = P, H = ie(P), Z = 1 / 0, ce = [];
						U--;

					) {
						var ue = d[U]
						U && h && (ue = Yr(ue, En(h))),
							(Z = Rs(ue.length, Z)),
							(H[U] = !A && (h || (S >= 120 && ue.length >= 120)) ? new mg(U && ue) : e)
					}
					ue = d[0]
					var Ae = -1,
						Te = H[0]
					e: for (; ++Ae < S && ce.length < Z; ) {
						var Ge = ue[Ae],
							dt = h ? h(Ge) : Ge
						if (((Ge = A || Ge !== 0 ? Ge : 0), !(Te ? _o(Te, dt) : E(ce, dt, A)))) {
							for (U = P; --U; ) {
								var Gt = H[U]
								if (!(Gt ? _o(Gt, dt) : E(d[U], dt, A))) continue e
							}
							Te && Te.push(dt), ce.push(Ge)
						}
					}
					return ce
				}
				function JIe(d, h, A, E) {
					return (
						Vc(d, function (S, P, U) {
							h(E, A(S), P, U)
						}),
						E
					)
				}
				function pv(d, h, A) {
					;(h = If(h, d)), (d = S9(d, h))
					var E = d == null ? d : d[Wc($a(h))]
					return E == null ? e : us(E, d, A)
				}
				function q6(d) {
					return jn(d) && Xs(d) == Ar
				}
				function zIe(d) {
					return jn(d) && Xs(d) == Gi
				}
				function jIe(d) {
					return jn(d) && Xs(d) == Nr
				}
				function Av(d, h, A, E, S) {
					return d === h
						? !0
						: d == null || h == null || (!jn(d) && !jn(h))
							? d !== d && h !== h
							: ZIe(d, h, A, E, Av, S)
				}
				function ZIe(d, h, A, E, S, P) {
					var U = Rt(d),
						H = Rt(h),
						Z = U ? de : ks(d),
						ce = H ? de : ks(h)
					;(Z = Z == Ar ? Ee : Z), (ce = ce == Ar ? Ee : ce)
					var ue = Z == Ee,
						Ae = ce == Ee,
						Te = Z == ce
					if (Te && Bf(d)) {
						if (!Bf(h)) return !1
						;(U = !0), (ue = !1)
					}
					if (Te && !ue)
						return P || (P = new Wl()), U || YA(d) ? v9(d, h, A, E, S, P) : wSe(d, h, Z, A, E, S, P)
					if (!(A & p)) {
						var Ge = ue && tn.call(d, "__wrapped__"),
							dt = Ae && tn.call(h, "__wrapped__")
						if (Ge || dt) {
							var Gt = Ge ? d.value() : d,
								ft = dt ? h.value() : h
							return P || (P = new Wl()), S(Gt, ft, A, E, P)
						}
					}
					return Te ? (P || (P = new Wl()), ISe(d, h, A, E, S, P)) : !1
				}
				function XIe(d) {
					return jn(d) && ks(d) == be
				}
				function f2(d, h, A, E) {
					var S = A.length,
						P = S,
						U = !E
					if (d == null) return !P
					for (d = cn(d); S--; ) {
						var H = A[S]
						if (U && H[2] ? H[1] !== d[H[0]] : !(H[0] in d)) return !1
					}
					for (; ++S < P; ) {
						H = A[S]
						var Z = H[0],
							ce = d[Z],
							ue = H[1]
						if (U && H[2]) {
							if (ce === e && !(Z in d)) return !1
						} else {
							var Ae = new Wl()
							if (E) var Te = E(ce, ue, Z, d, h, Ae)
							if (!(Te === e ? Av(ue, ce, p | g, E, Ae) : Te)) return !1
						}
					}
					return !0
				}
				function V6(d) {
					if (!Un(d) || QSe(d)) return !1
					var h = ud(d) ? Xwe : PN
					return h.test(Eg(d))
				}
				function eSe(d) {
					return jn(d) && Xs(d) == yn
				}
				function tSe(d) {
					return jn(d) && ks(d) == Ei
				}
				function rSe(d) {
					return jn(d) && iI(d.length) && !!an[Xs(d)]
				}
				function H6(d) {
					return typeof d == "function"
						? d
						: d == null
							? Bo
							: typeof d == "object"
								? Rt(d)
									? $6(d[0], d[1])
									: G6(d)
								: d$(d)
				}
				function h2(d) {
					if (!Cv(d)) return sIe(d)
					var h = []
					for (var A in cn(d)) tn.call(d, A) && A != "constructor" && h.push(A)
					return h
				}
				function nSe(d) {
					if (!Un(d)) return USe(d)
					var h = Cv(d),
						A = []
					for (var E in d) (E == "constructor" && (h || !tn.call(d, E))) || A.push(E)
					return A
				}
				function g2(d, h) {
					return d < h
				}
				function W6(d, h) {
					var A = -1,
						E = Io(d) ? ie(d.length) : []
					return (
						_f(d, function (S, P, U) {
							E[++A] = h(S, P, U)
						}),
						E
					)
				}
				function G6(d) {
					var h = D2(d)
					return h.length == 1 && h[0][2]
						? w9(h[0][0], h[0][1])
						: function (A) {
								return A === d || f2(A, d, h)
							}
				}
				function $6(d, h) {
					return R2(d) && _9(h)
						? w9(Wc(d), h)
						: function (A) {
								var E = q2(A, d)
								return E === e && E === h ? V2(A, d) : Av(h, E, p | g)
							}
				}
				function Vw(d, h, A, E, S) {
					d !== h &&
						l2(
							h,
							function (P, U) {
								if ((S || (S = new Wl()), Un(P))) iSe(d, h, U, A, Vw, E, S)
								else {
									var H = E ? E(M2(d, U), P, U + "", d, h, S) : e
									H === e && (H = P), o2(d, U, H)
								}
							},
							So,
						)
				}
				function iSe(d, h, A, E, S, P, U) {
					var H = M2(d, A),
						Z = M2(h, A),
						ce = U.get(Z)
					if (ce) {
						o2(d, A, ce)
						return
					}
					var ue = P ? P(H, Z, A + "", d, h, U) : e,
						Ae = ue === e
					if (Ae) {
						var Te = Rt(Z),
							Ge = !Te && Bf(Z),
							dt = !Te && !Ge && YA(Z)
						;(ue = Z),
							Te || Ge || dt
								? Rt(H)
									? (ue = H)
									: di(H)
										? (ue = wo(H))
										: Ge
											? ((Ae = !1), (ue = i9(Z, !0)))
											: dt
												? ((Ae = !1), (ue = s9(Z, !0)))
												: (ue = [])
								: Ev(Z) || bg(Z)
									? ((ue = H), bg(H) ? (ue = t$(H)) : (!Un(H) || ud(H)) && (ue = x9(Z)))
									: (Ae = !1)
					}
					Ae && (U.set(Z, ue), S(ue, Z, E, P, U), U.delete(Z)), o2(d, A, ue)
				}
				function Y6(d, h) {
					var A = d.length
					if (A) return (h += h < 0 ? A : 0), cd(h, A) ? d[h] : e
				}
				function K6(d, h, A) {
					h.length
						? (h = Yr(h, function (P) {
								return Rt(P)
									? function (U) {
											return Cg(U, P.length === 1 ? P[0] : P)
										}
									: P
							}))
						: (h = [Bo])
					var E = -1
					h = Yr(h, En(ct()))
					var S = W6(d, function (P, U, H) {
						var Z = Yr(h, function (ce) {
							return ce(P)
						})
						return { criteria: Z, index: ++E, value: P }
					})
					return st(S, function (P, U) {
						return mSe(P, U, A)
					})
				}
				function sSe(d, h) {
					return J6(d, h, function (A, E) {
						return V2(d, E)
					})
				}
				function J6(d, h, A) {
					for (var E = -1, S = h.length, P = {}; ++E < S; ) {
						var U = h[E],
							H = Cg(d, U)
						A(H, U) && mv(P, If(U, d), H)
					}
					return P
				}
				function oSe(d) {
					return function (h) {
						return Cg(h, d)
					}
				}
				function p2(d, h, A, E) {
					var S = E ? _ : nd,
						P = -1,
						U = h.length,
						H = d
					for (d === h && (h = wo(h)), A && (H = Yr(d, En(A))); ++P < U; )
						for (var Z = 0, ce = h[P], ue = A ? A(ce) : ce; (Z = S(H, ue, Z, E)) > -1; )
							H !== d && kw.call(H, Z, 1), kw.call(d, Z, 1)
					return d
				}
				function z6(d, h) {
					for (var A = d ? h.length : 0, E = A - 1; A--; ) {
						var S = h[A]
						if (A == E || S !== P) {
							var P = S
							cd(S) ? kw.call(d, S, 1) : C2(d, S)
						}
					}
					return d
				}
				function A2(d, h) {
					return d + Qw(T6() * (h - d + 1))
				}
				function aSe(d, h, A, E) {
					for (var S = -1, P = Pi(Fw((h - d) / (A || 1)), 0), U = ie(P); P--; ) (U[E ? P : ++S] = d), (d += A)
					return U
				}
				function m2(d, h) {
					var A = ""
					if (!d || h < 1 || h > K) return A
					do h % 2 && (A += d), (h = Qw(h / 2)), h && (d += d)
					while (h)
					return A
				}
				function zt(d, h) {
					return F2(I9(d, h, Bo), d + "")
				}
				function lSe(d) {
					return M6(KA(d))
				}
				function cSe(d, h) {
					var A = KA(d)
					return Zw(A, yg(h, 0, A.length))
				}
				function mv(d, h, A, E) {
					if (!Un(d)) return d
					h = If(h, d)
					for (var S = -1, P = h.length, U = P - 1, H = d; H != null && ++S < P; ) {
						var Z = Wc(h[S]),
							ce = A
						if (Z === "__proto__" || Z === "constructor" || Z === "prototype") return d
						if (S != U) {
							var ue = H[Z]
							;(ce = E ? E(ue, Z, H) : e), ce === e && (ce = Un(ue) ? ue : cd(h[S + 1]) ? [] : {})
						}
						hv(H, Z, ce), (H = H[Z])
					}
					return d
				}
				var j6 = Nw
						? function (d, h) {
								return Nw.set(d, h), d
							}
						: Bo,
					uSe = Mw
						? function (d, h) {
								return Mw(d, "toString", {
									configurable: !0,
									enumerable: !1,
									value: W2(h),
									writable: !0,
								})
							}
						: Bo
				function dSe(d) {
					return Zw(KA(d))
				}
				function Ga(d, h, A) {
					var E = -1,
						S = d.length
					h < 0 && (h = -h > S ? 0 : S + h),
						(A = A > S ? S : A),
						A < 0 && (A += S),
						(S = h > A ? 0 : (A - h) >>> 0),
						(h >>>= 0)
					for (var P = ie(S); ++E < S; ) P[E] = d[E + h]
					return P
				}
				function fSe(d, h) {
					var A
					return (
						_f(d, function (E, S, P) {
							return (A = h(E, S, P)), !A
						}),
						!!A
					)
				}
				function Hw(d, h, A) {
					var E = 0,
						S = d == null ? E : d.length
					if (typeof h == "number" && h === h && S <= Et) {
						for (; E < S; ) {
							var P = (E + S) >>> 1,
								U = d[P]
							U !== null && !aa(U) && (A ? U <= h : U < h) ? (E = P + 1) : (S = P)
						}
						return S
					}
					return y2(d, h, Bo, A)
				}
				function y2(d, h, A, E) {
					var S = 0,
						P = d == null ? 0 : d.length
					if (P === 0) return 0
					h = A(h)
					for (var U = h !== h, H = h === null, Z = aa(h), ce = h === e; S < P; ) {
						var ue = Qw((S + P) / 2),
							Ae = A(d[ue]),
							Te = Ae !== e,
							Ge = Ae === null,
							dt = Ae === Ae,
							Gt = aa(Ae)
						if (U) var ft = E || dt
						else
							ce
								? (ft = dt && (E || Te))
								: H
									? (ft = dt && Te && (E || !Ge))
									: Z
										? (ft = dt && Te && !Ge && (E || !Gt))
										: Ge || Gt
											? (ft = !1)
											: (ft = E ? Ae <= h : Ae < h)
						ft ? (S = ue + 1) : (P = ue)
					}
					return Rs(P, Ce)
				}
				function Z6(d, h) {
					for (var A = -1, E = d.length, S = 0, P = []; ++A < E; ) {
						var U = d[A],
							H = h ? h(U) : U
						if (!A || !Gl(H, Z)) {
							var Z = H
							P[S++] = U === 0 ? 0 : U
						}
					}
					return P
				}
				function X6(d) {
					return typeof d == "number" ? d : aa(d) ? Ze : +d
				}
				function oa(d) {
					if (typeof d == "string") return d
					if (Rt(d)) return Yr(d, oa) + ""
					if (aa(d)) return R6 ? R6.call(d) : ""
					var h = d + ""
					return h == "0" && 1 / d == -re ? "-0" : h
				}
				function wf(d, h, A) {
					var E = -1,
						S = rd,
						P = d.length,
						U = !0,
						H = [],
						Z = H
					if (A) (U = !1), (S = ql)
					else if (P >= r) {
						var ce = h ? null : xSe(d)
						if (ce) return _w(ce)
						;(U = !1), (S = _o), (Z = new mg())
					} else Z = h ? [] : H
					e: for (; ++E < P; ) {
						var ue = d[E],
							Ae = h ? h(ue) : ue
						if (((ue = A || ue !== 0 ? ue : 0), U && Ae === Ae)) {
							for (var Te = Z.length; Te--; ) if (Z[Te] === Ae) continue e
							h && Z.push(Ae), H.push(ue)
						} else S(Z, Ae, A) || (Z !== H && Z.push(Ae), H.push(ue))
					}
					return H
				}
				function C2(d, h) {
					return (h = If(h, d)), (d = S9(d, h)), d == null || delete d[Wc($a(h))]
				}
				function e9(d, h, A, E) {
					return mv(d, h, A(Cg(d, h)), E)
				}
				function Ww(d, h, A, E) {
					for (var S = d.length, P = E ? S : -1; (E ? P-- : ++P < S) && h(d[P], P, d); );
					return A ? Ga(d, E ? 0 : P, E ? P + 1 : S) : Ga(d, E ? P + 1 : 0, E ? S : P)
				}
				function t9(d, h) {
					var A = d
					return (
						A instanceof ur && (A = A.value()),
						sa(
							h,
							function (E, S) {
								return S.func.apply(S.thisArg, js([E], S.args))
							},
							A,
						)
					)
				}
				function v2(d, h, A) {
					var E = d.length
					if (E < 2) return E ? wf(d[0]) : []
					for (var S = -1, P = ie(E); ++S < E; )
						for (var U = d[S], H = -1; ++H < E; ) H != S && (P[S] = gv(P[S] || U, d[H], h, A))
					return wf(fs(P, 1), h, A)
				}
				function r9(d, h, A) {
					for (var E = -1, S = d.length, P = h.length, U = {}; ++E < S; ) {
						var H = E < P ? h[E] : e
						A(U, d[E], H)
					}
					return U
				}
				function E2(d) {
					return di(d) ? d : []
				}
				function b2(d) {
					return typeof d == "function" ? d : Bo
				}
				function If(d, h) {
					return Rt(d) ? d : R2(d, h) ? [d] : R9(Kr(d))
				}
				var hSe = zt
				function Sf(d, h, A) {
					var E = d.length
					return (A = A === e ? E : A), !h && A >= E ? d : Ga(d, h, A)
				}
				var n9 =
					eIe ||
					function (d) {
						return bi.clearTimeout(d)
					}
				function i9(d, h) {
					if (h) return d.slice()
					var A = d.length,
						E = w6 ? w6(A) : new d.constructor(A)
					return d.copy(E), E
				}
				function x2(d) {
					var h = new d.constructor(d.byteLength)
					return new Tw(h).set(new Tw(d)), h
				}
				function gSe(d, h) {
					var A = h ? x2(d.buffer) : d.buffer
					return new d.constructor(A, d.byteOffset, d.byteLength)
				}
				function pSe(d) {
					var h = new d.constructor(d.source, z_.exec(d))
					return (h.lastIndex = d.lastIndex), h
				}
				function ASe(d) {
					return fv ? cn(fv.call(d)) : {}
				}
				function s9(d, h) {
					var A = h ? x2(d.buffer) : d.buffer
					return new d.constructor(A, d.byteOffset, d.length)
				}
				function o9(d, h) {
					if (d !== h) {
						var A = d !== e,
							E = d === null,
							S = d === d,
							P = aa(d),
							U = h !== e,
							H = h === null,
							Z = h === h,
							ce = aa(h)
						if (
							(!H && !ce && !P && d > h) ||
							(P && U && Z && !H && !ce) ||
							(E && U && Z) ||
							(!A && Z) ||
							!S
						)
							return 1
						if (
							(!E && !P && !ce && d < h) ||
							(ce && A && S && !E && !P) ||
							(H && A && S) ||
							(!U && S) ||
							!Z
						)
							return -1
					}
					return 0
				}
				function mSe(d, h, A) {
					for (var E = -1, S = d.criteria, P = h.criteria, U = S.length, H = A.length; ++E < U; ) {
						var Z = o9(S[E], P[E])
						if (Z) {
							if (E >= H) return Z
							var ce = A[E]
							return Z * (ce == "desc" ? -1 : 1)
						}
					}
					return d.index - h.index
				}
				function a9(d, h, A, E) {
					for (
						var S = -1,
							P = d.length,
							U = A.length,
							H = -1,
							Z = h.length,
							ce = Pi(P - U, 0),
							ue = ie(Z + ce),
							Ae = !E;
						++H < Z;

					)
						ue[H] = h[H]
					for (; ++S < U; ) (Ae || S < P) && (ue[A[S]] = d[S])
					for (; ce--; ) ue[H++] = d[S++]
					return ue
				}
				function l9(d, h, A, E) {
					for (
						var S = -1,
							P = d.length,
							U = -1,
							H = A.length,
							Z = -1,
							ce = h.length,
							ue = Pi(P - H, 0),
							Ae = ie(ue + ce),
							Te = !E;
						++S < ue;

					)
						Ae[S] = d[S]
					for (var Ge = S; ++Z < ce; ) Ae[Ge + Z] = h[Z]
					for (; ++U < H; ) (Te || S < P) && (Ae[Ge + A[U]] = d[S++])
					return Ae
				}
				function wo(d, h) {
					var A = -1,
						E = d.length
					for (h || (h = ie(E)); ++A < E; ) h[A] = d[A]
					return h
				}
				function Hc(d, h, A, E) {
					var S = !A
					A || (A = {})
					for (var P = -1, U = h.length; ++P < U; ) {
						var H = h[P],
							Z = E ? E(A[H], d[H], H, A, d) : e
						Z === e && (Z = d[H]), S ? od(A, H, Z) : hv(A, H, Z)
					}
					return A
				}
				function ySe(d, h) {
					return Hc(d, T2(d), h)
				}
				function CSe(d, h) {
					return Hc(d, E9(d), h)
				}
				function Gw(d, h) {
					return function (A, E) {
						var S = Rt(A) ? it : qIe,
							P = h ? h() : {}
						return S(A, d, ct(E, 2), P)
					}
				}
				function WA(d) {
					return zt(function (h, A) {
						var E = -1,
							S = A.length,
							P = S > 1 ? A[S - 1] : e,
							U = S > 2 ? A[2] : e
						for (
							P = d.length > 3 && typeof P == "function" ? (S--, P) : e,
								U && eo(A[0], A[1], U) && ((P = S < 3 ? e : P), (S = 1)),
								h = cn(h);
							++E < S;

						) {
							var H = A[E]
							H && d(h, H, E, P)
						}
						return h
					})
				}
				function c9(d, h) {
					return function (A, E) {
						if (A == null) return A
						if (!Io(A)) return d(A, E)
						for (
							var S = A.length, P = h ? S : -1, U = cn(A);
							(h ? P-- : ++P < S) && E(U[P], P, U) !== !1;

						);
						return A
					}
				}
				function u9(d) {
					return function (h, A, E) {
						for (var S = -1, P = cn(h), U = E(h), H = U.length; H--; ) {
							var Z = U[d ? H : ++S]
							if (A(P[Z], Z, P) === !1) break
						}
						return h
					}
				}
				function vSe(d, h, A) {
					var E = h & m,
						S = yv(d)
					function P() {
						var U = this && this !== bi && this instanceof P ? S : d
						return U.apply(E ? A : this, arguments)
					}
					return P
				}
				function d9(d) {
					return function (h) {
						h = Kr(h)
						var A = LA(h) ? Hl(h) : e,
							E = A ? A[0] : h.charAt(0),
							S = A ? Sf(A, 1).join("") : h.slice(1)
						return E[d]() + S
					}
				}
				function GA(d) {
					return function (h) {
						return sa(c$(l$(h).replace(fw, "")), d, "")
					}
				}
				function yv(d) {
					return function () {
						var h = arguments
						switch (h.length) {
							case 0:
								return new d()
							case 1:
								return new d(h[0])
							case 2:
								return new d(h[0], h[1])
							case 3:
								return new d(h[0], h[1], h[2])
							case 4:
								return new d(h[0], h[1], h[2], h[3])
							case 5:
								return new d(h[0], h[1], h[2], h[3], h[4])
							case 6:
								return new d(h[0], h[1], h[2], h[3], h[4], h[5])
							case 7:
								return new d(h[0], h[1], h[2], h[3], h[4], h[5], h[6])
						}
						var A = HA(d.prototype),
							E = d.apply(A, h)
						return Un(E) ? E : A
					}
				}
				function ESe(d, h, A) {
					var E = yv(d)
					function S() {
						for (var P = arguments.length, U = ie(P), H = P, Z = $A(S); H--; ) U[H] = arguments[H]
						var ce = P < 3 && U[0] !== Z && U[P - 1] !== Z ? [] : Ef(U, Z)
						if (((P -= ce.length), P < A)) return A9(d, h, $w, S.placeholder, e, U, ce, e, e, A - P)
						var ue = this && this !== bi && this instanceof S ? E : d
						return us(ue, this, U)
					}
					return S
				}
				function f9(d) {
					return function (h, A, E) {
						var S = cn(h)
						if (!Io(h)) {
							var P = ct(A, 3)
							;(h = $i(h)),
								(A = function (H) {
									return P(S[H], H, S)
								})
						}
						var U = d(h, A, E)
						return U > -1 ? S[P ? h[U] : U] : e
					}
				}
				function h9(d) {
					return ld(function (h) {
						var A = h.length,
							E = A,
							S = Ha.prototype.thru
						for (d && h.reverse(); E--; ) {
							var P = h[E]
							if (typeof P != "function") throw new Va(i)
							if (S && !U && zw(P) == "wrapper") var U = new Ha([], !0)
						}
						for (E = U ? E : A; ++E < A; ) {
							P = h[E]
							var H = zw(P),
								Z = H == "wrapper" ? B2(P) : e
							Z && k2(Z[0]) && Z[1] == (M | v | w | Q) && !Z[4].length && Z[9] == 1
								? (U = U[zw(Z[0])].apply(U, Z[3]))
								: (U = P.length == 1 && k2(P) ? U[H]() : U.thru(P))
						}
						return function () {
							var ce = arguments,
								ue = ce[0]
							if (U && ce.length == 1 && Rt(ue)) return U.plant(ue).value()
							for (var Ae = 0, Te = A ? h[Ae].apply(this, ce) : ue; ++Ae < A; ) Te = h[Ae].call(this, Te)
							return Te
						}
					})
				}
				function $w(d, h, A, E, S, P, U, H, Z, ce) {
					var ue = h & M,
						Ae = h & m,
						Te = h & y,
						Ge = h & (v | b),
						dt = h & O,
						Gt = Te ? e : yv(d)
					function ft() {
						for (var nr = arguments.length, yr = ie(nr), la = nr; la--; ) yr[la] = arguments[la]
						if (Ge)
							var to = $A(ft),
								ca = Mwe(yr, to)
						if ((E && (yr = a9(yr, E, S, Ge)), P && (yr = l9(yr, P, U, Ge)), (nr -= ca), Ge && nr < ce)) {
							var fi = Ef(yr, to)
							return A9(d, h, $w, ft.placeholder, A, yr, fi, H, Z, ce - nr)
						}
						var $l = Ae ? A : this,
							fd = Te ? $l[d] : d
						return (
							(nr = yr.length),
							H ? (yr = qSe(yr, H)) : dt && nr > 1 && yr.reverse(),
							ue && Z < nr && (yr.length = Z),
							this && this !== bi && this instanceof ft && (fd = Gt || yv(fd)),
							fd.apply($l, yr)
						)
					}
					return ft
				}
				function g9(d, h) {
					return function (A, E) {
						return JIe(A, d, h(E), {})
					}
				}
				function Yw(d, h) {
					return function (A, E) {
						var S
						if (A === e && E === e) return h
						if ((A !== e && (S = A), E !== e)) {
							if (S === e) return E
							typeof A == "string" || typeof E == "string"
								? ((A = oa(A)), (E = oa(E)))
								: ((A = X6(A)), (E = X6(E))),
								(S = d(A, E))
						}
						return S
					}
				}
				function _2(d) {
					return ld(function (h) {
						return (
							(h = Yr(h, En(ct()))),
							zt(function (A) {
								var E = this
								return d(h, function (S) {
									return us(S, E, A)
								})
							})
						)
					})
				}
				function Kw(d, h) {
					h = h === e ? " " : oa(h)
					var A = h.length
					if (A < 2) return A ? m2(h, d) : h
					var E = m2(h, Fw(d / UA(h)))
					return LA(h) ? Sf(Hl(E), 0, d).join("") : E.slice(0, d)
				}
				function bSe(d, h, A, E) {
					var S = h & m,
						P = yv(d)
					function U() {
						for (
							var H = -1,
								Z = arguments.length,
								ce = -1,
								ue = E.length,
								Ae = ie(ue + Z),
								Te = this && this !== bi && this instanceof U ? P : d;
							++ce < ue;

						)
							Ae[ce] = E[ce]
						for (; Z--; ) Ae[ce++] = arguments[++H]
						return us(Te, S ? A : this, Ae)
					}
					return U
				}
				function p9(d) {
					return function (h, A, E) {
						return (
							E && typeof E != "number" && eo(h, A, E) && (A = E = e),
							(h = dd(h)),
							A === e ? ((A = h), (h = 0)) : (A = dd(A)),
							(E = E === e ? (h < A ? 1 : -1) : dd(E)),
							aSe(h, A, E, d)
						)
					}
				}
				function Jw(d) {
					return function (h, A) {
						return (typeof h == "string" && typeof A == "string") || ((h = Ya(h)), (A = Ya(A))), d(h, A)
					}
				}
				function A9(d, h, A, E, S, P, U, H, Z, ce) {
					var ue = h & v,
						Ae = ue ? U : e,
						Te = ue ? e : U,
						Ge = ue ? P : e,
						dt = ue ? e : P
					;(h |= ue ? w : B), (h &= ~(ue ? B : w)), h & C || (h &= ~(m | y))
					var Gt = [d, h, S, Ge, Ae, dt, Te, H, Z, ce],
						ft = A.apply(e, Gt)
					return k2(d) && B9(ft, Gt), (ft.placeholder = E), D9(ft, d, h)
				}
				function w2(d) {
					var h = Ni[d]
					return function (A, E) {
						if (((A = Ya(A)), (E = E == null ? 0 : Rs(Vt(E), 292)), E && D6(A))) {
							var S = (Kr(A) + "e").split("e"),
								P = h(S[0] + "e" + (+S[1] + E))
							return (S = (Kr(P) + "e").split("e")), +(S[0] + "e" + (+S[1] - E))
						}
						return h(A)
					}
				}
				var xSe =
					qA && 1 / _w(new qA([, -0]))[1] == re
						? function (d) {
								return new qA(d)
							}
						: Y2
				function m9(d) {
					return function (h) {
						var A = ks(h)
						return A == be ? t2(h) : A == Ei ? Owe(h) : Qi(h, d(h))
					}
				}
				function ad(d, h, A, E, S, P, U, H) {
					var Z = h & y
					if (!Z && typeof d != "function") throw new Va(i)
					var ce = E ? E.length : 0
					if (
						(ce || ((h &= ~(w | B)), (E = S = e)),
						(U = U === e ? U : Pi(Vt(U), 0)),
						(H = H === e ? H : Vt(H)),
						(ce -= S ? S.length : 0),
						h & B)
					) {
						var ue = E,
							Ae = S
						E = S = e
					}
					var Te = Z ? e : B2(d),
						Ge = [d, h, A, E, S, ue, Ae, P, U, H]
					if (
						(Te && LSe(Ge, Te),
						(d = Ge[0]),
						(h = Ge[1]),
						(A = Ge[2]),
						(E = Ge[3]),
						(S = Ge[4]),
						(H = Ge[9] = Ge[9] === e ? (Z ? 0 : d.length) : Pi(Ge[9] - ce, 0)),
						!H && h & (v | b) && (h &= ~(v | b)),
						!h || h == m)
					)
						var dt = vSe(d, h, A)
					else
						h == v || h == b
							? (dt = ESe(d, h, H))
							: (h == w || h == (m | w)) && !S.length
								? (dt = bSe(d, h, A, E))
								: (dt = $w.apply(e, Ge))
					var Gt = Te ? j6 : B9
					return D9(Gt(dt, Ge), d, h)
				}
				function y9(d, h, A, E) {
					return d === e || (Gl(d, OA[A]) && !tn.call(E, A)) ? h : d
				}
				function C9(d, h, A, E, S, P) {
					return Un(d) && Un(h) && (P.set(h, d), Vw(d, h, e, C9, P), P.delete(h)), d
				}
				function _Se(d) {
					return Ev(d) ? e : d
				}
				function v9(d, h, A, E, S, P) {
					var U = A & p,
						H = d.length,
						Z = h.length
					if (H != Z && !(U && Z > H)) return !1
					var ce = P.get(d),
						ue = P.get(h)
					if (ce && ue) return ce == h && ue == d
					var Ae = -1,
						Te = !0,
						Ge = A & g ? new mg() : e
					for (P.set(d, h), P.set(h, d); ++Ae < H; ) {
						var dt = d[Ae],
							Gt = h[Ae]
						if (E) var ft = U ? E(Gt, dt, Ae, h, d, P) : E(dt, Gt, Ae, d, h, P)
						if (ft !== e) {
							if (ft) continue
							Te = !1
							break
						}
						if (Ge) {
							if (
								!gg(h, function (nr, yr) {
									if (!_o(Ge, yr) && (dt === nr || S(dt, nr, A, E, P))) return Ge.push(yr)
								})
							) {
								Te = !1
								break
							}
						} else if (!(dt === Gt || S(dt, Gt, A, E, P))) {
							Te = !1
							break
						}
					}
					return P.delete(d), P.delete(h), Te
				}
				function wSe(d, h, A, E, S, P, U) {
					switch (A) {
						case ra:
							if (d.byteLength != h.byteLength || d.byteOffset != h.byteOffset) return !1
							;(d = d.buffer), (h = h.buffer)
						case Gi:
							return !(d.byteLength != h.byteLength || !P(new Tw(d), new Tw(h)))
						case tr:
						case Nr:
						case Rr:
							return Gl(+d, +h)
						case en:
							return d.name == h.name && d.message == h.message
						case yn:
						case Js:
							return d == h + ""
						case be:
							var H = t2
						case Ei:
							var Z = E & p
							if ((H || (H = _w), d.size != h.size && !Z)) return !1
							var ce = U.get(d)
							if (ce) return ce == h
							;(E |= g), U.set(d, h)
							var ue = v9(H(d), H(h), E, S, P, U)
							return U.delete(d), ue
						case Ju:
							if (fv) return fv.call(d) == fv.call(h)
					}
					return !1
				}
				function ISe(d, h, A, E, S, P) {
					var U = A & p,
						H = I2(d),
						Z = H.length,
						ce = I2(h),
						ue = ce.length
					if (Z != ue && !U) return !1
					for (var Ae = Z; Ae--; ) {
						var Te = H[Ae]
						if (!(U ? Te in h : tn.call(h, Te))) return !1
					}
					var Ge = P.get(d),
						dt = P.get(h)
					if (Ge && dt) return Ge == h && dt == d
					var Gt = !0
					P.set(d, h), P.set(h, d)
					for (var ft = U; ++Ae < Z; ) {
						Te = H[Ae]
						var nr = d[Te],
							yr = h[Te]
						if (E) var la = U ? E(yr, nr, Te, h, d, P) : E(nr, yr, Te, d, h, P)
						if (!(la === e ? nr === yr || S(nr, yr, A, E, P) : la)) {
							Gt = !1
							break
						}
						ft || (ft = Te == "constructor")
					}
					if (Gt && !ft) {
						var to = d.constructor,
							ca = h.constructor
						to != ca &&
							"constructor" in d &&
							"constructor" in h &&
							!(
								typeof to == "function" &&
								to instanceof to &&
								typeof ca == "function" &&
								ca instanceof ca
							) &&
							(Gt = !1)
					}
					return P.delete(d), P.delete(h), Gt
				}
				function ld(d) {
					return F2(I9(d, e, Q9), d + "")
				}
				function I2(d) {
					return O6(d, $i, T2)
				}
				function S2(d) {
					return O6(d, So, E9)
				}
				var B2 = Nw
					? function (d) {
							return Nw.get(d)
						}
					: Y2
				function zw(d) {
					for (var h = d.name + "", A = VA[h], E = tn.call(VA, h) ? A.length : 0; E--; ) {
						var S = A[E],
							P = S.func
						if (P == null || P == d) return S.name
					}
					return h
				}
				function $A(d) {
					var h = tn.call(F, "placeholder") ? F : d
					return h.placeholder
				}
				function ct() {
					var d = F.iteratee || G2
					return (d = d === G2 ? H6 : d), arguments.length ? d(arguments[0], arguments[1]) : d
				}
				function jw(d, h) {
					var A = d.__data__
					return FSe(h) ? A[typeof h == "string" ? "string" : "hash"] : A.map
				}
				function D2(d) {
					for (var h = $i(d), A = h.length; A--; ) {
						var E = h[A],
							S = d[E]
						h[A] = [E, S, _9(S)]
					}
					return h
				}
				function vg(d, h) {
					var A = Pwe(d, h)
					return V6(A) ? A : e
				}
				function SSe(d) {
					var h = tn.call(d, pg),
						A = d[pg]
					try {
						d[pg] = e
						var E = !0
					} catch {}
					var S = Bw.call(d)
					return E && (h ? (d[pg] = A) : delete d[pg]), S
				}
				var T2 = n2
						? function (d) {
								return d == null
									? []
									: ((d = cn(d)),
										qa(n2(d), function (h) {
											return S6.call(d, h)
										}))
							}
						: K2,
					E9 = n2
						? function (d) {
								for (var h = []; d; ) js(h, T2(d)), (d = Rw(d))
								return h
							}
						: K2,
					ks = Xs
				;((i2 && ks(new i2(new ArrayBuffer(1))) != ra) ||
					(cv && ks(new cv()) != be) ||
					(s2 && ks(s2.resolve()) != bt) ||
					(qA && ks(new qA()) != Ei) ||
					(uv && ks(new uv()) != rr)) &&
					(ks = function (d) {
						var h = Xs(d),
							A = h == Ee ? d.constructor : e,
							E = A ? Eg(A) : ""
						if (E)
							switch (E) {
								case cIe:
									return ra
								case uIe:
									return be
								case dIe:
									return bt
								case fIe:
									return Ei
								case hIe:
									return rr
							}
						return h
					})
				function BSe(d, h, A) {
					for (var E = -1, S = A.length; ++E < S; ) {
						var P = A[E],
							U = P.size
						switch (P.type) {
							case "drop":
								d += U
								break
							case "dropRight":
								h -= U
								break
							case "take":
								h = Rs(h, d + U)
								break
							case "takeRight":
								d = Pi(d, h - U)
								break
						}
					}
					return { start: d, end: h }
				}
				function DSe(d) {
					var h = d.match(Ke)
					return h ? h[1].split(Jt) : []
				}
				function b9(d, h, A) {
					h = If(h, d)
					for (var E = -1, S = h.length, P = !1; ++E < S; ) {
						var U = Wc(h[E])
						if (!(P = d != null && A(d, U))) break
						d = d[U]
					}
					return P || ++E != S
						? P
						: ((S = d == null ? 0 : d.length), !!S && iI(S) && cd(U, S) && (Rt(d) || bg(d)))
				}
				function TSe(d) {
					var h = d.length,
						A = new d.constructor(h)
					return (
						h &&
							typeof d[0] == "string" &&
							tn.call(d, "index") &&
							((A.index = d.index), (A.input = d.input)),
						A
					)
				}
				function x9(d) {
					return typeof d.constructor == "function" && !Cv(d) ? HA(Rw(d)) : {}
				}
				function RSe(d, h, A) {
					var E = d.constructor
					switch (h) {
						case Gi:
							return x2(d)
						case tr:
						case Nr:
							return new E(+d)
						case ra:
							return gSe(d, A)
						case zu:
						case ju:
						case VC:
						case na:
						case HC:
						case WC:
						case mr:
						case St:
						case Cn:
							return s9(d, A)
						case be:
							return new E()
						case Rr:
						case Js:
							return new E(d)
						case yn:
							return pSe(d)
						case Ei:
							return new E()
						case Ju:
							return ASe(d)
					}
				}
				function kSe(d, h) {
					var A = h.length
					if (!A) return d
					var E = A - 1
					return (
						(h[E] = (A > 1 ? "& " : "") + h[E]),
						(h = h.join(A > 2 ? ", " : " ")),
						d.replace(
							Zu,
							`{
/* [wrapped with ` +
								h +
								`] */
`,
						)
					)
				}
				function MSe(d) {
					return Rt(d) || bg(d) || !!(B6 && d && d[B6])
				}
				function cd(d, h) {
					var A = typeof d
					return (
						(h = h ?? K),
						!!h && (A == "number" || (A != "symbol" && UN.test(d))) && d > -1 && d % 1 == 0 && d < h
					)
				}
				function eo(d, h, A) {
					if (!Un(A)) return !1
					var E = typeof h
					return (E == "number" ? Io(A) && cd(h, A.length) : E == "string" && h in A) ? Gl(A[h], d) : !1
				}
				function R2(d, h) {
					if (Rt(d)) return !1
					var A = typeof d
					return A == "number" || A == "symbol" || A == "boolean" || d == null || aa(d)
						? !0
						: FN.test(d) || !SA.test(d) || (h != null && d in cn(h))
				}
				function FSe(d) {
					var h = typeof d
					return h == "string" || h == "number" || h == "symbol" || h == "boolean"
						? d !== "__proto__"
						: d === null
				}
				function k2(d) {
					var h = zw(d),
						A = F[h]
					if (typeof A != "function" || !(h in ur.prototype)) return !1
					if (d === A) return !0
					var E = B2(A)
					return !!E && d === E[0]
				}
				function QSe(d) {
					return !!_6 && _6 in d
				}
				var NSe = Iw ? ud : J2
				function Cv(d) {
					var h = d && d.constructor,
						A = (typeof h == "function" && h.prototype) || OA
					return d === A
				}
				function _9(d) {
					return d === d && !Un(d)
				}
				function w9(d, h) {
					return function (A) {
						return A == null ? !1 : A[d] === h && (h !== e || d in cn(A))
					}
				}
				function PSe(d) {
					var h = rI(d, function (E) {
							return A.size === a && A.clear(), E
						}),
						A = h.cache
					return h
				}
				function LSe(d, h) {
					var A = d[1],
						E = h[1],
						S = A | E,
						P = S < (m | y | M),
						U =
							(E == M && A == v) ||
							(E == M && A == Q && d[7].length <= h[8]) ||
							(E == (M | Q) && h[7].length <= h[8] && A == v)
					if (!(P || U)) return d
					E & m && ((d[2] = h[2]), (S |= A & m ? 0 : C))
					var H = h[3]
					if (H) {
						var Z = d[3]
						;(d[3] = Z ? a9(Z, H, h[4]) : H), (d[4] = Z ? Ef(d[3], l) : h[4])
					}
					return (
						(H = h[5]),
						H && ((Z = d[5]), (d[5] = Z ? l9(Z, H, h[6]) : H), (d[6] = Z ? Ef(d[5], l) : h[6])),
						(H = h[7]),
						H && (d[7] = H),
						E & M && (d[8] = d[8] == null ? h[8] : Rs(d[8], h[8])),
						d[9] == null && (d[9] = h[9]),
						(d[0] = h[0]),
						(d[1] = S),
						d
					)
				}
				function USe(d) {
					var h = []
					if (d != null) for (var A in cn(d)) h.push(A)
					return h
				}
				function OSe(d) {
					return Bw.call(d)
				}
				function I9(d, h, A) {
					return (
						(h = Pi(h === e ? d.length - 1 : h, 0)),
						function () {
							for (var E = arguments, S = -1, P = Pi(E.length - h, 0), U = ie(P); ++S < P; )
								U[S] = E[h + S]
							S = -1
							for (var H = ie(h + 1); ++S < h; ) H[S] = E[S]
							return (H[h] = A(U)), us(d, this, H)
						}
					)
				}
				function S9(d, h) {
					return h.length < 2 ? d : Cg(d, Ga(h, 0, -1))
				}
				function qSe(d, h) {
					for (var A = d.length, E = Rs(h.length, A), S = wo(d); E--; ) {
						var P = h[E]
						d[E] = cd(P, A) ? S[P] : e
					}
					return d
				}
				function M2(d, h) {
					if (!(h === "constructor" && typeof d[h] == "function") && h != "__proto__") return d[h]
				}
				var B9 = T9(j6),
					vv =
						rIe ||
						function (d, h) {
							return bi.setTimeout(d, h)
						},
					F2 = T9(uSe)
				function D9(d, h, A) {
					var E = h + ""
					return F2(d, kSe(E, VSe(DSe(E), A)))
				}
				function T9(d) {
					var h = 0,
						A = 0
					return function () {
						var E = oIe(),
							S = q - (E - A)
						if (((A = E), S > 0)) {
							if (++h >= ne) return arguments[0]
						} else h = 0
						return d.apply(e, arguments)
					}
				}
				function Zw(d, h) {
					var A = -1,
						E = d.length,
						S = E - 1
					for (h = h === e ? E : h; ++A < h; ) {
						var P = A2(A, S),
							U = d[P]
						;(d[P] = d[A]), (d[A] = U)
					}
					return (d.length = h), d
				}
				var R9 = PSe(function (d) {
					var h = []
					return (
						d.charCodeAt(0) === 46 && h.push(""),
						d.replace($C, function (A, E, S, P) {
							h.push(S ? P.replace(Uc, "$1") : E || A)
						}),
						h
					)
				})
				function Wc(d) {
					if (typeof d == "string" || aa(d)) return d
					var h = d + ""
					return h == "0" && 1 / d == -re ? "-0" : h
				}
				function Eg(d) {
					if (d != null) {
						try {
							return Sw.call(d)
						} catch {}
						try {
							return d + ""
						} catch {}
					}
					return ""
				}
				function VSe(d, h) {
					return (
						ds(jt, function (A) {
							var E = "_." + A[0]
							h & A[1] && !rd(d, E) && d.push(E)
						}),
						d.sort()
					)
				}
				function k9(d) {
					if (d instanceof ur) return d.clone()
					var h = new Ha(d.__wrapped__, d.__chain__)
					return (
						(h.__actions__ = wo(d.__actions__)),
						(h.__index__ = d.__index__),
						(h.__values__ = d.__values__),
						h
					)
				}
				function HSe(d, h, A) {
					;(A ? eo(d, h, A) : h === e) ? (h = 1) : (h = Pi(Vt(h), 0))
					var E = d == null ? 0 : d.length
					if (!E || h < 1) return []
					for (var S = 0, P = 0, U = ie(Fw(E / h)); S < E; ) U[P++] = Ga(d, S, (S += h))
					return U
				}
				function WSe(d) {
					for (var h = -1, A = d == null ? 0 : d.length, E = 0, S = []; ++h < A; ) {
						var P = d[h]
						P && (S[E++] = P)
					}
					return S
				}
				function GSe() {
					var d = arguments.length
					if (!d) return []
					for (var h = ie(d - 1), A = arguments[0], E = d; E--; ) h[E - 1] = arguments[E]
					return js(Rt(A) ? wo(A) : [A], fs(h, 1))
				}
				var $Se = zt(function (d, h) {
						return di(d) ? gv(d, fs(h, 1, di, !0)) : []
					}),
					YSe = zt(function (d, h) {
						var A = $a(h)
						return di(A) && (A = e), di(d) ? gv(d, fs(h, 1, di, !0), ct(A, 2)) : []
					}),
					KSe = zt(function (d, h) {
						var A = $a(h)
						return di(A) && (A = e), di(d) ? gv(d, fs(h, 1, di, !0), e, A) : []
					})
				function JSe(d, h, A) {
					var E = d == null ? 0 : d.length
					return E ? ((h = A || h === e ? 1 : Vt(h)), Ga(d, h < 0 ? 0 : h, E)) : []
				}
				function zSe(d, h, A) {
					var E = d == null ? 0 : d.length
					return E ? ((h = A || h === e ? 1 : Vt(h)), (h = E - h), Ga(d, 0, h < 0 ? 0 : h)) : []
				}
				function jSe(d, h) {
					return d && d.length ? Ww(d, ct(h, 3), !0, !0) : []
				}
				function ZSe(d, h) {
					return d && d.length ? Ww(d, ct(h, 3), !0) : []
				}
				function XSe(d, h, A, E) {
					var S = d == null ? 0 : d.length
					return S ? (A && typeof A != "number" && eo(d, h, A) && ((A = 0), (E = S)), GIe(d, h, A, E)) : []
				}
				function M9(d, h, A) {
					var E = d == null ? 0 : d.length
					if (!E) return -1
					var S = A == null ? 0 : Vt(A)
					return S < 0 && (S = Pi(E + S, 0)), PA(d, ct(h, 3), S)
				}
				function F9(d, h, A) {
					var E = d == null ? 0 : d.length
					if (!E) return -1
					var S = E - 1
					return A !== e && ((S = Vt(A)), (S = A < 0 ? Pi(E + S, 0) : Rs(S, E - 1))), PA(d, ct(h, 3), S, !0)
				}
				function Q9(d) {
					var h = d == null ? 0 : d.length
					return h ? fs(d, 1) : []
				}
				function eBe(d) {
					var h = d == null ? 0 : d.length
					return h ? fs(d, re) : []
				}
				function tBe(d, h) {
					var A = d == null ? 0 : d.length
					return A ? ((h = h === e ? 1 : Vt(h)), fs(d, h)) : []
				}
				function rBe(d) {
					for (var h = -1, A = d == null ? 0 : d.length, E = {}; ++h < A; ) {
						var S = d[h]
						E[S[0]] = S[1]
					}
					return E
				}
				function N9(d) {
					return d && d.length ? d[0] : e
				}
				function nBe(d, h, A) {
					var E = d == null ? 0 : d.length
					if (!E) return -1
					var S = A == null ? 0 : Vt(A)
					return S < 0 && (S = Pi(E + S, 0)), nd(d, h, S)
				}
				function iBe(d) {
					var h = d == null ? 0 : d.length
					return h ? Ga(d, 0, -1) : []
				}
				var sBe = zt(function (d) {
						var h = Yr(d, E2)
						return h.length && h[0] === d[0] ? d2(h) : []
					}),
					oBe = zt(function (d) {
						var h = $a(d),
							A = Yr(d, E2)
						return h === $a(A) ? (h = e) : A.pop(), A.length && A[0] === d[0] ? d2(A, ct(h, 2)) : []
					}),
					aBe = zt(function (d) {
						var h = $a(d),
							A = Yr(d, E2)
						return (
							(h = typeof h == "function" ? h : e),
							h && A.pop(),
							A.length && A[0] === d[0] ? d2(A, e, h) : []
						)
					})
				function lBe(d, h) {
					return d == null ? "" : iIe.call(d, h)
				}
				function $a(d) {
					var h = d == null ? 0 : d.length
					return h ? d[h - 1] : e
				}
				function cBe(d, h, A) {
					var E = d == null ? 0 : d.length
					if (!E) return -1
					var S = E
					return (
						A !== e && ((S = Vt(A)), (S = S < 0 ? Pi(E + S, 0) : Rs(S, E - 1))),
						h === h ? Vwe(d, h, S) : PA(d, I, S, !0)
					)
				}
				function uBe(d, h) {
					return d && d.length ? Y6(d, Vt(h)) : e
				}
				var dBe = zt(P9)
				function P9(d, h) {
					return d && d.length && h && h.length ? p2(d, h) : d
				}
				function fBe(d, h, A) {
					return d && d.length && h && h.length ? p2(d, h, ct(A, 2)) : d
				}
				function hBe(d, h, A) {
					return d && d.length && h && h.length ? p2(d, h, e, A) : d
				}
				var gBe = ld(function (d, h) {
					var A = d == null ? 0 : d.length,
						E = a2(d, h)
					return (
						z6(
							d,
							Yr(h, function (S) {
								return cd(S, A) ? +S : S
							}).sort(o9),
						),
						E
					)
				})
				function pBe(d, h) {
					var A = []
					if (!(d && d.length)) return A
					var E = -1,
						S = [],
						P = d.length
					for (h = ct(h, 3); ++E < P; ) {
						var U = d[E]
						h(U, E, d) && (A.push(U), S.push(E))
					}
					return z6(d, S), A
				}
				function Q2(d) {
					return d == null ? d : lIe.call(d)
				}
				function ABe(d, h, A) {
					var E = d == null ? 0 : d.length
					return E
						? (A && typeof A != "number" && eo(d, h, A)
								? ((h = 0), (A = E))
								: ((h = h == null ? 0 : Vt(h)), (A = A === e ? E : Vt(A))),
							Ga(d, h, A))
						: []
				}
				function mBe(d, h) {
					return Hw(d, h)
				}
				function yBe(d, h, A) {
					return y2(d, h, ct(A, 2))
				}
				function CBe(d, h) {
					var A = d == null ? 0 : d.length
					if (A) {
						var E = Hw(d, h)
						if (E < A && Gl(d[E], h)) return E
					}
					return -1
				}
				function vBe(d, h) {
					return Hw(d, h, !0)
				}
				function EBe(d, h, A) {
					return y2(d, h, ct(A, 2), !0)
				}
				function bBe(d, h) {
					var A = d == null ? 0 : d.length
					if (A) {
						var E = Hw(d, h, !0) - 1
						if (Gl(d[E], h)) return E
					}
					return -1
				}
				function xBe(d) {
					return d && d.length ? Z6(d) : []
				}
				function _Be(d, h) {
					return d && d.length ? Z6(d, ct(h, 2)) : []
				}
				function wBe(d) {
					var h = d == null ? 0 : d.length
					return h ? Ga(d, 1, h) : []
				}
				function IBe(d, h, A) {
					return d && d.length ? ((h = A || h === e ? 1 : Vt(h)), Ga(d, 0, h < 0 ? 0 : h)) : []
				}
				function SBe(d, h, A) {
					var E = d == null ? 0 : d.length
					return E ? ((h = A || h === e ? 1 : Vt(h)), (h = E - h), Ga(d, h < 0 ? 0 : h, E)) : []
				}
				function BBe(d, h) {
					return d && d.length ? Ww(d, ct(h, 3), !1, !0) : []
				}
				function DBe(d, h) {
					return d && d.length ? Ww(d, ct(h, 3)) : []
				}
				var TBe = zt(function (d) {
						return wf(fs(d, 1, di, !0))
					}),
					RBe = zt(function (d) {
						var h = $a(d)
						return di(h) && (h = e), wf(fs(d, 1, di, !0), ct(h, 2))
					}),
					kBe = zt(function (d) {
						var h = $a(d)
						return (h = typeof h == "function" ? h : e), wf(fs(d, 1, di, !0), e, h)
					})
				function MBe(d) {
					return d && d.length ? wf(d) : []
				}
				function FBe(d, h) {
					return d && d.length ? wf(d, ct(h, 2)) : []
				}
				function QBe(d, h) {
					return (h = typeof h == "function" ? h : e), d && d.length ? wf(d, e, h) : []
				}
				function N2(d) {
					if (!(d && d.length)) return []
					var h = 0
					return (
						(d = qa(d, function (A) {
							if (di(A)) return (h = Pi(A.length, h)), !0
						})),
						ln(h, function (A) {
							return Yr(d, te(A))
						})
					)
				}
				function L9(d, h) {
					if (!(d && d.length)) return []
					var A = N2(d)
					return h == null
						? A
						: Yr(A, function (E) {
								return us(h, e, E)
							})
				}
				var NBe = zt(function (d, h) {
						return di(d) ? gv(d, h) : []
					}),
					PBe = zt(function (d) {
						return v2(qa(d, di))
					}),
					LBe = zt(function (d) {
						var h = $a(d)
						return di(h) && (h = e), v2(qa(d, di), ct(h, 2))
					}),
					UBe = zt(function (d) {
						var h = $a(d)
						return (h = typeof h == "function" ? h : e), v2(qa(d, di), e, h)
					}),
					OBe = zt(N2)
				function qBe(d, h) {
					return r9(d || [], h || [], hv)
				}
				function VBe(d, h) {
					return r9(d || [], h || [], mv)
				}
				var HBe = zt(function (d) {
					var h = d.length,
						A = h > 1 ? d[h - 1] : e
					return (A = typeof A == "function" ? (d.pop(), A) : e), L9(d, A)
				})
				function U9(d) {
					var h = F(d)
					return (h.__chain__ = !0), h
				}
				function WBe(d, h) {
					return h(d), d
				}
				function Xw(d, h) {
					return h(d)
				}
				var GBe = ld(function (d) {
					var h = d.length,
						A = h ? d[0] : 0,
						E = this.__wrapped__,
						S = function (P) {
							return a2(P, d)
						}
					return h > 1 || this.__actions__.length || !(E instanceof ur) || !cd(A)
						? this.thru(S)
						: ((E = E.slice(A, +A + (h ? 1 : 0))),
							E.__actions__.push({ func: Xw, args: [S], thisArg: e }),
							new Ha(E, this.__chain__).thru(function (P) {
								return h && !P.length && P.push(e), P
							}))
				})
				function $Be() {
					return U9(this)
				}
				function YBe() {
					return new Ha(this.value(), this.__chain__)
				}
				function KBe() {
					this.__values__ === e && (this.__values__ = X9(this.value()))
					var d = this.__index__ >= this.__values__.length,
						h = d ? e : this.__values__[this.__index__++]
					return { done: d, value: h }
				}
				function JBe() {
					return this
				}
				function zBe(d) {
					for (var h, A = this; A instanceof Lw; ) {
						var E = k9(A)
						;(E.__index__ = 0), (E.__values__ = e), h ? (S.__wrapped__ = E) : (h = E)
						var S = E
						A = A.__wrapped__
					}
					return (S.__wrapped__ = d), h
				}
				function jBe() {
					var d = this.__wrapped__
					if (d instanceof ur) {
						var h = d
						return (
							this.__actions__.length && (h = new ur(this)),
							(h = h.reverse()),
							h.__actions__.push({ func: Xw, args: [Q2], thisArg: e }),
							new Ha(h, this.__chain__)
						)
					}
					return this.thru(Q2)
				}
				function ZBe() {
					return t9(this.__wrapped__, this.__actions__)
				}
				var XBe = Gw(function (d, h, A) {
					tn.call(d, A) ? ++d[A] : od(d, A, 1)
				})
				function eDe(d, h, A) {
					var E = Rt(d) ? vw : WIe
					return A && eo(d, h, A) && (h = e), E(d, ct(h, 3))
				}
				function tDe(d, h) {
					var A = Rt(d) ? qa : L6
					return A(d, ct(h, 3))
				}
				var rDe = f9(M9),
					nDe = f9(F9)
				function iDe(d, h) {
					return fs(eI(d, h), 1)
				}
				function sDe(d, h) {
					return fs(eI(d, h), re)
				}
				function oDe(d, h, A) {
					return (A = A === e ? 1 : Vt(A)), fs(eI(d, h), A)
				}
				function O9(d, h) {
					var A = Rt(d) ? ds : _f
					return A(d, ct(h, 3))
				}
				function q9(d, h) {
					var A = Rt(d) ? xo : P6
					return A(d, ct(h, 3))
				}
				var aDe = Gw(function (d, h, A) {
					tn.call(d, A) ? d[A].push(h) : od(d, A, [h])
				})
				function lDe(d, h, A, E) {
					;(d = Io(d) ? d : KA(d)), (A = A && !E ? Vt(A) : 0)
					var S = d.length
					return A < 0 && (A = Pi(S + A, 0)), sI(d) ? A <= S && d.indexOf(h, A) > -1 : !!S && nd(d, h, A) > -1
				}
				var cDe = zt(function (d, h, A) {
						var E = -1,
							S = typeof h == "function",
							P = Io(d) ? ie(d.length) : []
						return (
							_f(d, function (U) {
								P[++E] = S ? us(h, U, A) : pv(U, h, A)
							}),
							P
						)
					}),
					uDe = Gw(function (d, h, A) {
						od(d, A, h)
					})
				function eI(d, h) {
					var A = Rt(d) ? Yr : W6
					return A(d, ct(h, 3))
				}
				function dDe(d, h, A, E) {
					return d == null
						? []
						: (Rt(h) || (h = h == null ? [] : [h]),
							(A = E ? e : A),
							Rt(A) || (A = A == null ? [] : [A]),
							K6(d, h, A))
				}
				var fDe = Gw(
					function (d, h, A) {
						d[A ? 0 : 1].push(h)
					},
					function () {
						return [[], []]
					},
				)
				function hDe(d, h, A) {
					var E = Rt(d) ? sa : Be,
						S = arguments.length < 3
					return E(d, ct(h, 4), A, S, _f)
				}
				function gDe(d, h, A) {
					var E = Rt(d) ? NA : Be,
						S = arguments.length < 3
					return E(d, ct(h, 4), A, S, P6)
				}
				function pDe(d, h) {
					var A = Rt(d) ? qa : L6
					return A(d, nI(ct(h, 3)))
				}
				function ADe(d) {
					var h = Rt(d) ? M6 : lSe
					return h(d)
				}
				function mDe(d, h, A) {
					;(A ? eo(d, h, A) : h === e) ? (h = 1) : (h = Vt(h))
					var E = Rt(d) ? UIe : cSe
					return E(d, h)
				}
				function yDe(d) {
					var h = Rt(d) ? OIe : dSe
					return h(d)
				}
				function CDe(d) {
					if (d == null) return 0
					if (Io(d)) return sI(d) ? UA(d) : d.length
					var h = ks(d)
					return h == be || h == Ei ? d.size : h2(d).length
				}
				function vDe(d, h, A) {
					var E = Rt(d) ? gg : fSe
					return A && eo(d, h, A) && (h = e), E(d, ct(h, 3))
				}
				var EDe = zt(function (d, h) {
						if (d == null) return []
						var A = h.length
						return (
							A > 1 && eo(d, h[0], h[1]) ? (h = []) : A > 2 && eo(h[0], h[1], h[2]) && (h = [h[0]]),
							K6(d, fs(h, 1), [])
						)
					}),
					tI =
						tIe ||
						function () {
							return bi.Date.now()
						}
				function bDe(d, h) {
					if (typeof h != "function") throw new Va(i)
					return (
						(d = Vt(d)),
						function () {
							if (--d < 1) return h.apply(this, arguments)
						}
					)
				}
				function V9(d, h, A) {
					return (h = A ? e : h), (h = d && h == null ? d.length : h), ad(d, M, e, e, e, e, h)
				}
				function H9(d, h) {
					var A
					if (typeof h != "function") throw new Va(i)
					return (
						(d = Vt(d)),
						function () {
							return --d > 0 && (A = h.apply(this, arguments)), d <= 1 && (h = e), A
						}
					)
				}
				var P2 = zt(function (d, h, A) {
						var E = m
						if (A.length) {
							var S = Ef(A, $A(P2))
							E |= w
						}
						return ad(d, E, h, A, S)
					}),
					W9 = zt(function (d, h, A) {
						var E = m | y
						if (A.length) {
							var S = Ef(A, $A(W9))
							E |= w
						}
						return ad(h, E, d, A, S)
					})
				function G9(d, h, A) {
					h = A ? e : h
					var E = ad(d, v, e, e, e, e, e, h)
					return (E.placeholder = G9.placeholder), E
				}
				function $9(d, h, A) {
					h = A ? e : h
					var E = ad(d, b, e, e, e, e, e, h)
					return (E.placeholder = $9.placeholder), E
				}
				function Y9(d, h, A) {
					var E,
						S,
						P,
						U,
						H,
						Z,
						ce = 0,
						ue = !1,
						Ae = !1,
						Te = !0
					if (typeof d != "function") throw new Va(i)
					;(h = Ya(h) || 0),
						Un(A) &&
							((ue = !!A.leading),
							(Ae = "maxWait" in A),
							(P = Ae ? Pi(Ya(A.maxWait) || 0, h) : P),
							(Te = "trailing" in A ? !!A.trailing : Te))
					function Ge(fi) {
						var $l = E,
							fd = S
						return (E = S = e), (ce = fi), (U = d.apply(fd, $l)), U
					}
					function dt(fi) {
						return (ce = fi), (H = vv(nr, h)), ue ? Ge(fi) : U
					}
					function Gt(fi) {
						var $l = fi - Z,
							fd = fi - ce,
							f$ = h - $l
						return Ae ? Rs(f$, P - fd) : f$
					}
					function ft(fi) {
						var $l = fi - Z,
							fd = fi - ce
						return Z === e || $l >= h || $l < 0 || (Ae && fd >= P)
					}
					function nr() {
						var fi = tI()
						if (ft(fi)) return yr(fi)
						H = vv(nr, Gt(fi))
					}
					function yr(fi) {
						return (H = e), Te && E ? Ge(fi) : ((E = S = e), U)
					}
					function la() {
						H !== e && n9(H), (ce = 0), (E = Z = S = H = e)
					}
					function to() {
						return H === e ? U : yr(tI())
					}
					function ca() {
						var fi = tI(),
							$l = ft(fi)
						if (((E = arguments), (S = this), (Z = fi), $l)) {
							if (H === e) return dt(Z)
							if (Ae) return n9(H), (H = vv(nr, h)), Ge(Z)
						}
						return H === e && (H = vv(nr, h)), U
					}
					return (ca.cancel = la), (ca.flush = to), ca
				}
				var xDe = zt(function (d, h) {
						return N6(d, 1, h)
					}),
					_De = zt(function (d, h, A) {
						return N6(d, Ya(h) || 0, A)
					})
				function wDe(d) {
					return ad(d, O)
				}
				function rI(d, h) {
					if (typeof d != "function" || (h != null && typeof h != "function")) throw new Va(i)
					var A = function () {
						var E = arguments,
							S = h ? h.apply(this, E) : E[0],
							P = A.cache
						if (P.has(S)) return P.get(S)
						var U = d.apply(this, E)
						return (A.cache = P.set(S, U) || P), U
					}
					return (A.cache = new (rI.Cache || sd)()), A
				}
				rI.Cache = sd
				function nI(d) {
					if (typeof d != "function") throw new Va(i)
					return function () {
						var h = arguments
						switch (h.length) {
							case 0:
								return !d.call(this)
							case 1:
								return !d.call(this, h[0])
							case 2:
								return !d.call(this, h[0], h[1])
							case 3:
								return !d.call(this, h[0], h[1], h[2])
						}
						return !d.apply(this, h)
					}
				}
				function IDe(d) {
					return H9(2, d)
				}
				var SDe = hSe(function (d, h) {
						h = h.length == 1 && Rt(h[0]) ? Yr(h[0], En(ct())) : Yr(fs(h, 1), En(ct()))
						var A = h.length
						return zt(function (E) {
							for (var S = -1, P = Rs(E.length, A); ++S < P; ) E[S] = h[S].call(this, E[S])
							return us(d, this, E)
						})
					}),
					L2 = zt(function (d, h) {
						var A = Ef(h, $A(L2))
						return ad(d, w, e, h, A)
					}),
					K9 = zt(function (d, h) {
						var A = Ef(h, $A(K9))
						return ad(d, B, e, h, A)
					}),
					BDe = ld(function (d, h) {
						return ad(d, Q, e, e, e, h)
					})
				function DDe(d, h) {
					if (typeof d != "function") throw new Va(i)
					return (h = h === e ? h : Vt(h)), zt(d, h)
				}
				function TDe(d, h) {
					if (typeof d != "function") throw new Va(i)
					return (
						(h = h == null ? 0 : Pi(Vt(h), 0)),
						zt(function (A) {
							var E = A[h],
								S = Sf(A, 0, h)
							return E && js(S, E), us(d, this, S)
						})
					)
				}
				function RDe(d, h, A) {
					var E = !0,
						S = !0
					if (typeof d != "function") throw new Va(i)
					return (
						Un(A) && ((E = "leading" in A ? !!A.leading : E), (S = "trailing" in A ? !!A.trailing : S)),
						Y9(d, h, { leading: E, maxWait: h, trailing: S })
					)
				}
				function kDe(d) {
					return V9(d, 1)
				}
				function MDe(d, h) {
					return L2(b2(h), d)
				}
				function FDe() {
					if (!arguments.length) return []
					var d = arguments[0]
					return Rt(d) ? d : [d]
				}
				function QDe(d) {
					return Wa(d, f)
				}
				function NDe(d, h) {
					return (h = typeof h == "function" ? h : e), Wa(d, f, h)
				}
				function PDe(d) {
					return Wa(d, c | f)
				}
				function LDe(d, h) {
					return (h = typeof h == "function" ? h : e), Wa(d, c | f, h)
				}
				function UDe(d, h) {
					return h == null || Q6(d, h, $i(h))
				}
				function Gl(d, h) {
					return d === h || (d !== d && h !== h)
				}
				var ODe = Jw(u2),
					qDe = Jw(function (d, h) {
						return d >= h
					}),
					bg = q6(
						(function () {
							return arguments
						})(),
					)
						? q6
						: function (d) {
								return jn(d) && tn.call(d, "callee") && !S6.call(d, "callee")
							},
					Rt = ie.isArray,
					VDe = qc ? En(qc) : zIe
				function Io(d) {
					return d != null && iI(d.length) && !ud(d)
				}
				function di(d) {
					return jn(d) && Io(d)
				}
				function HDe(d) {
					return d === !0 || d === !1 || (jn(d) && Xs(d) == tr)
				}
				var Bf = nIe || J2,
					WDe = Cw ? En(Cw) : jIe
				function GDe(d) {
					return jn(d) && d.nodeType === 1 && !Ev(d)
				}
				function $De(d) {
					if (d == null) return !0
					if (
						Io(d) &&
						(Rt(d) || typeof d == "string" || typeof d.splice == "function" || Bf(d) || YA(d) || bg(d))
					)
						return !d.length
					var h = ks(d)
					if (h == be || h == Ei) return !d.size
					if (Cv(d)) return !h2(d).length
					for (var A in d) if (tn.call(d, A)) return !1
					return !0
				}
				function YDe(d, h) {
					return Av(d, h)
				}
				function KDe(d, h, A) {
					A = typeof A == "function" ? A : e
					var E = A ? A(d, h) : e
					return E === e ? Av(d, h, e, A) : !!E
				}
				function U2(d) {
					if (!jn(d)) return !1
					var h = Xs(d)
					return h == en || h == Ve || (typeof d.message == "string" && typeof d.name == "string" && !Ev(d))
				}
				function JDe(d) {
					return typeof d == "number" && D6(d)
				}
				function ud(d) {
					if (!Un(d)) return !1
					var h = Xs(d)
					return h == Pr || h == cr || h == Tr || h == sn
				}
				function J9(d) {
					return typeof d == "number" && d == Vt(d)
				}
				function iI(d) {
					return typeof d == "number" && d > -1 && d % 1 == 0 && d <= K
				}
				function Un(d) {
					var h = typeof d
					return d != null && (h == "object" || h == "function")
				}
				function jn(d) {
					return d != null && typeof d == "object"
				}
				var z9 = sv ? En(sv) : XIe
				function zDe(d, h) {
					return d === h || f2(d, h, D2(h))
				}
				function jDe(d, h, A) {
					return (A = typeof A == "function" ? A : e), f2(d, h, D2(h), A)
				}
				function ZDe(d) {
					return j9(d) && d != +d
				}
				function XDe(d) {
					if (NSe(d)) throw new Tt(n)
					return V6(d)
				}
				function eTe(d) {
					return d === null
				}
				function tTe(d) {
					return d == null
				}
				function j9(d) {
					return typeof d == "number" || (jn(d) && Xs(d) == Rr)
				}
				function Ev(d) {
					if (!jn(d) || Xs(d) != Ee) return !1
					var h = Rw(d)
					if (h === null) return !0
					var A = tn.call(h, "constructor") && h.constructor
					return typeof A == "function" && A instanceof A && Sw.call(A) == jwe
				}
				var O2 = hg ? En(hg) : eSe
				function rTe(d) {
					return J9(d) && d >= -K && d <= K
				}
				var Z9 = vn ? En(vn) : tSe
				function sI(d) {
					return typeof d == "string" || (!Rt(d) && jn(d) && Xs(d) == Js)
				}
				function aa(d) {
					return typeof d == "symbol" || (jn(d) && Xs(d) == Ju)
				}
				var YA = ov ? En(ov) : rSe
				function nTe(d) {
					return d === e
				}
				function iTe(d) {
					return jn(d) && ks(d) == rr
				}
				function sTe(d) {
					return jn(d) && Xs(d) == MN
				}
				var oTe = Jw(g2),
					aTe = Jw(function (d, h) {
						return d <= h
					})
				function X9(d) {
					if (!d) return []
					if (Io(d)) return sI(d) ? Hl(d) : wo(d)
					if (lv && d[lv]) return Uwe(d[lv]())
					var h = ks(d),
						A = h == be ? t2 : h == Ei ? _w : KA
					return A(d)
				}
				function dd(d) {
					if (!d) return d === 0 ? d : 0
					if (((d = Ya(d)), d === re || d === -re)) {
						var h = d < 0 ? -1 : 1
						return h * se
					}
					return d === d ? d : 0
				}
				function Vt(d) {
					var h = dd(d),
						A = h % 1
					return h === h ? (A ? h - A : h) : 0
				}
				function e$(d) {
					return d ? yg(Vt(d), 0, It) : 0
				}
				function Ya(d) {
					if (typeof d == "number") return d
					if (aa(d)) return Ze
					if (Un(d)) {
						var h = typeof d.valueOf == "function" ? d.valueOf() : d
						d = Un(h) ? h + "" : h
					}
					if (typeof d != "string") return d === 0 ? d : +d
					d = Zs(d)
					var A = j_.test(d)
					return A || LN.test(d) ? XN(d.slice(2), A ? 2 : 8) : NN.test(d) ? Ze : +d
				}
				function t$(d) {
					return Hc(d, So(d))
				}
				function lTe(d) {
					return d ? yg(Vt(d), -K, K) : d === 0 ? d : 0
				}
				function Kr(d) {
					return d == null ? "" : oa(d)
				}
				var cTe = WA(function (d, h) {
						if (Cv(h) || Io(h)) {
							Hc(h, $i(h), d)
							return
						}
						for (var A in h) tn.call(h, A) && hv(d, A, h[A])
					}),
					r$ = WA(function (d, h) {
						Hc(h, So(h), d)
					}),
					oI = WA(function (d, h, A, E) {
						Hc(h, So(h), d, E)
					}),
					uTe = WA(function (d, h, A, E) {
						Hc(h, $i(h), d, E)
					}),
					dTe = ld(a2)
				function fTe(d, h) {
					var A = HA(d)
					return h == null ? A : F6(A, h)
				}
				var hTe = zt(function (d, h) {
						d = cn(d)
						var A = -1,
							E = h.length,
							S = E > 2 ? h[2] : e
						for (S && eo(h[0], h[1], S) && (E = 1); ++A < E; )
							for (var P = h[A], U = So(P), H = -1, Z = U.length; ++H < Z; ) {
								var ce = U[H],
									ue = d[ce]
								;(ue === e || (Gl(ue, OA[ce]) && !tn.call(d, ce))) && (d[ce] = P[ce])
							}
						return d
					}),
					gTe = zt(function (d) {
						return d.push(e, C9), us(n$, e, d)
					})
				function pTe(d, h) {
					return bw(d, ct(h, 3), Vc)
				}
				function ATe(d, h) {
					return bw(d, ct(h, 3), c2)
				}
				function mTe(d, h) {
					return d == null ? d : l2(d, ct(h, 3), So)
				}
				function yTe(d, h) {
					return d == null ? d : U6(d, ct(h, 3), So)
				}
				function CTe(d, h) {
					return d && Vc(d, ct(h, 3))
				}
				function vTe(d, h) {
					return d && c2(d, ct(h, 3))
				}
				function ETe(d) {
					return d == null ? [] : qw(d, $i(d))
				}
				function bTe(d) {
					return d == null ? [] : qw(d, So(d))
				}
				function q2(d, h, A) {
					var E = d == null ? e : Cg(d, h)
					return E === e ? A : E
				}
				function xTe(d, h) {
					return d != null && b9(d, h, $Ie)
				}
				function V2(d, h) {
					return d != null && b9(d, h, YIe)
				}
				var _Te = g9(function (d, h, A) {
						h != null && typeof h.toString != "function" && (h = Bw.call(h)), (d[h] = A)
					}, W2(Bo)),
					wTe = g9(function (d, h, A) {
						h != null && typeof h.toString != "function" && (h = Bw.call(h)),
							tn.call(d, h) ? d[h].push(A) : (d[h] = [A])
					}, ct),
					ITe = zt(pv)
				function $i(d) {
					return Io(d) ? k6(d) : h2(d)
				}
				function So(d) {
					return Io(d) ? k6(d, !0) : nSe(d)
				}
				function STe(d, h) {
					var A = {}
					return (
						(h = ct(h, 3)),
						Vc(d, function (E, S, P) {
							od(A, h(E, S, P), E)
						}),
						A
					)
				}
				function BTe(d, h) {
					var A = {}
					return (
						(h = ct(h, 3)),
						Vc(d, function (E, S, P) {
							od(A, S, h(E, S, P))
						}),
						A
					)
				}
				var DTe = WA(function (d, h, A) {
						Vw(d, h, A)
					}),
					n$ = WA(function (d, h, A, E) {
						Vw(d, h, A, E)
					}),
					TTe = ld(function (d, h) {
						var A = {}
						if (d == null) return A
						var E = !1
						;(h = Yr(h, function (P) {
							return (P = If(P, d)), E || (E = P.length > 1), P
						})),
							Hc(d, S2(d), A),
							E && (A = Wa(A, c | u | f, _Se))
						for (var S = h.length; S--; ) C2(A, h[S])
						return A
					})
				function RTe(d, h) {
					return i$(d, nI(ct(h)))
				}
				var kTe = ld(function (d, h) {
					return d == null ? {} : sSe(d, h)
				})
				function i$(d, h) {
					if (d == null) return {}
					var A = Yr(S2(d), function (E) {
						return [E]
					})
					return (
						(h = ct(h)),
						J6(d, A, function (E, S) {
							return h(E, S[0])
						})
					)
				}
				function MTe(d, h, A) {
					h = If(h, d)
					var E = -1,
						S = h.length
					for (S || ((S = 1), (d = e)); ++E < S; ) {
						var P = d == null ? e : d[Wc(h[E])]
						P === e && ((E = S), (P = A)), (d = ud(P) ? P.call(d) : P)
					}
					return d
				}
				function FTe(d, h, A) {
					return d == null ? d : mv(d, h, A)
				}
				function QTe(d, h, A, E) {
					return (E = typeof E == "function" ? E : e), d == null ? d : mv(d, h, A, E)
				}
				var s$ = m9($i),
					o$ = m9(So)
				function NTe(d, h, A) {
					var E = Rt(d),
						S = E || Bf(d) || YA(d)
					if (((h = ct(h, 4)), A == null)) {
						var P = d && d.constructor
						S ? (A = E ? new P() : []) : Un(d) ? (A = ud(P) ? HA(Rw(d)) : {}) : (A = {})
					}
					return (
						(S ? ds : Vc)(d, function (U, H, Z) {
							return h(A, U, H, Z)
						}),
						A
					)
				}
				function PTe(d, h) {
					return d == null ? !0 : C2(d, h)
				}
				function LTe(d, h, A) {
					return d == null ? d : e9(d, h, b2(A))
				}
				function UTe(d, h, A, E) {
					return (E = typeof E == "function" ? E : e), d == null ? d : e9(d, h, b2(A), E)
				}
				function KA(d) {
					return d == null ? [] : Vl(d, $i(d))
				}
				function OTe(d) {
					return d == null ? [] : Vl(d, So(d))
				}
				function qTe(d, h, A) {
					return (
						A === e && ((A = h), (h = e)),
						A !== e && ((A = Ya(A)), (A = A === A ? A : 0)),
						h !== e && ((h = Ya(h)), (h = h === h ? h : 0)),
						yg(Ya(d), h, A)
					)
				}
				function VTe(d, h, A) {
					return (h = dd(h)), A === e ? ((A = h), (h = 0)) : (A = dd(A)), (d = Ya(d)), KIe(d, h, A)
				}
				function HTe(d, h, A) {
					if (
						(A && typeof A != "boolean" && eo(d, h, A) && (h = A = e),
						A === e &&
							(typeof h == "boolean" ? ((A = h), (h = e)) : typeof d == "boolean" && ((A = d), (d = e))),
						d === e && h === e
							? ((d = 0), (h = 1))
							: ((d = dd(d)), h === e ? ((h = d), (d = 0)) : (h = dd(h))),
						d > h)
					) {
						var E = d
						;(d = h), (h = E)
					}
					if (A || d % 1 || h % 1) {
						var S = T6()
						return Rs(d + S * (h - d + ZN("1e-" + ((S + "").length - 1))), h)
					}
					return A2(d, h)
				}
				var WTe = GA(function (d, h, A) {
					return (h = h.toLowerCase()), d + (A ? a$(h) : h)
				})
				function a$(d) {
					return H2(Kr(d).toLowerCase())
				}
				function l$(d) {
					return (d = Kr(d)), d && d.replace(ON, Fwe).replace(JN, "")
				}
				function GTe(d, h, A) {
					;(d = Kr(d)), (h = oa(h))
					var E = d.length
					A = A === e ? E : yg(Vt(A), 0, E)
					var S = A
					return (A -= h.length), A >= 0 && d.slice(A, S) == h
				}
				function $Te(d) {
					return (d = Kr(d)), d && GC.test(d) ? d.replace(Ct, Qwe) : d
				}
				function YTe(d) {
					return (d = Kr(d)), d && BA.test(d) ? d.replace(Fi, "\\$&") : d
				}
				var KTe = GA(function (d, h, A) {
						return d + (A ? "-" : "") + h.toLowerCase()
					}),
					JTe = GA(function (d, h, A) {
						return d + (A ? " " : "") + h.toLowerCase()
					}),
					zTe = d9("toLowerCase")
				function jTe(d, h, A) {
					;(d = Kr(d)), (h = Vt(h))
					var E = h ? UA(d) : 0
					if (!h || E >= h) return d
					var S = (h - E) / 2
					return Kw(Qw(S), A) + d + Kw(Fw(S), A)
				}
				function ZTe(d, h, A) {
					;(d = Kr(d)), (h = Vt(h))
					var E = h ? UA(d) : 0
					return h && E < h ? d + Kw(h - E, A) : d
				}
				function XTe(d, h, A) {
					;(d = Kr(d)), (h = Vt(h))
					var E = h ? UA(d) : 0
					return h && E < h ? Kw(h - E, A) + d : d
				}
				function eRe(d, h, A) {
					return A || h == null ? (h = 0) : h && (h = +h), aIe(Kr(d).replace(YC, ""), h || 0)
				}
				function tRe(d, h, A) {
					return (A ? eo(d, h, A) : h === e) ? (h = 1) : (h = Vt(h)), m2(Kr(d), h)
				}
				function rRe() {
					var d = arguments,
						h = Kr(d[0])
					return d.length < 3 ? h : h.replace(d[1], d[2])
				}
				var nRe = GA(function (d, h, A) {
					return d + (A ? "_" : "") + h.toLowerCase()
				})
				function iRe(d, h, A) {
					return (
						A && typeof A != "number" && eo(d, h, A) && (h = A = e),
						(A = A === e ? It : A >>> 0),
						A
							? ((d = Kr(d)),
								d && (typeof h == "string" || (h != null && !O2(h))) && ((h = oa(h)), !h && LA(d))
									? Sf(Hl(d), 0, A)
									: d.split(h, A))
							: []
					)
				}
				var sRe = GA(function (d, h, A) {
					return d + (A ? " " : "") + H2(h)
				})
				function oRe(d, h, A) {
					return (
						(d = Kr(d)),
						(A = A == null ? 0 : yg(Vt(A), 0, d.length)),
						(h = oa(h)),
						d.slice(A, A + h.length) == h
					)
				}
				function aRe(d, h, A) {
					var E = F.templateSettings
					A && eo(d, h, A) && (h = e), (d = Kr(d)), (h = oI({}, h, E, y9))
					var S = oI({}, h.imports, E.imports, y9),
						P = $i(S),
						U = Vl(S, P),
						H,
						Z,
						ce = 0,
						ue = h.interpolate || DA,
						Ae = "__p += '",
						Te = r2(
							(h.escape || DA).source +
								"|" +
								ue.source +
								"|" +
								(ue === Af ? KC : DA).source +
								"|" +
								(h.evaluate || DA).source +
								"|$",
							"g",
						),
						Ge =
							"//# sourceURL=" +
							(tn.call(h, "sourceURL")
								? (h.sourceURL + "").replace(/\s/g, " ")
								: "lodash.templateSources[" + ++jN + "]") +
							`
`
					d.replace(Te, function (ft, nr, yr, la, to, ca) {
						return (
							yr || (yr = la),
							(Ae += d.slice(ce, ca).replace(qN, Nwe)),
							nr &&
								((H = !0),
								(Ae +=
									`' +
__e(` +
									nr +
									`) +
'`)),
							to &&
								((Z = !0),
								(Ae +=
									`';
` +
									to +
									`;
__p += '`)),
							yr &&
								(Ae +=
									`' +
((__t = (` +
									yr +
									`)) == null ? '' : __t) +
'`),
							(ce = ca + ft.length),
							ft
						)
					}),
						(Ae += `';
`)
					var dt = tn.call(h, "variable") && h.variable
					if (!dt)
						Ae =
							`with (obj) {
` +
							Ae +
							`
}
`
					else if (dg.test(dt)) throw new Tt(s)
					;(Ae = (Z ? Ae.replace(La, "") : Ae).replace(Ua, "$1").replace(ug, "$1;")),
						(Ae =
							"function(" +
							(dt || "obj") +
							`) {
` +
							(dt
								? ""
								: `obj || (obj = {});
`) +
							"var __t, __p = ''" +
							(H ? ", __e = _.escape" : "") +
							(Z
								? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`
								: `;
`) +
							Ae +
							`return __p
}`)
					var Gt = u$(function () {
						return Ur(P, Ge + "return " + Ae).apply(e, U)
					})
					if (((Gt.source = Ae), U2(Gt))) throw Gt
					return Gt
				}
				function lRe(d) {
					return Kr(d).toLowerCase()
				}
				function cRe(d) {
					return Kr(d).toUpperCase()
				}
				function uRe(d, h, A) {
					if (((d = Kr(d)), d && (A || h === e))) return Zs(d)
					if (!d || !(h = oa(h))) return d
					var E = Hl(d),
						S = Hl(h),
						P = vf(E, S),
						U = xw(E, S) + 1
					return Sf(E, P, U).join("")
				}
				function dRe(d, h, A) {
					if (((d = Kr(d)), d && (A || h === e))) return d.slice(0, x6(d) + 1)
					if (!d || !(h = oa(h))) return d
					var E = Hl(d),
						S = xw(E, Hl(h)) + 1
					return Sf(E, 0, S).join("")
				}
				function fRe(d, h, A) {
					if (((d = Kr(d)), d && (A || h === e))) return d.replace(YC, "")
					if (!d || !(h = oa(h))) return d
					var E = Hl(d),
						S = vf(E, Hl(h))
					return Sf(E, S).join("")
				}
				function hRe(d, h) {
					var A = Y,
						E = j
					if (Un(h)) {
						var S = "separator" in h ? h.separator : S
						;(A = "length" in h ? Vt(h.length) : A), (E = "omission" in h ? oa(h.omission) : E)
					}
					d = Kr(d)
					var P = d.length
					if (LA(d)) {
						var U = Hl(d)
						P = U.length
					}
					if (A >= P) return d
					var H = A - UA(E)
					if (H < 1) return E
					var Z = U ? Sf(U, 0, H).join("") : d.slice(0, H)
					if (S === e) return Z + E
					if ((U && (H += Z.length - H), O2(S))) {
						if (d.slice(H).search(S)) {
							var ce,
								ue = Z
							for (
								S.global || (S = r2(S.source, Kr(z_.exec(S)) + "g")), S.lastIndex = 0;
								(ce = S.exec(ue));

							)
								var Ae = ce.index
							Z = Z.slice(0, Ae === e ? H : Ae)
						}
					} else if (d.indexOf(oa(S), H) != H) {
						var Te = Z.lastIndexOf(S)
						Te > -1 && (Z = Z.slice(0, Te))
					}
					return Z + E
				}
				function gRe(d) {
					return (d = Kr(d)), d && wA.test(d) ? d.replace(Ul, Hwe) : d
				}
				var pRe = GA(function (d, h, A) {
						return d + (A ? " " : "") + h.toUpperCase()
					}),
					H2 = d9("toUpperCase")
				function c$(d, h, A) {
					return (d = Kr(d)), (h = A ? e : h), h === e ? (Lwe(d) ? $we(d) : e2(d)) : d.match(h) || []
				}
				var u$ = zt(function (d, h) {
						try {
							return us(d, e, h)
						} catch (A) {
							return U2(A) ? A : new Tt(A)
						}
					}),
					ARe = ld(function (d, h) {
						return (
							ds(h, function (A) {
								;(A = Wc(A)), od(d, A, P2(d[A], d))
							}),
							d
						)
					})
				function mRe(d) {
					var h = d == null ? 0 : d.length,
						A = ct()
					return (
						(d = h
							? Yr(d, function (E) {
									if (typeof E[1] != "function") throw new Va(i)
									return [A(E[0]), E[1]]
								})
							: []),
						zt(function (E) {
							for (var S = -1; ++S < h; ) {
								var P = d[S]
								if (us(P[0], this, E)) return us(P[1], this, E)
							}
						})
					)
				}
				function yRe(d) {
					return HIe(Wa(d, c))
				}
				function W2(d) {
					return function () {
						return d
					}
				}
				function CRe(d, h) {
					return d == null || d !== d ? h : d
				}
				var vRe = h9(),
					ERe = h9(!0)
				function Bo(d) {
					return d
				}
				function G2(d) {
					return H6(typeof d == "function" ? d : Wa(d, c))
				}
				function bRe(d) {
					return G6(Wa(d, c))
				}
				function xRe(d, h) {
					return $6(d, Wa(h, c))
				}
				var _Re = zt(function (d, h) {
						return function (A) {
							return pv(A, d, h)
						}
					}),
					wRe = zt(function (d, h) {
						return function (A) {
							return pv(d, A, h)
						}
					})
				function $2(d, h, A) {
					var E = $i(h),
						S = qw(h, E)
					A == null &&
						!(Un(h) && (S.length || !E.length)) &&
						((A = h), (h = d), (d = this), (S = qw(h, $i(h))))
					var P = !(Un(A) && "chain" in A) || !!A.chain,
						U = ud(d)
					return (
						ds(S, function (H) {
							var Z = h[H]
							;(d[H] = Z),
								U &&
									(d.prototype[H] = function () {
										var ce = this.__chain__
										if (P || ce) {
											var ue = d(this.__wrapped__),
												Ae = (ue.__actions__ = wo(this.__actions__))
											return (
												Ae.push({ func: Z, args: arguments, thisArg: d }),
												(ue.__chain__ = ce),
												ue
											)
										}
										return Z.apply(d, js([this.value()], arguments))
									})
						}),
						d
					)
				}
				function IRe() {
					return bi._ === this && (bi._ = Zwe), this
				}
				function Y2() {}
				function SRe(d) {
					return (
						(d = Vt(d)),
						zt(function (h) {
							return Y6(h, d)
						})
					)
				}
				var BRe = _2(Yr),
					DRe = _2(vw),
					TRe = _2(gg)
				function d$(d) {
					return R2(d) ? te(Wc(d)) : oSe(d)
				}
				function RRe(d) {
					return function (h) {
						return d == null ? e : Cg(d, h)
					}
				}
				var kRe = p9(),
					MRe = p9(!0)
				function K2() {
					return []
				}
				function J2() {
					return !1
				}
				function FRe() {
					return {}
				}
				function QRe() {
					return ""
				}
				function NRe() {
					return !0
				}
				function PRe(d, h) {
					if (((d = Vt(d)), d < 1 || d > K)) return []
					var A = It,
						E = Rs(d, It)
					;(h = ct(h)), (d -= It)
					for (var S = ln(E, h); ++A < d; ) h(A)
					return S
				}
				function LRe(d) {
					return Rt(d) ? Yr(d, Wc) : aa(d) ? [d] : wo(R9(Kr(d)))
				}
				function URe(d) {
					var h = ++zwe
					return Kr(d) + h
				}
				var ORe = Yw(function (d, h) {
						return d + h
					}, 0),
					qRe = w2("ceil"),
					VRe = Yw(function (d, h) {
						return d / h
					}, 1),
					HRe = w2("floor")
				function WRe(d) {
					return d && d.length ? Ow(d, Bo, u2) : e
				}
				function GRe(d, h) {
					return d && d.length ? Ow(d, ct(h, 2), u2) : e
				}
				function $Re(d) {
					return L(d, Bo)
				}
				function YRe(d, h) {
					return L(d, ct(h, 2))
				}
				function KRe(d) {
					return d && d.length ? Ow(d, Bo, g2) : e
				}
				function JRe(d, h) {
					return d && d.length ? Ow(d, ct(h, 2), g2) : e
				}
				var zRe = Yw(function (d, h) {
						return d * h
					}, 1),
					jRe = w2("round"),
					ZRe = Yw(function (d, h) {
						return d - h
					}, 0)
				function XRe(d) {
					return d && d.length ? qt(d, Bo) : 0
				}
				function eke(d, h) {
					return d && d.length ? qt(d, ct(h, 2)) : 0
				}
				return (
					(F.after = bDe),
					(F.ary = V9),
					(F.assign = cTe),
					(F.assignIn = r$),
					(F.assignInWith = oI),
					(F.assignWith = uTe),
					(F.at = dTe),
					(F.before = H9),
					(F.bind = P2),
					(F.bindAll = ARe),
					(F.bindKey = W9),
					(F.castArray = FDe),
					(F.chain = U9),
					(F.chunk = HSe),
					(F.compact = WSe),
					(F.concat = GSe),
					(F.cond = mRe),
					(F.conforms = yRe),
					(F.constant = W2),
					(F.countBy = XBe),
					(F.create = fTe),
					(F.curry = G9),
					(F.curryRight = $9),
					(F.debounce = Y9),
					(F.defaults = hTe),
					(F.defaultsDeep = gTe),
					(F.defer = xDe),
					(F.delay = _De),
					(F.difference = $Se),
					(F.differenceBy = YSe),
					(F.differenceWith = KSe),
					(F.drop = JSe),
					(F.dropRight = zSe),
					(F.dropRightWhile = jSe),
					(F.dropWhile = ZSe),
					(F.fill = XSe),
					(F.filter = tDe),
					(F.flatMap = iDe),
					(F.flatMapDeep = sDe),
					(F.flatMapDepth = oDe),
					(F.flatten = Q9),
					(F.flattenDeep = eBe),
					(F.flattenDepth = tBe),
					(F.flip = wDe),
					(F.flow = vRe),
					(F.flowRight = ERe),
					(F.fromPairs = rBe),
					(F.functions = ETe),
					(F.functionsIn = bTe),
					(F.groupBy = aDe),
					(F.initial = iBe),
					(F.intersection = sBe),
					(F.intersectionBy = oBe),
					(F.intersectionWith = aBe),
					(F.invert = _Te),
					(F.invertBy = wTe),
					(F.invokeMap = cDe),
					(F.iteratee = G2),
					(F.keyBy = uDe),
					(F.keys = $i),
					(F.keysIn = So),
					(F.map = eI),
					(F.mapKeys = STe),
					(F.mapValues = BTe),
					(F.matches = bRe),
					(F.matchesProperty = xRe),
					(F.memoize = rI),
					(F.merge = DTe),
					(F.mergeWith = n$),
					(F.method = _Re),
					(F.methodOf = wRe),
					(F.mixin = $2),
					(F.negate = nI),
					(F.nthArg = SRe),
					(F.omit = TTe),
					(F.omitBy = RTe),
					(F.once = IDe),
					(F.orderBy = dDe),
					(F.over = BRe),
					(F.overArgs = SDe),
					(F.overEvery = DRe),
					(F.overSome = TRe),
					(F.partial = L2),
					(F.partialRight = K9),
					(F.partition = fDe),
					(F.pick = kTe),
					(F.pickBy = i$),
					(F.property = d$),
					(F.propertyOf = RRe),
					(F.pull = dBe),
					(F.pullAll = P9),
					(F.pullAllBy = fBe),
					(F.pullAllWith = hBe),
					(F.pullAt = gBe),
					(F.range = kRe),
					(F.rangeRight = MRe),
					(F.rearg = BDe),
					(F.reject = pDe),
					(F.remove = pBe),
					(F.rest = DDe),
					(F.reverse = Q2),
					(F.sampleSize = mDe),
					(F.set = FTe),
					(F.setWith = QTe),
					(F.shuffle = yDe),
					(F.slice = ABe),
					(F.sortBy = EDe),
					(F.sortedUniq = xBe),
					(F.sortedUniqBy = _Be),
					(F.split = iRe),
					(F.spread = TDe),
					(F.tail = wBe),
					(F.take = IBe),
					(F.takeRight = SBe),
					(F.takeRightWhile = BBe),
					(F.takeWhile = DBe),
					(F.tap = WBe),
					(F.throttle = RDe),
					(F.thru = Xw),
					(F.toArray = X9),
					(F.toPairs = s$),
					(F.toPairsIn = o$),
					(F.toPath = LRe),
					(F.toPlainObject = t$),
					(F.transform = NTe),
					(F.unary = kDe),
					(F.union = TBe),
					(F.unionBy = RBe),
					(F.unionWith = kBe),
					(F.uniq = MBe),
					(F.uniqBy = FBe),
					(F.uniqWith = QBe),
					(F.unset = PTe),
					(F.unzip = N2),
					(F.unzipWith = L9),
					(F.update = LTe),
					(F.updateWith = UTe),
					(F.values = KA),
					(F.valuesIn = OTe),
					(F.without = NBe),
					(F.words = c$),
					(F.wrap = MDe),
					(F.xor = PBe),
					(F.xorBy = LBe),
					(F.xorWith = UBe),
					(F.zip = OBe),
					(F.zipObject = qBe),
					(F.zipObjectDeep = VBe),
					(F.zipWith = HBe),
					(F.entries = s$),
					(F.entriesIn = o$),
					(F.extend = r$),
					(F.extendWith = oI),
					$2(F, F),
					(F.add = ORe),
					(F.attempt = u$),
					(F.camelCase = WTe),
					(F.capitalize = a$),
					(F.ceil = qRe),
					(F.clamp = qTe),
					(F.clone = QDe),
					(F.cloneDeep = PDe),
					(F.cloneDeepWith = LDe),
					(F.cloneWith = NDe),
					(F.conformsTo = UDe),
					(F.deburr = l$),
					(F.defaultTo = CRe),
					(F.divide = VRe),
					(F.endsWith = GTe),
					(F.eq = Gl),
					(F.escape = $Te),
					(F.escapeRegExp = YTe),
					(F.every = eDe),
					(F.find = rDe),
					(F.findIndex = M9),
					(F.findKey = pTe),
					(F.findLast = nDe),
					(F.findLastIndex = F9),
					(F.findLastKey = ATe),
					(F.floor = HRe),
					(F.forEach = O9),
					(F.forEachRight = q9),
					(F.forIn = mTe),
					(F.forInRight = yTe),
					(F.forOwn = CTe),
					(F.forOwnRight = vTe),
					(F.get = q2),
					(F.gt = ODe),
					(F.gte = qDe),
					(F.has = xTe),
					(F.hasIn = V2),
					(F.head = N9),
					(F.identity = Bo),
					(F.includes = lDe),
					(F.indexOf = nBe),
					(F.inRange = VTe),
					(F.invoke = ITe),
					(F.isArguments = bg),
					(F.isArray = Rt),
					(F.isArrayBuffer = VDe),
					(F.isArrayLike = Io),
					(F.isArrayLikeObject = di),
					(F.isBoolean = HDe),
					(F.isBuffer = Bf),
					(F.isDate = WDe),
					(F.isElement = GDe),
					(F.isEmpty = $De),
					(F.isEqual = YDe),
					(F.isEqualWith = KDe),
					(F.isError = U2),
					(F.isFinite = JDe),
					(F.isFunction = ud),
					(F.isInteger = J9),
					(F.isLength = iI),
					(F.isMap = z9),
					(F.isMatch = zDe),
					(F.isMatchWith = jDe),
					(F.isNaN = ZDe),
					(F.isNative = XDe),
					(F.isNil = tTe),
					(F.isNull = eTe),
					(F.isNumber = j9),
					(F.isObject = Un),
					(F.isObjectLike = jn),
					(F.isPlainObject = Ev),
					(F.isRegExp = O2),
					(F.isSafeInteger = rTe),
					(F.isSet = Z9),
					(F.isString = sI),
					(F.isSymbol = aa),
					(F.isTypedArray = YA),
					(F.isUndefined = nTe),
					(F.isWeakMap = iTe),
					(F.isWeakSet = sTe),
					(F.join = lBe),
					(F.kebabCase = KTe),
					(F.last = $a),
					(F.lastIndexOf = cBe),
					(F.lowerCase = JTe),
					(F.lowerFirst = zTe),
					(F.lt = oTe),
					(F.lte = aTe),
					(F.max = WRe),
					(F.maxBy = GRe),
					(F.mean = $Re),
					(F.meanBy = YRe),
					(F.min = KRe),
					(F.minBy = JRe),
					(F.stubArray = K2),
					(F.stubFalse = J2),
					(F.stubObject = FRe),
					(F.stubString = QRe),
					(F.stubTrue = NRe),
					(F.multiply = zRe),
					(F.nth = uBe),
					(F.noConflict = IRe),
					(F.noop = Y2),
					(F.now = tI),
					(F.pad = jTe),
					(F.padEnd = ZTe),
					(F.padStart = XTe),
					(F.parseInt = eRe),
					(F.random = HTe),
					(F.reduce = hDe),
					(F.reduceRight = gDe),
					(F.repeat = tRe),
					(F.replace = rRe),
					(F.result = MTe),
					(F.round = jRe),
					(F.runInContext = J),
					(F.sample = ADe),
					(F.size = CDe),
					(F.snakeCase = nRe),
					(F.some = vDe),
					(F.sortedIndex = mBe),
					(F.sortedIndexBy = yBe),
					(F.sortedIndexOf = CBe),
					(F.sortedLastIndex = vBe),
					(F.sortedLastIndexBy = EBe),
					(F.sortedLastIndexOf = bBe),
					(F.startCase = sRe),
					(F.startsWith = oRe),
					(F.subtract = ZRe),
					(F.sum = XRe),
					(F.sumBy = eke),
					(F.template = aRe),
					(F.times = PRe),
					(F.toFinite = dd),
					(F.toInteger = Vt),
					(F.toLength = e$),
					(F.toLower = lRe),
					(F.toNumber = Ya),
					(F.toSafeInteger = lTe),
					(F.toString = Kr),
					(F.toUpper = cRe),
					(F.trim = uRe),
					(F.trimEnd = dRe),
					(F.trimStart = fRe),
					(F.truncate = hRe),
					(F.unescape = gRe),
					(F.uniqueId = URe),
					(F.upperCase = pRe),
					(F.upperFirst = H2),
					(F.each = O9),
					(F.eachRight = q9),
					(F.first = N9),
					$2(
						F,
						(function () {
							var d = {}
							return (
								Vc(F, function (h, A) {
									tn.call(F.prototype, A) || (d[A] = h)
								}),
								d
							)
						})(),
						{ chain: !1 },
					),
					(F.VERSION = t),
					ds(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (d) {
						F[d].placeholder = F
					}),
					ds(["drop", "take"], function (d, h) {
						;(ur.prototype[d] = function (A) {
							A = A === e ? 1 : Pi(Vt(A), 0)
							var E = this.__filtered__ && !h ? new ur(this) : this.clone()
							return (
								E.__filtered__
									? (E.__takeCount__ = Rs(A, E.__takeCount__))
									: E.__views__.push({
											size: Rs(A, It),
											type: d + (E.__dir__ < 0 ? "Right" : ""),
										}),
								E
							)
						}),
							(ur.prototype[d + "Right"] = function (A) {
								return this.reverse()[d](A).reverse()
							})
					}),
					ds(["filter", "map", "takeWhile"], function (d, h) {
						var A = h + 1,
							E = A == me || A == N
						ur.prototype[d] = function (S) {
							var P = this.clone()
							return (
								P.__iteratees__.push({ iteratee: ct(S, 3), type: A }),
								(P.__filtered__ = P.__filtered__ || E),
								P
							)
						}
					}),
					ds(["head", "last"], function (d, h) {
						var A = "take" + (h ? "Right" : "")
						ur.prototype[d] = function () {
							return this[A](1).value()[0]
						}
					}),
					ds(["initial", "tail"], function (d, h) {
						var A = "drop" + (h ? "" : "Right")
						ur.prototype[d] = function () {
							return this.__filtered__ ? new ur(this) : this[A](1)
						}
					}),
					(ur.prototype.compact = function () {
						return this.filter(Bo)
					}),
					(ur.prototype.find = function (d) {
						return this.filter(d).head()
					}),
					(ur.prototype.findLast = function (d) {
						return this.reverse().find(d)
					}),
					(ur.prototype.invokeMap = zt(function (d, h) {
						return typeof d == "function"
							? new ur(this)
							: this.map(function (A) {
									return pv(A, d, h)
								})
					})),
					(ur.prototype.reject = function (d) {
						return this.filter(nI(ct(d)))
					}),
					(ur.prototype.slice = function (d, h) {
						d = Vt(d)
						var A = this
						return A.__filtered__ && (d > 0 || h < 0)
							? new ur(A)
							: (d < 0 ? (A = A.takeRight(-d)) : d && (A = A.drop(d)),
								h !== e && ((h = Vt(h)), (A = h < 0 ? A.dropRight(-h) : A.take(h - d))),
								A)
					}),
					(ur.prototype.takeRightWhile = function (d) {
						return this.reverse().takeWhile(d).reverse()
					}),
					(ur.prototype.toArray = function () {
						return this.take(It)
					}),
					Vc(ur.prototype, function (d, h) {
						var A = /^(?:filter|find|map|reject)|While$/.test(h),
							E = /^(?:head|last)$/.test(h),
							S = F[E ? "take" + (h == "last" ? "Right" : "") : h],
							P = E || /^find/.test(h)
						S &&
							(F.prototype[h] = function () {
								var U = this.__wrapped__,
									H = E ? [1] : arguments,
									Z = U instanceof ur,
									ce = H[0],
									ue = Z || Rt(U),
									Ae = function (nr) {
										var yr = S.apply(F, js([nr], H))
										return E && Te ? yr[0] : yr
									}
								ue && A && typeof ce == "function" && ce.length != 1 && (Z = ue = !1)
								var Te = this.__chain__,
									Ge = !!this.__actions__.length,
									dt = P && !Te,
									Gt = Z && !Ge
								if (!P && ue) {
									U = Gt ? U : new ur(this)
									var ft = d.apply(U, H)
									return ft.__actions__.push({ func: Xw, args: [Ae], thisArg: e }), new Ha(ft, Te)
								}
								return dt && Gt
									? d.apply(this, H)
									: ((ft = this.thru(Ae)), dt ? (E ? ft.value()[0] : ft.value()) : ft)
							})
					}),
					ds(["pop", "push", "shift", "sort", "splice", "unshift"], function (d) {
						var h = ww[d],
							A = /^(?:push|sort|unshift)$/.test(d) ? "tap" : "thru",
							E = /^(?:pop|shift)$/.test(d)
						F.prototype[d] = function () {
							var S = arguments
							if (E && !this.__chain__) {
								var P = this.value()
								return h.apply(Rt(P) ? P : [], S)
							}
							return this[A](function (U) {
								return h.apply(Rt(U) ? U : [], S)
							})
						}
					}),
					Vc(ur.prototype, function (d, h) {
						var A = F[h]
						if (A) {
							var E = A.name + ""
							tn.call(VA, E) || (VA[E] = []), VA[E].push({ name: h, func: A })
						}
					}),
					(VA[$w(e, y).name] = [{ name: "wrapper", func: e }]),
					(ur.prototype.clone = gIe),
					(ur.prototype.reverse = pIe),
					(ur.prototype.value = AIe),
					(F.prototype.at = GBe),
					(F.prototype.chain = $Be),
					(F.prototype.commit = YBe),
					(F.prototype.next = KBe),
					(F.prototype.plant = zBe),
					(F.prototype.reverse = jBe),
					(F.prototype.toJSON = F.prototype.valueOf = F.prototype.value = ZBe),
					(F.prototype.first = F.prototype.head),
					lv && (F.prototype[lv] = JBe),
					F
				)
			},
			bf = Ywe()
		typeof define == "function" && typeof define.amd == "object" && define.amd
			? ((bi._ = bf),
				define(function () {
					return bf
				}))
			: td
				? (((td.exports = bf)._ = bf), (nv._ = bf))
				: (bi._ = bf)
	}).call(um)
})
var bm = x((Rbt, HK) => {
	"use strict"
	HK.exports = Gg
	Gg.CAPTURING_PHASE = 1
	Gg.AT_TARGET = 2
	Gg.BUBBLING_PHASE = 3
	function Gg(e, t) {
		if (
			((this.type = ""),
			(this.target = null),
			(this.currentTarget = null),
			(this.eventPhase = Gg.AT_TARGET),
			(this.bubbles = !1),
			(this.cancelable = !1),
			(this.isTrusted = !1),
			(this.defaultPrevented = !1),
			(this.timeStamp = Date.now()),
			(this._propagationStopped = !1),
			(this._immediatePropagationStopped = !1),
			(this._initialized = !0),
			(this._dispatching = !1),
			e && (this.type = e),
			t)
		)
			for (var r in t) this[r] = t[r]
	}
	Gg.prototype = Object.create(Object.prototype, {
		constructor: { value: Gg },
		stopPropagation: {
			value: function () {
				this._propagationStopped = !0
			},
		},
		stopImmediatePropagation: {
			value: function () {
				;(this._propagationStopped = !0), (this._immediatePropagationStopped = !0)
			},
		},
		preventDefault: {
			value: function () {
				this.cancelable && (this.defaultPrevented = !0)
			},
		},
		initEvent: {
			value: function (t, r, n) {
				;(this._initialized = !0),
					!this._dispatching &&
						((this._propagationStopped = !1),
						(this._immediatePropagationStopped = !1),
						(this.defaultPrevented = !1),
						(this.isTrusted = !1),
						(this.target = null),
						(this.type = t),
						(this.bubbles = r),
						(this.cancelable = n))
			},
		},
	})
})
var JP = x((kbt, GK) => {
	"use strict"
	var WK = bm()
	GK.exports = KP
	function KP() {
		WK.call(this), (this.view = null), (this.detail = 0)
	}
	KP.prototype = Object.create(WK.prototype, {
		constructor: { value: KP },
		initUIEvent: {
			value: function (e, t, r, n, i) {
				this.initEvent(e, t, r), (this.view = n), (this.detail = i)
			},
		},
	})
})
var jP = x((Mbt, YK) => {
	"use strict"
	var $K = JP()
	YK.exports = zP
	function zP() {
		$K.call(this),
			(this.screenX = this.screenY = this.clientX = this.clientY = 0),
			(this.ctrlKey = this.altKey = this.shiftKey = this.metaKey = !1),
			(this.button = 0),
			(this.buttons = 1),
			(this.relatedTarget = null)
	}
	zP.prototype = Object.create($K.prototype, {
		constructor: { value: zP },
		initMouseEvent: {
			value: function (e, t, r, n, i, s, o, a, l, c, u, f, p, g, m) {
				switch (
					(this.initEvent(e, t, r, n, i),
					(this.screenX = s),
					(this.screenY = o),
					(this.clientX = a),
					(this.clientY = l),
					(this.ctrlKey = c),
					(this.altKey = u),
					(this.shiftKey = f),
					(this.metaKey = p),
					(this.button = g),
					g)
				) {
					case 0:
						this.buttons = 1
						break
					case 1:
						this.buttons = 4
						break
					case 2:
						this.buttons = 2
						break
					default:
						this.buttons = 0
						break
				}
				this.relatedTarget = m
			},
		},
		getModifierState: {
			value: function (e) {
				switch (e) {
					case "Alt":
						return this.altKey
					case "Control":
						return this.ctrlKey
					case "Shift":
						return this.shiftKey
					case "Meta":
						return this.metaKey
					default:
						return !1
				}
			},
		},
	})
})
/**
 * Monkey patch the `MouseEvent` class to add a constructor that takes a bunch of fields.
 * This is necessary because the `MouseEvent` constructor is not available in the browser.
 *
 * @param {Object} fields - The fields to pass to the constructor.
 * @param {MouseEventTarget} fields.target - The target of the event.
 * @param {string} fields.type - The type of event.
 * @param {boolean} [fields.bubbles=false] - Whether the event bubbles.
 * @param {boolean} [fields.cancelable=false] - Whether the event is cancelable.
 * @param {Window} fields.view - The window associated with the event.
 * @param {number} fields.detail - The detail of the event.
 * @param {number} fields.screenX - The x-coordinate of the event on the screen.
 * @param {number} fields.screenY - The y-coordinate of the event on the screen.
 * @param {number} fields.clientX - The x-coordinate of the event on the client.
 * @param {number} fields.clientY - The y-coordinate of the event on the client.
 * @param {number} fields.ctrlKey - Whether the control key was pressed.
 * @param {number} fields.altKey - Whether the alt key was pressed.
 * @param {number} fields.shiftKey - Whether the shift key was pressed.
 * @param {number} fields.metaKey - Whether the meta key was pressed.
 * @param {number} fields.button - The button that was pressed.
 * @param {number} fields.buttons - The buttons that were pressed.
 * @param {MouseEventRelatedTarget} fields.relatedTarget - The target of the event if it was a related target event.
 */
var aS = x((Fbt, JK) => {
	"use strict"
	JK.exports = oS
	var o2e = 1,
		a2e = 3,
		l2e = 4,
		c2e = 5,
		u2e = 7,
		d2e = 8,
		f2e = 9,
		h2e = 11,
		g2e = 12,
		p2e = 13,
		A2e = 14,
		m2e = 15,
		y2e = 17,
		C2e = 18,
		v2e = 19,
		E2e = 20,
		b2e = 21,
		x2e = 22,
		_2e = 23,
		w2e = 24,
		I2e = 25,
		S2e = [
			null,
			"INDEX_SIZE_ERR",
			null,
			"HIERARCHY_REQUEST_ERR",
			"WRONG_DOCUMENT_ERR",
			"INVALID_CHARACTER_ERR",
			null,
			"NO_MODIFICATION_ALLOWED_ERR",
			"NOT_FOUND_ERR",
			"NOT_SUPPORTED_ERR",
			"INUSE_ATTRIBUTE_ERR",
			"INVALID_STATE_ERR",
			"SYNTAX_ERR",
			"INVALID_MODIFICATION_ERR",
			"NAMESPACE_ERR",
			"INVALID_ACCESS_ERR",
			null,
			"TYPE_MISMATCH_ERR",
			"SECURITY_ERR",
			"NETWORK_ERR",
			"ABORT_ERR",
			"URL_MISMATCH_ERR",
			"QUOTA_EXCEEDED_ERR",
			"TIMEOUT_ERR",
			"INVALID_NODE_TYPE_ERR",
			"DATA_CLONE_ERR",
		],
		B2e = [
			null,
			"INDEX_SIZE_ERR (1): the index is not in the allowed range",
			null,
			"HIERARCHY_REQUEST_ERR (3): the operation would yield an incorrect nodes model",
			"WRONG_DOCUMENT_ERR (4): the object is in the wrong Document, a call to importNode is required",
			"INVALID_CHARACTER_ERR (5): the string contains invalid characters",
			null,
			"NO_MODIFICATION_ALLOWED_ERR (7): the object can not be modified",
			"NOT_FOUND_ERR (8): the object can not be found here",
			"NOT_SUPPORTED_ERR (9): this operation is not supported",
			"INUSE_ATTRIBUTE_ERR (10): setAttributeNode called on owned Attribute",
			"INVALID_STATE_ERR (11): the object is in an invalid state",
			"SYNTAX_ERR (12): the string did not match the expected pattern",
			"INVALID_MODIFICATION_ERR (13): the object can not be modified in this way",
			"NAMESPACE_ERR (14): the operation is not allowed by Namespaces in XML",
			"INVALID_ACCESS_ERR (15): the object does not support the operation or argument",
			null,
			"TYPE_MISMATCH_ERR (17): the type of the object does not match the expected type",
			"SECURITY_ERR (18): the operation is insecure",
			"NETWORK_ERR (19): a network error occurred",
			"ABORT_ERR (20): the user aborted an operation",
			"URL_MISMATCH_ERR (21): the given URL does not match another URL",
			"QUOTA_EXCEEDED_ERR (22): the quota has been exceeded",
			"TIMEOUT_ERR (23): a timeout occurred",
			"INVALID_NODE_TYPE_ERR (24): the supplied node is invalid or has an invalid ancestor for this operation",
			"DATA_CLONE_ERR (25): the object can not be cloned.",
		],
		KK = {
			INDEX_SIZE_ERR: o2e,
			DOMSTRING_SIZE_ERR: 2,
			HIERARCHY_REQUEST_ERR: a2e,
			WRONG_DOCUMENT_ERR: l2e,
			INVALID_CHARACTER_ERR: c2e,
			NO_DATA_ALLOWED_ERR: 6,
			NO_MODIFICATION_ALLOWED_ERR: u2e,
			NOT_FOUND_ERR: d2e,
			NOT_SUPPORTED_ERR: f2e,
			INUSE_ATTRIBUTE_ERR: 10,
			INVALID_STATE_ERR: h2e,
			SYNTAX_ERR: g2e,
			INVALID_MODIFICATION_ERR: p2e,
			NAMESPACE_ERR: A2e,
			INVALID_ACCESS_ERR: m2e,
			VALIDATION_ERR: 16,
			TYPE_MISMATCH_ERR: y2e,
			SECURITY_ERR: C2e,
			NETWORK_ERR: v2e,
			ABORT_ERR: E2e,
			URL_MISMATCH_ERR: b2e,
			QUOTA_EXCEEDED_ERR: x2e,
			TIMEOUT_ERR: _2e,
			INVALID_NODE_TYPE_ERR: w2e,
			DATA_CLONE_ERR: I2e,
		}
	function oS(e) {
		Error.call(this),
			Error.captureStackTrace(this, this.constructor),
			(this.code = e),
			(this.message = B2e[e]),
			(this.name = S2e[e])
	}
	oS.prototype.__proto__ = Error.prototype
	for (sS in KK)
		(ZP = { value: KK[sS] }), Object.defineProperty(oS, sS, ZP), Object.defineProperty(oS.prototype, sS, ZP)
	var ZP, sS
})
var lS = x((zK) => {
	"use strict"
	zK.isApiWritable = !globalThis.__domino_frozen__
})
var ei = x((Or) => {
	"use strict"
	var Xn = aS(),
		gi = Xn,
		D2e = lS().isApiWritable
	Or.NAMESPACE = {
		HTML: "http://www.w3.org/1999/xhtml",
		XML: "http://www.w3.org/XML/1998/namespace",
		XMLNS: "http://www.w3.org/2000/xmlns/",
		MATHML: "http://www.w3.org/1998/Math/MathML",
		SVG: "http://www.w3.org/2000/svg",
		XLINK: "http://www.w3.org/1999/xlink",
	}
	Or.IndexSizeError = function () {
		throw new Xn(gi.INDEX_SIZE_ERR)
	}
	Or.HierarchyRequestError = function () {
		throw new Xn(gi.HIERARCHY_REQUEST_ERR)
	}
	Or.WrongDocumentError = function () {
		throw new Xn(gi.WRONG_DOCUMENT_ERR)
	}
	Or.InvalidCharacterError = function () {
		throw new Xn(gi.INVALID_CHARACTER_ERR)
	}
	Or.NoModificationAllowedError = function () {
		throw new Xn(gi.NO_MODIFICATION_ALLOWED_ERR)
	}
	Or.NotFoundError = function () {
		throw new Xn(gi.NOT_FOUND_ERR)
	}
	Or.NotSupportedError = function () {
		throw new Xn(gi.NOT_SUPPORTED_ERR)
	}
	Or.InvalidStateError = function () {
		throw new Xn(gi.INVALID_STATE_ERR)
	}
	Or.SyntaxError = function () {
		throw new Xn(gi.SYNTAX_ERR)
	}
	Or.InvalidModificationError = function () {
		throw new Xn(gi.INVALID_MODIFICATION_ERR)
	}
	Or.NamespaceError = function () {
		throw new Xn(gi.NAMESPACE_ERR)
	}
	Or.InvalidAccessError = function () {
		throw new Xn(gi.INVALID_ACCESS_ERR)
	}
	Or.TypeMismatchError = function () {
		throw new Xn(gi.TYPE_MISMATCH_ERR)
	}
	Or.SecurityError = function () {
		throw new Xn(gi.SECURITY_ERR)
	}
	Or.NetworkError = function () {
		throw new Xn(gi.NETWORK_ERR)
	}
	Or.AbortError = function () {
		throw new Xn(gi.ABORT_ERR)
	}
	Or.UrlMismatchError = function () {
		throw new Xn(gi.URL_MISMATCH_ERR)
	}
	Or.QuotaExceededError = function () {
		throw new Xn(gi.QUOTA_EXCEEDED_ERR)
	}
	Or.TimeoutError = function () {
		throw new Xn(gi.TIMEOUT_ERR)
	}
	Or.InvalidNodeTypeError = function () {
		throw new Xn(gi.INVALID_NODE_TYPE_ERR)
	}
	Or.DataCloneError = function () {
		throw new Xn(gi.DATA_CLONE_ERR)
	}
	Or.nyi = function () {
		throw new Error("NotYetImplemented")
	}
	Or.shouldOverride = function () {
		throw new Error("Abstract function; should be overriding in subclass.")
	}
	Or.assert = function (e, t) {
		if (!e)
			throw new Error(
				"Assertion failed: " +
					(t || "") +
					`
` +
					new Error().stack,
			)
	}
	Or.expose = function (e, t) {
		for (var r in e) Object.defineProperty(t.prototype, r, { value: e[r], writable: D2e })
	}
	Or.merge = function (e, t) {
		for (var r in t) e[r] = t[r]
	}
	Or.documentOrder = function (e, t) {
		return 3 - (e.compareDocumentPosition(t) & 6)
	}
	Or.toASCIILowerCase = function (e) {
		return e.replace(/[A-Z]+/g, function (t) {
			return t.toLowerCase()
		})
	}
	Or.toASCIIUpperCase = function (e) {
		return e.replace(/[a-z]+/g, function (t) {
			return t.toUpperCase()
		})
	}
})
var XP = x((Pbt, ZK) => {
	"use strict"
	var $g = bm(),
		T2e = jP(),
		R2e = ei()
	ZK.exports = jK
	function jK() {}
	jK.prototype = {
		addEventListener: function (t, r, n) {
			if (r) {
				n === void 0 && (n = !1),
					this._listeners || (this._listeners = Object.create(null)),
					this._listeners[t] || (this._listeners[t] = [])
				for (var i = this._listeners[t], s = 0, o = i.length; s < o; s++) {
					var a = i[s]
					if (a.listener === r && a.capture === n) return
				}
				var l = { listener: r, capture: n }
				typeof r == "function" && (l.f = r), i.push(l)
			}
		},
		removeEventListener: function (t, r, n) {
			if ((n === void 0 && (n = !1), this._listeners)) {
				var i = this._listeners[t]
				if (i)
					for (var s = 0, o = i.length; s < o; s++) {
						var a = i[s]
						if (a.listener === r && a.capture === n) {
							i.length === 1 ? (this._listeners[t] = void 0) : i.splice(s, 1)
							return
						}
					}
			}
		},
		dispatchEvent: function (t) {
			return this._dispatchEvent(t, !1)
		},
		_dispatchEvent: function (t, r) {
			typeof r != "boolean" && (r = !1)
			function n(c, u) {
				var f = u.type,
					p = u.eventPhase
				if (((u.currentTarget = c), p !== $g.CAPTURING_PHASE && c._handlers && c._handlers[f])) {
					var g = c._handlers[f],
						m
					if (typeof g == "function") m = g.call(u.currentTarget, u)
					else {
						var y = g.handleEvent
						if (typeof y != "function")
							throw new TypeError("handleEvent property of event handler object isnot a function.")
						m = y.call(g, u)
					}
					switch (u.type) {
						case "mouseover":
							m === !0 && u.preventDefault()
							break
						case "beforeunload":
						default:
							m === !1 && u.preventDefault()
							break
					}
				}
				var C = c._listeners && c._listeners[f]
				if (C) {
					C = C.slice()
					for (var v = 0, b = C.length; v < b; v++) {
						if (u._immediatePropagationStopped) return
						var w = C[v]
						if (!((p === $g.CAPTURING_PHASE && !w.capture) || (p === $g.BUBBLING_PHASE && w.capture)))
							if (w.f) w.f.call(u.currentTarget, u)
							else {
								var B = w.listener.handleEvent
								if (typeof B != "function")
									throw new TypeError(
										"handleEvent property of event listener object is not a function.",
									)
								B.call(w.listener, u)
							}
					}
				}
			}
			;(!t._initialized || t._dispatching) && R2e.InvalidStateError(),
				(t.isTrusted = r),
				(t._dispatching = !0),
				(t.target = this)
			for (var i = [], s = this.parentNode; s; s = s.parentNode) i.push(s)
			t.eventPhase = $g.CAPTURING_PHASE
			for (var o = i.length - 1; o >= 0 && (n(i[o], t), !t._propagationStopped); o--);
			if (
				(t._propagationStopped || ((t.eventPhase = $g.AT_TARGET), n(this, t)),
				t.bubbles && !t._propagationStopped)
			) {
				t.eventPhase = $g.BUBBLING_PHASE
				for (var a = 0, l = i.length; a < l && (n(i[a], t), !t._propagationStopped); a++);
			}
			if (
				((t._dispatching = !1),
				(t.eventPhase = $g.AT_TARGET),
				(t.currentTarget = null),
				r && !t.defaultPrevented && t instanceof T2e)
			)
				switch (t.type) {
					case "mousedown":
						this._armed = { x: t.clientX, y: t.clientY, t: t.timeStamp }
						break
					case "mouseout":
					case "mouseover":
						this._armed = null
						break
					case "mouseup":
						this._isClick(t) && this._doClick(t), (this._armed = null)
						break
				}
			return !t.defaultPrevented
		},
		_isClick: function (e) {
			return (
				this._armed !== null &&
				e.type === "mouseup" &&
				e.isTrusted &&
				e.button === 0 &&
				e.timeStamp - this._armed.t < 1e3 &&
				Math.abs(e.clientX - this._armed.x) < 10 &&
				Math.abs(e.clientY - this._armed.Y) < 10
			)
		},
		_doClick: function (e) {
			if (!this._click_in_progress) {
				this._click_in_progress = !0
				for (var t = this; t && !t._post_click_activation_steps; ) t = t.parentNode
				t && t._pre_click_activation_steps && t._pre_click_activation_steps()
				var r = this.ownerDocument.createEvent("MouseEvent")
				r.initMouseEvent(
					"click",
					!0,
					!0,
					this.ownerDocument.defaultView,
					1,
					e.screenX,
					e.screenY,
					e.clientX,
					e.clientY,
					e.ctrlKey,
					e.altKey,
					e.shiftKey,
					e.metaKey,
					e.button,
					null,
				)
				var n = this._dispatchEvent(r, !0)
				t &&
					(n
						? t._post_click_activation_steps && t._post_click_activation_steps(r)
						: t._cancelled_activation_steps && t._cancelled_activation_steps())
			}
		},
		_setEventHandler: function (t, r) {
			this._handlers || (this._handlers = Object.create(null)), (this._handlers[t] = r)
		},
		_getEventHandler: function (t) {
			return (this._handlers && this._handlers[t]) || null
		},
	}
})
var eL = x((Lbt, XK) => {
	"use strict"
	var Ed = ei(),
		Za = (XK.exports = {
			valid: function (e) {
				return (
					Ed.assert(e, "list falsy"),
					Ed.assert(e._previousSibling, "previous falsy"),
					Ed.assert(e._nextSibling, "next falsy"),
					!0
				)
			},
			insertBefore: function (e, t) {
				Ed.assert(Za.valid(e) && Za.valid(t))
				var r = e,
					n = e._previousSibling,
					i = t,
					s = t._previousSibling
				;(r._previousSibling = s),
					(n._nextSibling = i),
					(s._nextSibling = r),
					(i._previousSibling = n),
					Ed.assert(Za.valid(e) && Za.valid(t))
			},
			replace: function (e, t) {
				Ed.assert(Za.valid(e) && (t === null || Za.valid(t))),
					t !== null && Za.insertBefore(t, e),
					Za.remove(e),
					Ed.assert(Za.valid(e) && (t === null || Za.valid(t)))
			},
			remove: function (e) {
				Ed.assert(Za.valid(e))
				var t = e._previousSibling
				if (t !== e) {
					var r = e._nextSibling
					;(t._nextSibling = r),
						(r._previousSibling = t),
						(e._previousSibling = e._nextSibling = e),
						Ed.assert(Za.valid(e))
				}
			},
		})
})
var tL = x((Ubt, aJ) => {
	"use strict"
	aJ.exports = {
		serializeOne: L2e,
		ɵescapeMatchingClosingTag: iJ,
		ɵescapeClosingCommentTag: sJ,
		ɵescapeProcessingInstructionContent: oJ,
	}
	var nJ = ei(),
		Yg = nJ.NAMESPACE,
		eJ = {
			STYLE: !0,
			SCRIPT: !0,
			XMP: !0,
			IFRAME: !0,
			NOEMBED: !0,
			NOFRAMES: !0,
			PLAINTEXT: !0,
		},
		k2e = {
			area: !0,
			base: !0,
			basefont: !0,
			bgsound: !0,
			br: !0,
			col: !0,
			embed: !0,
			frame: !0,
			hr: !0,
			img: !0,
			input: !0,
			keygen: !0,
			link: !0,
			meta: !0,
			param: !0,
			source: !0,
			track: !0,
			wbr: !0,
		},
		M2e = {},
		tJ = /[&<>\u00A0]/g,
		rJ = /[&"<>\u00A0]/g
	function F2e(e) {
		return tJ.test(e)
			? e.replace(tJ, (t) => {
					switch (t) {
						case "&":
							return "&amp;"
						case "<":
							return "&lt;"
						case ">":
							return "&gt;"
						case "\xA0":
							return "&nbsp;"
					}
				})
			: e
	}
	function Q2e(e) {
		return rJ.test(e)
			? e.replace(rJ, (t) => {
					switch (t) {
						case "<":
							return "&lt;"
						case ">":
							return "&gt;"
						case "&":
							return "&amp;"
						case '"':
							return "&quot;"
						case "\xA0":
							return "&nbsp;"
					}
				})
			: e
	}
	function N2e(e) {
		var t = e.namespaceURI
		return t
			? t === Yg.XML
				? "xml:" + e.localName
				: t === Yg.XLINK
					? "xlink:" + e.localName
					: t === Yg.XMLNS
						? e.localName === "xmlns"
							? "xmlns"
							: "xmlns:" + e.localName
						: e.name
			: e.localName
	}
	function iJ(e, t) {
		let r = "</" + t
		if (!e.toLowerCase().includes(r)) return e
		let n = [...e],
			i = e.matchAll(new RegExp(r, "ig"))
		for (let s of i) n[s.index] = "&lt;"
		return n.join("")
	}
	var P2e = /--!?>/
	function sJ(e) {
		return P2e.test(e) ? e.replace(/(--\!?)>/g, "$1&gt;") : e
	}
	function oJ(e) {
		return e.includes(">") ? e.replaceAll(">", "&gt;") : e
	}
	function L2e(e, t) {
		var r = ""
		switch (e.nodeType) {
			case 1:
				var n = e.namespaceURI,
					i = n === Yg.HTML,
					s = i || n === Yg.SVG || n === Yg.MATHML ? e.localName : e.tagName
				r += "<" + s
				for (var o = 0, a = e._numattrs; o < a; o++) {
					var l = e._attr(o)
					;(r += " " + N2e(l)), l.value !== void 0 && (r += '="' + Q2e(l.value) + '"')
				}
				if (((r += ">"), !(i && k2e[s]))) {
					var c = e.serialize()
					eJ[s.toUpperCase()] && (c = iJ(c, s)),
						i &&
							M2e[s] &&
							c.charAt(0) ===
								`
` &&
							(r += `
`),
						(r += c),
						(r += "</" + s + ">")
				}
				break
			case 3:
			case 4:
				var u
				t.nodeType === 1 && t.namespaceURI === Yg.HTML ? (u = t.tagName) : (u = ""),
					eJ[u] || (u === "NOSCRIPT" && t.ownerDocument._scripting_enabled)
						? (r += e.data)
						: (r += F2e(e.data))
				break
			case 8:
				r += "<!--" + sJ(e.data) + "-->"
				break
			case 7:
				let f = oJ(e.data)
				r += "<?" + e.target + " " + f + "?>"
				break
			case 10:
				;(r += "<!DOCTYPE " + e.name), (r += ">")
				break
			default:
				nJ.InvalidStateError()
		}
		return r
	}
})
var ps = x((Obt, hJ) => {
	"use strict"
	hJ.exports = Fn
	var fJ = XP(),
		cS = eL(),
		lJ = tL(),
		qr = ei()
	function Fn() {
		fJ.call(this),
			(this.parentNode = null),
			(this._nextSibling = this._previousSibling = this),
			(this._index = void 0)
	}
	var Fo = (Fn.ELEMENT_NODE = 1),
		rL = (Fn.ATTRIBUTE_NODE = 2),
		uS = (Fn.TEXT_NODE = 3),
		U2e = (Fn.CDATA_SECTION_NODE = 4),
		O2e = (Fn.ENTITY_REFERENCE_NODE = 5),
		nL = (Fn.ENTITY_NODE = 6),
		cJ = (Fn.PROCESSING_INSTRUCTION_NODE = 7),
		uJ = (Fn.COMMENT_NODE = 8),
		Yv = (Fn.DOCUMENT_NODE = 9),
		Xa = (Fn.DOCUMENT_TYPE_NODE = 10),
		Pf = (Fn.DOCUMENT_FRAGMENT_NODE = 11),
		iL = (Fn.NOTATION_NODE = 12),
		sL = (Fn.DOCUMENT_POSITION_DISCONNECTED = 1),
		oL = (Fn.DOCUMENT_POSITION_PRECEDING = 2),
		aL = (Fn.DOCUMENT_POSITION_FOLLOWING = 4),
		dJ = (Fn.DOCUMENT_POSITION_CONTAINS = 8),
		lL = (Fn.DOCUMENT_POSITION_CONTAINED_BY = 16),
		cL = (Fn.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32)
	Fn.prototype = Object.create(fJ.prototype, {
		baseURI: { get: qr.nyi },
		parentElement: {
			get: function () {
				return this.parentNode && this.parentNode.nodeType === Fo ? this.parentNode : null
			},
		},
		hasChildNodes: { value: qr.shouldOverride },
		firstChild: { get: qr.shouldOverride },
		lastChild: { get: qr.shouldOverride },
		isConnected: {
			get: function () {
				let e = this
				for (; e != null; ) {
					if (e.nodeType === Fn.DOCUMENT_NODE) return !0
					;(e = e.parentNode), e != null && e.nodeType === Fn.DOCUMENT_FRAGMENT_NODE && (e = e.host)
				}
				return !1
			},
		},
		previousSibling: {
			get: function () {
				var e = this.parentNode
				return !e || this === e.firstChild ? null : this._previousSibling
			},
		},
		nextSibling: {
			get: function () {
				var e = this.parentNode,
					t = this._nextSibling
				return !e || t === e.firstChild ? null : t
			},
		},
		textContent: {
			get: function () {
				return null
			},
			set: function (e) {},
		},
		innerText: {
			get: function () {
				return null
			},
			set: function (e) {},
		},
		_countChildrenOfType: {
			value: function (e) {
				for (var t = 0, r = this.firstChild; r !== null; r = r.nextSibling) r.nodeType === e && t++
				return t
			},
		},
		_ensureInsertValid: {
			value: function (t, r, n) {
				var i = this,
					s,
					o
				if (!t.nodeType) throw new TypeError("not a node")
				switch (i.nodeType) {
					case Yv:
					case Pf:
					case Fo:
						break
					default:
						qr.HierarchyRequestError()
				}
				switch (
					(t.isAncestor(i) && qr.HierarchyRequestError(),
					(r !== null || !n) && r.parentNode !== i && qr.NotFoundError(),
					t.nodeType)
				) {
					case Pf:
					case Xa:
					case Fo:
					case uS:
					case cJ:
					case uJ:
						break
					default:
						qr.HierarchyRequestError()
				}
				if (i.nodeType === Yv)
					switch (t.nodeType) {
						case uS:
							qr.HierarchyRequestError()
							break
						case Pf:
							switch (
								(t._countChildrenOfType(uS) > 0 && qr.HierarchyRequestError(),
								t._countChildrenOfType(Fo))
							) {
								case 0:
									break
								case 1:
									if (r !== null)
										for (
											n && r.nodeType === Xa && qr.HierarchyRequestError(), o = r.nextSibling;
											o !== null;
											o = o.nextSibling
										)
											o.nodeType === Xa && qr.HierarchyRequestError()
									;(s = i._countChildrenOfType(Fo)),
										n
											? s > 0 && qr.HierarchyRequestError()
											: (s > 1 || (s === 1 && r.nodeType !== Fo)) && qr.HierarchyRequestError()
									break
								default:
									qr.HierarchyRequestError()
							}
							break
						case Fo:
							if (r !== null)
								for (
									n && r.nodeType === Xa && qr.HierarchyRequestError(), o = r.nextSibling;
									o !== null;
									o = o.nextSibling
								)
									o.nodeType === Xa && qr.HierarchyRequestError()
							;(s = i._countChildrenOfType(Fo)),
								n
									? s > 0 && qr.HierarchyRequestError()
									: (s > 1 || (s === 1 && r.nodeType !== Fo)) && qr.HierarchyRequestError()
							break
						case Xa:
							if (r === null) i._countChildrenOfType(Fo) && qr.HierarchyRequestError()
							else
								for (o = i.firstChild; o !== null && o !== r; o = o.nextSibling)
									o.nodeType === Fo && qr.HierarchyRequestError()
							;(s = i._countChildrenOfType(Xa)),
								n
									? s > 0 && qr.HierarchyRequestError()
									: (s > 1 || (s === 1 && r.nodeType !== Xa)) && qr.HierarchyRequestError()
							break
					}
				else t.nodeType === Xa && qr.HierarchyRequestError()
			},
		},
		insertBefore: {
			value: function (t, r) {
				var n = this
				n._ensureInsertValid(t, r, !0)
				var i = r
				return i === t && (i = t.nextSibling), n.doc.adoptNode(t), t._insertOrReplace(n, i, !1), t
			},
		},
		appendChild: {
			value: function (e) {
				return this.insertBefore(e, null)
			},
		},
		_appendChild: {
			value: function (e) {
				e._insertOrReplace(this, null, !1)
			},
		},
		removeChild: {
			value: function (t) {
				var r = this
				if (!t.nodeType) throw new TypeError("not a node")
				return t.parentNode !== r && qr.NotFoundError(), t.remove(), t
			},
		},
		replaceChild: {
			value: function (t, r) {
				var n = this
				return (
					n._ensureInsertValid(t, r, !1),
					t.doc !== n.doc && n.doc.adoptNode(t),
					t._insertOrReplace(n, r, !0),
					r
				)
			},
		},
		contains: {
			value: function (t) {
				return t === null ? !1 : this === t ? !0 : (this.compareDocumentPosition(t) & lL) !== 0
			},
		},
		compareDocumentPosition: {
			value: function (t) {
				if (this === t) return 0
				if (this.doc !== t.doc || this.rooted !== t.rooted) return sL + cL
				for (var r = [], n = [], i = this; i !== null; i = i.parentNode) r.push(i)
				for (i = t; i !== null; i = i.parentNode) n.push(i)
				if ((r.reverse(), n.reverse(), r[0] !== n[0])) return sL + cL
				i = Math.min(r.length, n.length)
				for (var s = 1; s < i; s++) if (r[s] !== n[s]) return r[s].index < n[s].index ? aL : oL
				return r.length < n.length ? aL + lL : oL + dJ
			},
		},
		isSameNode: {
			value: function (t) {
				return this === t
			},
		},
		isEqualNode: {
			value: function (t) {
				if (!t || t.nodeType !== this.nodeType || !this.isEqual(t)) return !1
				for (var r = this.firstChild, n = t.firstChild; r && n; r = r.nextSibling, n = n.nextSibling)
					if (!r.isEqualNode(n)) return !1
				return r === null && n === null
			},
		},
		cloneNode: {
			value: function (e) {
				var t = this.clone()
				if (e) for (var r = this.firstChild; r !== null; r = r.nextSibling) t._appendChild(r.cloneNode(!0))
				return t
			},
		},
		lookupPrefix: {
			value: function (t) {
				var r
				if (t === "" || t === null || t === void 0) return null
				switch (this.nodeType) {
					case Fo:
						return this._lookupNamespacePrefix(t, this)
					case Yv:
						return (r = this.documentElement), r ? r.lookupPrefix(t) : null
					case nL:
					case iL:
					case Pf:
					case Xa:
						return null
					case rL:
						return (r = this.ownerElement), r ? r.lookupPrefix(t) : null
					default:
						return (r = this.parentElement), r ? r.lookupPrefix(t) : null
				}
			},
		},
		lookupNamespaceURI: {
			value: function (t) {
				;(t === "" || t === void 0) && (t = null)
				var r
				switch (this.nodeType) {
					case Fo:
						return qr.shouldOverride()
					case Yv:
						return (r = this.documentElement), r ? r.lookupNamespaceURI(t) : null
					case nL:
					case iL:
					case Xa:
					case Pf:
						return null
					case rL:
						return (r = this.ownerElement), r ? r.lookupNamespaceURI(t) : null
					default:
						return (r = this.parentElement), r ? r.lookupNamespaceURI(t) : null
				}
			},
		},
		isDefaultNamespace: {
			value: function (t) {
				;(t === "" || t === void 0) && (t = null)
				var r = this.lookupNamespaceURI(null)
				return r === t
			},
		},
		index: {
			get: function () {
				var e = this.parentNode
				if (this === e.firstChild) return 0
				var t = e.childNodes
				if (this._index === void 0 || t[this._index] !== this) {
					for (var r = 0; r < t.length; r++) t[r]._index = r
					qr.assert(t[this._index] === this)
				}
				return this._index
			},
		},
		isAncestor: {
			value: function (e) {
				if (this.doc !== e.doc || this.rooted !== e.rooted) return !1
				for (var t = e; t; t = t.parentNode) if (t === this) return !0
				return !1
			},
		},
		ensureSameDoc: {
			value: function (e) {
				e.ownerDocument === null
					? (e.ownerDocument = this.doc)
					: e.ownerDocument !== this.doc && qr.WrongDocumentError()
			},
		},
		removeChildren: { value: qr.shouldOverride },
		_insertOrReplace: {
			value: function (t, r, n) {
				var i = this,
					s,
					o
				if (
					(i.nodeType === Pf && i.rooted && qr.HierarchyRequestError(),
					t._childNodes && ((s = r === null ? t._childNodes.length : r.index), i.parentNode === t))
				) {
					var a = i.index
					a < s && s--
				}
				n && (r.rooted && r.doc.mutateRemove(r), (r.parentNode = null))
				var l = r
				l === null && (l = t.firstChild)
				var c = i.rooted && t.rooted
				if (i.nodeType === Pf) {
					for (var u = [0, n ? 1 : 0], f, p = i.firstChild; p !== null; p = f)
						(f = p.nextSibling), u.push(p), (p.parentNode = t)
					var g = u.length
					if (
						(n ? cS.replace(l, g > 2 ? u[2] : null) : g > 2 && l !== null && cS.insertBefore(u[2], l),
						t._childNodes)
					)
						for (
							u[0] = r === null ? t._childNodes.length : r._index,
								t._childNodes.splice.apply(t._childNodes, u),
								o = 2;
							o < g;
							o++
						)
							u[o]._index = u[0] + (o - 2)
					else t._firstChild === r && (g > 2 ? (t._firstChild = u[2]) : n && (t._firstChild = null))
					if ((i._childNodes ? (i._childNodes.length = 0) : (i._firstChild = null), t.rooted))
						for (t.modify(), o = 2; o < g; o++) t.doc.mutateInsert(u[o])
				} else {
					if (r === i) return
					c ? i._remove() : i.parentNode && i.remove(),
						(i.parentNode = t),
						n
							? (cS.replace(l, i),
								t._childNodes
									? ((i._index = s), (t._childNodes[s] = i))
									: t._firstChild === r && (t._firstChild = i))
							: (l !== null && cS.insertBefore(i, l),
								t._childNodes
									? ((i._index = s), t._childNodes.splice(s, 0, i))
									: t._firstChild === r && (t._firstChild = i)),
						c ? (t.modify(), t.doc.mutateMove(i)) : t.rooted && (t.modify(), t.doc.mutateInsert(i))
				}
			},
		},
		lastModTime: {
			get: function () {
				return this._lastModTime || (this._lastModTime = this.doc.modclock), this._lastModTime
			},
		},
		modify: {
			value: function () {
				if (this.doc.modclock)
					for (var e = ++this.doc.modclock, t = this; t; t = t.parentElement)
						t._lastModTime && (t._lastModTime = e)
			},
		},
		doc: {
			get: function () {
				return this.ownerDocument || this
			},
		},
		rooted: {
			get: function () {
				return !!this._nid
			},
		},
		normalize: {
			value: function () {
				for (var e, t = this.firstChild; t !== null; t = e)
					if (((e = t.nextSibling), t.normalize && t.normalize(), t.nodeType === Fn.TEXT_NODE)) {
						if (t.nodeValue === "") {
							this.removeChild(t)
							continue
						}
						var r = t.previousSibling
						r !== null && r.nodeType === Fn.TEXT_NODE && (r.appendData(t.nodeValue), this.removeChild(t))
					}
			},
		},
		serialize: {
			value: function () {
				if (this._innerHTML) return this._innerHTML
				for (var e = "", t = this.firstChild; t !== null; t = t.nextSibling) e += lJ.serializeOne(t, this)
				return e
			},
		},
		outerHTML: {
			get: function () {
				return lJ.serializeOne(this, { nodeType: 0 })
			},
			set: qr.nyi,
		},
		ELEMENT_NODE: { value: Fo },
		ATTRIBUTE_NODE: { value: rL },
		TEXT_NODE: { value: uS },
		CDATA_SECTION_NODE: { value: U2e },
		ENTITY_REFERENCE_NODE: { value: O2e },
		ENTITY_NODE: { value: nL },
		PROCESSING_INSTRUCTION_NODE: { value: cJ },
		COMMENT_NODE: { value: uJ },
		DOCUMENT_NODE: { value: Yv },
		DOCUMENT_TYPE_NODE: { value: Xa },
		DOCUMENT_FRAGMENT_NODE: { value: Pf },
		NOTATION_NODE: { value: iL },
		DOCUMENT_POSITION_DISCONNECTED: { value: sL },
		DOCUMENT_POSITION_PRECEDING: { value: oL },
		DOCUMENT_POSITION_FOLLOWING: { value: aL },
		DOCUMENT_POSITION_CONTAINS: { value: dJ },
		DOCUMENT_POSITION_CONTAINED_BY: { value: lL },
		DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: { value: cL },
	})
})
var pJ = x((Vbt, gJ) => {
	"use strict"
	gJ.exports = class extends Array {
		constructor(t) {
			if ((super((t && t.length) || 0), t)) for (var r in t) this[r] = t[r]
		}
		item(t) {
			return this[t] || null
		}
	}
})
var mJ = x((Hbt, AJ) => {
	"use strict"
	function q2e(e) {
		return this[e] || null
	}
	function V2e(e) {
		return e || (e = []), (e.item = q2e), e
	}
	AJ.exports = V2e
})
var Kg = x((Wbt, yJ) => {
	"use strict"
	var uL
	try {
		uL = pJ()
	} catch {
		uL = mJ()
	}
	yJ.exports = uL
})
var dS = x((Gbt, EJ) => {
	"use strict"
	EJ.exports = vJ
	var CJ = ps(),
		H2e = Kg()
	function vJ() {
		CJ.call(this), (this._firstChild = this._childNodes = null)
	}
	vJ.prototype = Object.create(CJ.prototype, {
		hasChildNodes: {
			value: function () {
				return this._childNodes ? this._childNodes.length > 0 : this._firstChild !== null
			},
		},
		childNodes: {
			get: function () {
				return this._ensureChildNodes(), this._childNodes
			},
		},
		firstChild: {
			get: function () {
				return this._childNodes
					? this._childNodes.length === 0
						? null
						: this._childNodes[0]
					: this._firstChild
			},
		},
		lastChild: {
			get: function () {
				var e = this._childNodes,
					t
				return e
					? e.length === 0
						? null
						: e[e.length - 1]
					: ((t = this._firstChild), t === null ? null : t._previousSibling)
			},
		},
		_ensureChildNodes: {
			value: function () {
				if (!this._childNodes) {
					var e = this._firstChild,
						t = e,
						r = (this._childNodes = new H2e())
					if (e)
						do r.push(t), (t = t._nextSibling)
						while (t !== e)
					this._firstChild = null
				}
			},
		},
		removeChildren: {
			value: function () {
				for (var t = this.rooted ? this.ownerDocument : null, r = this.firstChild, n; r !== null; )
					(n = r), (r = n.nextSibling), t && t.mutateRemove(n), (n.parentNode = null)
				this._childNodes ? (this._childNodes.length = 0) : (this._firstChild = null), this.modify()
			},
		},
	})
})
var fS = x((hL) => {
	"use strict"
	hL.isValidName = z2e
	hL.isValidQName = j2e
	var W2e = /^[_:A-Za-z][-.:\w]+$/,
		G2e = /^([_A-Za-z][-.\w]+|[_A-Za-z][-.\w]+:[_A-Za-z][-.\w]+)$/,
		Kv =
			"_A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD",
		Jv =
			"-._A-Za-z0-9\xB7\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0300-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD",
		Jg = "[" + Kv + "][" + Jv + "]*",
		dL = Kv + ":",
		fL = Jv + ":",
		$2e = new RegExp("^[" + dL + "][" + fL + "]*$"),
		Y2e = new RegExp("^(" + Jg + "|" + Jg + ":" + Jg + ")$"),
		bJ = /[\uD800-\uDB7F\uDC00-\uDFFF]/,
		xJ = /[\uD800-\uDB7F\uDC00-\uDFFF]/g,
		_J = /[\uD800-\uDB7F][\uDC00-\uDFFF]/g
	Kv += "\uD800-\u{EFC00}-\uDFFF"
	Jv += "\uD800-\u{EFC00}-\uDFFF"
	Jg = "[" + Kv + "][" + Jv + "]*"
	dL = Kv + ":"
	fL = Jv + ":"
	var K2e = new RegExp("^[" + dL + "][" + fL + "]*$"),
		J2e = new RegExp("^(" + Jg + "|" + Jg + ":" + Jg + ")$")
	function z2e(e) {
		if (W2e.test(e) || $2e.test(e)) return !0
		if (!bJ.test(e) || !K2e.test(e)) return !1
		var t = e.match(xJ),
			r = e.match(_J)
		return r !== null && 2 * r.length === t.length
	}
	function j2e(e) {
		if (G2e.test(e) || Y2e.test(e)) return !0
		if (!bJ.test(e) || !J2e.test(e)) return !1
		var t = e.match(xJ),
			r = e.match(_J)
		return r !== null && 2 * r.length === t.length
	}
})
var pL = x((gL) => {
	"use strict"
	var wJ = ei()
	gL.property = function (e) {
		if (Array.isArray(e.type)) {
			var t = Object.create(null)
			e.type.forEach(function (i) {
				t[i.value || i] = i.alias || i
			})
			var r = e.missing
			r === void 0 && (r = null)
			var n = e.invalid
			return (
				n === void 0 && (n = r),
				{
					get: function () {
						var i = this._getattr(e.name)
						return i === null ? r : ((i = t[i.toLowerCase()]), i !== void 0 ? i : n !== null ? n : i)
					},
					set: function (i) {
						this._setattr(e.name, i)
					},
				}
			)
		} else {
			if (e.type === Boolean)
				return {
					get: function () {
						return this.hasAttribute(e.name)
					},
					set: function (i) {
						i ? this._setattr(e.name, "") : this.removeAttribute(e.name)
					},
				}
			if (
				e.type === Number ||
				e.type === "long" ||
				e.type === "unsigned long" ||
				e.type === "limited unsigned long with fallback"
			)
				return Z2e(e)
			if (!e.type || e.type === String)
				return {
					get: function () {
						return this._getattr(e.name) || ""
					},
					set: function (i) {
						e.treatNullAsEmptyString && i === null && (i = ""), this._setattr(e.name, i)
					},
				}
			if (typeof e.type == "function") return e.type(e.name, e)
		}
		throw new Error("Invalid attribute definition")
	}
	function Z2e(e) {
		var t
		typeof e.default == "function"
			? (t = e.default)
			: typeof e.default == "number"
				? (t = function () {
						return e.default
					})
				: (t = function () {
						wJ.assert(!1, typeof e.default)
					})
		var r = e.type === "unsigned long",
			n = e.type === "long",
			i = e.type === "limited unsigned long with fallback",
			s = e.min,
			o = e.max,
			a = e.setmin
		return (
			s === void 0 && (r && (s = 0), n && (s = -2147483648), i && (s = 1)),
			o === void 0 && (r || n || i) && (o = 2147483647),
			{
				get: function () {
					var l = this._getattr(e.name),
						c = e.float ? parseFloat(l) : parseInt(l, 10)
					if (l === null || !isFinite(c) || (s !== void 0 && c < s) || (o !== void 0 && c > o))
						return t.call(this)
					if (r || n || i) {
						if (!/^[ \t\n\f\r]*[-+]?[0-9]/.test(l)) return t.call(this)
						c = c | 0
					}
					return c
				},
				set: function (l) {
					e.float || (l = Math.floor(l)),
						a !== void 0 && l < a && wJ.IndexSizeError(e.name + " set to " + l),
						r
							? (l = l < 0 || l > 2147483647 ? t.call(this) : l | 0)
							: i
								? (l = l < 1 || l > 2147483647 ? t.call(this) : l | 0)
								: n && (l = l < -2147483648 || l > 2147483647 ? t.call(this) : l | 0),
						this._setattr(e.name, String(l))
				},
			}
		)
	}
	gL.registerChangeHandler = function (e, t, r) {
		var n = e.prototype
		Object.prototype.hasOwnProperty.call(n, "_attributeChangeHandlers") ||
			(n._attributeChangeHandlers = Object.create(n._attributeChangeHandlers || null)),
			(n._attributeChangeHandlers[t] = r)
	}
})
var BJ = x((Kbt, SJ) => {
	"use strict"
	SJ.exports = IJ
	var X2e = ps()
	function IJ(e, t) {
		;(this.root = e),
			(this.filter = t),
			(this.lastModTime = e.lastModTime),
			(this.done = !1),
			(this.cache = []),
			this.traverse()
	}
	IJ.prototype = Object.create(Object.prototype, {
		length: {
			get: function () {
				return this.checkcache(), this.done || this.traverse(), this.cache.length
			},
		},
		item: {
			value: function (e) {
				return this.checkcache(), !this.done && e >= this.cache.length && this.traverse(), this.cache[e]
			},
		},
		checkcache: {
			value: function () {
				if (this.lastModTime !== this.root.lastModTime) {
					for (var e = this.cache.length - 1; e >= 0; e--) this[e] = void 0
					;(this.cache.length = 0), (this.done = !1), (this.lastModTime = this.root.lastModTime)
				}
			},
		},
		traverse: {
			value: function (e) {
				e !== void 0 && e++
				for (var t; (t = this.next()) !== null; )
					if (((this[this.cache.length] = t), this.cache.push(t), e && this.cache.length === e)) return
				this.done = !0
			},
		},
		next: {
			value: function () {
				var e = this.cache.length === 0 ? this.root : this.cache[this.cache.length - 1],
					t
				for (e.nodeType === X2e.DOCUMENT_NODE ? (t = e.documentElement) : (t = e.nextElement(this.root)); t; ) {
					if (this.filter(t)) return t
					t = t.nextElement(this.root)
				}
				return null
			},
		},
	})
})
var mL = x((Jbt, RJ) => {
	"use strict"
	var AL = ei()
	RJ.exports = TJ
	function TJ(e, t) {
		;(this._getString = e), (this._setString = t), (this._length = 0), (this._lastStringValue = ""), this._update()
	}
	Object.defineProperties(TJ.prototype, {
		length: {
			get: function () {
				return this._length
			},
		},
		item: {
			value: function (e) {
				var t = xm(this)
				return e < 0 || e >= t.length ? null : t[e]
			},
		},
		contains: {
			value: function (e) {
				e = String(e)
				var t = xm(this)
				return t.indexOf(e) > -1
			},
		},
		add: {
			value: function () {
				for (var e = xm(this), t = 0, r = arguments.length; t < r; t++) {
					var n = zv(arguments[t])
					e.indexOf(n) < 0 && e.push(n)
				}
				this._update(e)
			},
		},
		remove: {
			value: function () {
				for (var e = xm(this), t = 0, r = arguments.length; t < r; t++) {
					var n = zv(arguments[t]),
						i = e.indexOf(n)
					i > -1 && e.splice(i, 1)
				}
				this._update(e)
			},
		},
		toggle: {
			value: function (t, r) {
				return (
					(t = zv(t)),
					this.contains(t)
						? r === void 0 || r === !1
							? (this.remove(t), !1)
							: !0
						: r === void 0 || r === !0
							? (this.add(t), !0)
							: !1
				)
			},
		},
		replace: {
			value: function (t, r) {
				String(r) === "" && AL.SyntaxError(), (t = zv(t)), (r = zv(r))
				var n = xm(this),
					i = n.indexOf(t)
				if (i < 0) return !1
				var s = n.indexOf(r)
				return s < 0 ? (n[i] = r) : i < s ? ((n[i] = r), n.splice(s, 1)) : n.splice(i, 1), this._update(n), !0
			},
		},
		toString: {
			value: function () {
				return this._getString()
			},
		},
		value: {
			get: function () {
				return this._getString()
			},
			set: function (e) {
				this._setString(e), this._update()
			},
		},
		_update: {
			value: function (e) {
				e ? (DJ(this, e), this._setString(e.join(" ").trim())) : DJ(this, xm(this)),
					(this._lastStringValue = this._getString())
			},
		},
	})
	function DJ(e, t) {
		var r = e._length,
			n
		for (e._length = t.length, n = 0; n < t.length; n++) e[n] = t[n]
		for (; n < r; n++) e[n] = void 0
	}
	function zv(e) {
		return (e = String(e)), e === "" && AL.SyntaxError(), /[ \t\r\n\f]/.test(e) && AL.InvalidCharacterError(), e
	}
	function ePe(e) {
		for (var t = e._length, r = Array(t), n = 0; n < t; n++) r[n] = e[n]
		return r
	}
	function xm(e) {
		var t = e._getString()
		if (t === e._lastStringValue) return ePe(e)
		var r = t.replace(/(^[ \t\r\n\f]+)|([ \t\r\n\f]+$)/g, "")
		if (r === "") return []
		var n = Object.create(null)
		return r.split(/[ \t\r\n\f]+/g).filter(function (i) {
			var s = "$" + i
			return n[s] ? !1 : ((n[s] = !0), !0)
		})
	}
})
var AS = x((Im, PJ) => {
	"use strict"
	var hS = Object.create(null, {
			location: {
				get: function () {
					throw new Error("window.location is not supported.")
				},
			},
		}),
		tPe = function (e, t) {
			return e.compareDocumentPosition(t)
		},
		rPe = function (e, t) {
			return tPe(e, t) & 2 ? 1 : -1
		},
		pS = function (e) {
			for (; (e = e.nextSibling) && e.nodeType !== 1; );
			return e
		},
		wm = function (e) {
			for (; (e = e.previousSibling) && e.nodeType !== 1; );
			return e
		},
		nPe = function (e) {
			if ((e = e.firstChild)) for (; e.nodeType !== 1 && (e = e.nextSibling); );
			return e
		},
		iPe = function (e) {
			if ((e = e.lastChild)) for (; e.nodeType !== 1 && (e = e.previousSibling); );
			return e
		},
		_m = function (e) {
			if (!e.parentNode) return !1
			var t = e.parentNode.nodeType
			return t === 1 || t === 9
		},
		kJ = function (e) {
			if (!e) return e
			var t = e[0]
			return t === '"' || t === "'"
				? (e[e.length - 1] === t ? (e = e.slice(1, -1)) : (e = e.slice(1)),
					e.replace(mt.str_escape, function (r) {
						var n = /^\\(?:([0-9A-Fa-f]+)|([\r\n\f]+))/.exec(r)
						if (!n) return r.slice(1)
						if (n[2]) return ""
						var i = parseInt(n[1], 16)
						return String.fromCodePoint ? String.fromCodePoint(i) : String.fromCharCode(i)
					}))
				: mt.ident.test(e)
					? Lf(e)
					: e
		},
		Lf = function (e) {
			return e.replace(mt.escape, function (t) {
				var r = /^\\([0-9A-Fa-f]+)/.exec(t)
				if (!r) return t[1]
				var n = parseInt(r[1], 16)
				return String.fromCodePoint ? String.fromCodePoint(n) : String.fromCharCode(n)
			})
		},
		sPe = (function () {
			return Array.prototype.indexOf
				? Array.prototype.indexOf
				: function (e, t) {
						for (var r = this.length; r--; ) if (this[r] === t) return r
						return -1
					}
		})(),
		FJ = function (e, t) {
			var r = mt.inside.source.replace(/</g, e).replace(/>/g, t)
			return new RegExp(r)
		},
		Qo = function (e, t, r) {
			return (e = e.source), (e = e.replace(t, r.source || r)), new RegExp(e)
		},
		MJ = function (e, t) {
			return e
				.replace(/^(?:\w+:\/\/|\/+)/, "")
				.replace(/(?:\/+|\/*#.*?)$/, "")
				.split("/", t)
				.join("/")
		},
		oPe = function (e, t) {
			var r = e.replace(/\s+/g, ""),
				n
			return (
				r === "even" ? (r = "2n+0") : r === "odd" ? (r = "2n+1") : r.indexOf("n") === -1 && (r = "0n" + r),
				(n = /^([+-])?(\d+)?n([+-])?(\d+)?$/.exec(r)),
				{
					group: n[1] === "-" ? -(n[2] || 1) : +(n[2] || 1),
					offset: n[4] ? (n[3] === "-" ? -n[4] : +n[4]) : 0,
				}
			)
		},
		yL = function (e, t, r) {
			var n = oPe(e),
				i = n.group,
				s = n.offset,
				o = r ? iPe : nPe,
				a = r ? wm : pS
			return function (l) {
				if (_m(l))
					for (var c = o(l.parentNode), u = 0; c; ) {
						if ((t(c, l) && u++, c === l)) return (u -= s), i && u ? u % i === 0 && u < 0 == i < 0 : !u
						c = a(c)
					}
			}
		},
		Yi = {
			"*": (function () {
				return function () {
					return !0
				}
			})(),
			type: function (e) {
				return (
					(e = e.toLowerCase()),
					function (t) {
						return t.nodeName.toLowerCase() === e
					}
				)
			},
			attr: function (e, t, r, n) {
				return (
					(t = QJ[t]),
					function (i) {
						var s
						switch (e) {
							case "for":
								s = i.htmlFor
								break
							case "class":
								;(s = i.className), s === "" && i.getAttribute("class") == null && (s = null)
								break
							case "href":
							case "src":
								s = i.getAttribute(e, 2)
								break
							case "title":
								s = i.getAttribute("title") || null
								break
							case "id":
							case "lang":
							case "dir":
							case "accessKey":
							case "hidden":
							case "tabIndex":
							case "style":
								if (i.getAttribute) {
									s = i.getAttribute(e)
									break
								}
							default:
								if (i.hasAttribute && !i.hasAttribute(e)) break
								s = i[e] != null ? i[e] : i.getAttribute && i.getAttribute(e)
								break
						}
						if (s != null) return (s = s + ""), n && ((s = s.toLowerCase()), (r = r.toLowerCase())), t(s, r)
					}
				)
			},
			":first-child": function (e) {
				return !wm(e) && _m(e)
			},
			":last-child": function (e) {
				return !pS(e) && _m(e)
			},
			":only-child": function (e) {
				return !wm(e) && !pS(e) && _m(e)
			},
			":nth-child": function (e, t) {
				return yL(
					e,
					function () {
						return !0
					},
					t,
				)
			},
			":nth-last-child": function (e) {
				return Yi[":nth-child"](e, !0)
			},
			":root": function (e) {
				return e.ownerDocument.documentElement === e
			},
			":empty": function (e) {
				return !e.firstChild
			},
			":not": function (e) {
				var t = vL(e)
				return function (r) {
					return !t(r)
				}
			},
			":first-of-type": function (e) {
				if (_m(e)) {
					for (var t = e.nodeName; (e = wm(e)); ) if (e.nodeName === t) return
					return !0
				}
			},
			":last-of-type": function (e) {
				if (_m(e)) {
					for (var t = e.nodeName; (e = pS(e)); ) if (e.nodeName === t) return
					return !0
				}
			},
			":only-of-type": function (e) {
				return Yi[":first-of-type"](e) && Yi[":last-of-type"](e)
			},
			":nth-of-type": function (e, t) {
				return yL(
					e,
					function (r, n) {
						return r.nodeName === n.nodeName
					},
					t,
				)
			},
			":nth-last-of-type": function (e) {
				return Yi[":nth-of-type"](e, !0)
			},
			":checked": function (e) {
				return !!(e.checked || e.selected)
			},
			":indeterminate": function (e) {
				return !Yi[":checked"](e)
			},
			":enabled": function (e) {
				return !e.disabled && e.type !== "hidden"
			},
			":disabled": function (e) {
				return !!e.disabled
			},
			":target": function (e) {
				return e.id === hS.location.hash.substring(1)
			},
			":focus": function (e) {
				return e === e.ownerDocument.activeElement
			},
			":is": function (e) {
				return vL(e)
			},
			":matches": function (e) {
				return Yi[":is"](e)
			},
			":nth-match": function (e, t) {
				var r = e.split(/\s*,\s*/),
					n = r.shift(),
					i = vL(r.join(","))
				return yL(n, i, t)
			},
			":nth-last-match": function (e) {
				return Yi[":nth-match"](e, !0)
			},
			":links-here": function (e) {
				return e + "" == hS.location + ""
			},
			":lang": function (e) {
				return function (t) {
					for (; t; ) {
						if (t.lang) return t.lang.indexOf(e) === 0
						t = t.parentNode
					}
				}
			},
			":dir": function (e) {
				return function (t) {
					for (; t; ) {
						if (t.dir) return t.dir === e
						t = t.parentNode
					}
				}
			},
			":scope": function (e, t) {
				var r = t || e.ownerDocument
				return r.nodeType === 9 ? e === r.documentElement : e === r
			},
			":any-link": function (e) {
				return typeof e.href == "string"
			},
			":local-link": function (e) {
				if (e.nodeName) return e.href && e.host === hS.location.host
				var t = +e + 1
				return function (r) {
					if (r.href) {
						var n = hS.location + "",
							i = r + ""
						return MJ(n, t) === MJ(i, t)
					}
				}
			},
			":default": function (e) {
				return !!e.defaultSelected
			},
			":valid": function (e) {
				return e.willValidate || (e.validity && e.validity.valid)
			},
			":invalid": function (e) {
				return !Yi[":valid"](e)
			},
			":in-range": function (e) {
				return e.value > e.min && e.value <= e.max
			},
			":out-of-range": function (e) {
				return !Yi[":in-range"](e)
			},
			":required": function (e) {
				return !!e.required
			},
			":optional": function (e) {
				return !e.required
			},
			":read-only": function (e) {
				if (e.readOnly) return !0
				var t = e.getAttribute("contenteditable"),
					r = e.contentEditable,
					n = e.nodeName.toLowerCase()
				return (n = n !== "input" && n !== "textarea"), (n || e.disabled) && t == null && r !== "true"
			},
			":read-write": function (e) {
				return !Yi[":read-only"](e)
			},
			":hover": function () {
				throw new Error(":hover is not supported.")
			},
			":active": function () {
				throw new Error(":active is not supported.")
			},
			":link": function () {
				throw new Error(":link is not supported.")
			},
			":visited": function () {
				throw new Error(":visited is not supported.")
			},
			":column": function () {
				throw new Error(":column is not supported.")
			},
			":nth-column": function () {
				throw new Error(":nth-column is not supported.")
			},
			":nth-last-column": function () {
				throw new Error(":nth-last-column is not supported.")
			},
			":current": function () {
				throw new Error(":current is not supported.")
			},
			":past": function () {
				throw new Error(":past is not supported.")
			},
			":future": function () {
				throw new Error(":future is not supported.")
			},
			":contains": function (e) {
				return function (t) {
					var r = t.innerText || t.textContent || t.value || ""
					return r.indexOf(e) !== -1
				}
			},
			":has": function (e) {
				return function (t) {
					return NJ(e, t).length > 0
				}
			},
		},
		QJ = {
			"-": function () {
				return !0
			},
			"=": function (e, t) {
				return e === t
			},
			"*=": function (e, t) {
				return e.indexOf(t) !== -1
			},
			"~=": function (e, t) {
				var r, n, i, s
				for (n = 0; ; n = r + 1) {
					if (((r = e.indexOf(t, n)), r === -1)) return !1
					if (((i = e[r - 1]), (s = e[r + t.length]), (!i || i === " ") && (!s || s === " "))) return !0
				}
			},
			"|=": function (e, t) {
				var r = e.indexOf(t),
					n
				if (r === 0) return (n = e[r + t.length]), n === "-" || !n
			},
			"^=": function (e, t) {
				return e.indexOf(t) === 0
			},
			"$=": function (e, t) {
				var r = e.lastIndexOf(t)
				return r !== -1 && r + t.length === e.length
			},
			"!=": function (e, t) {
				return e !== t
			},
		},
		jv = {
			" ": function (e) {
				return function (t) {
					for (; (t = t.parentNode); ) if (e(t)) return t
				}
			},
			">": function (e) {
				return function (t) {
					if ((t = t.parentNode)) return e(t) && t
				}
			},
			"+": function (e) {
				return function (t) {
					if ((t = wm(t))) return e(t) && t
				}
			},
			"~": function (e) {
				return function (t) {
					for (; (t = wm(t)); ) if (e(t)) return t
				}
			},
			noop: function (e) {
				return function (t) {
					return e(t) && t
				}
			},
			ref: function (e, t) {
				var r
				function n(i) {
					for (var s = i.ownerDocument, o = s.getElementsByTagName("*"), a = o.length; a--; )
						if (((r = o[a]), n.test(i))) return (r = null), !0
					r = null
				}
				return (
					(n.combinator = function (i) {
						if (!(!r || !r.getAttribute)) {
							var s = r.getAttribute(t) || ""
							if ((s[0] === "#" && (s = s.substring(1)), s === i.id && e(r))) return r
						}
					}),
					n
				)
			},
		},
		mt = {
			escape: /\\(?:[^0-9A-Fa-f\r\n]|[0-9A-Fa-f]{1,6}[\r\n\t ]?)/g,
			str_escape: /(escape)|\\(\n|\r\n?|\f)/g,
			nonascii: /[\u00A0-\uFFFF]/,
			cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,
			qname: /^ *(cssid|\*)/,
			simple: /^(?:([.#]cssid)|pseudo|attr)/,
			ref: /^ *\/(cssid)\/ */,
			combinator: /^(?: +([^ \w*.#\\]) +|( )+|([^ \w*.#\\]))(?! *$)/,
			attr: /^\[(cssid)(?:([^\w]?=)(inside))?\]/,
			pseudo: /^(:cssid)(?:\((inside)\))?/,
			inside: /(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|<[^"'>]*>|\\["'>]|[^"'>])*/,
			ident: /^(cssid)$/,
		}
	mt.cssid = Qo(mt.cssid, "nonascii", mt.nonascii)
	mt.cssid = Qo(mt.cssid, "escape", mt.escape)
	mt.qname = Qo(mt.qname, "cssid", mt.cssid)
	mt.simple = Qo(mt.simple, "cssid", mt.cssid)
	mt.ref = Qo(mt.ref, "cssid", mt.cssid)
	mt.attr = Qo(mt.attr, "cssid", mt.cssid)
	mt.pseudo = Qo(mt.pseudo, "cssid", mt.cssid)
	mt.inside = Qo(mt.inside, `[^"'>]*`, mt.inside)
	mt.attr = Qo(mt.attr, "inside", FJ("\\[", "\\]"))
	mt.pseudo = Qo(mt.pseudo, "inside", FJ("\\(", "\\)"))
	mt.simple = Qo(mt.simple, "pseudo", mt.pseudo)
	mt.simple = Qo(mt.simple, "attr", mt.attr)
	mt.ident = Qo(mt.ident, "cssid", mt.cssid)
	mt.str_escape = Qo(mt.str_escape, "escape", mt.escape)
	/**
	 * The regular expression Zv is constructed from all the regular expressions
	 * above. It matches any of the following:
	 * - a CSS identifier (including escaped characters)
	 * - a CSS class selector (`.foo`)
	 * - a CSS id selector (`#foo`)
	 * - a CSS pseudo-class selector (`:hover`)
	 * - a CSS attribute selector (`[attr]`)
	 * - a CSS attribute selector with a value (`[attr="value"]`)
	 * - a CSS combinator selector (`>`, `+`, `~`, ` `)
	 * - a CSS reference selector (`/foo/`)
	 * @param {string} e - the input string to match against
	 * @returns {boolean} whether the input string matches one of the above
	 */
	var Zv = function (e) {
			for (var t = e.replace(/^\s+|\s+$/g, ""), r, n = [], i = [], s, o, a, l, c; t; ) {
				if ((a = mt.qname.exec(t))) (t = t.substring(a[0].length)), (o = Lf(a[1])), i.push(gS(o, !0))
				else if ((a = mt.simple.exec(t)))
					(t = t.substring(a[0].length)), (o = "*"), i.push(gS(o, !0)), i.push(gS(a))
				else throw new SyntaxError("Invalid selector.")
				for (; (a = mt.simple.exec(t)); ) (t = t.substring(a[0].length)), i.push(gS(a))
				if (
					(t[0] === "!" && ((t = t.substring(1)), (s = lPe()), (s.qname = o), i.push(s.simple)),
					(a = mt.ref.exec(t)))
				) {
					;(t = t.substring(a[0].length)), (c = jv.ref(CL(i), Lf(a[1]))), n.push(c.combinator), (i = [])
					continue
				}
				if ((a = mt.combinator.exec(t))) {
					if (((t = t.substring(a[0].length)), (l = a[1] || a[2] || a[3]), l === ",")) {
						n.push(jv.noop(CL(i)))
						break
					}
				} else l = "noop"
				if (!jv[l]) throw new SyntaxError("Bad combinator.")
				n.push(jv[l](CL(i))), (i = [])
			}
			return (
				(r = aPe(n)),
				(r.qname = o),
				(r.sel = t),
				s && ((s.lname = r.qname), (s.test = r), (s.qname = s.qname), (s.sel = r.sel), (r = s)),
				c && ((c.test = r), (c.qname = r.qname), (c.sel = r.sel), (r = c)),
				r
			)
		},
		gS = function (e, t) {
			if (t) return e === "*" ? Yi["*"] : Yi.type(e)
			if (e[1])
				return e[1][0] === "."
					? Yi.attr("class", "~=", Lf(e[1].substring(1)), !1)
					: Yi.attr("id", "=", Lf(e[1].substring(1)), !1)
			if (e[2]) return e[3] ? Yi[Lf(e[2])](kJ(e[3])) : Yi[Lf(e[2])]
			if (e[4]) {
				var r = e[6],
					n = /["'\s]\s*I$/i.test(r)
				return n && (r = r.replace(/\s*I$/i, "")), Yi.attr(Lf(e[4]), e[5] || "-", kJ(r), n)
			}
			throw new SyntaxError("Unknown Selector.")
		},
		CL = function (e) {
			var t = e.length,
				r
			return t < 2
				? e[0]
				: function (n) {
						if (n) {
							for (r = 0; r < t; r++) if (!e[r](n)) return
							return !0
						}
					}
		},
		aPe = function (e) {
			return e.length < 2
				? function (t) {
						return !!e[0](t)
					}
				: function (t) {
						for (var r = e.length; r--; ) if (!(t = e[r](t))) return
						return !0
					}
		},
		lPe = function () {
			var e
			function t(r) {
				for (var n = r.ownerDocument, i = n.getElementsByTagName(t.lname), s = i.length; s--; )
					if (t.test(i[s]) && e === r) return (e = null), !0
				e = null
			}
			return (
				(t.simple = function (r) {
					return (e = r), !0
				}),
				t
			)
		},
		vL = function (e) {
			for (var t = Zv(e), r = [t]; t.sel; ) (t = Zv(t.sel)), r.push(t)
			return r.length < 2
				? t
				: function (n) {
						for (var i = r.length, s = 0; s < i; s++) if (r[s](n)) return !0
					}
		},
		NJ = function (e, t) {
			for (var r = [], n = Zv(e), i = t.getElementsByTagName(n.qname), s = 0, o; (o = i[s++]); ) n(o) && r.push(o)
			if (n.sel) {
				for (; n.sel; )
					for (n = Zv(n.sel), i = t.getElementsByTagName(n.qname), s = 0; (o = i[s++]); )
						n(o) && sPe.call(r, o) === -1 && r.push(o)
				r.sort(rPe)
			}
			return r
		}
	PJ.exports = Im = function (e, t) {
		var r, n
		if (t.nodeType !== 11 && e.indexOf(" ") === -1) {
			if (
				e[0] === "#" &&
				t.rooted &&
				/^#[A-Z_][-A-Z0-9_]*$/i.test(e) &&
				t.doc._hasMultipleElementsWithId &&
				((r = e.substring(1)), !t.doc._hasMultipleElementsWithId(r))
			)
				return (n = t.doc.getElementById(r)), n ? [n] : []
			if (e[0] === "." && /^\.\w+$/.test(e)) return t.getElementsByClassName(e.substring(1))
			if (/^\w+$/.test(e)) return t.getElementsByTagName(e)
		}
		return NJ(e, t)
	}
	Im.selectors = Yi
	Im.operators = QJ
	Im.combinators = jv
	Im.matches = function (e, t) {
		var r = { sel: t }
		do if (((r = Zv(r.sel)), r(e))) return !0
		while (r.sel)
		return !1
	}
})
var mS = x((zbt, LJ) => {
	"use strict"
	var cPe = ps(),
		uPe = eL(),
		EL = function (e, t) {
			for (var r = e.createDocumentFragment(), n = 0; n < t.length; n++) {
				var i = t[n],
					s = i instanceof cPe
				r.appendChild(s ? i : e.createTextNode(String(i)))
			}
			return r
		},
		dPe = {
			after: {
				value: function () {
					var t = Array.prototype.slice.call(arguments),
						r = this.parentNode,
						n = this.nextSibling
					if (r !== null) {
						for (
							;
							n &&
							t.some(function (s) {
								return s === n
							});

						)
							n = n.nextSibling
						var i = EL(this.doc, t)
						r.insertBefore(i, n)
					}
				},
			},
			before: {
				value: function () {
					var t = Array.prototype.slice.call(arguments),
						r = this.parentNode,
						n = this.previousSibling
					if (r !== null) {
						for (
							;
							n &&
							t.some(function (o) {
								return o === n
							});

						)
							n = n.previousSibling
						var i = EL(this.doc, t),
							s = n ? n.nextSibling : r.firstChild
						r.insertBefore(i, s)
					}
				},
			},
			remove: {
				value: function () {
					this.parentNode !== null &&
						(this.doc &&
							(this.doc._preremoveNodeIterators(this), this.rooted && this.doc.mutateRemove(this)),
						this._remove(),
						(this.parentNode = null))
				},
			},
			_remove: {
				value: function () {
					var t = this.parentNode
					t !== null &&
						(t._childNodes
							? t._childNodes.splice(this.index, 1)
							: t._firstChild === this &&
								(this._nextSibling === this
									? (t._firstChild = null)
									: (t._firstChild = this._nextSibling)),
						uPe.remove(this),
						t.modify())
				},
			},
			replaceWith: {
				value: function () {
					var t = Array.prototype.slice.call(arguments),
						r = this.parentNode,
						n = this.nextSibling
					if (r !== null) {
						for (
							;
							n &&
							t.some(function (s) {
								return s === n
							});

						)
							n = n.nextSibling
						var i = EL(this.doc, t)
						this.parentNode === r ? r.replaceChild(i, this) : r.insertBefore(i, n)
					}
				},
			},
		}
	LJ.exports = dPe
})
var bL = x((jbt, OJ) => {
	"use strict"
	var UJ = ps(),
		fPe = {
			nextElementSibling: {
				get: function () {
					if (this.parentNode) {
						for (var e = this.nextSibling; e !== null; e = e.nextSibling)
							if (e.nodeType === UJ.ELEMENT_NODE) return e
					}
					return null
				},
			},
			previousElementSibling: {
				get: function () {
					if (this.parentNode) {
						for (var e = this.previousSibling; e !== null; e = e.previousSibling)
							if (e.nodeType === UJ.ELEMENT_NODE) return e
					}
					return null
				},
			},
		}
	OJ.exports = fPe
})
var xL = x((Zbt, VJ) => {
	"use strict"
	VJ.exports = qJ
	var Sm = ei()
	function qJ(e) {
		this.element = e
	}
	Object.defineProperties(qJ.prototype, {
		length: { get: Sm.shouldOverride },
		item: { value: Sm.shouldOverride },
		getNamedItem: {
			value: function (t) {
				return this.element.getAttributeNode(t)
			},
		},
		getNamedItemNS: {
			value: function (t, r) {
				return this.element.getAttributeNodeNS(t, r)
			},
		},
		setNamedItem: { value: Sm.nyi },
		setNamedItemNS: { value: Sm.nyi },
		removeNamedItem: {
			value: function (t) {
				var r = this.element.getAttributeNode(t)
				if (r) return this.element.removeAttribute(t), r
				Sm.NotFoundError()
			},
		},
		removeNamedItemNS: {
			value: function (t, r) {
				var n = this.element.getAttributeNodeNS(t, r)
				if (n) return this.element.removeAttributeNS(t, r), n
				Sm.NotFoundError()
			},
		},
	})
})
/**
 * We polyfill the `NamedNodeMap` API for SVG elements. This is needed because
 * SVG elements don't have a `NamedNodeMap` property, but we need it to be able
 * to use the `getAttributeNode` method.
 */
var Dm = x((Xbt, YJ) => {
	"use strict"
	YJ.exports = Uf
	var _L = fS(),
		qn = ei(),
		jc = qn.NAMESPACE,
		CS = pL(),
		ec = ps(),
		wL = Kg(),
		hPe = tL(),
		yS = BJ(),
		Bm = aS(),
		gPe = mL(),
		IL = AS(),
		WJ = dS(),
		pPe = mS(),
		APe = bL(),
		GJ = xL(),
		HJ = Object.create(null)
	function Uf(e, t, r, n) {
		WJ.call(this),
			(this.nodeType = ec.ELEMENT_NODE),
			(this.ownerDocument = e),
			(this.localName = t),
			(this.namespaceURI = r),
			(this.prefix = n),
			(this._tagName = void 0),
			(this._attrsByQName = Object.create(null)),
			(this._attrsByLName = Object.create(null)),
			(this._attrKeys = [])
	}
	function SL(e, t) {
		if (e.nodeType === ec.TEXT_NODE) t.push(e._data)
		else for (var r = 0, n = e.childNodes.length; r < n; r++) SL(e.childNodes[r], t)
	}
	Uf.prototype = Object.create(WJ.prototype, {
		isHTML: {
			get: function () {
				return this.namespaceURI === jc.HTML && this.ownerDocument.isHTML
			},
		},
		tagName: {
			get: function () {
				if (this._tagName === void 0) {
					var t
					if (
						(this.prefix === null ? (t = this.localName) : (t = this.prefix + ":" + this.localName),
						this.isHTML)
					) {
						var r = HJ[t]
						r || (HJ[t] = r = qn.toASCIIUpperCase(t)), (t = r)
					}
					this._tagName = t
				}
				return this._tagName
			},
		},
		nodeName: {
			get: function () {
				return this.tagName
			},
		},
		nodeValue: {
			get: function () {
				return null
			},
			set: function () {},
		},
		textContent: {
			get: function () {
				var e = []
				return SL(this, e), e.join("")
			},
			set: function (e) {
				this.removeChildren(), e != null && e !== "" && this._appendChild(this.ownerDocument.createTextNode(e))
			},
		},
		innerText: {
			get: function () {
				var e = []
				return (
					SL(this, e),
					e
						.join("")
						.replace(/[ \t\n\f\r]+/g, " ")
						.trim()
				)
			},
			set: function (e) {
				this.removeChildren(), e != null && e !== "" && this._appendChild(this.ownerDocument.createTextNode(e))
			},
		},
		innerHTML: {
			get: function () {
				return this.serialize()
			},
			set: qn.nyi,
		},
		outerHTML: {
			get: function () {
				return hPe.serializeOne(this, { nodeType: 0 })
			},
			set: function (e) {
				var t = this.ownerDocument,
					r = this.parentNode
				if (r !== null) {
					r.nodeType === ec.DOCUMENT_NODE && qn.NoModificationAllowedError(),
						r.nodeType === ec.DOCUMENT_FRAGMENT_NODE && (r = r.ownerDocument.createElement("body"))
					var n = t.implementation.mozHTMLParser(t._address, r)
					n.parse(e === null ? "" : String(e), !0), this.replaceWith(n._asDocumentFragment())
				}
			},
		},
		_insertAdjacent: {
			value: function (t, r) {
				var n = !1
				switch (t) {
					case "beforebegin":
						n = !0
					case "afterend":
						var i = this.parentNode
						return i === null ? null : i.insertBefore(r, n ? this : this.nextSibling)
					case "afterbegin":
						n = !0
					case "beforeend":
						return this.insertBefore(r, n ? this.firstChild : null)
					default:
						return qn.SyntaxError()
				}
			},
		},
		insertAdjacentElement: {
			value: function (t, r) {
				if (r.nodeType !== ec.ELEMENT_NODE) throw new TypeError("not an element")
				return (t = qn.toASCIILowerCase(String(t))), this._insertAdjacent(t, r)
			},
		},
		insertAdjacentText: {
			value: function (t, r) {
				var n = this.ownerDocument.createTextNode(r)
				;(t = qn.toASCIILowerCase(String(t))), this._insertAdjacent(t, n)
			},
		},
		insertAdjacentHTML: {
			value: function (t, r) {
				;(t = qn.toASCIILowerCase(String(t))), (r = String(r))
				var n
				switch (t) {
					case "beforebegin":
					case "afterend":
						;(n = this.parentNode),
							(n === null || n.nodeType === ec.DOCUMENT_NODE) && qn.NoModificationAllowedError()
						break
					case "afterbegin":
					case "beforeend":
						n = this
						break
					default:
						qn.SyntaxError()
				}
				;(!(n instanceof Uf) ||
					(n.ownerDocument.isHTML && n.localName === "html" && n.namespaceURI === jc.HTML)) &&
					(n = n.ownerDocument.createElementNS(jc.HTML, "body"))
				var i = this.ownerDocument.implementation.mozHTMLParser(this.ownerDocument._address, n)
				i.parse(r, !0), this._insertAdjacent(t, i._asDocumentFragment())
			},
		},
		children: {
			get: function () {
				return this._children || (this._children = new $J(this)), this._children
			},
		},
		attributes: {
			get: function () {
				return this._attributes || (this._attributes = new DL(this)), this._attributes
			},
		},
		firstElementChild: {
			get: function () {
				for (var e = this.firstChild; e !== null; e = e.nextSibling)
					if (e.nodeType === ec.ELEMENT_NODE) return e
				return null
			},
		},
		lastElementChild: {
			get: function () {
				for (var e = this.lastChild; e !== null; e = e.previousSibling)
					if (e.nodeType === ec.ELEMENT_NODE) return e
				return null
			},
		},
		childElementCount: {
			get: function () {
				return this.children.length
			},
		},
		nextElement: {
			value: function (e) {
				e || (e = this.ownerDocument.documentElement)
				var t = this.firstElementChild
				if (!t) {
					if (this === e) return null
					t = this.nextElementSibling
				}
				if (t) return t
				for (var r = this.parentElement; r && r !== e; r = r.parentElement)
					if (((t = r.nextElementSibling), t)) return t
				return null
			},
		},
		getElementsByTagName: {
			value: function (t) {
				var r
				return t
					? (t === "*"
							? (r = function () {
									return !0
								})
							: this.isHTML
								? (r = mPe(t))
								: (r = BL(t)),
						new yS(this, r))
					: new wL()
			},
		},
		getElementsByTagNameNS: {
			value: function (t, r) {
				var n
				return (
					t === "*" && r === "*"
						? (n = function () {
								return !0
							})
						: t === "*"
							? (n = BL(r))
							: r === "*"
								? (n = yPe(t))
								: (n = CPe(t, r)),
					new yS(this, n)
				)
			},
		},
		getElementsByClassName: {
			value: function (t) {
				if (((t = String(t).trim()), t === "")) {
					var r = new wL()
					return r
				}
				return (t = t.split(/[ \t\r\n\f]+/)), new yS(this, vPe(t))
			},
		},
		getElementsByName: {
			value: function (t) {
				return new yS(this, EPe(String(t)))
			},
		},
		clone: {
			value: function () {
				var t
				this.namespaceURI !== jc.HTML || this.prefix || !this.ownerDocument.isHTML
					? (t = this.ownerDocument.createElementNS(
							this.namespaceURI,
							this.prefix !== null ? this.prefix + ":" + this.localName : this.localName,
						))
					: (t = this.ownerDocument.createElement(this.localName))
				for (var r = 0, n = this._attrKeys.length; r < n; r++) {
					var i = this._attrKeys[r],
						s = this._attrsByLName[i],
						o = s.cloneNode()
					o._setOwnerElement(t), (t._attrsByLName[i] = o), t._addQName(o)
				}
				return (t._attrKeys = this._attrKeys.concat()), t
			},
		},
		isEqual: {
			value: function (t) {
				if (
					this.localName !== t.localName ||
					this.namespaceURI !== t.namespaceURI ||
					this.prefix !== t.prefix ||
					this._numattrs !== t._numattrs
				)
					return !1
				for (var r = 0, n = this._numattrs; r < n; r++) {
					var i = this._attr(r)
					if (
						!t.hasAttributeNS(i.namespaceURI, i.localName) ||
						t.getAttributeNS(i.namespaceURI, i.localName) !== i.value
					)
						return !1
				}
				return !0
			},
		},
		_lookupNamespacePrefix: {
			value: function (t, r) {
				if (
					this.namespaceURI &&
					this.namespaceURI === t &&
					this.prefix !== null &&
					r.lookupNamespaceURI(this.prefix) === t
				)
					return this.prefix
				for (var n = 0, i = this._numattrs; n < i; n++) {
					var s = this._attr(n)
					if (s.prefix === "xmlns" && s.value === t && r.lookupNamespaceURI(s.localName) === t)
						return s.localName
				}
				var o = this.parentElement
				return o ? o._lookupNamespacePrefix(t, r) : null
			},
		},
		lookupNamespaceURI: {
			value: function (t) {
				if (((t === "" || t === void 0) && (t = null), this.namespaceURI !== null && this.prefix === t))
					return this.namespaceURI
				for (var r = 0, n = this._numattrs; r < n; r++) {
					var i = this._attr(r)
					if (
						i.namespaceURI === jc.XMLNS &&
						((i.prefix === "xmlns" && i.localName === t) ||
							(t === null && i.prefix === null && i.localName === "xmlns"))
					)
						return i.value || null
				}
				var s = this.parentElement
				return s ? s.lookupNamespaceURI(t) : null
			},
		},
		getAttribute: {
			value: function (t) {
				var r = this.getAttributeNode(t)
				return r ? r.value : null
			},
		},
		getAttributeNS: {
			value: function (t, r) {
				var n = this.getAttributeNodeNS(t, r)
				return n ? n.value : null
			},
		},
		getAttributeNode: {
			value: function (t) {
				;(t = String(t)), /[A-Z]/.test(t) && this.isHTML && (t = qn.toASCIILowerCase(t))
				var r = this._attrsByQName[t]
				return r ? (Array.isArray(r) && (r = r[0]), r) : null
			},
		},
		getAttributeNodeNS: {
			value: function (t, r) {
				;(t = t == null ? "" : String(t)), (r = String(r))
				var n = this._attrsByLName[t + "|" + r]
				return n || null
			},
		},
		hasAttribute: {
			value: function (t) {
				return (
					(t = String(t)),
					/[A-Z]/.test(t) && this.isHTML && (t = qn.toASCIILowerCase(t)),
					this._attrsByQName[t] !== void 0
				)
			},
		},
		hasAttributeNS: {
			value: function (t, r) {
				;(t = t == null ? "" : String(t)), (r = String(r))
				var n = t + "|" + r
				return this._attrsByLName[n] !== void 0
			},
		},
		hasAttributes: {
			value: function () {
				return this._numattrs > 0
			},
		},
		toggleAttribute: {
			value: function (t, r) {
				;(t = String(t)),
					_L.isValidName(t) || qn.InvalidCharacterError(),
					/[A-Z]/.test(t) && this.isHTML && (t = qn.toASCIILowerCase(t))
				var n = this._attrsByQName[t]
				return n === void 0
					? r === void 0 || r === !0
						? (this._setAttribute(t, ""), !0)
						: !1
					: r === void 0 || r === !1
						? (this.removeAttribute(t), !1)
						: !0
			},
		},
		_setAttribute: {
			value: function (t, r) {
				var n = this._attrsByQName[t],
					i
				n ? Array.isArray(n) && (n = n[0]) : ((n = this._newattr(t)), (i = !0)),
					(n.value = r),
					this._attributes && (this._attributes[t] = n),
					i && this._newattrhook && this._newattrhook(t, r)
			},
		},
		setAttribute: {
			value: function (t, r) {
				;(t = String(t)),
					_L.isValidName(t) || qn.InvalidCharacterError(),
					/[A-Z]/.test(t) && this.isHTML && (t = qn.toASCIILowerCase(t)),
					this._setAttribute(t, String(r))
			},
		},
		_setAttributeNS: {
			value: function (t, r, n) {
				var i = r.indexOf(":"),
					s,
					o
				i < 0 ? ((s = null), (o = r)) : ((s = r.substring(0, i)), (o = r.substring(i + 1))),
					(t === "" || t === void 0) && (t = null)
				var a = (t === null ? "" : t) + "|" + o,
					l = this._attrsByLName[a],
					c
				l ||
					((l = new Xv(this, o, s, t)),
					(c = !0),
					(this._attrsByLName[a] = l),
					this._attributes && (this._attributes[this._attrKeys.length] = l),
					this._attrKeys.push(a),
					this._addQName(l)),
					(l.value = n),
					c && this._newattrhook && this._newattrhook(r, n)
			},
		},
		setAttributeNS: {
			value: function (t, r, n) {
				;(t = t == null || t === "" ? null : String(t)),
					(r = String(r)),
					_L.isValidQName(r) || qn.InvalidCharacterError()
				var i = r.indexOf(":"),
					s = i < 0 ? null : r.substring(0, i)
				;((s !== null && t === null) ||
					(s === "xml" && t !== jc.XML) ||
					((r === "xmlns" || s === "xmlns") && t !== jc.XMLNS) ||
					(t === jc.XMLNS && !(r === "xmlns" || s === "xmlns"))) &&
					qn.NamespaceError(),
					this._setAttributeNS(t, r, String(n))
			},
		},
		setAttributeNode: {
			value: function (t) {
				if (t.ownerElement !== null && t.ownerElement !== this) throw new Bm(Bm.INUSE_ATTRIBUTE_ERR)
				var r = null,
					n = this._attrsByQName[t.name]
				if (n) {
					if (
						(Array.isArray(n) || (n = [n]),
						n.some(function (i) {
							return i === t
						}))
					)
						return t
					if (t.ownerElement !== null) throw new Bm(Bm.INUSE_ATTRIBUTE_ERR)
					n.forEach(function (i) {
						this.removeAttributeNode(i)
					}, this),
						(r = n[0])
				}
				return this.setAttributeNodeNS(t), r
			},
		},
		setAttributeNodeNS: {
			value: function (t) {
				if (t.ownerElement !== null) throw new Bm(Bm.INUSE_ATTRIBUTE_ERR)
				var r = t.namespaceURI,
					n = (r === null ? "" : r) + "|" + t.localName,
					i = this._attrsByLName[n]
				return (
					i && this.removeAttributeNode(i),
					t._setOwnerElement(this),
					(this._attrsByLName[n] = t),
					this._attributes && (this._attributes[this._attrKeys.length] = t),
					this._attrKeys.push(n),
					this._addQName(t),
					this._newattrhook && this._newattrhook(t.name, t.value),
					i || null
				)
			},
		},
		removeAttribute: {
			value: function (t) {
				;(t = String(t)), /[A-Z]/.test(t) && this.isHTML && (t = qn.toASCIILowerCase(t))
				var r = this._attrsByQName[t]
				if (r) {
					Array.isArray(r)
						? r.length > 2
							? (r = r.shift())
							: ((this._attrsByQName[t] = r[1]), (r = r[0]))
						: (this._attrsByQName[t] = void 0)
					var n = r.namespaceURI,
						i = (n === null ? "" : n) + "|" + r.localName
					this._attrsByLName[i] = void 0
					var s = this._attrKeys.indexOf(i)
					this._attributes &&
						(Array.prototype.splice.call(this._attributes, s, 1), (this._attributes[t] = void 0)),
						this._attrKeys.splice(s, 1)
					var o = r.onchange
					r._setOwnerElement(null),
						o && o.call(r, this, r.localName, r.value, null),
						this.rooted && this.ownerDocument.mutateRemoveAttr(r)
				}
			},
		},
		removeAttributeNS: {
			value: function (t, r) {
				;(t = t == null ? "" : String(t)), (r = String(r))
				var n = t + "|" + r,
					i = this._attrsByLName[n]
				if (i) {
					this._attrsByLName[n] = void 0
					var s = this._attrKeys.indexOf(n)
					this._attributes && Array.prototype.splice.call(this._attributes, s, 1),
						this._attrKeys.splice(s, 1),
						this._removeQName(i)
					var o = i.onchange
					i._setOwnerElement(null),
						o && o.call(i, this, i.localName, i.value, null),
						this.rooted && this.ownerDocument.mutateRemoveAttr(i)
				}
			},
		},
		removeAttributeNode: {
			value: function (t) {
				var r = t.namespaceURI,
					n = (r === null ? "" : r) + "|" + t.localName
				return this._attrsByLName[n] !== t && qn.NotFoundError(), this.removeAttributeNS(r, t.localName), t
			},
		},
		getAttributeNames: {
			value: function () {
				var t = this
				return this._attrKeys.map(function (r) {
					return t._attrsByLName[r].name
				})
			},
		},
		_getattr: {
			value: function (t) {
				var r = this._attrsByQName[t]
				return r ? r.value : null
			},
		},
		_setattr: {
			value: function (t, r) {
				var n = this._attrsByQName[t],
					i
				n || ((n = this._newattr(t)), (i = !0)),
					(n.value = String(r)),
					this._attributes && (this._attributes[t] = n),
					i && this._newattrhook && this._newattrhook(t, r)
			},
		},
		_newattr: {
			value: function (t) {
				var r = new Xv(this, t, null, null),
					n = "|" + t
				return (
					(this._attrsByQName[t] = r),
					(this._attrsByLName[n] = r),
					this._attributes && (this._attributes[this._attrKeys.length] = r),
					this._attrKeys.push(n),
					r
				)
			},
		},
		_addQName: {
			value: function (e) {
				var t = e.name,
					r = this._attrsByQName[t]
				r ? (Array.isArray(r) ? r.push(e) : (this._attrsByQName[t] = [r, e])) : (this._attrsByQName[t] = e),
					this._attributes && (this._attributes[t] = e)
			},
		},
		_removeQName: {
			value: function (e) {
				var t = e.name,
					r = this._attrsByQName[t]
				if (Array.isArray(r)) {
					var n = r.indexOf(e)
					qn.assert(n !== -1),
						r.length === 2
							? ((this._attrsByQName[t] = r[1 - n]),
								this._attributes && (this._attributes[t] = this._attrsByQName[t]))
							: (r.splice(n, 1),
								this._attributes && this._attributes[t] === e && (this._attributes[t] = r[0]))
				} else
					qn.assert(r === e),
						(this._attrsByQName[t] = void 0),
						this._attributes && (this._attributes[t] = void 0)
			},
		},
		_numattrs: {
			get: function () {
				return this._attrKeys.length
			},
		},
		_attr: {
			value: function (e) {
				return this._attrsByLName[this._attrKeys[e]]
			},
		},
		id: CS.property({ name: "id" }),
		className: CS.property({ name: "class" }),
		classList: {
			get: function () {
				var e = this
				if (this._classList) return this._classList
				var t = new gPe(
					function () {
						return e.className || ""
					},
					function (r) {
						e.className = r
					},
				)
				return (this._classList = t), t
			},
			set: function (e) {
				this.className = e
			},
		},
		matches: {
			value: function (e) {
				return IL.matches(this, e)
			},
		},
		closest: {
			value: function (e) {
				var t = this
				do {
					if (t.matches && t.matches(e)) return t
					t = t.parentElement || t.parentNode
				} while (t !== null && t.nodeType === ec.ELEMENT_NODE)
				return null
			},
		},
		querySelector: {
			value: function (e) {
				return IL(e, this)[0]
			},
		},
		querySelectorAll: {
			value: function (e) {
				var t = IL(e, this)
				return t.item ? t : new wL(t)
			},
		},
	})
	Object.defineProperties(Uf.prototype, pPe)
	Object.defineProperties(Uf.prototype, APe)
	CS.registerChangeHandler(Uf, "id", function (e, t, r, n) {
		e.rooted && (r && e.ownerDocument.delId(r, e), n && e.ownerDocument.addId(n, e))
	})
	CS.registerChangeHandler(Uf, "class", function (e, t, r, n) {
		e._classList && e._classList._update()
	})
	function Xv(e, t, r, n, i) {
		;(this.localName = t),
			(this.prefix = r === null || r === "" ? null : "" + r),
			(this.namespaceURI = n === null || n === "" ? null : "" + n),
			(this.data = i),
			this._setOwnerElement(e)
	}
	Xv.prototype = Object.create(Object.prototype, {
		ownerElement: {
			get: function () {
				return this._ownerElement
			},
		},
		_setOwnerElement: {
			value: function (t) {
				;(this._ownerElement = t),
					this.prefix === null && this.namespaceURI === null && t
						? (this.onchange = t._attributeChangeHandlers[this.localName])
						: (this.onchange = null)
			},
		},
		name: {
			get: function () {
				return this.prefix ? this.prefix + ":" + this.localName : this.localName
			},
		},
		specified: {
			get: function () {
				return !0
			},
		},
		value: {
			get: function () {
				return this.data
			},
			set: function (e) {
				var t = this.data
				;(e = e === void 0 ? "" : e + ""),
					e !== t &&
						((this.data = e),
						this.ownerElement &&
							(this.onchange && this.onchange(this.ownerElement, this.localName, t, e),
							this.ownerElement.rooted && this.ownerElement.ownerDocument.mutateAttr(this, t)))
			},
		},
		cloneNode: {
			value: function (t) {
				return new Xv(null, this.localName, this.prefix, this.namespaceURI, this.data)
			},
		},
		nodeType: {
			get: function () {
				return ec.ATTRIBUTE_NODE
			},
		},
		nodeName: {
			get: function () {
				return this.name
			},
		},
		nodeValue: {
			get: function () {
				return this.value
			},
			set: function (e) {
				this.value = e
			},
		},
		textContent: {
			get: function () {
				return this.value
			},
			set: function (e) {
				e == null && (e = ""), (this.value = e)
			},
		},
		innerText: {
			get: function () {
				return this.value
			},
			set: function (e) {
				e == null && (e = ""), (this.value = e)
			},
		},
	})
	Uf._Attr = Xv
	function DL(e) {
		GJ.call(this, e)
		for (var t in e._attrsByQName) this[t] = e._attrsByQName[t]
		for (var r = 0; r < e._attrKeys.length; r++) this[r] = e._attrsByLName[e._attrKeys[r]]
	}
	DL.prototype = Object.create(GJ.prototype, {
		length: {
			get: function () {
				return this.element._attrKeys.length
			},
			set: function () {},
		},
		item: {
			value: function (e) {
				return (e = e >>> 0), e >= this.length ? null : this.element._attrsByLName[this.element._attrKeys[e]]
			},
		},
	})
	globalThis.Symbol?.iterator &&
		(DL.prototype[globalThis.Symbol.iterator] = function () {
			var e = 0,
				t = this.length,
				r = this
			return {
				next: function () {
					return e < t ? { value: r.item(e++) } : { done: !0 }
				},
			}
		})
	function $J(e) {
		;(this.element = e), this.updateCache()
	}
	$J.prototype = Object.create(Object.prototype, {
		length: {
			get: function () {
				return this.updateCache(), this.childrenByNumber.length
			},
		},
		item: {
			value: function (t) {
				return this.updateCache(), this.childrenByNumber[t] || null
			},
		},
		namedItem: {
			value: function (t) {
				return this.updateCache(), this.childrenByName[t] || null
			},
		},
		namedItems: {
			get: function () {
				return this.updateCache(), this.childrenByName
			},
		},
		updateCache: {
			value: function () {
				var t = /^(a|applet|area|embed|form|frame|frameset|iframe|img|object)$/
				if (this.lastModTime !== this.element.lastModTime) {
					this.lastModTime = this.element.lastModTime
					for (var r = (this.childrenByNumber && this.childrenByNumber.length) || 0, n = 0; n < r; n++)
						this[n] = void 0
					;(this.childrenByNumber = []), (this.childrenByName = Object.create(null))
					for (var i = this.element.firstChild; i !== null; i = i.nextSibling)
						if (i.nodeType === ec.ELEMENT_NODE) {
							;(this[this.childrenByNumber.length] = i), this.childrenByNumber.push(i)
							var s = i.getAttribute("id")
							s && !this.childrenByName[s] && (this.childrenByName[s] = i)
							var o = i.getAttribute("name")
							o &&
								this.element.namespaceURI === jc.HTML &&
								t.test(this.element.localName) &&
								!this.childrenByName[o] &&
								(this.childrenByName[s] = i)
						}
				}
			},
		},
	})
	function BL(e) {
		return function (t) {
			return t.localName === e
		}
	}
	function mPe(e) {
		var t = qn.toASCIILowerCase(e)
		return t === e
			? BL(e)
			: function (r) {
					return r.isHTML ? r.localName === t : r.localName === e
				}
	}
	function yPe(e) {
		return function (t) {
			return t.namespaceURI === e
		}
	}
	function CPe(e, t) {
		return function (r) {
			return r.namespaceURI === e && r.localName === t
		}
	}
	function vPe(e) {
		return function (t) {
			return e.every(function (r) {
				return t.classList.contains(r)
			})
		}
	}
	function EPe(e) {
		return function (t) {
			return t.namespaceURI !== jc.HTML ? !1 : t.getAttribute("name") === e
		}
	}
})
var TL = x((ext, ZJ) => {
	"use strict"
	ZJ.exports = jJ
	var JJ = ps(),
		bPe = Kg(),
		zJ = ei(),
		KJ = zJ.HierarchyRequestError,
		xPe = zJ.NotFoundError
	function jJ() {
		JJ.call(this)
	}
	jJ.prototype = Object.create(JJ.prototype, {
		hasChildNodes: {
			value: function () {
				return !1
			},
		},
		firstChild: { value: null },
		lastChild: { value: null },
		insertBefore: {
			value: function (e, t) {
				if (!e.nodeType) throw new TypeError("not a node")
				KJ()
			},
		},
		replaceChild: {
			value: function (e, t) {
				if (!e.nodeType) throw new TypeError("not a node")
				KJ()
			},
		},
		removeChild: {
			value: function (e) {
				if (!e.nodeType) throw new TypeError("not a node")
				xPe()
			},
		},
		removeChildren: { value: function () {} },
		childNodes: {
			get: function () {
				return this._childNodes || (this._childNodes = new bPe()), this._childNodes
			},
		},
	})
})
var eE = x((txt, tz) => {
	"use strict"
	tz.exports = vS
	var ez = TL(),
		XJ = ei(),
		_Pe = mS(),
		wPe = bL()
	function vS() {
		ez.call(this)
	}
	vS.prototype = Object.create(ez.prototype, {
		substringData: {
			value: function (t, r) {
				if (arguments.length < 2) throw new TypeError("Not enough arguments")
				return (
					(t = t >>> 0),
					(r = r >>> 0),
					(t > this.data.length || t < 0 || r < 0) && XJ.IndexSizeError(),
					this.data.substring(t, t + r)
				)
			},
		},
		appendData: {
			value: function (t) {
				if (arguments.length < 1) throw new TypeError("Not enough arguments")
				this.data += String(t)
			},
		},
		insertData: {
			value: function (t, r) {
				return this.replaceData(t, 0, r)
			},
		},
		deleteData: {
			value: function (t, r) {
				return this.replaceData(t, r, "")
			},
		},
		replaceData: {
			value: function (t, r, n) {
				var i = this.data,
					s = i.length
				;(t = t >>> 0),
					(r = r >>> 0),
					(n = String(n)),
					(t > s || t < 0) && XJ.IndexSizeError(),
					t + r > s && (r = s - t)
				var o = i.substring(0, t),
					a = i.substring(t + r)
				this.data = o + n + a
			},
		},
		isEqual: {
			value: function (t) {
				return this._data === t._data
			},
		},
		length: {
			get: function () {
				return this.data.length
			},
		},
	})
	Object.defineProperties(vS.prototype, _Pe)
	Object.defineProperties(vS.prototype, wPe)
})
var kL = x((rxt, sz) => {
	"use strict"
	sz.exports = RL
	var rz = ei(),
		nz = ps(),
		iz = eE()
	function RL(e, t) {
		iz.call(this),
			(this.nodeType = nz.TEXT_NODE),
			(this.ownerDocument = e),
			(this._data = t),
			(this._index = void 0)
	}
	var tE = {
		get: function () {
			return this._data
		},
		set: function (e) {
			e == null ? (e = "") : (e = String(e)),
				e !== this._data &&
					((this._data = e),
					this.rooted && this.ownerDocument.mutateValue(this),
					this.parentNode && this.parentNode._textchangehook && this.parentNode._textchangehook(this))
		},
	}
	RL.prototype = Object.create(iz.prototype, {
		nodeName: { value: "#text" },
		nodeValue: tE,
		textContent: tE,
		innerText: tE,
		data: {
			get: tE.get,
			set: function (e) {
				tE.set.call(this, e === null ? "" : String(e))
			},
		},
		splitText: {
			value: function (t) {
				;(t > this._data.length || t < 0) && rz.IndexSizeError()
				var r = this._data.substring(t),
					n = this.ownerDocument.createTextNode(r)
				this.data = this.data.substring(0, t)
				var i = this.parentNode
				return i !== null && i.insertBefore(n, this.nextSibling), n
			},
		},
		wholeText: {
			get: function () {
				for (
					var t = this.textContent, r = this.nextSibling;
					r && r.nodeType === nz.TEXT_NODE;
					r = r.nextSibling
				)
					t += r.textContent
				return t
			},
		},
		replaceWholeText: { value: rz.nyi },
		clone: {
			value: function () {
				return new RL(this.ownerDocument, this._data)
			},
		},
	})
})
var FL = x((nxt, az) => {
	"use strict"
	az.exports = ML
	var IPe = ps(),
		oz = eE()
	function ML(e, t) {
		oz.call(this), (this.nodeType = IPe.COMMENT_NODE), (this.ownerDocument = e), (this._data = t)
	}
	var rE = {
		get: function () {
			return this._data
		},
		set: function (e) {
			e == null ? (e = "") : (e = String(e)),
				(this._data = e),
				this.rooted && this.ownerDocument.mutateValue(this)
		},
	}
	ML.prototype = Object.create(oz.prototype, {
		nodeName: { value: "#comment" },
		nodeValue: rE,
		textContent: rE,
		innerText: rE,
		data: {
			get: rE.get,
			set: function (e) {
				rE.set.call(this, e === null ? "" : String(e))
			},
		},
		clone: {
			value: function () {
				return new ML(this.ownerDocument, this._data)
			},
		},
	})
})
var NL = x((ixt, uz) => {
	"use strict"
	uz.exports = QL
	var SPe = ps(),
		BPe = Kg(),
		cz = dS(),
		ES = Dm(),
		DPe = AS(),
		lz = ei()
	function QL(e) {
		cz.call(this), (this.nodeType = SPe.DOCUMENT_FRAGMENT_NODE), (this.ownerDocument = e)
	}
	QL.prototype = Object.create(cz.prototype, {
		nodeName: { value: "#document-fragment" },
		nodeValue: {
			get: function () {
				return null
			},
			set: function () {},
		},
		textContent: Object.getOwnPropertyDescriptor(ES.prototype, "textContent"),
		innerText: Object.getOwnPropertyDescriptor(ES.prototype, "innerText"),
		querySelector: {
			value: function (e) {
				var t = this.querySelectorAll(e)
				return t.length ? t[0] : null
			},
		},
		querySelectorAll: {
			value: function (e) {
				var t = Object.create(this)
				;(t.isHTML = !0),
					(t.getElementsByTagName = ES.prototype.getElementsByTagName),
					(t.nextElement = Object.getOwnPropertyDescriptor(ES.prototype, "firstElementChild").get)
				var r = DPe(e, t)
				return r.item ? r : new BPe(r)
			},
		},
		clone: {
			value: function () {
				return new QL(this.ownerDocument)
			},
		},
		isEqual: {
			value: function (t) {
				return !0
			},
		},
		innerHTML: {
			get: function () {
				return this.serialize()
			},
			set: lz.nyi,
		},
		outerHTML: {
			get: function () {
				return this.serialize()
			},
			set: lz.nyi,
		},
	})
})
var LL = x((sxt, fz) => {
	"use strict"
	fz.exports = PL
	var TPe = ps(),
		dz = eE()
	function PL(e, t, r) {
		dz.call(this),
			(this.nodeType = TPe.PROCESSING_INSTRUCTION_NODE),
			(this.ownerDocument = e),
			(this.target = t),
			(this._data = r)
	}
	var nE = {
		get: function () {
			return this._data
		},
		set: function (e) {
			e == null ? (e = "") : (e = String(e)),
				(this._data = e),
				this.rooted && this.ownerDocument.mutateValue(this)
		},
	}
	PL.prototype = Object.create(dz.prototype, {
		nodeName: {
			get: function () {
				return this.target
			},
		},
		nodeValue: nE,
		textContent: nE,
		innerText: nE,
		data: {
			get: nE.get,
			set: function (e) {
				nE.set.call(this, e === null ? "" : String(e))
			},
		},
		clone: {
			value: function () {
				return new PL(this.ownerDocument, this.target, this._data)
			},
		},
		isEqual: {
			value: function (t) {
				return this.target === t.target && this._data === t._data
			},
		},
	})
})
var iE = x((oxt, hz) => {
	"use strict"
	var UL = {
		FILTER_ACCEPT: 1,
		FILTER_REJECT: 2,
		FILTER_SKIP: 3,
		SHOW_ALL: 4294967295,
		SHOW_ELEMENT: 1,
		SHOW_ATTRIBUTE: 2,
		SHOW_TEXT: 4,
		SHOW_CDATA_SECTION: 8,
		SHOW_ENTITY_REFERENCE: 16,
		SHOW_ENTITY: 32,
		SHOW_PROCESSING_INSTRUCTION: 64,
		SHOW_COMMENT: 128,
		SHOW_DOCUMENT: 256,
		SHOW_DOCUMENT_TYPE: 512,
		SHOW_DOCUMENT_FRAGMENT: 1024,
		SHOW_NOTATION: 2048,
	}
	hz.exports = UL.constructor = UL.prototype = UL
})
var qL = x((lxt, pz) => {
	"use strict"
	var axt = (pz.exports = {
		nextSkippingChildren: RPe,
		nextAncestorSibling: OL,
		next: kPe,
		previous: MPe,
		deepLastChild: gz,
	})
	function RPe(e, t) {
		return e === t ? null : e.nextSibling !== null ? e.nextSibling : OL(e, t)
	}
	function OL(e, t) {
		for (e = e.parentNode; e !== null; e = e.parentNode) {
			if (e === t) return null
			if (e.nextSibling !== null) return e.nextSibling
		}
		return null
	}
	function kPe(e, t) {
		var r
		return (r = e.firstChild), r !== null ? r : e === t ? null : ((r = e.nextSibling), r !== null ? r : OL(e, t))
	}
	function gz(e) {
		for (; e.lastChild; ) e = e.lastChild
		return e
	}
	function MPe(e, t) {
		var r
		return (r = e.previousSibling), r !== null ? gz(r) : ((r = e.parentNode), r === t ? null : r)
	}
})
var bz = x((cxt, Ez) => {
	"use strict"
	Ez.exports = vz
	var FPe = ps(),
		As = iE(),
		Az = qL(),
		Cz = ei(),
		VL = {
			first: "firstChild",
			last: "lastChild",
			next: "firstChild",
			previous: "lastChild",
		},
		HL = {
			first: "nextSibling",
			last: "previousSibling",
			next: "nextSibling",
			previous: "previousSibling",
		}
	function mz(e, t) {
		var r, n, i, s, o
		for (n = e._currentNode[VL[t]]; n !== null; ) {
			if (((s = e._internalFilter(n)), s === As.FILTER_ACCEPT)) return (e._currentNode = n), n
			if (s === As.FILTER_SKIP && ((r = n[VL[t]]), r !== null)) {
				n = r
				continue
			}
			for (; n !== null; ) {
				if (((o = n[HL[t]]), o !== null)) {
					n = o
					break
				}
				if (((i = n.parentNode), i === null || i === e.root || i === e._currentNode)) return null
				n = i
			}
		}
		return null
	}
	function yz(e, t) {
		var r, n, i
		if (((r = e._currentNode), r === e.root)) return null
		for (;;) {
			for (i = r[HL[t]]; i !== null; ) {
				if (((r = i), (n = e._internalFilter(r)), n === As.FILTER_ACCEPT)) return (e._currentNode = r), r
				;(i = r[VL[t]]), (n === As.FILTER_REJECT || i === null) && (i = r[HL[t]])
			}
			if (((r = r.parentNode), r === null || r === e.root || e._internalFilter(r) === As.FILTER_ACCEPT))
				return null
		}
	}
	function vz(e, t, r) {
		;(!e || !e.nodeType) && Cz.NotSupportedError(),
			(this._root = e),
			(this._whatToShow = Number(t) || 0),
			(this._filter = r || null),
			(this._active = !1),
			(this._currentNode = e)
	}
	Object.defineProperties(vz.prototype, {
		root: {
			get: function () {
				return this._root
			},
		},
		whatToShow: {
			get: function () {
				return this._whatToShow
			},
		},
		filter: {
			get: function () {
				return this._filter
			},
		},
		currentNode: {
			get: function () {
				return this._currentNode
			},
			set: function (t) {
				if (!(t instanceof FPe)) throw new TypeError("Not a Node")
				this._currentNode = t
			},
		},
		_internalFilter: {
			value: function (t) {
				var r, n
				if ((this._active && Cz.InvalidStateError(), !((1 << (t.nodeType - 1)) & this._whatToShow)))
					return As.FILTER_SKIP
				if (((n = this._filter), n === null)) r = As.FILTER_ACCEPT
				else {
					this._active = !0
					try {
						typeof n == "function" ? (r = n(t)) : (r = n.acceptNode(t))
					} finally {
						this._active = !1
					}
				}
				return +r
			},
		},
		parentNode: {
			value: function () {
				for (var t = this._currentNode; t !== this.root; ) {
					if (((t = t.parentNode), t === null)) return null
					if (this._internalFilter(t) === As.FILTER_ACCEPT) return (this._currentNode = t), t
				}
				return null
			},
		},
		firstChild: {
			value: function () {
				return mz(this, "first")
			},
		},
		lastChild: {
			value: function () {
				return mz(this, "last")
			},
		},
		previousSibling: {
			value: function () {
				return yz(this, "previous")
			},
		},
		nextSibling: {
			value: function () {
				return yz(this, "next")
			},
		},
		previousNode: {
			value: function () {
				var t, r, n, i
				for (t = this._currentNode; t !== this._root; ) {
					for (n = t.previousSibling; n; n = t.previousSibling)
						if (((t = n), (r = this._internalFilter(t)), r !== As.FILTER_REJECT)) {
							for (
								i = t.lastChild;
								i && ((t = i), (r = this._internalFilter(t)), r !== As.FILTER_REJECT);
								i = t.lastChild
							);
							if (r === As.FILTER_ACCEPT) return (this._currentNode = t), t
						}
					if (t === this.root || t.parentNode === null) return null
					if (((t = t.parentNode), this._internalFilter(t) === As.FILTER_ACCEPT))
						return (this._currentNode = t), t
				}
				return null
			},
		},
		nextNode: {
			value: function () {
				var t, r, n, i
				;(t = this._currentNode), (r = As.FILTER_ACCEPT)
				e: for (;;) {
					for (n = t.firstChild; n; n = t.firstChild) {
						if (((t = n), (r = this._internalFilter(t)), r === As.FILTER_ACCEPT))
							return (this._currentNode = t), t
						if (r === As.FILTER_REJECT) break
					}
					for (i = Az.nextSkippingChildren(t, this.root); i; i = Az.nextSkippingChildren(t, this.root)) {
						if (((t = i), (r = this._internalFilter(t)), r === As.FILTER_ACCEPT))
							return (this._currentNode = t), t
						if (r === As.FILTER_SKIP) continue e
					}
					return null
				}
			},
		},
		toString: {
			value: function () {
				return "[object TreeWalker]"
			},
		},
	})
})
var Bz = x((uxt, Sz) => {
	"use strict"
	Sz.exports = Iz
	var WL = iE(),
		GL = qL(),
		wz = ei()
	function QPe(e, t, r) {
		return r ? GL.next(e, t) : e === t ? null : GL.previous(e, null)
	}
	function xz(e, t) {
		for (; t; t = t.parentNode) if (e === t) return !0
		return !1
	}
	function _z(e, t) {
		var r, n
		for (r = e._referenceNode, n = e._pointerBeforeReferenceNode; ; ) {
			if (n === t) n = !n
			else if (((r = QPe(r, e._root, t)), r === null)) return null
			var i = e._internalFilter(r)
			if (i === WL.FILTER_ACCEPT) break
		}
		return (e._referenceNode = r), (e._pointerBeforeReferenceNode = n), r
	}
	function Iz(e, t, r) {
		;(!e || !e.nodeType) && wz.NotSupportedError(),
			(this._root = e),
			(this._referenceNode = e),
			(this._pointerBeforeReferenceNode = !0),
			(this._whatToShow = Number(t) || 0),
			(this._filter = r || null),
			(this._active = !1),
			e.doc._attachNodeIterator(this)
	}
	Object.defineProperties(Iz.prototype, {
		root: {
			get: function () {
				return this._root
			},
		},
		referenceNode: {
			get: function () {
				return this._referenceNode
			},
		},
		pointerBeforeReferenceNode: {
			get: function () {
				return this._pointerBeforeReferenceNode
			},
		},
		whatToShow: {
			get: function () {
				return this._whatToShow
			},
		},
		filter: {
			get: function () {
				return this._filter
			},
		},
		_internalFilter: {
			value: function (t) {
				var r, n
				if ((this._active && wz.InvalidStateError(), !((1 << (t.nodeType - 1)) & this._whatToShow)))
					return WL.FILTER_SKIP
				if (((n = this._filter), n === null)) r = WL.FILTER_ACCEPT
				else {
					this._active = !0
					try {
						typeof n == "function" ? (r = n(t)) : (r = n.acceptNode(t))
					} finally {
						this._active = !1
					}
				}
				return +r
			},
		},
		_preremove: {
			value: function (t) {
				if (!xz(t, this._root) && xz(t, this._referenceNode)) {
					if (this._pointerBeforeReferenceNode) {
						for (var r = t; r.lastChild; ) r = r.lastChild
						if (((r = GL.next(r, this.root)), r)) {
							this._referenceNode = r
							return
						}
						this._pointerBeforeReferenceNode = !1
					}
					if (t.previousSibling === null) this._referenceNode = t.parentNode
					else {
						this._referenceNode = t.previousSibling
						var n
						for (n = this._referenceNode.lastChild; n; n = this._referenceNode.lastChild)
							this._referenceNode = n
					}
				}
			},
		},
		nextNode: {
			value: function () {
				return _z(this, !0)
			},
		},
		previousNode: {
			value: function () {
				return _z(this, !1)
			},
		},
		detach: { value: function () {} },
		toString: {
			value: function () {
				return "[object NodeIterator]"
			},
		},
	})
})
var bS = x((dxt, Dz) => {
	"use strict"
	Dz.exports = ms
	function ms(e) {
		if (!e) return Object.create(ms.prototype)
		this.url = e.replace(/^[ \t\n\r\f]+|[ \t\n\r\f]+$/g, "")
		var t = ms.pattern.exec(this.url)
		if (t) {
			if ((t[2] && (this.scheme = t[2]), t[4])) {
				var r = t[4].match(ms.userinfoPattern)
				if (
					(r && ((this.username = r[1]), (this.password = r[3]), (t[4] = t[4].substring(r[0].length))),
					t[4].match(ms.portPattern))
				) {
					var n = t[4].lastIndexOf(":")
					;(this.host = t[4].substring(0, n)), (this.port = t[4].substring(n + 1))
				} else this.host = t[4]
			}
			t[5] && (this.path = t[5]), t[6] && (this.query = t[7]), t[8] && (this.fragment = t[9])
		}
	}
	ms.pattern = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/
	ms.userinfoPattern = /^([^@:]*)(:([^@]*))?@/
	ms.portPattern = /:\d+$/
	ms.authorityPattern = /^[^:\/?#]+:\/\//
	ms.hierarchyPattern = /^[^:\/?#]+:\//
	ms.percentEncode = function (t) {
		var r = t.charCodeAt(0)
		if (r < 256) return "%" + r.toString(16)
		throw Error("can't percent-encode codepoints > 255 yet")
	}
	ms.prototype = {
		constructor: ms,
		isAbsolute: function () {
			return !!this.scheme
		},
		isAuthorityBased: function () {
			return ms.authorityPattern.test(this.url)
		},
		isHierarchical: function () {
			return ms.hierarchyPattern.test(this.url)
		},
		toString: function () {
			var e = ""
			return (
				this.scheme !== void 0 && (e += this.scheme + ":"),
				this.isAbsolute() &&
					((e += "//"),
					(this.username || this.password) &&
						((e += this.username || ""), this.password && (e += ":" + this.password), (e += "@")),
					this.host && (e += this.host)),
				this.port !== void 0 && (e += ":" + this.port),
				this.path !== void 0 && (e += this.path),
				this.query !== void 0 && (e += "?" + this.query),
				this.fragment !== void 0 && (e += "#" + this.fragment),
				e
			)
		},
		resolve: function (e) {
			var t = this,
				r = new ms(e),
				n = new ms()
			return (
				r.scheme !== void 0
					? ((n.scheme = r.scheme),
						(n.username = r.username),
						(n.password = r.password),
						(n.host = r.host),
						(n.port = r.port),
						(n.path = s(r.path)),
						(n.query = r.query))
					: ((n.scheme = t.scheme),
						r.host !== void 0
							? ((n.username = r.username),
								(n.password = r.password),
								(n.host = r.host),
								(n.port = r.port),
								(n.path = s(r.path)),
								(n.query = r.query))
							: ((n.username = t.username),
								(n.password = t.password),
								(n.host = t.host),
								(n.port = t.port),
								r.path
									? (r.path.charAt(0) === "/"
											? (n.path = s(r.path))
											: ((n.path = i(t.path, r.path)), (n.path = s(n.path))),
										(n.query = r.query))
									: ((n.path = t.path),
										r.query !== void 0 ? (n.query = r.query) : (n.query = t.query)))),
				(n.fragment = r.fragment),
				n.toString()
			)
			function i(o, a) {
				if (t.host !== void 0 && !t.path) return "/" + a
				var l = o.lastIndexOf("/")
				return l === -1 ? a : o.substring(0, l + 1) + a
			}
			function s(o) {
				if (!o) return o
				for (var a = ""; o.length > 0; ) {
					if (o === "." || o === "..") {
						o = ""
						break
					}
					var l = o.substring(0, 2),
						c = o.substring(0, 3),
						u = o.substring(0, 4)
					if (c === "../") o = o.substring(3)
					else if (l === "./") o = o.substring(2)
					else if (c === "/./") o = "/" + o.substring(3)
					else if (l === "/." && o.length === 2) o = "/"
					else if (u === "/../" || (c === "/.." && o.length === 3))
						(o = "/" + o.substring(4)), (a = a.replace(/\/?[^\/]*$/, ""))
					else {
						var f = o.match(/(\/?([^\/]*))/)[0]
						;(a += f), (o = o.substring(f.length))
					}
				}
				return a
			}
		},
	}
})
var kz = x((fxt, Rz) => {
	"use strict"
	Rz.exports = $L
	var Tz = bm()
	function $L(e, t) {
		Tz.call(this, e, t)
	}
	$L.prototype = Object.create(Tz.prototype, { constructor: { value: $L } })
})
var YL = x((hxt, Mz) => {
	"use strict"
	Mz.exports = {
		Event: bm(),
		UIEvent: JP(),
		MouseEvent: jP(),
		CustomEvent: kz(),
	}
})
var Qz = x((Tm) => {
	"use strict"
	Object.defineProperty(Tm, "__esModule", { value: !0 })
	Tm.hyphenate = Tm.parse = void 0
	function NPe(e) {
		let t = [],
			r = 0,
			n = 0,
			i = 0,
			s = 0,
			o = 0,
			a = null
		for (; r < e.length; )
			switch (e.charCodeAt(r++)) {
				case 40:
					n++
					break
				case 41:
					n--
					break
				case 39:
					i === 0 ? (i = 39) : i === 39 && e.charCodeAt(r - 1) !== 92 && (i = 0)
					break
				case 34:
					i === 0 ? (i = 34) : i === 34 && e.charCodeAt(r - 1) !== 92 && (i = 0)
					break
				case 58:
					!a && n === 0 && i === 0 && ((a = Fz(e.substring(o, r - 1).trim())), (s = r))
					break
				case 59:
					if (a && s > 0 && n === 0 && i === 0) {
						let c = e.substring(s, r - 1).trim()
						t.push(a, c), (o = r), (s = 0), (a = null)
					}
					break
			}
		if (a && s) {
			let l = e.slice(s).trim()
			t.push(a, l)
		}
		return t
	}
	Tm.parse = NPe
	function Fz(e) {
		return e.replace(/[a-z][A-Z]/g, (t) => t.charAt(0) + "-" + t.charAt(1)).toLowerCase()
	}
	Tm.hyphenate = Fz
})
var xS = x((pxt, Oz) => {
	"use strict"
	var { parse: PPe } = Qz()
	Oz.exports = function (e) {
		let t = new Uz(e),
			r = {
				get: function (n, i) {
					return i in n ? n[i] : n.getPropertyValue(Nz(i))
				},
				has: function (n, i) {
					return !0
				},
				set: function (n, i, s) {
					return i in n ? (n[i] = s) : n.setProperty(Nz(i), s ?? void 0), !0
				},
			}
		return new Proxy(t, r)
	}
	function Nz(e) {
		return e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
	}
	function Uz(e) {
		this._element = e
	}
	var Pz = "!important"
	function Lz(e) {
		let t = { property: {}, priority: {} }
		if (!e) return t
		let r = PPe(e)
		if (r.length < 2) return t
		for (let n = 0; n < r.length; n += 2) {
			let i = r[n],
				s = r[n + 1]
			s.endsWith(Pz) && ((t.priority[i] = "important"), (s = s.slice(0, -Pz.length).trim())), (t.property[i] = s)
		}
		return t
	}
	var Rm = {}
	Uz.prototype = Object.create(Object.prototype, {
		_parsed: {
			get: function () {
				if (!this._parsedStyles || this.cssText !== this._lastParsedText) {
					var e = this.cssText
					;(this._parsedStyles = Lz(e)), (this._lastParsedText = e), delete this._names
				}
				return this._parsedStyles
			},
		},
		_serialize: {
			value: function () {
				var e = this._parsed,
					t = ""
				for (var r in e.property)
					t && (t += " "),
						(t += r + ": " + e.property[r]),
						e.priority[r] && (t += " !" + e.priority[r]),
						(t += ";")
				;(this.cssText = t), (this._lastParsedText = t), delete this._names
			},
		},
		cssText: {
			get: function () {
				return this._element.getAttribute("style")
			},
			set: function (e) {
				this._element.setAttribute("style", e)
			},
		},
		length: {
			get: function () {
				return (
					this._names || (this._names = Object.getOwnPropertyNames(this._parsed.property)), this._names.length
				)
			},
		},
		item: {
			value: function (e) {
				return this._names || (this._names = Object.getOwnPropertyNames(this._parsed.property)), this._names[e]
			},
		},
		getPropertyValue: {
			value: function (e) {
				return (e = e.toLowerCase()), this._parsed.property[e] || ""
			},
		},
		getPropertyPriority: {
			value: function (e) {
				return (e = e.toLowerCase()), this._parsed.priority[e] || ""
			},
		},
		setProperty: {
			value: function (e, t, r) {
				if (
					((e = e.toLowerCase()),
					t == null && (t = ""),
					r == null && (r = ""),
					t !== Rm && (t = "" + t),
					(t = t.trim()),
					t === "")
				) {
					this.removeProperty(e)
					return
				}
				if (!(r !== "" && r !== Rm && !/^important$/i.test(r))) {
					var n = this._parsed
					if (t === Rm) {
						if (!n.property[e]) return
						r !== "" ? (n.priority[e] = "important") : delete n.priority[e]
					} else {
						if (t.indexOf(";") !== -1) return
						var i = Lz(e + ":" + t)
						if (
							Object.getOwnPropertyNames(i.property).length === 0 ||
							Object.getOwnPropertyNames(i.priority).length !== 0
						)
							return
						for (var s in i.property)
							(n.property[s] = i.property[s]),
								r !== Rm &&
									(r !== "" ? (n.priority[s] = "important") : n.priority[s] && delete n.priority[s])
					}
					this._serialize()
				}
			},
		},
		setPropertyValue: {
			value: function (e, t) {
				return this.setProperty(e, t, Rm)
			},
		},
		setPropertyPriority: {
			value: function (e, t) {
				return this.setProperty(e, Rm, t)
			},
		},
		removeProperty: {
			value: function (e) {
				e = e.toLowerCase()
				var t = this._parsed
				e in t.property && (delete t.property[e], delete t.priority[e], this._serialize())
			},
		},
	})
})
var KL = x((Axt, qz) => {
	"use strict"
	var Ki = bS()
	qz.exports = sE
	function sE() {}
	sE.prototype = Object.create(Object.prototype, {
		_url: {
			get: function () {
				return new Ki(this.href)
			},
		},
		protocol: {
			get: function () {
				var e = this._url
				return e && e.scheme ? e.scheme + ":" : ":"
			},
			set: function (e) {
				var t = this.href,
					r = new Ki(t)
				r.isAbsolute() &&
					((e = e.replace(/:+$/, "")),
					(e = e.replace(/[^-+\.a-zA-Z0-9]/g, Ki.percentEncode)),
					e.length > 0 && ((r.scheme = e), (t = r.toString()))),
					(this.href = t)
			},
		},
		host: {
			get: function () {
				var e = this._url
				return e.isAbsolute() && e.isAuthorityBased() ? e.host + (e.port ? ":" + e.port : "") : ""
			},
			set: function (e) {
				var t = this.href,
					r = new Ki(t)
				r.isAbsolute() &&
					r.isAuthorityBased() &&
					((e = e.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, Ki.percentEncode)),
					e.length > 0 && ((r.host = e), delete r.port, (t = r.toString()))),
					(this.href = t)
			},
		},
		hostname: {
			get: function () {
				var e = this._url
				return e.isAbsolute() && e.isAuthorityBased() ? e.host : ""
			},
			set: function (e) {
				var t = this.href,
					r = new Ki(t)
				r.isAbsolute() &&
					r.isAuthorityBased() &&
					((e = e.replace(/^\/+/, "")),
					(e = e.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, Ki.percentEncode)),
					e.length > 0 && ((r.host = e), (t = r.toString()))),
					(this.href = t)
			},
		},
		port: {
			get: function () {
				var e = this._url
				return e.isAbsolute() && e.isAuthorityBased() && e.port !== void 0 ? e.port : ""
			},
			set: function (e) {
				var t = this.href,
					r = new Ki(t)
				r.isAbsolute() &&
					r.isAuthorityBased() &&
					((e = "" + e),
					(e = e.replace(/[^0-9].*$/, "")),
					(e = e.replace(/^0+/, "")),
					e.length === 0 && (e = "0"),
					parseInt(e, 10) <= 65535 && ((r.port = e), (t = r.toString()))),
					(this.href = t)
			},
		},
		pathname: {
			get: function () {
				var e = this._url
				return e.isAbsolute() && e.isHierarchical() ? e.path : ""
			},
			set: function (e) {
				var t = this.href,
					r = new Ki(t)
				r.isAbsolute() &&
					r.isHierarchical() &&
					(e.charAt(0) !== "/" && (e = "/" + e),
					(e = e.replace(/[^-+\._~!$&'()*,;:=@\/a-zA-Z0-9]/g, Ki.percentEncode)),
					(r.path = e),
					(t = r.toString())),
					(this.href = t)
			},
		},
		search: {
			get: function () {
				var e = this._url
				return e.isAbsolute() && e.isHierarchical() && e.query !== void 0 ? "?" + e.query : ""
			},
			set: function (e) {
				var t = this.href,
					r = new Ki(t)
				r.isAbsolute() &&
					r.isHierarchical() &&
					(e.charAt(0) === "?" && (e = e.substring(1)),
					(e = e.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, Ki.percentEncode)),
					(r.query = e),
					(t = r.toString())),
					(this.href = t)
			},
		},
		hash: {
			get: function () {
				var e = this._url
				return e == null || e.fragment == null || e.fragment === "" ? "" : "#" + e.fragment
			},
			set: function (e) {
				var t = this.href,
					r = new Ki(t)
				e.charAt(0) === "#" && (e = e.substring(1)),
					(e = e.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, Ki.percentEncode)),
					(r.fragment = e),
					(t = r.toString()),
					(this.href = t)
			},
		},
		username: {
			get: function () {
				var e = this._url
				return e.username || ""
			},
			set: function (e) {
				var t = this.href,
					r = new Ki(t)
				r.isAbsolute() &&
					((e = e.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\:]/g, Ki.percentEncode)),
					(r.username = e),
					(t = r.toString())),
					(this.href = t)
			},
		},
		password: {
			get: function () {
				var e = this._url
				return e.password || ""
			},
			set: function (e) {
				var t = this.href,
					r = new Ki(t)
				r.isAbsolute() &&
					(e === ""
						? (r.password = null)
						: ((e = e.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\]/g, Ki.percentEncode)), (r.password = e)),
					(t = r.toString())),
					(this.href = t)
			},
		},
		origin: {
			get: function () {
				var e = this._url
				if (e == null) return ""
				var t = function (r) {
					var n = [e.scheme, e.host, +e.port || r]
					return n[0] + "://" + n[1] + (n[2] === r ? "" : ":" + n[2])
				}
				switch (e.scheme) {
					case "ftp":
						return t(21)
					case "gopher":
						return t(70)
					case "http":
					case "ws":
						return t(80)
					case "https":
					case "wss":
						return t(443)
					default:
						return e.scheme + "://"
				}
			},
		},
	})
	sE._inherit = function (e) {
		Object.getOwnPropertyNames(sE.prototype).forEach(function (t) {
			if (!(t === "constructor" || t === "href")) {
				var r = Object.getOwnPropertyDescriptor(sE.prototype, t)
				Object.defineProperty(e, t, r)
			}
		})
	}
})
var JL = x((mxt, Wz) => {
	"use strict"
	var Vz = pL(),
		LPe = lS().isApiWritable
	Wz.exports = function (e, t, r, n) {
		var i = e.ctor
		if (i) {
			var s = e.props || {}
			if (e.attributes)
				for (var o in e.attributes) {
					var a = e.attributes[o]
					;(typeof a != "object" || Array.isArray(a)) && (a = { type: a }),
						a.name || (a.name = o.toLowerCase()),
						(s[o] = Vz.property(a))
				}
			;(s.constructor = { value: i, writable: LPe }),
				(i.prototype = Object.create((e.superclass || t).prototype, s)),
				e.events && OPe(i, e.events),
				(r[e.name] = i)
		} else i = t
		return (
			(e.tags || (e.tag && [e.tag]) || []).forEach(function (l) {
				n[l] = i
			}),
			i
		)
	}
	function Hz(e, t, r, n) {
		;(this.body = e), (this.document = t), (this.form = r), (this.element = n)
	}
	Hz.prototype.build = function () {
		return () => {}
	}
	function UPe(e, t, r, n) {
		var i = e.ownerDocument || Object.create(null),
			s = e.form || Object.create(null)
		e[t] = new Hz(n, i, s, e).build()
	}
	function OPe(e, t) {
		var r = e.prototype
		t.forEach(function (n) {
			Object.defineProperty(r, "on" + n, {
				get: function () {
					return this._getEventHandler(n)
				},
				set: function (i) {
					this._setEventHandler(n, i)
				},
			}),
				Vz.registerChangeHandler(e, "on" + n, UPe)
		})
	}
})
var IS = x((wS) => {
	"use strict"
	var zL = ps(),
		Gz = Dm(),
		qPe = xS(),
		ha = ei(),
		$z = KL(),
		VPe = JL(),
		bd = (wS.elements = {}),
		oE = Object.create(null)
	wS.createElement = function (e, t, r) {
		var n = oE[t] || WPe
		return new n(e, t, r)
	}
	function Me(e) {
		return VPe(e, ze, bd, oE)
	}
	function ti(e) {
		return {
			get: function () {
				var t = this._getattr(e)
				if (t === null) return ""
				var r = this.doc._resolve(t)
				return r === null ? t : r
			},
			set: function (t) {
				this._setattr(e, t)
			},
		}
	}
	function _S(e) {
		return {
			get: function () {
				var t = this._getattr(e)
				return t === null ? null : t.toLowerCase() === "use-credentials" ? "use-credentials" : "anonymous"
			},
			set: function (t) {
				t == null ? this.removeAttribute(e) : this._setattr(e, t)
			},
		}
	}
	var km = {
			type: [
				"",
				"no-referrer",
				"no-referrer-when-downgrade",
				"same-origin",
				"origin",
				"strict-origin",
				"origin-when-cross-origin",
				"strict-origin-when-cross-origin",
				"unsafe-url",
			],
			missing: "",
		},
		HPe = {
			A: !0,
			LINK: !0,
			BUTTON: !0,
			INPUT: !0,
			SELECT: !0,
			TEXTAREA: !0,
			COMMAND: !0,
		},
		tc = function (e, t, r) {
			ze.call(this, e, t, r), (this._form = null)
		},
		ze = (wS.HTMLElement = Me({
			superclass: Gz,
			name: "HTMLElement",
			ctor: function (t, r, n) {
				Gz.call(this, t, r, ha.NAMESPACE.HTML, n)
			},
			props: {
				dangerouslySetInnerHTML: {
					set: function (e) {
						this._innerHTML = e
					},
				},
				innerHTML: {
					get: function () {
						return this.serialize()
					},
					set: function (e) {
						var t = this.ownerDocument.implementation.mozHTMLParser(this.ownerDocument._address, this)
						t.parse(e === null ? "" : String(e), !0)
						for (var r = this instanceof oE.template ? this.content : this; r.hasChildNodes(); )
							r.removeChild(r.firstChild)
						r.appendChild(t._asDocumentFragment())
					},
				},
				style: {
					get: function () {
						return this._style || (this._style = new qPe(this)), this._style
					},
					set: function (e) {
						e == null && (e = ""), this._setattr("style", String(e))
					},
				},
				blur: { value: function () {} },
				focus: { value: function () {} },
				forceSpellCheck: { value: function () {} },
				click: {
					value: function () {
						if (!this._click_in_progress) {
							this._click_in_progress = !0
							try {
								this._pre_click_activation_steps && this._pre_click_activation_steps()
								var e = this.ownerDocument.createEvent("MouseEvent")
								e.initMouseEvent(
									"click",
									!0,
									!0,
									this.ownerDocument.defaultView,
									1,
									0,
									0,
									0,
									0,
									!1,
									!1,
									!1,
									!1,
									0,
									null,
								)
								var t = this.dispatchEvent(e)
								t
									? this._post_click_activation_steps && this._post_click_activation_steps(e)
									: this._cancelled_activation_steps && this._cancelled_activation_steps()
							} finally {
								this._click_in_progress = !1
							}
						}
					},
				},
				submit: { value: ha.nyi },
			},
			attributes: {
				title: String,
				lang: String,
				dir: { type: ["ltr", "rtl", "auto"], missing: "" },
				draggable: { type: ["true", "false"], treatNullAsEmptyString: !0 },
				spellcheck: { type: ["true", "false"], missing: "" },
				enterKeyHint: {
					type: ["enter", "done", "go", "next", "previous", "search", "send"],
					missing: "",
				},
				autoCapitalize: {
					type: ["off", "on", "none", "sentences", "words", "characters"],
					missing: "",
				},
				autoFocus: Boolean,
				accessKey: String,
				nonce: String,
				hidden: Boolean,
				translate: { type: ["no", "yes"], missing: "" },
				tabIndex: {
					type: "long",
					default: function () {
						return this.tagName in HPe || this.contentEditable ? 0 : -1
					},
				},
			},
			events: [
				"abort",
				"canplay",
				"canplaythrough",
				"change",
				"click",
				"contextmenu",
				"cuechange",
				"dblclick",
				"drag",
				"dragend",
				"dragenter",
				"dragleave",
				"dragover",
				"dragstart",
				"drop",
				"durationchange",
				"emptied",
				"ended",
				"input",
				"invalid",
				"keydown",
				"keypress",
				"keyup",
				"loadeddata",
				"loadedmetadata",
				"loadstart",
				"mousedown",
				"mousemove",
				"mouseout",
				"mouseover",
				"mouseup",
				"mousewheel",
				"pause",
				"play",
				"playing",
				"progress",
				"ratechange",
				"readystatechange",
				"reset",
				"seeked",
				"seeking",
				"select",
				"show",
				"stalled",
				"submit",
				"suspend",
				"timeupdate",
				"volumechange",
				"waiting",
				"blur",
				"error",
				"focus",
				"load",
				"scroll",
			],
		})),
		WPe = Me({
			name: "HTMLUnknownElement",
			ctor: function (t, r, n) {
				ze.call(this, t, r, n)
			},
		}),
		rc = {
			form: {
				get: function () {
					return this._form
				},
			},
		}
	Me({
		tag: "a",
		name: "HTMLAnchorElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		props: {
			_post_click_activation_steps: {
				value: function (e) {
					this.href && (this.ownerDocument.defaultView.location = this.href)
				},
			},
		},
		attributes: {
			href: ti,
			ping: String,
			download: String,
			target: String,
			rel: String,
			media: String,
			hreflang: String,
			type: String,
			referrerPolicy: km,
			coords: String,
			charset: String,
			name: String,
			rev: String,
			shape: String,
		},
	})
	$z._inherit(oE.a.prototype)
	Me({
		tag: "area",
		name: "HTMLAreaElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			alt: String,
			target: String,
			download: String,
			rel: String,
			media: String,
			href: ti,
			hreflang: String,
			type: String,
			shape: String,
			coords: String,
			ping: String,
			referrerPolicy: km,
			noHref: Boolean,
		},
	})
	$z._inherit(oE.area.prototype)
	Me({
		tag: "br",
		name: "HTMLBRElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { clear: String },
	})
	Me({
		tag: "base",
		name: "HTMLBaseElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { target: String },
	})
	Me({
		tag: "body",
		name: "HTMLBodyElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		events: [
			"afterprint",
			"beforeprint",
			"beforeunload",
			"blur",
			"error",
			"focus",
			"hashchange",
			"load",
			"message",
			"offline",
			"online",
			"pagehide",
			"pageshow",
			"popstate",
			"resize",
			"scroll",
			"storage",
			"unload",
		],
		attributes: {
			text: { type: String, treatNullAsEmptyString: !0 },
			link: { type: String, treatNullAsEmptyString: !0 },
			vLink: { type: String, treatNullAsEmptyString: !0 },
			aLink: { type: String, treatNullAsEmptyString: !0 },
			bgColor: { type: String, treatNullAsEmptyString: !0 },
			background: String,
		},
	})
	Me({
		tag: "button",
		name: "HTMLButtonElement",
		ctor: function (t, r, n) {
			tc.call(this, t, r, n)
		},
		props: rc,
		attributes: {
			name: String,
			value: String,
			disabled: Boolean,
			autofocus: Boolean,
			type: { type: ["submit", "reset", "button", "menu"], missing: "submit" },
			formTarget: String,
			formAction: ti,
			formNoValidate: Boolean,
			formMethod: {
				type: ["get", "post", "dialog"],
				invalid: "get",
				missing: "",
			},
			formEnctype: {
				type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"],
				invalid: "application/x-www-form-urlencoded",
				missing: "",
			},
		},
	})
	Me({
		tag: "dl",
		name: "HTMLDListElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { compact: Boolean },
	})
	Me({
		tag: "data",
		name: "HTMLDataElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { value: String },
	})
	Me({
		tag: "datalist",
		name: "HTMLDataListElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
	})
	Me({
		tag: "details",
		name: "HTMLDetailsElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { open: Boolean },
	})
	Me({
		tag: "div",
		name: "HTMLDivElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { align: String },
	})
	Me({
		tag: "embed",
		name: "HTMLEmbedElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			src: ti,
			type: String,
			width: String,
			height: String,
			align: String,
			name: String,
		},
	})
	Me({
		tag: "fieldset",
		name: "HTMLFieldSetElement",
		ctor: function (t, r, n) {
			tc.call(this, t, r, n)
		},
		props: rc,
		attributes: { disabled: Boolean, name: String },
	})
	Me({
		tag: "form",
		name: "HTMLFormElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			action: String,
			autocomplete: { type: ["on", "off"], missing: "on" },
			name: String,
			acceptCharset: { name: "accept-charset" },
			target: String,
			noValidate: Boolean,
			method: {
				type: ["get", "post", "dialog"],
				invalid: "get",
				missing: "get",
			},
			enctype: {
				type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"],
				invalid: "application/x-www-form-urlencoded",
				missing: "application/x-www-form-urlencoded",
			},
			encoding: {
				name: "enctype",
				type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"],
				invalid: "application/x-www-form-urlencoded",
				missing: "application/x-www-form-urlencoded",
			},
		},
	})
	Me({
		tag: "hr",
		name: "HTMLHRElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			align: String,
			color: String,
			noShade: Boolean,
			size: String,
			width: String,
		},
	})
	Me({
		tag: "head",
		name: "HTMLHeadElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
	})
	Me({
		tags: ["h1", "h2", "h3", "h4", "h5", "h6"],
		name: "HTMLHeadingElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { align: String },
	})
	Me({
		tag: "html",
		name: "HTMLHtmlElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { xmlns: ti, version: String },
	})
	Me({
		tag: "iframe",
		name: "HTMLIFrameElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			src: ti,
			srcdoc: String,
			name: String,
			width: String,
			height: String,
			seamless: Boolean,
			allow: Boolean,
			allowFullscreen: Boolean,
			allowUserMedia: Boolean,
			allowPaymentRequest: Boolean,
			referrerPolicy: km,
			loading: { type: ["eager", "lazy"], treatNullAsEmptyString: !0 },
			align: String,
			scrolling: String,
			frameBorder: String,
			longDesc: ti,
			marginHeight: { type: String, treatNullAsEmptyString: !0 },
			marginWidth: { type: String, treatNullAsEmptyString: !0 },
		},
	})
	Me({
		tag: "img",
		name: "HTMLImageElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			alt: String,
			src: ti,
			srcset: String,
			crossOrigin: _S,
			useMap: String,
			isMap: Boolean,
			sizes: String,
			height: { type: "unsigned long", default: 0 },
			width: { type: "unsigned long", default: 0 },
			referrerPolicy: km,
			loading: { type: ["eager", "lazy"], missing: "" },
			name: String,
			lowsrc: ti,
			align: String,
			hspace: { type: "unsigned long", default: 0 },
			vspace: { type: "unsigned long", default: 0 },
			longDesc: ti,
			border: { type: String, treatNullAsEmptyString: !0 },
		},
	})
	Me({
		tag: "input",
		name: "HTMLInputElement",
		ctor: function (t, r, n) {
			tc.call(this, t, r, n)
		},
		props: {
			form: rc.form,
			_post_click_activation_steps: {
				value: function (e) {
					if (this.type === "checkbox") this.checked = !this.checked
					else if (this.type === "radio")
						for (var t = this.form.getElementsByName(this.name), r = t.length - 1; r >= 0; r--) {
							var n = t[r]
							n.checked = n === this
						}
				},
			},
		},
		attributes: {
			name: String,
			disabled: Boolean,
			autofocus: Boolean,
			accept: String,
			alt: String,
			max: String,
			min: String,
			pattern: String,
			placeholder: String,
			step: String,
			dirName: String,
			defaultValue: { name: "value" },
			multiple: Boolean,
			required: Boolean,
			readOnly: Boolean,
			checked: Boolean,
			value: String,
			src: ti,
			defaultChecked: { name: "checked", type: Boolean },
			size: { type: "unsigned long", default: 20, min: 1, setmin: 1 },
			width: { type: "unsigned long", min: 0, setmin: 0, default: 0 },
			height: { type: "unsigned long", min: 0, setmin: 0, default: 0 },
			minLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
			maxLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
			autocomplete: String,
			type: {
				type: [
					"text",
					"hidden",
					"search",
					"tel",
					"url",
					"email",
					"password",
					"datetime",
					"date",
					"month",
					"week",
					"time",
					"datetime-local",
					"number",
					"range",
					"color",
					"checkbox",
					"radio",
					"file",
					"submit",
					"image",
					"reset",
					"button",
				],
				missing: "text",
			},
			formTarget: String,
			formNoValidate: Boolean,
			formMethod: { type: ["get", "post"], invalid: "get", missing: "" },
			formEnctype: {
				type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"],
				invalid: "application/x-www-form-urlencoded",
				missing: "",
			},
			inputMode: {
				type: [
					"verbatim",
					"latin",
					"latin-name",
					"latin-prose",
					"full-width-latin",
					"kana",
					"kana-name",
					"katakana",
					"numeric",
					"tel",
					"email",
					"url",
				],
				missing: "",
			},
			align: String,
			useMap: String,
		},
	})
	Me({
		tag: "keygen",
		name: "HTMLKeygenElement",
		ctor: function (t, r, n) {
			tc.call(this, t, r, n)
		},
		props: rc,
		attributes: {
			name: String,
			disabled: Boolean,
			autofocus: Boolean,
			challenge: String,
			keytype: { type: ["rsa"], missing: "" },
		},
	})
	Me({
		tag: "li",
		name: "HTMLLIElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { value: { type: "long", default: 0 }, type: String },
	})
	Me({
		tag: "label",
		name: "HTMLLabelElement",
		ctor: function (t, r, n) {
			tc.call(this, t, r, n)
		},
		props: rc,
		attributes: { htmlFor: { name: "for", type: String } },
	})
	Me({
		tag: "legend",
		name: "HTMLLegendElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { align: String },
	})
	Me({
		tag: "link",
		name: "HTMLLinkElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			href: ti,
			rel: String,
			media: String,
			hreflang: String,
			type: String,
			crossOrigin: _S,
			nonce: String,
			integrity: String,
			referrerPolicy: km,
			imageSizes: String,
			imageSrcset: String,
			charset: String,
			rev: String,
			target: String,
		},
	})
	Me({
		tag: "map",
		name: "HTMLMapElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { name: String },
	})
	Me({
		tag: "menu",
		name: "HTMLMenuElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			type: { type: ["context", "popup", "toolbar"], missing: "toolbar" },
			label: String,
			compact: Boolean,
		},
	})
	Me({
		tag: "meta",
		name: "HTMLMetaElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			name: String,
			content: String,
			httpEquiv: { name: "http-equiv", type: String },
			scheme: String,
		},
	})
	Me({
		tag: "meter",
		name: "HTMLMeterElement",
		ctor: function (t, r, n) {
			tc.call(this, t, r, n)
		},
		props: rc,
	})
	Me({
		tags: ["ins", "del"],
		name: "HTMLModElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { cite: ti, dateTime: String },
	})
	Me({
		tag: "ol",
		name: "HTMLOListElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		props: {
			_numitems: {
				get: function () {
					var e = 0
					return (
						this.childNodes.forEach(function (t) {
							t.nodeType === zL.ELEMENT_NODE && t.tagName === "LI" && e++
						}),
						e
					)
				},
			},
		},
		attributes: {
			type: String,
			reversed: Boolean,
			start: {
				type: "long",
				default: function () {
					return this.reversed ? this._numitems : 1
				},
			},
			compact: Boolean,
		},
	})
	Me({
		tag: "object",
		name: "HTMLObjectElement",
		ctor: function (t, r, n) {
			tc.call(this, t, r, n)
		},
		props: rc,
		attributes: {
			data: ti,
			type: String,
			name: String,
			useMap: String,
			typeMustMatch: Boolean,
			width: String,
			height: String,
			align: String,
			archive: String,
			code: String,
			declare: Boolean,
			hspace: { type: "unsigned long", default: 0 },
			standby: String,
			vspace: { type: "unsigned long", default: 0 },
			codeBase: ti,
			codeType: String,
			border: { type: String, treatNullAsEmptyString: !0 },
		},
	})
	Me({
		tag: "optgroup",
		name: "HTMLOptGroupElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { disabled: Boolean, label: String },
	})
	Me({
		tag: "option",
		name: "HTMLOptionElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		props: {
			form: {
				get: function () {
					for (var e = this.parentNode; e && e.nodeType === zL.ELEMENT_NODE; ) {
						if (e.localName === "select") return e.form
						e = e.parentNode
					}
				},
			},
			value: {
				get: function () {
					return this._getattr("value") || this.text
				},
				set: function (e) {
					this._setattr("value", e)
				},
			},
			text: {
				get: function () {
					return this.textContent.replace(/[ \t\n\f\r]+/g, " ").trim()
				},
				set: function (e) {
					this.textContent = e
				},
			},
		},
		attributes: {
			disabled: Boolean,
			defaultSelected: { name: "selected", type: Boolean },
			label: String,
		},
	})
	Me({
		tag: "output",
		name: "HTMLOutputElement",
		ctor: function (t, r, n) {
			tc.call(this, t, r, n)
		},
		props: rc,
		attributes: { name: String },
	})
	Me({
		tag: "p",
		name: "HTMLParagraphElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { align: String },
	})
	Me({
		tag: "param",
		name: "HTMLParamElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			name: String,
			value: String,
			type: String,
			valueType: String,
		},
	})
	Me({
		tags: ["pre", "listing", "xmp"],
		name: "HTMLPreElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { width: { type: "long", default: 0 } },
	})
	Me({
		tag: "progress",
		name: "HTMLProgressElement",
		ctor: function (t, r, n) {
			tc.call(this, t, r, n)
		},
		props: rc,
		attributes: { max: { type: Number, float: !0, default: 1, min: 0 } },
	})
	Me({
		tags: ["q", "blockquote"],
		name: "HTMLQuoteElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { cite: ti },
	})
	Me({
		tag: "script",
		name: "HTMLScriptElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		props: {
			text: {
				get: function () {
					for (var e = "", t = 0, r = this.childNodes.length; t < r; t++) {
						var n = this.childNodes[t]
						n.nodeType === zL.TEXT_NODE && (e += n._data)
					}
					return e
				},
				set: function (e) {
					this.removeChildren(),
						e !== null && e !== "" && this.appendChild(this.ownerDocument.createTextNode(e))
				},
			},
		},
		attributes: {
			src: ti,
			type: String,
			charset: String,
			referrerPolicy: km,
			defer: Boolean,
			async: Boolean,
			nomodule: Boolean,
			crossOrigin: _S,
			nonce: String,
			integrity: String,
		},
	})
	Me({
		tag: "select",
		name: "HTMLSelectElement",
		ctor: function (t, r, n) {
			tc.call(this, t, r, n)
		},
		props: {
			form: rc.form,
			options: {
				get: function () {
					return this.getElementsByTagName("option")
				},
			},
		},
		attributes: {
			autocomplete: String,
			name: String,
			disabled: Boolean,
			autofocus: Boolean,
			multiple: Boolean,
			required: Boolean,
			size: { type: "unsigned long", default: 0 },
		},
	})
	Me({
		tag: "span",
		name: "HTMLSpanElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
	})
	Me({
		tag: "style",
		name: "HTMLStyleElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { media: String, type: String, scoped: Boolean },
	})
	Me({
		tag: "caption",
		name: "HTMLTableCaptionElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { align: String },
	})
	Me({
		name: "HTMLTableCellElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			colSpan: { type: "unsigned long", default: 1 },
			rowSpan: { type: "unsigned long", default: 1 },
			scope: { type: ["row", "col", "rowgroup", "colgroup"], missing: "" },
			abbr: String,
			align: String,
			axis: String,
			height: String,
			width: String,
			ch: { name: "char", type: String },
			chOff: { name: "charoff", type: String },
			noWrap: Boolean,
			vAlign: String,
			bgColor: { type: String, treatNullAsEmptyString: !0 },
		},
	})
	Me({
		tags: ["col", "colgroup"],
		name: "HTMLTableColElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			span: { type: "limited unsigned long with fallback", default: 1, min: 1 },
			align: String,
			ch: { name: "char", type: String },
			chOff: { name: "charoff", type: String },
			vAlign: String,
			width: String,
		},
	})
	Me({
		tag: "table",
		name: "HTMLTableElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		props: {
			rows: {
				get: function () {
					return this.getElementsByTagName("tr")
				},
			},
		},
		attributes: {
			align: String,
			border: String,
			frame: String,
			rules: String,
			summary: String,
			width: String,
			bgColor: { type: String, treatNullAsEmptyString: !0 },
			cellPadding: { type: String, treatNullAsEmptyString: !0 },
			cellSpacing: { type: String, treatNullAsEmptyString: !0 },
		},
	})
	Me({
		tag: "template",
		name: "HTMLTemplateElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n), (this._contentFragment = t._templateDoc.createDocumentFragment())
		},
		props: {
			content: {
				get: function () {
					return this._contentFragment
				},
			},
			serialize: {
				value: function () {
					return this.content.serialize()
				},
			},
		},
	})
	Me({
		tag: "tr",
		name: "HTMLTableRowElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		props: {
			cells: {
				get: function () {
					return this.querySelectorAll("td,th")
				},
			},
		},
		attributes: {
			align: String,
			ch: { name: "char", type: String },
			chOff: { name: "charoff", type: String },
			vAlign: String,
			bgColor: { type: String, treatNullAsEmptyString: !0 },
		},
	})
	Me({
		tags: ["thead", "tfoot", "tbody"],
		name: "HTMLTableSectionElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		props: {
			rows: {
				get: function () {
					return this.getElementsByTagName("tr")
				},
			},
		},
		attributes: {
			align: String,
			ch: { name: "char", type: String },
			chOff: { name: "charoff", type: String },
			vAlign: String,
		},
	})
	Me({
		tag: "textarea",
		name: "HTMLTextAreaElement",
		ctor: function (t, r, n) {
			tc.call(this, t, r, n)
		},
		props: {
			form: rc.form,
			type: {
				get: function () {
					return "textarea"
				},
			},
			defaultValue: {
				get: function () {
					return this.textContent
				},
				set: function (e) {
					this.textContent = e
				},
			},
			value: {
				get: function () {
					return this.defaultValue
				},
				set: function (e) {
					this.defaultValue = e
				},
			},
			textLength: {
				get: function () {
					return this.value.length
				},
			},
		},
		attributes: {
			autocomplete: String,
			name: String,
			disabled: Boolean,
			autofocus: Boolean,
			placeholder: String,
			wrap: String,
			dirName: String,
			required: Boolean,
			readOnly: Boolean,
			rows: { type: "limited unsigned long with fallback", default: 2 },
			cols: { type: "limited unsigned long with fallback", default: 20 },
			maxLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
			minLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
			inputMode: {
				type: [
					"verbatim",
					"latin",
					"latin-name",
					"latin-prose",
					"full-width-latin",
					"kana",
					"kana-name",
					"katakana",
					"numeric",
					"tel",
					"email",
					"url",
				],
				missing: "",
			},
		},
	})
	Me({
		tag: "time",
		name: "HTMLTimeElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { dateTime: String, pubDate: Boolean },
	})
	Me({
		tag: "title",
		name: "HTMLTitleElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		props: {
			text: {
				get: function () {
					return this.textContent
				},
			},
		},
	})
	Me({
		tag: "ul",
		name: "HTMLUListElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { type: String, compact: Boolean },
	})
	Me({
		name: "HTMLMediaElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			src: ti,
			crossOrigin: _S,
			preload: {
				type: ["metadata", "none", "auto", { value: "", alias: "auto" }],
				missing: "auto",
			},
			loop: Boolean,
			autoplay: Boolean,
			mediaGroup: String,
			controls: Boolean,
			defaultMuted: { name: "muted", type: Boolean },
		},
	})
	Me({
		name: "HTMLAudioElement",
		tag: "audio",
		superclass: bd.HTMLMediaElement,
		ctor: function (t, r, n) {
			bd.HTMLMediaElement.call(this, t, r, n)
		},
	})
	Me({
		name: "HTMLVideoElement",
		tag: "video",
		superclass: bd.HTMLMediaElement,
		ctor: function (t, r, n) {
			bd.HTMLMediaElement.call(this, t, r, n)
		},
		attributes: {
			poster: ti,
			width: { type: "unsigned long", min: 0, default: 0 },
			height: { type: "unsigned long", min: 0, default: 0 },
		},
	})
	Me({
		tag: "td",
		name: "HTMLTableDataCellElement",
		superclass: bd.HTMLTableCellElement,
		ctor: function (t, r, n) {
			bd.HTMLTableCellElement.call(this, t, r, n)
		},
	})
	Me({
		tag: "th",
		name: "HTMLTableHeaderCellElement",
		superclass: bd.HTMLTableCellElement,
		ctor: function (t, r, n) {
			bd.HTMLTableCellElement.call(this, t, r, n)
		},
	})
	Me({
		tag: "frameset",
		name: "HTMLFrameSetElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
	})
	Me({
		tag: "frame",
		name: "HTMLFrameElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
	})
	Me({
		tag: "canvas",
		name: "HTMLCanvasElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		props: {
			getContext: { value: ha.nyi },
			probablySupportsContext: { value: ha.nyi },
			setContext: { value: ha.nyi },
			transferControlToProxy: { value: ha.nyi },
			toDataURL: { value: ha.nyi },
			toBlob: { value: ha.nyi },
		},
		attributes: {
			width: { type: "unsigned long", default: 300 },
			height: { type: "unsigned long", default: 150 },
		},
	})
	Me({
		tag: "dialog",
		name: "HTMLDialogElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		props: {
			show: { value: ha.nyi },
			showModal: { value: ha.nyi },
			close: { value: ha.nyi },
		},
		attributes: { open: Boolean, returnValue: String },
	})
	Me({
		tag: "menuitem",
		name: "HTMLMenuItemElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		props: {
			_label: {
				get: function () {
					var e = this._getattr("label")
					return e !== null && e !== "" ? e : ((e = this.textContent), e.replace(/[ \t\n\f\r]+/g, " ").trim())
				},
			},
			label: {
				get: function () {
					var e = this._getattr("label")
					return e !== null ? e : this._label
				},
				set: function (e) {
					this._setattr("label", e)
				},
			},
		},
		attributes: {
			type: { type: ["command", "checkbox", "radio"], missing: "command" },
			icon: ti,
			disabled: Boolean,
			checked: Boolean,
			radiogroup: String,
			default: Boolean,
		},
	})
	Me({
		tag: "source",
		name: "HTMLSourceElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			srcset: String,
			sizes: String,
			media: String,
			src: ti,
			type: String,
			width: String,
			height: String,
		},
	})
	Me({
		tag: "track",
		name: "HTMLTrackElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			src: ti,
			srclang: String,
			label: String,
			default: Boolean,
			kind: {
				type: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
				missing: "subtitles",
				invalid: "metadata",
			},
		},
		props: {
			NONE: {
				get: function () {
					return 0
				},
			},
			LOADING: {
				get: function () {
					return 1
				},
			},
			LOADED: {
				get: function () {
					return 2
				},
			},
			ERROR: {
				get: function () {
					return 3
				},
			},
			readyState: { get: ha.nyi },
			track: { get: ha.nyi },
		},
	})
	Me({
		tag: "font",
		name: "HTMLFontElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: {
			color: { type: String, treatNullAsEmptyString: !0 },
			face: { type: String },
			size: { type: String },
		},
	})
	Me({
		tag: "dir",
		name: "HTMLDirectoryElement",
		ctor: function (t, r, n) {
			ze.call(this, t, r, n)
		},
		attributes: { compact: Boolean },
	})
	Me({
		tags: [
			"abbr",
			"address",
			"article",
			"aside",
			"b",
			"bdi",
			"bdo",
			"cite",
			"content",
			"code",
			"dd",
			"dfn",
			"dt",
			"em",
			"figcaption",
			"figure",
			"footer",
			"header",
			"hgroup",
			"i",
			"kbd",
			"main",
			"mark",
			"nav",
			"noscript",
			"rb",
			"rp",
			"rt",
			"rtc",
			"ruby",
			"s",
			"samp",
			"section",
			"small",
			"strong",
			"sub",
			"summary",
			"sup",
			"u",
			"var",
			"wbr",
			"acronym",
			"basefont",
			"big",
			"center",
			"nobr",
			"noembed",
			"noframes",
			"plaintext",
			"strike",
			"tt",
		],
	})
})
var XL = x((SS) => {
	"use strict"
	var Yz = Dm(),
		GPe = JL(),
		$Pe = ei(),
		YPe = xS(),
		KPe = (SS.elements = {}),
		Kz = Object.create(null)
	SS.createElement = function (e, t, r) {
		var n = Kz[t] || ZL
		return new n(e, t, r)
	}
	function jL(e) {
		return GPe(e, ZL, KPe, Kz)
	}
	var ZL = jL({
		superclass: Yz,
		name: "SVGElement",
		ctor: function (t, r, n) {
			Yz.call(this, t, r, $Pe.NAMESPACE.SVG, n)
		},
		props: {
			style: {
				get: function () {
					return this._style || (this._style = new YPe(this)), this._style
				},
			},
		},
	})
	jL({
		name: "SVGSVGElement",
		ctor: function (t, r, n) {
			ZL.call(this, t, r, n)
		},
		tag: "svg",
		props: {
			createSVGRect: {
				value: function () {
					return SS.createElement(this.ownerDocument, "rect", null)
				},
			},
		},
	})
	jL({
		tags: [
			"a",
			"altGlyph",
			"altGlyphDef",
			"altGlyphItem",
			"animate",
			"animateColor",
			"animateMotion",
			"animateTransform",
			"circle",
			"clipPath",
			"color-profile",
			"cursor",
			"defs",
			"desc",
			"ellipse",
			"feBlend",
			"feColorMatrix",
			"feComponentTransfer",
			"feComposite",
			"feConvolveMatrix",
			"feDiffuseLighting",
			"feDisplacementMap",
			"feDistantLight",
			"feFlood",
			"feFuncA",
			"feFuncB",
			"feFuncG",
			"feFuncR",
			"feGaussianBlur",
			"feImage",
			"feMerge",
			"feMergeNode",
			"feMorphology",
			"feOffset",
			"fePointLight",
			"feSpecularLighting",
			"feSpotLight",
			"feTile",
			"feTurbulence",
			"filter",
			"font",
			"font-face",
			"font-face-format",
			"font-face-name",
			"font-face-src",
			"font-face-uri",
			"foreignObject",
			"g",
			"glyph",
			"glyphRef",
			"hkern",
			"image",
			"line",
			"linearGradient",
			"marker",
			"mask",
			"metadata",
			"missing-glyph",
			"mpath",
			"path",
			"pattern",
			"polygon",
			"polyline",
			"radialGradient",
			"rect",
			"script",
			"set",
			"stop",
			"style",
			"switch",
			"symbol",
			"text",
			"textPath",
			"title",
			"tref",
			"tspan",
			"use",
			"view",
			"vkern",
		],
	})
})
var zz = x((vxt, Jz) => {
	"use strict"
	Jz.exports = {
		VALUE: 1,
		ATTR: 2,
		REMOVE_ATTR: 3,
		REMOVE: 4,
		MOVE: 5,
		INSERT: 6,
	}
})
var DS = x((Ext, oj) => {
	"use strict"
	oj.exports = lE
	var Ns = ps(),
		JPe = Kg(),
		rj = dS(),
		Of = Dm(),
		zPe = kL(),
		jPe = FL(),
		aE = bm(),
		ZPe = NL(),
		XPe = LL(),
		eLe = cE(),
		tLe = bz(),
		rLe = Bz(),
		jz = iE(),
		Zz = bS(),
		Xz = AS(),
		nLe = YL(),
		BS = fS(),
		eU = IS(),
		iLe = XL(),
		Mr = ei(),
		Mm = zz(),
		Qm = Mr.NAMESPACE,
		tU = lS().isApiWritable
	function lE(e, t) {
		rj.call(this),
			(this.nodeType = Ns.DOCUMENT_NODE),
			(this.isHTML = e),
			(this._address = t || "about:blank"),
			(this.readyState = "loading"),
			(this.implementation = new eLe(this)),
			(this.ownerDocument = null),
			(this._contentType = e ? "text/html" : "application/xml"),
			(this.doctype = null),
			(this.documentElement = null),
			(this._templateDocCache = null),
			(this._nodeIterators = null),
			(this._nid = 1),
			(this._nextnid = 2),
			(this._nodes = [null, this]),
			(this.byId = Object.create(null)),
			(this.modclock = 0)
	}
	var sLe = {
			event: "Event",
			customevent: "CustomEvent",
			uievent: "UIEvent",
			mouseevent: "MouseEvent",
		},
		oLe = {
			events: "event",
			htmlevents: "event",
			mouseevents: "mouseevent",
			mutationevents: "mutationevent",
			uievents: "uievent",
		},
		Fm = function (e, t, r) {
			return {
				get: function () {
					var n = e.call(this)
					return n ? n[t] : r
				},
				set: function (n) {
					var i = e.call(this)
					i && (i[t] = n)
				},
			}
		}
	function ej(e, t) {
		var r, n, i
		return (
			e === "" && (e = null),
			BS.isValidQName(t) || Mr.InvalidCharacterError(),
			(r = null),
			(n = t),
			(i = t.indexOf(":")),
			i >= 0 && ((r = t.substring(0, i)), (n = t.substring(i + 1))),
			r !== null && e === null && Mr.NamespaceError(),
			r === "xml" && e !== Qm.XML && Mr.NamespaceError(),
			(r === "xmlns" || t === "xmlns") && e !== Qm.XMLNS && Mr.NamespaceError(),
			e === Qm.XMLNS && !(r === "xmlns" || t === "xmlns") && Mr.NamespaceError(),
			{ namespace: e, prefix: r, localName: n }
		)
	}
	lE.prototype = Object.create(rj.prototype, {
		_setMutationHandler: {
			value: function (e) {
				this.mutationHandler = e
			},
		},
		_dispatchRendererEvent: {
			value: function (e, t, r) {
				var n = this._nodes[e]
				n && n._dispatchEvent(new aE(t, r), !0)
			},
		},
		nodeName: { value: "#document" },
		nodeValue: {
			get: function () {
				return null
			},
			set: function () {},
		},
		documentURI: {
			get: function () {
				return this._address
			},
			set: Mr.nyi,
		},
		compatMode: {
			get: function () {
				return this._quirks ? "BackCompat" : "CSS1Compat"
			},
		},
		createTextNode: {
			value: function (e) {
				return new zPe(this, String(e))
			},
		},
		createComment: {
			value: function (e) {
				return new jPe(this, e)
			},
		},
		createDocumentFragment: {
			value: function () {
				return new ZPe(this)
			},
		},
		createProcessingInstruction: {
			value: function (e, t) {
				return (!BS.isValidName(e) || t.indexOf("?>") !== -1) && Mr.InvalidCharacterError(), new XPe(this, e, t)
			},
		},
		createAttribute: {
			value: function (e) {
				return (
					(e = String(e)),
					BS.isValidName(e) || Mr.InvalidCharacterError(),
					this.isHTML && (e = Mr.toASCIILowerCase(e)),
					new Of._Attr(null, e, null, null, "")
				)
			},
		},
		createAttributeNS: {
			value: function (e, t) {
				;(e = e == null || e === "" ? null : String(e)), (t = String(t))
				var r = ej(e, t)
				return new Of._Attr(null, r.localName, r.prefix, r.namespace, "")
			},
		},
		createElement: {
			value: function (e) {
				return (
					(e = String(e)),
					BS.isValidName(e) || Mr.InvalidCharacterError(),
					this.isHTML
						? (/[A-Z]/.test(e) && (e = Mr.toASCIILowerCase(e)), eU.createElement(this, e, null))
						: this.contentType === "application/xhtml+xml"
							? eU.createElement(this, e, null)
							: new Of(this, e, null, null)
				)
			},
			writable: tU,
		},
		createElementNS: {
			value: function (e, t) {
				;(e = e == null || e === "" ? null : String(e)), (t = String(t))
				var r = ej(e, t)
				return this._createElementNS(r.localName, r.namespace, r.prefix)
			},
			writable: tU,
		},
		_createElementNS: {
			value: function (e, t, r) {
				return t === Qm.HTML
					? eU.createElement(this, e, r)
					: t === Qm.SVG
						? iLe.createElement(this, e, r)
						: new Of(this, e, t, r)
			},
		},
		createEvent: {
			value: function (t) {
				t = t.toLowerCase()
				var r = oLe[t] || t,
					n = nLe[sLe[r]]
				if (n) {
					var i = new n()
					return (i._initialized = !1), i
				} else Mr.NotSupportedError()
			},
		},
		createTreeWalker: {
			value: function (e, t, r) {
				if (!e) throw new TypeError("root argument is required")
				if (!(e instanceof Ns)) throw new TypeError("root not a node")
				return (t = t === void 0 ? jz.SHOW_ALL : +t), (r = r === void 0 ? null : r), new tLe(e, t, r)
			},
		},
		createNodeIterator: {
			value: function (e, t, r) {
				if (!e) throw new TypeError("root argument is required")
				if (!(e instanceof Ns)) throw new TypeError("root not a node")
				return (t = t === void 0 ? jz.SHOW_ALL : +t), (r = r === void 0 ? null : r), new rLe(e, t, r)
			},
		},
		_attachNodeIterator: {
			value: function (e) {
				this._nodeIterators || (this._nodeIterators = []), this._nodeIterators.push(e)
			},
		},
		_detachNodeIterator: {
			value: function (e) {
				var t = this._nodeIterators.indexOf(e)
				this._nodeIterators.splice(t, 1)
			},
		},
		_preremoveNodeIterators: {
			value: function (e) {
				this._nodeIterators &&
					this._nodeIterators.forEach(function (t) {
						t._preremove(e)
					})
			},
		},
		_updateDocTypeElement: {
			value: function () {
				this.doctype = this.documentElement = null
				for (var t = this.firstChild; t !== null; t = t.nextSibling)
					t.nodeType === Ns.DOCUMENT_TYPE_NODE
						? (this.doctype = t)
						: t.nodeType === Ns.ELEMENT_NODE && (this.documentElement = t)
			},
		},
		insertBefore: {
			value: function (t, r) {
				return Ns.prototype.insertBefore.call(this, t, r), this._updateDocTypeElement(), t
			},
		},
		replaceChild: {
			value: function (t, r) {
				return Ns.prototype.replaceChild.call(this, t, r), this._updateDocTypeElement(), r
			},
		},
		removeChild: {
			value: function (t) {
				return Ns.prototype.removeChild.call(this, t), this._updateDocTypeElement(), t
			},
		},
		getElementById: {
			value: function (e) {
				var t = this.byId[e]
				return t ? (t instanceof xd ? t.getFirst() : t) : null
			},
		},
		_hasMultipleElementsWithId: {
			value: function (e) {
				return this.byId[e] instanceof xd
			},
		},
		getElementsByName: { value: Of.prototype.getElementsByName },
		getElementsByTagName: { value: Of.prototype.getElementsByTagName },
		getElementsByTagNameNS: { value: Of.prototype.getElementsByTagNameNS },
		getElementsByClassName: { value: Of.prototype.getElementsByClassName },
		adoptNode: {
			value: function (t) {
				return (
					t.nodeType === Ns.DOCUMENT_NODE && Mr.NotSupportedError(),
					t.nodeType === Ns.ATTRIBUTE_NODE ||
						(t.parentNode && t.parentNode.removeChild(t), t.ownerDocument !== this && sj(t, this)),
					t
				)
			},
		},
		importNode: {
			value: function (t, r) {
				return this.adoptNode(t.cloneNode(r))
			},
			writable: tU,
		},
		origin: {
			get: function () {
				return null
			},
		},
		characterSet: {
			get: function () {
				return "UTF-8"
			},
		},
		contentType: {
			get: function () {
				return this._contentType
			},
		},
		URL: {
			get: function () {
				return this._address
			},
		},
		domain: { get: Mr.nyi, set: Mr.nyi },
		referrer: { get: Mr.nyi },
		cookie: { get: Mr.nyi, set: Mr.nyi },
		lastModified: { get: Mr.nyi },
		location: {
			get: function () {
				return this.defaultView ? this.defaultView.location : null
			},
			set: Mr.nyi,
		},
		_titleElement: {
			get: function () {
				return this.getElementsByTagName("title").item(0) || null
			},
		},
		title: {
			get: function () {
				var e = this._titleElement,
					t = e ? e.textContent : ""
				return t.replace(/[ \t\n\r\f]+/g, " ").replace(/(^ )|( $)/g, "")
			},
			set: function (e) {
				var t = this._titleElement,
					r = this.head
				;(!t && !r) || (t || ((t = this.createElement("title")), r.appendChild(t)), (t.textContent = e))
			},
		},
		dir: Fm(
			function () {
				var e = this.documentElement
				if (e && e.tagName === "HTML") return e
			},
			"dir",
			"",
		),
		fgColor: Fm(
			function () {
				return this.body
			},
			"text",
			"",
		),
		linkColor: Fm(
			function () {
				return this.body
			},
			"link",
			"",
		),
		vlinkColor: Fm(
			function () {
				return this.body
			},
			"vLink",
			"",
		),
		alinkColor: Fm(
			function () {
				return this.body
			},
			"aLink",
			"",
		),
		bgColor: Fm(
			function () {
				return this.body
			},
			"bgColor",
			"",
		),
		charset: {
			get: function () {
				return this.characterSet
			},
		},
		inputEncoding: {
			get: function () {
				return this.characterSet
			},
		},
		scrollingElement: {
			get: function () {
				return this._quirks ? this.body : this.documentElement
			},
		},
		body: {
			get: function () {
				return tj(this.documentElement, "body")
			},
			set: Mr.nyi,
		},
		head: {
			get: function () {
				return tj(this.documentElement, "head")
			},
		},
		images: { get: Mr.nyi },
		embeds: { get: Mr.nyi },
		plugins: { get: Mr.nyi },
		links: { get: Mr.nyi },
		forms: { get: Mr.nyi },
		scripts: { get: Mr.nyi },
		applets: {
			get: function () {
				return []
			},
		},
		activeElement: {
			get: function () {
				return null
			},
		},
		innerHTML: {
			get: function () {
				return this.serialize()
			},
			set: Mr.nyi,
		},
		outerHTML: {
			get: function () {
				return this.serialize()
			},
			set: Mr.nyi,
		},
		write: {
			value: function (e) {
				if ((this.isHTML || Mr.InvalidStateError(), !!this._parser)) {
					this._parser
					var t = arguments.join("")
					this._parser.parse(t)
				}
			},
		},
		writeln: {
			value: function (t) {
				this.write(
					Array.prototype.join.call(arguments, "") +
						`
`,
				)
			},
		},
		open: {
			value: function () {
				this.documentElement = null
			},
		},
		close: {
			value: function () {
				;(this.readyState = "interactive"),
					this._dispatchEvent(new aE("readystatechange"), !0),
					this._dispatchEvent(new aE("DOMContentLoaded"), !0),
					(this.readyState = "complete"),
					this._dispatchEvent(new aE("readystatechange"), !0),
					this.defaultView && this.defaultView._dispatchEvent(new aE("load"), !0)
			},
		},
		clone: {
			value: function () {
				var t = new lE(this.isHTML, this._address)
				return (t._quirks = this._quirks), (t._contentType = this._contentType), t
			},
		},
		cloneNode: {
			value: function (t) {
				var r = Ns.prototype.cloneNode.call(this, !1)
				if (t) for (var n = this.firstChild; n !== null; n = n.nextSibling) r._appendChild(r.importNode(n, !0))
				return r._updateDocTypeElement(), r
			},
		},
		isEqual: {
			value: function (t) {
				return !0
			},
		},
		mutateValue: {
			value: function (e) {
				this.mutationHandler && this.mutationHandler({ type: Mm.VALUE, target: e, data: e.data })
			},
		},
		mutateAttr: {
			value: function (e, t) {
				this.mutationHandler &&
					this.mutationHandler({
						type: Mm.ATTR,
						target: e.ownerElement,
						attr: e,
					})
			},
		},
		mutateRemoveAttr: {
			value: function (e) {
				this.mutationHandler &&
					this.mutationHandler({
						type: Mm.REMOVE_ATTR,
						target: e.ownerElement,
						attr: e,
					})
			},
		},
		mutateRemove: {
			value: function (e) {
				this.mutationHandler &&
					this.mutationHandler({
						type: Mm.REMOVE,
						target: e.parentNode,
						node: e,
					}),
					ij(e)
			},
		},
		mutateInsert: {
			value: function (e) {
				nj(e),
					this.mutationHandler &&
						this.mutationHandler({
							type: Mm.INSERT,
							target: e.parentNode,
							node: e,
						})
			},
		},
		mutateMove: {
			value: function (e) {
				this.mutationHandler && this.mutationHandler({ type: Mm.MOVE, target: e })
			},
		},
		addId: {
			value: function (t, r) {
				var n = this.byId[t]
				n ? (n instanceof xd || ((n = new xd(n)), (this.byId[t] = n)), n.add(r)) : (this.byId[t] = r)
			},
		},
		delId: {
			value: function (t, r) {
				var n = this.byId[t]
				Mr.assert(n),
					n instanceof xd
						? (n.del(r), n.length === 1 && (this.byId[t] = n.downgrade()))
						: (this.byId[t] = void 0)
			},
		},
		_resolve: {
			value: function (e) {
				return new Zz(this._documentBaseURL).resolve(e)
			},
		},
		_documentBaseURL: {
			get: function () {
				var e = this._address
				e === "about:blank" && (e = "/")
				var t = this.querySelector("base[href]")
				return t ? new Zz(e).resolve(t.getAttribute("href")) : e
			},
		},
		_templateDoc: {
			get: function () {
				if (!this._templateDocCache) {
					var e = new lE(this.isHTML, this._address)
					this._templateDocCache = e._templateDocCache = e
				}
				return this._templateDocCache
			},
		},
		querySelector: {
			value: function (e) {
				return Xz(e, this)[0]
			},
		},
		querySelectorAll: {
			value: function (e) {
				var t = Xz(e, this)
				return t.item ? t : new JPe(t)
			},
		},
	})
	var aLe = [
		"abort",
		"canplay",
		"canplaythrough",
		"change",
		"click",
		"contextmenu",
		"cuechange",
		"dblclick",
		"drag",
		"dragend",
		"dragenter",
		"dragleave",
		"dragover",
		"dragstart",
		"drop",
		"durationchange",
		"emptied",
		"ended",
		"input",
		"invalid",
		"keydown",
		"keypress",
		"keyup",
		"loadeddata",
		"loadedmetadata",
		"loadstart",
		"mousedown",
		"mousemove",
		"mouseout",
		"mouseover",
		"mouseup",
		"mousewheel",
		"pause",
		"play",
		"playing",
		"progress",
		"ratechange",
		"readystatechange",
		"reset",
		"seeked",
		"seeking",
		"select",
		"show",
		"stalled",
		"submit",
		"suspend",
		"timeupdate",
		"volumechange",
		"waiting",
		"blur",
		"error",
		"focus",
		"load",
		"scroll",
	]
	aLe.forEach(function (e) {
		Object.defineProperty(lE.prototype, "on" + e, {
			get: function () {
				return this._getEventHandler(e)
			},
			set: function (t) {
				this._setEventHandler(e, t)
			},
		})
	})
	function tj(e, t) {
		if (e && e.isHTML) {
			for (var r = e.firstChild; r !== null; r = r.nextSibling)
				if (r.nodeType === Ns.ELEMENT_NODE && r.localName === t && r.namespaceURI === Qm.HTML) return r
		}
		return null
	}
	function lLe(e) {
		if (
			((e._nid = e.ownerDocument._nextnid++),
			(e.ownerDocument._nodes[e._nid] = e),
			e.nodeType === Ns.ELEMENT_NODE)
		) {
			var t = e.getAttribute("id")
			t && e.ownerDocument.addId(t, e), e._roothook && e._roothook()
		}
	}
	function cLe(e) {
		if (e.nodeType === Ns.ELEMENT_NODE) {
			var t = e.getAttribute("id")
			t && e.ownerDocument.delId(t, e)
		}
		;(e.ownerDocument._nodes[e._nid] = void 0), (e._nid = void 0)
	}
	function nj(e) {
		if ((lLe(e), e.nodeType === Ns.ELEMENT_NODE)) for (var t = e.firstChild; t !== null; t = t.nextSibling) nj(t)
	}
	function ij(e) {
		cLe(e)
		for (var t = e.firstChild; t !== null; t = t.nextSibling) ij(t)
	}
	function sj(e, t) {
		;(e.ownerDocument = t),
			(e._lastModTime = void 0),
			Object.prototype.hasOwnProperty.call(e, "_tagName") && (e._tagName = void 0)
		for (var r = e.firstChild; r !== null; r = r.nextSibling) sj(r, t)
	}
	function xd(e) {
		;(this.nodes = Object.create(null)), (this.nodes[e._nid] = e), (this.length = 1), (this.firstNode = void 0)
	}
	xd.prototype.add = function (e) {
		this.nodes[e._nid] || ((this.nodes[e._nid] = e), this.length++, (this.firstNode = void 0))
	}
	xd.prototype.del = function (e) {
		this.nodes[e._nid] && (delete this.nodes[e._nid], this.length--, (this.firstNode = void 0))
	}
	xd.prototype.getFirst = function () {
		if (!this.firstNode) {
			var e
			for (e in this.nodes)
				(this.firstNode === void 0 ||
					this.firstNode.compareDocumentPosition(this.nodes[e]) & Ns.DOCUMENT_POSITION_PRECEDING) &&
					(this.firstNode = this.nodes[e])
		}
		return this.firstNode
	}
	xd.prototype.downgrade = function () {
		if (this.length === 1) {
			var e
			for (e in this.nodes) return this.nodes[e]
		}
		return this
	}
})
var RS = x((bxt, lj) => {
	"use strict"
	lj.exports = TS
	var uLe = ps(),
		aj = TL(),
		dLe = mS()
	function TS(e, t, r, n) {
		aj.call(this),
			(this.nodeType = uLe.DOCUMENT_TYPE_NODE),
			(this.ownerDocument = e || null),
			(this.name = t),
			(this.publicId = r || ""),
			(this.systemId = n || "")
	}
	TS.prototype = Object.create(aj.prototype, {
		nodeName: {
			get: function () {
				return this.name
			},
		},
		nodeValue: {
			get: function () {
				return null
			},
			set: function () {},
		},
		clone: {
			value: function () {
				return new TS(this.ownerDocument, this.name, this.publicId, this.systemId)
			},
		},
		isEqual: {
			value: function (t) {
				return this.name === t.name && this.publicId === t.publicId && this.systemId === t.systemId
			},
		},
	})
	Object.defineProperties(TS.prototype, dLe)
})
var LS = x((xxt, Rj) => {
	"use strict"
	Rj.exports = Ir
	var fLe = DS(),
		hLe = RS(),
		rU = ps(),
		ot = ei().NAMESPACE,
		xj = IS(),
		Jr = xj.elements,
		zg = Function.prototype.apply.bind(Array.prototype.push),
		kS = -1,
		Nm = 1,
		Ps = 2,
		ir = 3,
		Zc = 4,
		gLe = 5,
		pLe = [],
		ALe =
			/^HTML$|^-\/\/W3O\/\/DTD W3 HTML Strict 3\.0\/\/EN\/\/$|^-\/W3C\/DTD HTML 4\.0 Transitional\/EN$|^\+\/\/Silmaril\/\/dtd html Pro v0r11 19970101\/\/|^-\/\/AdvaSoft Ltd\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/AS\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict\/\/|^-\/\/IETF\/\/DTD HTML 2\.0\/\/|^-\/\/IETF\/\/DTD HTML 2\.1E\/\/|^-\/\/IETF\/\/DTD HTML 3\.0\/\/|^-\/\/IETF\/\/DTD HTML 3\.2 Final\/\/|^-\/\/IETF\/\/DTD HTML 3\.2\/\/|^-\/\/IETF\/\/DTD HTML 3\/\/|^-\/\/IETF\/\/DTD HTML Level 0\/\/|^-\/\/IETF\/\/DTD HTML Level 1\/\/|^-\/\/IETF\/\/DTD HTML Level 2\/\/|^-\/\/IETF\/\/DTD HTML Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 0\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict\/\/|^-\/\/IETF\/\/DTD HTML\/\/|^-\/\/Metrius\/\/DTD Metrius Presentational\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 Tables\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 Tables\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD HTML\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD Strict HTML\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML 2\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended 1\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended Relaxed 1\.0\/\/|^-\/\/SoftQuad Software\/\/DTD HoTMetaL PRO 6\.0::19990601::extensions to HTML 4\.0\/\/|^-\/\/SoftQuad\/\/DTD HoTMetaL PRO 4\.0::19971010::extensions to HTML 4\.0\/\/|^-\/\/Spyglass\/\/DTD HTML 2\.0 Extended\/\/|^-\/\/SQ\/\/DTD HTML 2\.0 HoTMetaL \+ extensions\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava HTML\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava Strict HTML\/\/|^-\/\/W3C\/\/DTD HTML 3 1995-03-24\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Draft\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Final\/\/|^-\/\/W3C\/\/DTD HTML 3\.2\/\/|^-\/\/W3C\/\/DTD HTML 3\.2S Draft\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Transitional\/\/|^-\/\/W3C\/\/DTD HTML Experimental 19960712\/\/|^-\/\/W3C\/\/DTD HTML Experimental 970421\/\/|^-\/\/W3C\/\/DTD W3 HTML\/\/|^-\/\/W3O\/\/DTD W3 HTML 3\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML 2\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML\/\//i,
		mLe = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd",
		cj = /^-\/\/W3C\/\/DTD HTML 4\.01 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.01 Transitional\/\//i,
		yLe = /^-\/\/W3C\/\/DTD XHTML 1\.0 Frameset\/\/|^-\/\/W3C\/\/DTD XHTML 1\.0 Transitional\/\//i,
		Zg = Object.create(null)
	Zg[ot.HTML] = {
		__proto__: null,
		address: !0,
		applet: !0,
		area: !0,
		article: !0,
		aside: !0,
		base: !0,
		basefont: !0,
		bgsound: !0,
		blockquote: !0,
		body: !0,
		br: !0,
		button: !0,
		caption: !0,
		center: !0,
		col: !0,
		colgroup: !0,
		dd: !0,
		details: !0,
		dir: !0,
		div: !0,
		dl: !0,
		dt: !0,
		embed: !0,
		fieldset: !0,
		figcaption: !0,
		figure: !0,
		footer: !0,
		form: !0,
		frame: !0,
		frameset: !0,
		h1: !0,
		h2: !0,
		h3: !0,
		h4: !0,
		h5: !0,
		h6: !0,
		head: !0,
		header: !0,
		hgroup: !0,
		hr: !0,
		html: !0,
		iframe: !0,
		img: !0,
		input: !0,
		li: !0,
		link: !0,
		listing: !0,
		main: !0,
		marquee: !0,
		menu: !0,
		meta: !0,
		nav: !0,
		noembed: !0,
		noframes: !0,
		noscript: !0,
		object: !0,
		ol: !0,
		p: !0,
		param: !0,
		plaintext: !0,
		pre: !0,
		script: !0,
		section: !0,
		select: !0,
		source: !0,
		style: !0,
		summary: !0,
		table: !0,
		tbody: !0,
		td: !0,
		template: !0,
		textarea: !0,
		tfoot: !0,
		th: !0,
		thead: !0,
		title: !0,
		tr: !0,
		track: !0,
		ul: !0,
		wbr: !0,
		xmp: !0,
	}
	Zg[ot.SVG] = { __proto__: null, foreignObject: !0, desc: !0, title: !0 }
	Zg[ot.MATHML] = {
		__proto__: null,
		mi: !0,
		mo: !0,
		mn: !0,
		ms: !0,
		mtext: !0,
		"annotation-xml": !0,
	}
	var sU = Object.create(null)
	sU[ot.HTML] = { __proto__: null, address: !0, div: !0, p: !0 }
	var _j = Object.create(null)
	_j[ot.HTML] = { __proto__: null, dd: !0, dt: !0 }
	var Pm = Object.create(null)
	Pm[ot.HTML] = {
		__proto__: null,
		table: !0,
		thead: !0,
		tbody: !0,
		tfoot: !0,
		tr: !0,
	}
	var wj = Object.create(null)
	wj[ot.HTML] = {
		__proto__: null,
		dd: !0,
		dt: !0,
		li: !0,
		menuitem: !0,
		optgroup: !0,
		option: !0,
		p: !0,
		rb: !0,
		rp: !0,
		rt: !0,
		rtc: !0,
	}
	var Ij = Object.create(null)
	Ij[ot.HTML] = {
		__proto__: null,
		caption: !0,
		colgroup: !0,
		dd: !0,
		dt: !0,
		li: !0,
		optgroup: !0,
		option: !0,
		p: !0,
		rb: !0,
		rp: !0,
		rt: !0,
		rtc: !0,
		tbody: !0,
		td: !0,
		tfoot: !0,
		th: !0,
		thead: !0,
		tr: !0,
	}
	var QS = Object.create(null)
	QS[ot.HTML] = { __proto__: null, table: !0, template: !0, html: !0 }
	var NS = Object.create(null)
	NS[ot.HTML] = {
		__proto__: null,
		tbody: !0,
		tfoot: !0,
		thead: !0,
		template: !0,
		html: !0,
	}
	var oU = Object.create(null)
	oU[ot.HTML] = { __proto__: null, tr: !0, template: !0, html: !0 }
	var Sj = Object.create(null)
	Sj[ot.HTML] = {
		__proto__: null,
		button: !0,
		fieldset: !0,
		input: !0,
		keygen: !0,
		object: !0,
		output: !0,
		select: !0,
		textarea: !0,
		img: !0,
	}
	var Xc = Object.create(null)
	Xc[ot.HTML] = {
		__proto__: null,
		applet: !0,
		caption: !0,
		html: !0,
		table: !0,
		td: !0,
		th: !0,
		marquee: !0,
		object: !0,
		template: !0,
	}
	Xc[ot.MATHML] = {
		__proto__: null,
		mi: !0,
		mo: !0,
		mn: !0,
		ms: !0,
		mtext: !0,
		"annotation-xml": !0,
	}
	Xc[ot.SVG] = { __proto__: null, foreignObject: !0, desc: !0, title: !0 }
	var PS = Object.create(Xc)
	PS[ot.HTML] = Object.create(Xc[ot.HTML])
	PS[ot.HTML].ol = !0
	PS[ot.HTML].ul = !0
	var aU = Object.create(Xc)
	aU[ot.HTML] = Object.create(Xc[ot.HTML])
	aU[ot.HTML].button = !0
	var Bj = Object.create(null)
	Bj[ot.HTML] = { __proto__: null, html: !0, table: !0, template: !0 }
	var CLe = Object.create(null)
	CLe[ot.HTML] = { __proto__: null, optgroup: !0, option: !0 }
	var Dj = Object.create(null)
	Dj[ot.MATHML] = {
		__proto__: null,
		mi: !0,
		mo: !0,
		mn: !0,
		ms: !0,
		mtext: !0,
	}
	var Tj = Object.create(null)
	Tj[ot.SVG] = { __proto__: null, foreignObject: !0, desc: !0, title: !0 }
	var uj = {
			__proto__: null,
			"xlink:actuate": ot.XLINK,
			"xlink:arcrole": ot.XLINK,
			"xlink:href": ot.XLINK,
			"xlink:role": ot.XLINK,
			"xlink:show": ot.XLINK,
			"xlink:title": ot.XLINK,
			"xlink:type": ot.XLINK,
			"xml:base": ot.XML,
			"xml:lang": ot.XML,
			"xml:space": ot.XML,
			xmlns: ot.XMLNS,
			"xmlns:xlink": ot.XMLNS,
		},
		dj = {
			__proto__: null,
			attributename: "attributeName",
			attributetype: "attributeType",
			basefrequency: "baseFrequency",
			baseprofile: "baseProfile",
			calcmode: "calcMode",
			clippathunits: "clipPathUnits",
			diffuseconstant: "diffuseConstant",
			edgemode: "edgeMode",
			filterunits: "filterUnits",
			glyphref: "glyphRef",
			gradienttransform: "gradientTransform",
			gradientunits: "gradientUnits",
			kernelmatrix: "kernelMatrix",
			kernelunitlength: "kernelUnitLength",
			keypoints: "keyPoints",
			keysplines: "keySplines",
			keytimes: "keyTimes",
			lengthadjust: "lengthAdjust",
			limitingconeangle: "limitingConeAngle",
			markerheight: "markerHeight",
			markerunits: "markerUnits",
			markerwidth: "markerWidth",
			maskcontentunits: "maskContentUnits",
			maskunits: "maskUnits",
			numoctaves: "numOctaves",
			pathlength: "pathLength",
			patterncontentunits: "patternContentUnits",
			patterntransform: "patternTransform",
			patternunits: "patternUnits",
			pointsatx: "pointsAtX",
			pointsaty: "pointsAtY",
			pointsatz: "pointsAtZ",
			preservealpha: "preserveAlpha",
			preserveaspectratio: "preserveAspectRatio",
			primitiveunits: "primitiveUnits",
			refx: "refX",
			refy: "refY",
			repeatcount: "repeatCount",
			repeatdur: "repeatDur",
			requiredextensions: "requiredExtensions",
			requiredfeatures: "requiredFeatures",
			specularconstant: "specularConstant",
			specularexponent: "specularExponent",
			spreadmethod: "spreadMethod",
			startoffset: "startOffset",
			stddeviation: "stdDeviation",
			stitchtiles: "stitchTiles",
			surfacescale: "surfaceScale",
			systemlanguage: "systemLanguage",
			tablevalues: "tableValues",
			targetx: "targetX",
			targety: "targetY",
			textlength: "textLength",
			viewbox: "viewBox",
			viewtarget: "viewTarget",
			xchannelselector: "xChannelSelector",
			ychannelselector: "yChannelSelector",
			zoomandpan: "zoomAndPan",
		},
		fj = {
			__proto__: null,
			altglyph: "altGlyph",
			altglyphdef: "altGlyphDef",
			altglyphitem: "altGlyphItem",
			animatecolor: "animateColor",
			animatemotion: "animateMotion",
			animatetransform: "animateTransform",
			clippath: "clipPath",
			feblend: "feBlend",
			fecolormatrix: "feColorMatrix",
			fecomponenttransfer: "feComponentTransfer",
			fecomposite: "feComposite",
			feconvolvematrix: "feConvolveMatrix",
			fediffuselighting: "feDiffuseLighting",
			fedisplacementmap: "feDisplacementMap",
			fedistantlight: "feDistantLight",
			feflood: "feFlood",
			fefunca: "feFuncA",
			fefuncb: "feFuncB",
			fefuncg: "feFuncG",
			fefuncr: "feFuncR",
			fegaussianblur: "feGaussianBlur",
			feimage: "feImage",
			femerge: "feMerge",
			femergenode: "feMergeNode",
			femorphology: "feMorphology",
			feoffset: "feOffset",
			fepointlight: "fePointLight",
			fespecularlighting: "feSpecularLighting",
			fespotlight: "feSpotLight",
			fetile: "feTile",
			feturbulence: "feTurbulence",
			foreignobject: "foreignObject",
			glyphref: "glyphRef",
			lineargradient: "linearGradient",
			radialgradient: "radialGradient",
			textpath: "textPath",
		},
		hj = {
			__proto__: null,
			0: 65533,
			128: 8364,
			130: 8218,
			131: 402,
			132: 8222,
			133: 8230,
			134: 8224,
			135: 8225,
			136: 710,
			137: 8240,
			138: 352,
			139: 8249,
			140: 338,
			142: 381,
			145: 8216,
			146: 8217,
			147: 8220,
			148: 8221,
			149: 8226,
			150: 8211,
			151: 8212,
			152: 732,
			153: 8482,
			154: 353,
			155: 8250,
			156: 339,
			158: 382,
			159: 376,
		},
		vLe = {
			__proto__: null,
			AElig: 198,
			"AElig;": 198,
			AMP: 38,
			"AMP;": 38,
			Aacute: 193,
			"Aacute;": 193,
			"Abreve;": 258,
			Acirc: 194,
			"Acirc;": 194,
			"Acy;": 1040,
			"Afr;": [55349, 56580],
			Agrave: 192,
			"Agrave;": 192,
			"Alpha;": 913,
			"Amacr;": 256,
			"And;": 10835,
			"Aogon;": 260,
			"Aopf;": [55349, 56632],
			"ApplyFunction;": 8289,
			Aring: 197,
			"Aring;": 197,
			"Ascr;": [55349, 56476],
			"Assign;": 8788,
			Atilde: 195,
			"Atilde;": 195,
			Auml: 196,
			"Auml;": 196,
			"Backslash;": 8726,
			"Barv;": 10983,
			"Barwed;": 8966,
			"Bcy;": 1041,
			"Because;": 8757,
			"Bernoullis;": 8492,
			"Beta;": 914,
			"Bfr;": [55349, 56581],
			"Bopf;": [55349, 56633],
			"Breve;": 728,
			"Bscr;": 8492,
			"Bumpeq;": 8782,
			"CHcy;": 1063,
			COPY: 169,
			"COPY;": 169,
			"Cacute;": 262,
			"Cap;": 8914,
			"CapitalDifferentialD;": 8517,
			"Cayleys;": 8493,
			"Ccaron;": 268,
			Ccedil: 199,
			"Ccedil;": 199,
			"Ccirc;": 264,
			"Cconint;": 8752,
			"Cdot;": 266,
			"Cedilla;": 184,
			"CenterDot;": 183,
			"Cfr;": 8493,
			"Chi;": 935,
			"CircleDot;": 8857,
			"CircleMinus;": 8854,
			"CirclePlus;": 8853,
			"CircleTimes;": 8855,
			"ClockwiseContourIntegral;": 8754,
			"CloseCurlyDoubleQuote;": 8221,
			"CloseCurlyQuote;": 8217,
			"Colon;": 8759,
			"Colone;": 10868,
			"Congruent;": 8801,
			"Conint;": 8751,
			"ContourIntegral;": 8750,
			"Copf;": 8450,
			"Coproduct;": 8720,
			"CounterClockwiseContourIntegral;": 8755,
			"Cross;": 10799,
			"Cscr;": [55349, 56478],
			"Cup;": 8915,
			"CupCap;": 8781,
			"DD;": 8517,
			"DDotrahd;": 10513,
			"DJcy;": 1026,
			"DScy;": 1029,
			"DZcy;": 1039,
			"Dagger;": 8225,
			"Darr;": 8609,
			"Dashv;": 10980,
			"Dcaron;": 270,
			"Dcy;": 1044,
			"Del;": 8711,
			"Delta;": 916,
			"Dfr;": [55349, 56583],
			"DiacriticalAcute;": 180,
			"DiacriticalDot;": 729,
			"DiacriticalDoubleAcute;": 733,
			"DiacriticalGrave;": 96,
			"DiacriticalTilde;": 732,
			"Diamond;": 8900,
			"DifferentialD;": 8518,
			"Dopf;": [55349, 56635],
			"Dot;": 168,
			"DotDot;": 8412,
			"DotEqual;": 8784,
			"DoubleContourIntegral;": 8751,
			"DoubleDot;": 168,
			"DoubleDownArrow;": 8659,
			"DoubleLeftArrow;": 8656,
			"DoubleLeftRightArrow;": 8660,
			"DoubleLeftTee;": 10980,
			"DoubleLongLeftArrow;": 10232,
			"DoubleLongLeftRightArrow;": 10234,
			"DoubleLongRightArrow;": 10233,
			"DoubleRightArrow;": 8658,
			"DoubleRightTee;": 8872,
			"DoubleUpArrow;": 8657,
			"DoubleUpDownArrow;": 8661,
			"DoubleVerticalBar;": 8741,
			"DownArrow;": 8595,
			"DownArrowBar;": 10515,
			"DownArrowUpArrow;": 8693,
			"DownBreve;": 785,
			"DownLeftRightVector;": 10576,
			"DownLeftTeeVector;": 10590,
			"DownLeftVector;": 8637,
			"DownLeftVectorBar;": 10582,
			"DownRightTeeVector;": 10591,
			"DownRightVector;": 8641,
			"DownRightVectorBar;": 10583,
			"DownTee;": 8868,
			"DownTeeArrow;": 8615,
			"Downarrow;": 8659,
			"Dscr;": [55349, 56479],
			"Dstrok;": 272,
			"ENG;": 330,
			ETH: 208,
			"ETH;": 208,
			Eacute: 201,
			"Eacute;": 201,
			"Ecaron;": 282,
			Ecirc: 202,
			"Ecirc;": 202,
			"Ecy;": 1069,
			"Edot;": 278,
			"Efr;": [55349, 56584],
			Egrave: 200,
			"Egrave;": 200,
			"Element;": 8712,
			"Emacr;": 274,
			"EmptySmallSquare;": 9723,
			"EmptyVerySmallSquare;": 9643,
			"Eogon;": 280,
			"Eopf;": [55349, 56636],
			"Epsilon;": 917,
			"Equal;": 10869,
			"EqualTilde;": 8770,
			"Equilibrium;": 8652,
			"Escr;": 8496,
			"Esim;": 10867,
			"Eta;": 919,
			Euml: 203,
			"Euml;": 203,
			"Exists;": 8707,
			"ExponentialE;": 8519,
			"Fcy;": 1060,
			"Ffr;": [55349, 56585],
			"FilledSmallSquare;": 9724,
			"FilledVerySmallSquare;": 9642,
			"Fopf;": [55349, 56637],
			"ForAll;": 8704,
			"Fouriertrf;": 8497,
			"Fscr;": 8497,
			"GJcy;": 1027,
			GT: 62,
			"GT;": 62,
			"Gamma;": 915,
			"Gammad;": 988,
			"Gbreve;": 286,
			"Gcedil;": 290,
			"Gcirc;": 284,
			"Gcy;": 1043,
			"Gdot;": 288,
			"Gfr;": [55349, 56586],
			"Gg;": 8921,
			"Gopf;": [55349, 56638],
			"GreaterEqual;": 8805,
			"GreaterEqualLess;": 8923,
			"GreaterFullEqual;": 8807,
			"GreaterGreater;": 10914,
			"GreaterLess;": 8823,
			"GreaterSlantEqual;": 10878,
			"GreaterTilde;": 8819,
			"Gscr;": [55349, 56482],
			"Gt;": 8811,
			"HARDcy;": 1066,
			"Hacek;": 711,
			"Hat;": 94,
			"Hcirc;": 292,
			"Hfr;": 8460,
			"HilbertSpace;": 8459,
			"Hopf;": 8461,
			"HorizontalLine;": 9472,
			"Hscr;": 8459,
			"Hstrok;": 294,
			"HumpDownHump;": 8782,
			"HumpEqual;": 8783,
			"IEcy;": 1045,
			"IJlig;": 306,
			"IOcy;": 1025,
			Iacute: 205,
			"Iacute;": 205,
			Icirc: 206,
			"Icirc;": 206,
			"Icy;": 1048,
			"Idot;": 304,
			"Ifr;": 8465,
			Igrave: 204,
			"Igrave;": 204,
			"Im;": 8465,
			"Imacr;": 298,
			"ImaginaryI;": 8520,
			"Implies;": 8658,
			"Int;": 8748,
			"Integral;": 8747,
			"Intersection;": 8898,
			"InvisibleComma;": 8291,
			"InvisibleTimes;": 8290,
			"Iogon;": 302,
			"Iopf;": [55349, 56640],
			"Iota;": 921,
			"Iscr;": 8464,
			"Itilde;": 296,
			"Iukcy;": 1030,
			Iuml: 207,
			"Iuml;": 207,
			"Jcirc;": 308,
			"Jcy;": 1049,
			"Jfr;": [55349, 56589],
			"Jopf;": [55349, 56641],
			"Jscr;": [55349, 56485],
			"Jsercy;": 1032,
			"Jukcy;": 1028,
			"KHcy;": 1061,
			"KJcy;": 1036,
			"Kappa;": 922,
			"Kcedil;": 310,
			"Kcy;": 1050,
			"Kfr;": [55349, 56590],
			"Kopf;": [55349, 56642],
			"Kscr;": [55349, 56486],
			"LJcy;": 1033,
			LT: 60,
			"LT;": 60,
			"Lacute;": 313,
			"Lambda;": 923,
			"Lang;": 10218,
			"Laplacetrf;": 8466,
			"Larr;": 8606,
			"Lcaron;": 317,
			"Lcedil;": 315,
			"Lcy;": 1051,
			"LeftAngleBracket;": 10216,
			"LeftArrow;": 8592,
			"LeftArrowBar;": 8676,
			"LeftArrowRightArrow;": 8646,
			"LeftCeiling;": 8968,
			"LeftDoubleBracket;": 10214,
			"LeftDownTeeVector;": 10593,
			"LeftDownVector;": 8643,
			"LeftDownVectorBar;": 10585,
			"LeftFloor;": 8970,
			"LeftRightArrow;": 8596,
			"LeftRightVector;": 10574,
			"LeftTee;": 8867,
			"LeftTeeArrow;": 8612,
			"LeftTeeVector;": 10586,
			"LeftTriangle;": 8882,
			"LeftTriangleBar;": 10703,
			"LeftTriangleEqual;": 8884,
			"LeftUpDownVector;": 10577,
			"LeftUpTeeVector;": 10592,
			"LeftUpVector;": 8639,
			"LeftUpVectorBar;": 10584,
			"LeftVector;": 8636,
			"LeftVectorBar;": 10578,
			"Leftarrow;": 8656,
			"Leftrightarrow;": 8660,
			"LessEqualGreater;": 8922,
			"LessFullEqual;": 8806,
			"LessGreater;": 8822,
			"LessLess;": 10913,
			"LessSlantEqual;": 10877,
			"LessTilde;": 8818,
			"Lfr;": [55349, 56591],
			"Ll;": 8920,
			"Lleftarrow;": 8666,
			"Lmidot;": 319,
			"LongLeftArrow;": 10229,
			"LongLeftRightArrow;": 10231,
			"LongRightArrow;": 10230,
			"Longleftarrow;": 10232,
			"Longleftrightarrow;": 10234,
			"Longrightarrow;": 10233,
			"Lopf;": [55349, 56643],
			"LowerLeftArrow;": 8601,
			"LowerRightArrow;": 8600,
			"Lscr;": 8466,
			"Lsh;": 8624,
			"Lstrok;": 321,
			"Lt;": 8810,
			"Map;": 10501,
			"Mcy;": 1052,
			"MediumSpace;": 8287,
			"Mellintrf;": 8499,
			"Mfr;": [55349, 56592],
			"MinusPlus;": 8723,
			"Mopf;": [55349, 56644],
			"Mscr;": 8499,
			"Mu;": 924,
			"NJcy;": 1034,
			"Nacute;": 323,
			"Ncaron;": 327,
			"Ncedil;": 325,
			"Ncy;": 1053,
			"NegativeMediumSpace;": 8203,
			"NegativeThickSpace;": 8203,
			"NegativeThinSpace;": 8203,
			"NegativeVeryThinSpace;": 8203,
			"NestedGreaterGreater;": 8811,
			"NestedLessLess;": 8810,
			"NewLine;": 10,
			"Nfr;": [55349, 56593],
			"NoBreak;": 8288,
			"NonBreakingSpace;": 160,
			"Nopf;": 8469,
			"Not;": 10988,
			"NotCongruent;": 8802,
			"NotCupCap;": 8813,
			"NotDoubleVerticalBar;": 8742,
			"NotElement;": 8713,
			"NotEqual;": 8800,
			"NotEqualTilde;": [8770, 824],
			"NotExists;": 8708,
			"NotGreater;": 8815,
			"NotGreaterEqual;": 8817,
			"NotGreaterFullEqual;": [8807, 824],
			"NotGreaterGreater;": [8811, 824],
			"NotGreaterLess;": 8825,
			"NotGreaterSlantEqual;": [10878, 824],
			"NotGreaterTilde;": 8821,
			"NotHumpDownHump;": [8782, 824],
			"NotHumpEqual;": [8783, 824],
			"NotLeftTriangle;": 8938,
			"NotLeftTriangleBar;": [10703, 824],
			"NotLeftTriangleEqual;": 8940,
			"NotLess;": 8814,
			"NotLessEqual;": 8816,
			"NotLessGreater;": 8824,
			"NotLessLess;": [8810, 824],
			"NotLessSlantEqual;": [10877, 824],
			"NotLessTilde;": 8820,
			"NotNestedGreaterGreater;": [10914, 824],
			"NotNestedLessLess;": [10913, 824],
			"NotPrecedes;": 8832,
			"NotPrecedesEqual;": [10927, 824],
			"NotPrecedesSlantEqual;": 8928,
			"NotReverseElement;": 8716,
			"NotRightTriangle;": 8939,
			"NotRightTriangleBar;": [10704, 824],
			"NotRightTriangleEqual;": 8941,
			"NotSquareSubset;": [8847, 824],
			"NotSquareSubsetEqual;": 8930,
			"NotSquareSuperset;": [8848, 824],
			"NotSquareSupersetEqual;": 8931,
			"NotSubset;": [8834, 8402],
			"NotSubsetEqual;": 8840,
			"NotSucceeds;": 8833,
			"NotSucceedsEqual;": [10928, 824],
			"NotSucceedsSlantEqual;": 8929,
			"NotSucceedsTilde;": [8831, 824],
			"NotSuperset;": [8835, 8402],
			"NotSupersetEqual;": 8841,
			"NotTilde;": 8769,
			"NotTildeEqual;": 8772,
			"NotTildeFullEqual;": 8775,
			"NotTildeTilde;": 8777,
			"NotVerticalBar;": 8740,
			"Nscr;": [55349, 56489],
			Ntilde: 209,
			"Ntilde;": 209,
			"Nu;": 925,
			"OElig;": 338,
			Oacute: 211,
			"Oacute;": 211,
			Ocirc: 212,
			"Ocirc;": 212,
			"Ocy;": 1054,
			"Odblac;": 336,
			"Ofr;": [55349, 56594],
			Ograve: 210,
			"Ograve;": 210,
			"Omacr;": 332,
			"Omega;": 937,
			"Omicron;": 927,
			"Oopf;": [55349, 56646],
			"OpenCurlyDoubleQuote;": 8220,
			"OpenCurlyQuote;": 8216,
			"Or;": 10836,
			"Oscr;": [55349, 56490],
			Oslash: 216,
			"Oslash;": 216,
			Otilde: 213,
			"Otilde;": 213,
			"Otimes;": 10807,
			Ouml: 214,
			"Ouml;": 214,
			"OverBar;": 8254,
			"OverBrace;": 9182,
			"OverBracket;": 9140,
			"OverParenthesis;": 9180,
			"PartialD;": 8706,
			"Pcy;": 1055,
			"Pfr;": [55349, 56595],
			"Phi;": 934,
			"Pi;": 928,
			"PlusMinus;": 177,
			"Poincareplane;": 8460,
			"Popf;": 8473,
			"Pr;": 10939,
			"Precedes;": 8826,
			"PrecedesEqual;": 10927,
			"PrecedesSlantEqual;": 8828,
			"PrecedesTilde;": 8830,
			"Prime;": 8243,
			"Product;": 8719,
			"Proportion;": 8759,
			"Proportional;": 8733,
			"Pscr;": [55349, 56491],
			"Psi;": 936,
			QUOT: 34,
			"QUOT;": 34,
			"Qfr;": [55349, 56596],
			"Qopf;": 8474,
			"Qscr;": [55349, 56492],
			"RBarr;": 10512,
			REG: 174,
			"REG;": 174,
			"Racute;": 340,
			"Rang;": 10219,
			"Rarr;": 8608,
			"Rarrtl;": 10518,
			"Rcaron;": 344,
			"Rcedil;": 342,
			"Rcy;": 1056,
			"Re;": 8476,
			"ReverseElement;": 8715,
			"ReverseEquilibrium;": 8651,
			"ReverseUpEquilibrium;": 10607,
			"Rfr;": 8476,
			"Rho;": 929,
			"RightAngleBracket;": 10217,
			"RightArrow;": 8594,
			"RightArrowBar;": 8677,
			"RightArrowLeftArrow;": 8644,
			"RightCeiling;": 8969,
			"RightDoubleBracket;": 10215,
			"RightDownTeeVector;": 10589,
			"RightDownVector;": 8642,
			"RightDownVectorBar;": 10581,
			"RightFloor;": 8971,
			"RightTee;": 8866,
			"RightTeeArrow;": 8614,
			"RightTeeVector;": 10587,
			"RightTriangle;": 8883,
			"RightTriangleBar;": 10704,
			"RightTriangleEqual;": 8885,
			"RightUpDownVector;": 10575,
			"RightUpTeeVector;": 10588,
			"RightUpVector;": 8638,
			"RightUpVectorBar;": 10580,
			"RightVector;": 8640,
			"RightVectorBar;": 10579,
			"Rightarrow;": 8658,
			"Ropf;": 8477,
			"RoundImplies;": 10608,
			"Rrightarrow;": 8667,
			"Rscr;": 8475,
			"Rsh;": 8625,
			"RuleDelayed;": 10740,
			"SHCHcy;": 1065,
			"SHcy;": 1064,
			"SOFTcy;": 1068,
			"Sacute;": 346,
			"Sc;": 10940,
			"Scaron;": 352,
			"Scedil;": 350,
			"Scirc;": 348,
			"Scy;": 1057,
			"Sfr;": [55349, 56598],
			"ShortDownArrow;": 8595,
			"ShortLeftArrow;": 8592,
			"ShortRightArrow;": 8594,
			"ShortUpArrow;": 8593,
			"Sigma;": 931,
			"SmallCircle;": 8728,
			"Sopf;": [55349, 56650],
			"Sqrt;": 8730,
			"Square;": 9633,
			"SquareIntersection;": 8851,
			"SquareSubset;": 8847,
			"SquareSubsetEqual;": 8849,
			"SquareSuperset;": 8848,
			"SquareSupersetEqual;": 8850,
			"SquareUnion;": 8852,
			"Sscr;": [55349, 56494],
			"Star;": 8902,
			"Sub;": 8912,
			"Subset;": 8912,
			"SubsetEqual;": 8838,
			"Succeeds;": 8827,
			"SucceedsEqual;": 10928,
			"SucceedsSlantEqual;": 8829,
			"SucceedsTilde;": 8831,
			"SuchThat;": 8715,
			"Sum;": 8721,
			"Sup;": 8913,
			"Superset;": 8835,
			"SupersetEqual;": 8839,
			"Supset;": 8913,
			THORN: 222,
			"THORN;": 222,
			"TRADE;": 8482,
			"TSHcy;": 1035,
			"TScy;": 1062,
			"Tab;": 9,
			"Tau;": 932,
			"Tcaron;": 356,
			"Tcedil;": 354,
			"Tcy;": 1058,
			"Tfr;": [55349, 56599],
			"Therefore;": 8756,
			"Theta;": 920,
			"ThickSpace;": [8287, 8202],
			"ThinSpace;": 8201,
			"Tilde;": 8764,
			"TildeEqual;": 8771,
			"TildeFullEqual;": 8773,
			"TildeTilde;": 8776,
			"Topf;": [55349, 56651],
			"TripleDot;": 8411,
			"Tscr;": [55349, 56495],
			"Tstrok;": 358,
			Uacute: 218,
			"Uacute;": 218,
			"Uarr;": 8607,
			"Uarrocir;": 10569,
			"Ubrcy;": 1038,
			"Ubreve;": 364,
			Ucirc: 219,
			"Ucirc;": 219,
			"Ucy;": 1059,
			"Udblac;": 368,
			"Ufr;": [55349, 56600],
			Ugrave: 217,
			"Ugrave;": 217,
			"Umacr;": 362,
			"UnderBar;": 95,
			"UnderBrace;": 9183,
			"UnderBracket;": 9141,
			"UnderParenthesis;": 9181,
			"Union;": 8899,
			"UnionPlus;": 8846,
			"Uogon;": 370,
			"Uopf;": [55349, 56652],
			"UpArrow;": 8593,
			"UpArrowBar;": 10514,
			"UpArrowDownArrow;": 8645,
			"UpDownArrow;": 8597,
			"UpEquilibrium;": 10606,
			"UpTee;": 8869,
			"UpTeeArrow;": 8613,
			"Uparrow;": 8657,
			"Updownarrow;": 8661,
			"UpperLeftArrow;": 8598,
			"UpperRightArrow;": 8599,
			"Upsi;": 978,
			"Upsilon;": 933,
			"Uring;": 366,
			"Uscr;": [55349, 56496],
			"Utilde;": 360,
			Uuml: 220,
			"Uuml;": 220,
			"VDash;": 8875,
			"Vbar;": 10987,
			"Vcy;": 1042,
			"Vdash;": 8873,
			"Vdashl;": 10982,
			"Vee;": 8897,
			"Verbar;": 8214,
			"Vert;": 8214,
			"VerticalBar;": 8739,
			"VerticalLine;": 124,
			"VerticalSeparator;": 10072,
			"VerticalTilde;": 8768,
			"VeryThinSpace;": 8202,
			"Vfr;": [55349, 56601],
			"Vopf;": [55349, 56653],
			"Vscr;": [55349, 56497],
			"Vvdash;": 8874,
			"Wcirc;": 372,
			"Wedge;": 8896,
			"Wfr;": [55349, 56602],
			"Wopf;": [55349, 56654],
			"Wscr;": [55349, 56498],
			"Xfr;": [55349, 56603],
			"Xi;": 926,
			"Xopf;": [55349, 56655],
			"Xscr;": [55349, 56499],
			"YAcy;": 1071,
			"YIcy;": 1031,
			"YUcy;": 1070,
			Yacute: 221,
			"Yacute;": 221,
			"Ycirc;": 374,
			"Ycy;": 1067,
			"Yfr;": [55349, 56604],
			"Yopf;": [55349, 56656],
			"Yscr;": [55349, 56500],
			"Yuml;": 376,
			"ZHcy;": 1046,
			"Zacute;": 377,
			"Zcaron;": 381,
			"Zcy;": 1047,
			"Zdot;": 379,
			"ZeroWidthSpace;": 8203,
			"Zeta;": 918,
			"Zfr;": 8488,
			"Zopf;": 8484,
			"Zscr;": [55349, 56501],
			aacute: 225,
			"aacute;": 225,
			"abreve;": 259,
			"ac;": 8766,
			"acE;": [8766, 819],
			"acd;": 8767,
			acirc: 226,
			"acirc;": 226,
			acute: 180,
			"acute;": 180,
			"acy;": 1072,
			aelig: 230,
			"aelig;": 230,
			"af;": 8289,
			"afr;": [55349, 56606],
			agrave: 224,
			"agrave;": 224,
			"alefsym;": 8501,
			"aleph;": 8501,
			"alpha;": 945,
			"amacr;": 257,
			"amalg;": 10815,
			amp: 38,
			"amp;": 38,
			"and;": 8743,
			"andand;": 10837,
			"andd;": 10844,
			"andslope;": 10840,
			"andv;": 10842,
			"ang;": 8736,
			"ange;": 10660,
			"angle;": 8736,
			"angmsd;": 8737,
			"angmsdaa;": 10664,
			"angmsdab;": 10665,
			"angmsdac;": 10666,
			"angmsdad;": 10667,
			"angmsdae;": 10668,
			"angmsdaf;": 10669,
			"angmsdag;": 10670,
			"angmsdah;": 10671,
			"angrt;": 8735,
			"angrtvb;": 8894,
			"angrtvbd;": 10653,
			"angsph;": 8738,
			"angst;": 197,
			"angzarr;": 9084,
			"aogon;": 261,
			"aopf;": [55349, 56658],
			"ap;": 8776,
			"apE;": 10864,
			"apacir;": 10863,
			"ape;": 8778,
			"apid;": 8779,
			"apos;": 39,
			"approx;": 8776,
			"approxeq;": 8778,
			aring: 229,
			"aring;": 229,
			"ascr;": [55349, 56502],
			"ast;": 42,
			"asymp;": 8776,
			"asympeq;": 8781,
			atilde: 227,
			"atilde;": 227,
			auml: 228,
			"auml;": 228,
			"awconint;": 8755,
			"awint;": 10769,
			"bNot;": 10989,
			"backcong;": 8780,
			"backepsilon;": 1014,
			"backprime;": 8245,
			"backsim;": 8765,
			"backsimeq;": 8909,
			"barvee;": 8893,
			"barwed;": 8965,
			"barwedge;": 8965,
			"bbrk;": 9141,
			"bbrktbrk;": 9142,
			"bcong;": 8780,
			"bcy;": 1073,
			"bdquo;": 8222,
			"becaus;": 8757,
			"because;": 8757,
			"bemptyv;": 10672,
			"bepsi;": 1014,
			"bernou;": 8492,
			"beta;": 946,
			"beth;": 8502,
			"between;": 8812,
			"bfr;": [55349, 56607],
			"bigcap;": 8898,
			"bigcirc;": 9711,
			"bigcup;": 8899,
			"bigodot;": 10752,
			"bigoplus;": 10753,
			"bigotimes;": 10754,
			"bigsqcup;": 10758,
			"bigstar;": 9733,
			"bigtriangledown;": 9661,
			"bigtriangleup;": 9651,
			"biguplus;": 10756,
			"bigvee;": 8897,
			"bigwedge;": 8896,
			"bkarow;": 10509,
			"blacklozenge;": 10731,
			"blacksquare;": 9642,
			"blacktriangle;": 9652,
			"blacktriangledown;": 9662,
			"blacktriangleleft;": 9666,
			"blacktriangleright;": 9656,
			"blank;": 9251,
			"blk12;": 9618,
			"blk14;": 9617,
			"blk34;": 9619,
			"block;": 9608,
			"bne;": [61, 8421],
			"bnequiv;": [8801, 8421],
			"bnot;": 8976,
			"bopf;": [55349, 56659],
			"bot;": 8869,
			"bottom;": 8869,
			"bowtie;": 8904,
			"boxDL;": 9559,
			"boxDR;": 9556,
			"boxDl;": 9558,
			"boxDr;": 9555,
			"boxH;": 9552,
			"boxHD;": 9574,
			"boxHU;": 9577,
			"boxHd;": 9572,
			"boxHu;": 9575,
			"boxUL;": 9565,
			"boxUR;": 9562,
			"boxUl;": 9564,
			"boxUr;": 9561,
			"boxV;": 9553,
			"boxVH;": 9580,
			"boxVL;": 9571,
			"boxVR;": 9568,
			"boxVh;": 9579,
			"boxVl;": 9570,
			"boxVr;": 9567,
			"boxbox;": 10697,
			"boxdL;": 9557,
			"boxdR;": 9554,
			"boxdl;": 9488,
			"boxdr;": 9484,
			"boxh;": 9472,
			"boxhD;": 9573,
			"boxhU;": 9576,
			"boxhd;": 9516,
			"boxhu;": 9524,
			"boxminus;": 8863,
			"boxplus;": 8862,
			"boxtimes;": 8864,
			"boxuL;": 9563,
			"boxuR;": 9560,
			"boxul;": 9496,
			"boxur;": 9492,
			"boxv;": 9474,
			"boxvH;": 9578,
			"boxvL;": 9569,
			"boxvR;": 9566,
			"boxvh;": 9532,
			"boxvl;": 9508,
			"boxvr;": 9500,
			"bprime;": 8245,
			"breve;": 728,
			brvbar: 166,
			"brvbar;": 166,
			"bscr;": [55349, 56503],
			"bsemi;": 8271,
			"bsim;": 8765,
			"bsime;": 8909,
			"bsol;": 92,
			"bsolb;": 10693,
			"bsolhsub;": 10184,
			"bull;": 8226,
			"bullet;": 8226,
			"bump;": 8782,
			"bumpE;": 10926,
			"bumpe;": 8783,
			"bumpeq;": 8783,
			"cacute;": 263,
			"cap;": 8745,
			"capand;": 10820,
			"capbrcup;": 10825,
			"capcap;": 10827,
			"capcup;": 10823,
			"capdot;": 10816,
			"caps;": [8745, 65024],
			"caret;": 8257,
			"caron;": 711,
			"ccaps;": 10829,
			"ccaron;": 269,
			ccedil: 231,
			"ccedil;": 231,
			"ccirc;": 265,
			"ccups;": 10828,
			"ccupssm;": 10832,
			"cdot;": 267,
			cedil: 184,
			"cedil;": 184,
			"cemptyv;": 10674,
			cent: 162,
			"cent;": 162,
			"centerdot;": 183,
			"cfr;": [55349, 56608],
			"chcy;": 1095,
			"check;": 10003,
			"checkmark;": 10003,
			"chi;": 967,
			"cir;": 9675,
			"cirE;": 10691,
			"circ;": 710,
			"circeq;": 8791,
			"circlearrowleft;": 8634,
			"circlearrowright;": 8635,
			"circledR;": 174,
			"circledS;": 9416,
			"circledast;": 8859,
			"circledcirc;": 8858,
			"circleddash;": 8861,
			"cire;": 8791,
			"cirfnint;": 10768,
			"cirmid;": 10991,
			"cirscir;": 10690,
			"clubs;": 9827,
			"clubsuit;": 9827,
			"colon;": 58,
			"colone;": 8788,
			"coloneq;": 8788,
			"comma;": 44,
			"commat;": 64,
			"comp;": 8705,
			"compfn;": 8728,
			"complement;": 8705,
			"complexes;": 8450,
			"cong;": 8773,
			"congdot;": 10861,
			"conint;": 8750,
			"copf;": [55349, 56660],
			"coprod;": 8720,
			copy: 169,
			"copy;": 169,
			"copysr;": 8471,
			"crarr;": 8629,
			"cross;": 10007,
			"cscr;": [55349, 56504],
			"csub;": 10959,
			"csube;": 10961,
			"csup;": 10960,
			"csupe;": 10962,
			"ctdot;": 8943,
			"cudarrl;": 10552,
			"cudarrr;": 10549,
			"cuepr;": 8926,
			"cuesc;": 8927,
			"cularr;": 8630,
			"cularrp;": 10557,
			"cup;": 8746,
			"cupbrcap;": 10824,
			"cupcap;": 10822,
			"cupcup;": 10826,
			"cupdot;": 8845,
			"cupor;": 10821,
			"cups;": [8746, 65024],
			"curarr;": 8631,
			"curarrm;": 10556,
			"curlyeqprec;": 8926,
			"curlyeqsucc;": 8927,
			"curlyvee;": 8910,
			"curlywedge;": 8911,
			curren: 164,
			"curren;": 164,
			"curvearrowleft;": 8630,
			"curvearrowright;": 8631,
			"cuvee;": 8910,
			"cuwed;": 8911,
			"cwconint;": 8754,
			"cwint;": 8753,
			"cylcty;": 9005,
			"dArr;": 8659,
			"dHar;": 10597,
			"dagger;": 8224,
			"daleth;": 8504,
			"darr;": 8595,
			"dash;": 8208,
			"dashv;": 8867,
			"dbkarow;": 10511,
			"dblac;": 733,
			"dcaron;": 271,
			"dcy;": 1076,
			"dd;": 8518,
			"ddagger;": 8225,
			"ddarr;": 8650,
			"ddotseq;": 10871,
			deg: 176,
			"deg;": 176,
			"delta;": 948,
			"demptyv;": 10673,
			"dfisht;": 10623,
			"dfr;": [55349, 56609],
			"dharl;": 8643,
			"dharr;": 8642,
			"diam;": 8900,
			"diamond;": 8900,
			"diamondsuit;": 9830,
			"diams;": 9830,
			"die;": 168,
			"digamma;": 989,
			"disin;": 8946,
			"div;": 247,
			divide: 247,
			"divide;": 247,
			"divideontimes;": 8903,
			"divonx;": 8903,
			"djcy;": 1106,
			"dlcorn;": 8990,
			"dlcrop;": 8973,
			"dollar;": 36,
			"dopf;": [55349, 56661],
			"dot;": 729,
			"doteq;": 8784,
			"doteqdot;": 8785,
			"dotminus;": 8760,
			"dotplus;": 8724,
			"dotsquare;": 8865,
			"doublebarwedge;": 8966,
			"downarrow;": 8595,
			"downdownarrows;": 8650,
			"downharpoonleft;": 8643,
			"downharpoonright;": 8642,
			"drbkarow;": 10512,
			"drcorn;": 8991,
			"drcrop;": 8972,
			"dscr;": [55349, 56505],
			"dscy;": 1109,
			"dsol;": 10742,
			"dstrok;": 273,
			"dtdot;": 8945,
			"dtri;": 9663,
			"dtrif;": 9662,
			"duarr;": 8693,
			"duhar;": 10607,
			"dwangle;": 10662,
			"dzcy;": 1119,
			"dzigrarr;": 10239,
			"eDDot;": 10871,
			"eDot;": 8785,
			eacute: 233,
			"eacute;": 233,
			"easter;": 10862,
			"ecaron;": 283,
			"ecir;": 8790,
			ecirc: 234,
			"ecirc;": 234,
			"ecolon;": 8789,
			"ecy;": 1101,
			"edot;": 279,
			"ee;": 8519,
			"efDot;": 8786,
			"efr;": [55349, 56610],
			"eg;": 10906,
			egrave: 232,
			"egrave;": 232,
			"egs;": 10902,
			"egsdot;": 10904,
			"el;": 10905,
			"elinters;": 9191,
			"ell;": 8467,
			"els;": 10901,
			"elsdot;": 10903,
			"emacr;": 275,
			"empty;": 8709,
			"emptyset;": 8709,
			"emptyv;": 8709,
			"emsp13;": 8196,
			"emsp14;": 8197,
			"emsp;": 8195,
			"eng;": 331,
			"ensp;": 8194,
			"eogon;": 281,
			"eopf;": [55349, 56662],
			"epar;": 8917,
			"eparsl;": 10723,
			"eplus;": 10865,
			"epsi;": 949,
			"epsilon;": 949,
			"epsiv;": 1013,
			"eqcirc;": 8790,
			"eqcolon;": 8789,
			"eqsim;": 8770,
			"eqslantgtr;": 10902,
			"eqslantless;": 10901,
			"equals;": 61,
			"equest;": 8799,
			"equiv;": 8801,
			"equivDD;": 10872,
			"eqvparsl;": 10725,
			"erDot;": 8787,
			"erarr;": 10609,
			"escr;": 8495,
			"esdot;": 8784,
			"esim;": 8770,
			"eta;": 951,
			eth: 240,
			"eth;": 240,
			euml: 235,
			"euml;": 235,
			"euro;": 8364,
			"excl;": 33,
			"exist;": 8707,
			"expectation;": 8496,
			"exponentiale;": 8519,
			"fallingdotseq;": 8786,
			"fcy;": 1092,
			"female;": 9792,
			"ffilig;": 64259,
			"fflig;": 64256,
			"ffllig;": 64260,
			"ffr;": [55349, 56611],
			"filig;": 64257,
			"fjlig;": [102, 106],
			"flat;": 9837,
			"fllig;": 64258,
			"fltns;": 9649,
			"fnof;": 402,
			"fopf;": [55349, 56663],
			"forall;": 8704,
			"fork;": 8916,
			"forkv;": 10969,
			"fpartint;": 10765,
			frac12: 189,
			"frac12;": 189,
			"frac13;": 8531,
			frac14: 188,
			"frac14;": 188,
			"frac15;": 8533,
			"frac16;": 8537,
			"frac18;": 8539,
			"frac23;": 8532,
			"frac25;": 8534,
			frac34: 190,
			"frac34;": 190,
			"frac35;": 8535,
			"frac38;": 8540,
			"frac45;": 8536,
			"frac56;": 8538,
			"frac58;": 8541,
			"frac78;": 8542,
			"frasl;": 8260,
			"frown;": 8994,
			"fscr;": [55349, 56507],
			"gE;": 8807,
			"gEl;": 10892,
			"gacute;": 501,
			"gamma;": 947,
			"gammad;": 989,
			"gap;": 10886,
			"gbreve;": 287,
			"gcirc;": 285,
			"gcy;": 1075,
			"gdot;": 289,
			"ge;": 8805,
			"gel;": 8923,
			"geq;": 8805,
			"geqq;": 8807,
			"geqslant;": 10878,
			"ges;": 10878,
			"gescc;": 10921,
			"gesdot;": 10880,
			"gesdoto;": 10882,
			"gesdotol;": 10884,
			"gesl;": [8923, 65024],
			"gesles;": 10900,
			"gfr;": [55349, 56612],
			"gg;": 8811,
			"ggg;": 8921,
			"gimel;": 8503,
			"gjcy;": 1107,
			"gl;": 8823,
			"glE;": 10898,
			"gla;": 10917,
			"glj;": 10916,
			"gnE;": 8809,
			"gnap;": 10890,
			"gnapprox;": 10890,
			"gne;": 10888,
			"gneq;": 10888,
			"gneqq;": 8809,
			"gnsim;": 8935,
			"gopf;": [55349, 56664],
			"grave;": 96,
			"gscr;": 8458,
			"gsim;": 8819,
			"gsime;": 10894,
			"gsiml;": 10896,
			gt: 62,
			"gt;": 62,
			"gtcc;": 10919,
			"gtcir;": 10874,
			"gtdot;": 8919,
			"gtlPar;": 10645,
			"gtquest;": 10876,
			"gtrapprox;": 10886,
			"gtrarr;": 10616,
			"gtrdot;": 8919,
			"gtreqless;": 8923,
			"gtreqqless;": 10892,
			"gtrless;": 8823,
			"gtrsim;": 8819,
			"gvertneqq;": [8809, 65024],
			"gvnE;": [8809, 65024],
			"hArr;": 8660,
			"hairsp;": 8202,
			"half;": 189,
			"hamilt;": 8459,
			"hardcy;": 1098,
			"harr;": 8596,
			"harrcir;": 10568,
			"harrw;": 8621,
			"hbar;": 8463,
			"hcirc;": 293,
			"hearts;": 9829,
			"heartsuit;": 9829,
			"hellip;": 8230,
			"hercon;": 8889,
			"hfr;": [55349, 56613],
			"hksearow;": 10533,
			"hkswarow;": 10534,
			"hoarr;": 8703,
			"homtht;": 8763,
			"hookleftarrow;": 8617,
			"hookrightarrow;": 8618,
			"hopf;": [55349, 56665],
			"horbar;": 8213,
			"hscr;": [55349, 56509],
			"hslash;": 8463,
			"hstrok;": 295,
			"hybull;": 8259,
			"hyphen;": 8208,
			iacute: 237,
			"iacute;": 237,
			"ic;": 8291,
			icirc: 238,
			"icirc;": 238,
			"icy;": 1080,
			"iecy;": 1077,
			iexcl: 161,
			"iexcl;": 161,
			"iff;": 8660,
			"ifr;": [55349, 56614],
			igrave: 236,
			"igrave;": 236,
			"ii;": 8520,
			"iiiint;": 10764,
			"iiint;": 8749,
			"iinfin;": 10716,
			"iiota;": 8489,
			"ijlig;": 307,
			"imacr;": 299,
			"image;": 8465,
			"imagline;": 8464,
			"imagpart;": 8465,
			"imath;": 305,
			"imof;": 8887,
			"imped;": 437,
			"in;": 8712,
			"incare;": 8453,
			"infin;": 8734,
			"infintie;": 10717,
			"inodot;": 305,
			"int;": 8747,
			"intcal;": 8890,
			"integers;": 8484,
			"intercal;": 8890,
			"intlarhk;": 10775,
			"intprod;": 10812,
			"iocy;": 1105,
			"iogon;": 303,
			"iopf;": [55349, 56666],
			"iota;": 953,
			"iprod;": 10812,
			iquest: 191,
			"iquest;": 191,
			"iscr;": [55349, 56510],
			"isin;": 8712,
			"isinE;": 8953,
			"isindot;": 8949,
			"isins;": 8948,
			"isinsv;": 8947,
			"isinv;": 8712,
			"it;": 8290,
			"itilde;": 297,
			"iukcy;": 1110,
			iuml: 239,
			"iuml;": 239,
			"jcirc;": 309,
			"jcy;": 1081,
			"jfr;": [55349, 56615],
			"jmath;": 567,
			"jopf;": [55349, 56667],
			"jscr;": [55349, 56511],
			"jsercy;": 1112,
			"jukcy;": 1108,
			"kappa;": 954,
			"kappav;": 1008,
			"kcedil;": 311,
			"kcy;": 1082,
			"kfr;": [55349, 56616],
			"kgreen;": 312,
			"khcy;": 1093,
			"kjcy;": 1116,
			"kopf;": [55349, 56668],
			"kscr;": [55349, 56512],
			"lAarr;": 8666,
			"lArr;": 8656,
			"lAtail;": 10523,
			"lBarr;": 10510,
			"lE;": 8806,
			"lEg;": 10891,
			"lHar;": 10594,
			"lacute;": 314,
			"laemptyv;": 10676,
			"lagran;": 8466,
			"lambda;": 955,
			"lang;": 10216,
			"langd;": 10641,
			"langle;": 10216,
			"lap;": 10885,
			laquo: 171,
			"laquo;": 171,
			"larr;": 8592,
			"larrb;": 8676,
			"larrbfs;": 10527,
			"larrfs;": 10525,
			"larrhk;": 8617,
			"larrlp;": 8619,
			"larrpl;": 10553,
			"larrsim;": 10611,
			"larrtl;": 8610,
			"lat;": 10923,
			"latail;": 10521,
			"late;": 10925,
			"lates;": [10925, 65024],
			"lbarr;": 10508,
			"lbbrk;": 10098,
			"lbrace;": 123,
			"lbrack;": 91,
			"lbrke;": 10635,
			"lbrksld;": 10639,
			"lbrkslu;": 10637,
			"lcaron;": 318,
			"lcedil;": 316,
			"lceil;": 8968,
			"lcub;": 123,
			"lcy;": 1083,
			"ldca;": 10550,
			"ldquo;": 8220,
			"ldquor;": 8222,
			"ldrdhar;": 10599,
			"ldrushar;": 10571,
			"ldsh;": 8626,
			"le;": 8804,
			"leftarrow;": 8592,
			"leftarrowtail;": 8610,
			"leftharpoondown;": 8637,
			"leftharpoonup;": 8636,
			"leftleftarrows;": 8647,
			"leftrightarrow;": 8596,
			"leftrightarrows;": 8646,
			"leftrightharpoons;": 8651,
			"leftrightsquigarrow;": 8621,
			"leftthreetimes;": 8907,
			"leg;": 8922,
			"leq;": 8804,
			"leqq;": 8806,
			"leqslant;": 10877,
			"les;": 10877,
			"lescc;": 10920,
			"lesdot;": 10879,
			"lesdoto;": 10881,
			"lesdotor;": 10883,
			"lesg;": [8922, 65024],
			"lesges;": 10899,
			"lessapprox;": 10885,
			"lessdot;": 8918,
			"lesseqgtr;": 8922,
			"lesseqqgtr;": 10891,
			"lessgtr;": 8822,
			"lesssim;": 8818,
			"lfisht;": 10620,
			"lfloor;": 8970,
			"lfr;": [55349, 56617],
			"lg;": 8822,
			"lgE;": 10897,
			"lhard;": 8637,
			"lharu;": 8636,
			"lharul;": 10602,
			"lhblk;": 9604,
			"ljcy;": 1113,
			"ll;": 8810,
			"llarr;": 8647,
			"llcorner;": 8990,
			"llhard;": 10603,
			"lltri;": 9722,
			"lmidot;": 320,
			"lmoust;": 9136,
			"lmoustache;": 9136,
			"lnE;": 8808,
			"lnap;": 10889,
			"lnapprox;": 10889,
			"lne;": 10887,
			"lneq;": 10887,
			"lneqq;": 8808,
			"lnsim;": 8934,
			"loang;": 10220,
			"loarr;": 8701,
			"lobrk;": 10214,
			"longleftarrow;": 10229,
			"longleftrightarrow;": 10231,
			"longmapsto;": 10236,
			"longrightarrow;": 10230,
			"looparrowleft;": 8619,
			"looparrowright;": 8620,
			"lopar;": 10629,
			"lopf;": [55349, 56669],
			"loplus;": 10797,
			"lotimes;": 10804,
			"lowast;": 8727,
			"lowbar;": 95,
			"loz;": 9674,
			"lozenge;": 9674,
			"lozf;": 10731,
			"lpar;": 40,
			"lparlt;": 10643,
			"lrarr;": 8646,
			"lrcorner;": 8991,
			"lrhar;": 8651,
			"lrhard;": 10605,
			"lrm;": 8206,
			"lrtri;": 8895,
			"lsaquo;": 8249,
			"lscr;": [55349, 56513],
			"lsh;": 8624,
			"lsim;": 8818,
			"lsime;": 10893,
			"lsimg;": 10895,
			"lsqb;": 91,
			"lsquo;": 8216,
			"lsquor;": 8218,
			"lstrok;": 322,
			lt: 60,
			"lt;": 60,
			"ltcc;": 10918,
			"ltcir;": 10873,
			"ltdot;": 8918,
			"lthree;": 8907,
			"ltimes;": 8905,
			"ltlarr;": 10614,
			"ltquest;": 10875,
			"ltrPar;": 10646,
			"ltri;": 9667,
			"ltrie;": 8884,
			"ltrif;": 9666,
			"lurdshar;": 10570,
			"luruhar;": 10598,
			"lvertneqq;": [8808, 65024],
			"lvnE;": [8808, 65024],
			"mDDot;": 8762,
			macr: 175,
			"macr;": 175,
			"male;": 9794,
			"malt;": 10016,
			"maltese;": 10016,
			"map;": 8614,
			"mapsto;": 8614,
			"mapstodown;": 8615,
			"mapstoleft;": 8612,
			"mapstoup;": 8613,
			"marker;": 9646,
			"mcomma;": 10793,
			"mcy;": 1084,
			"mdash;": 8212,
			"measuredangle;": 8737,
			"mfr;": [55349, 56618],
			"mho;": 8487,
			micro: 181,
			"micro;": 181,
			"mid;": 8739,
			"midast;": 42,
			"midcir;": 10992,
			middot: 183,
			"middot;": 183,
			"minus;": 8722,
			"minusb;": 8863,
			"minusd;": 8760,
			"minusdu;": 10794,
			"mlcp;": 10971,
			"mldr;": 8230,
			"mnplus;": 8723,
			"models;": 8871,
			"mopf;": [55349, 56670],
			"mp;": 8723,
			"mscr;": [55349, 56514],
			"mstpos;": 8766,
			"mu;": 956,
			"multimap;": 8888,
			"mumap;": 8888,
			"nGg;": [8921, 824],
			"nGt;": [8811, 8402],
			"nGtv;": [8811, 824],
			"nLeftarrow;": 8653,
			"nLeftrightarrow;": 8654,
			"nLl;": [8920, 824],
			"nLt;": [8810, 8402],
			"nLtv;": [8810, 824],
			"nRightarrow;": 8655,
			"nVDash;": 8879,
			"nVdash;": 8878,
			"nabla;": 8711,
			"nacute;": 324,
			"nang;": [8736, 8402],
			"nap;": 8777,
			"napE;": [10864, 824],
			"napid;": [8779, 824],
			"napos;": 329,
			"napprox;": 8777,
			"natur;": 9838,
			"natural;": 9838,
			"naturals;": 8469,
			nbsp: 160,
			"nbsp;": 160,
			"nbump;": [8782, 824],
			"nbumpe;": [8783, 824],
			"ncap;": 10819,
			"ncaron;": 328,
			"ncedil;": 326,
			"ncong;": 8775,
			"ncongdot;": [10861, 824],
			"ncup;": 10818,
			"ncy;": 1085,
			"ndash;": 8211,
			"ne;": 8800,
			"neArr;": 8663,
			"nearhk;": 10532,
			"nearr;": 8599,
			"nearrow;": 8599,
			"nedot;": [8784, 824],
			"nequiv;": 8802,
			"nesear;": 10536,
			"nesim;": [8770, 824],
			"nexist;": 8708,
			"nexists;": 8708,
			"nfr;": [55349, 56619],
			"ngE;": [8807, 824],
			"nge;": 8817,
			"ngeq;": 8817,
			"ngeqq;": [8807, 824],
			"ngeqslant;": [10878, 824],
			"nges;": [10878, 824],
			"ngsim;": 8821,
			"ngt;": 8815,
			"ngtr;": 8815,
			"nhArr;": 8654,
			"nharr;": 8622,
			"nhpar;": 10994,
			"ni;": 8715,
			"nis;": 8956,
			"nisd;": 8954,
			"niv;": 8715,
			"njcy;": 1114,
			"nlArr;": 8653,
			"nlE;": [8806, 824],
			"nlarr;": 8602,
			"nldr;": 8229,
			"nle;": 8816,
			"nleftarrow;": 8602,
			"nleftrightarrow;": 8622,
			"nleq;": 8816,
			"nleqq;": [8806, 824],
			"nleqslant;": [10877, 824],
			"nles;": [10877, 824],
			"nless;": 8814,
			"nlsim;": 8820,
			"nlt;": 8814,
			"nltri;": 8938,
			"nltrie;": 8940,
			"nmid;": 8740,
			"nopf;": [55349, 56671],
			not: 172,
			"not;": 172,
			"notin;": 8713,
			"notinE;": [8953, 824],
			"notindot;": [8949, 824],
			"notinva;": 8713,
			"notinvb;": 8951,
			"notinvc;": 8950,
			"notni;": 8716,
			"notniva;": 8716,
			"notnivb;": 8958,
			"notnivc;": 8957,
			"npar;": 8742,
			"nparallel;": 8742,
			"nparsl;": [11005, 8421],
			"npart;": [8706, 824],
			"npolint;": 10772,
			"npr;": 8832,
			"nprcue;": 8928,
			"npre;": [10927, 824],
			"nprec;": 8832,
			"npreceq;": [10927, 824],
			"nrArr;": 8655,
			"nrarr;": 8603,
			"nrarrc;": [10547, 824],
			"nrarrw;": [8605, 824],
			"nrightarrow;": 8603,
			"nrtri;": 8939,
			"nrtrie;": 8941,
			"nsc;": 8833,
			"nsccue;": 8929,
			"nsce;": [10928, 824],
			"nscr;": [55349, 56515],
			"nshortmid;": 8740,
			"nshortparallel;": 8742,
			"nsim;": 8769,
			"nsime;": 8772,
			"nsimeq;": 8772,
			"nsmid;": 8740,
			"nspar;": 8742,
			"nsqsube;": 8930,
			"nsqsupe;": 8931,
			"nsub;": 8836,
			"nsubE;": [10949, 824],
			"nsube;": 8840,
			"nsubset;": [8834, 8402],
			"nsubseteq;": 8840,
			"nsubseteqq;": [10949, 824],
			"nsucc;": 8833,
			"nsucceq;": [10928, 824],
			"nsup;": 8837,
			"nsupE;": [10950, 824],
			"nsupe;": 8841,
			"nsupset;": [8835, 8402],
			"nsupseteq;": 8841,
			"nsupseteqq;": [10950, 824],
			"ntgl;": 8825,
			ntilde: 241,
			"ntilde;": 241,
			"ntlg;": 8824,
			"ntriangleleft;": 8938,
			"ntrianglelefteq;": 8940,
			"ntriangleright;": 8939,
			"ntrianglerighteq;": 8941,
			"nu;": 957,
			"num;": 35,
			"numero;": 8470,
			"numsp;": 8199,
			"nvDash;": 8877,
			"nvHarr;": 10500,
			"nvap;": [8781, 8402],
			"nvdash;": 8876,
			"nvge;": [8805, 8402],
			"nvgt;": [62, 8402],
			"nvinfin;": 10718,
			"nvlArr;": 10498,
			"nvle;": [8804, 8402],
			"nvlt;": [60, 8402],
			"nvltrie;": [8884, 8402],
			"nvrArr;": 10499,
			"nvrtrie;": [8885, 8402],
			"nvsim;": [8764, 8402],
			"nwArr;": 8662,
			"nwarhk;": 10531,
			"nwarr;": 8598,
			"nwarrow;": 8598,
			"nwnear;": 10535,
			"oS;": 9416,
			oacute: 243,
			"oacute;": 243,
			"oast;": 8859,
			"ocir;": 8858,
			ocirc: 244,
			"ocirc;": 244,
			"ocy;": 1086,
			"odash;": 8861,
			"odblac;": 337,
			"odiv;": 10808,
			"odot;": 8857,
			"odsold;": 10684,
			"oelig;": 339,
			"ofcir;": 10687,
			"ofr;": [55349, 56620],
			"ogon;": 731,
			ograve: 242,
			"ograve;": 242,
			"ogt;": 10689,
			"ohbar;": 10677,
			"ohm;": 937,
			"oint;": 8750,
			"olarr;": 8634,
			"olcir;": 10686,
			"olcross;": 10683,
			"oline;": 8254,
			"olt;": 10688,
			"omacr;": 333,
			"omega;": 969,
			"omicron;": 959,
			"omid;": 10678,
			"ominus;": 8854,
			"oopf;": [55349, 56672],
			"opar;": 10679,
			"operp;": 10681,
			"oplus;": 8853,
			"or;": 8744,
			"orarr;": 8635,
			"ord;": 10845,
			"order;": 8500,
			"orderof;": 8500,
			ordf: 170,
			"ordf;": 170,
			ordm: 186,
			"ordm;": 186,
			"origof;": 8886,
			"oror;": 10838,
			"orslope;": 10839,
			"orv;": 10843,
			"oscr;": 8500,
			oslash: 248,
			"oslash;": 248,
			"osol;": 8856,
			otilde: 245,
			"otilde;": 245,
			"otimes;": 8855,
			"otimesas;": 10806,
			ouml: 246,
			"ouml;": 246,
			"ovbar;": 9021,
			"par;": 8741,
			para: 182,
			"para;": 182,
			"parallel;": 8741,
			"parsim;": 10995,
			"parsl;": 11005,
			"part;": 8706,
			"pcy;": 1087,
			"percnt;": 37,
			"period;": 46,
			"permil;": 8240,
			"perp;": 8869,
			"pertenk;": 8241,
			"pfr;": [55349, 56621],
			"phi;": 966,
			"phiv;": 981,
			"phmmat;": 8499,
			"phone;": 9742,
			"pi;": 960,
			"pitchfork;": 8916,
			"piv;": 982,
			"planck;": 8463,
			"planckh;": 8462,
			"plankv;": 8463,
			"plus;": 43,
			"plusacir;": 10787,
			"plusb;": 8862,
			"pluscir;": 10786,
			"plusdo;": 8724,
			"plusdu;": 10789,
			"pluse;": 10866,
			plusmn: 177,
			"plusmn;": 177,
			"plussim;": 10790,
			"plustwo;": 10791,
			"pm;": 177,
			"pointint;": 10773,
			"popf;": [55349, 56673],
			pound: 163,
			"pound;": 163,
			"pr;": 8826,
			"prE;": 10931,
			"prap;": 10935,
			"prcue;": 8828,
			"pre;": 10927,
			"prec;": 8826,
			"precapprox;": 10935,
			"preccurlyeq;": 8828,
			"preceq;": 10927,
			"precnapprox;": 10937,
			"precneqq;": 10933,
			"precnsim;": 8936,
			"precsim;": 8830,
			"prime;": 8242,
			"primes;": 8473,
			"prnE;": 10933,
			"prnap;": 10937,
			"prnsim;": 8936,
			"prod;": 8719,
			"profalar;": 9006,
			"profline;": 8978,
			"profsurf;": 8979,
			"prop;": 8733,
			"propto;": 8733,
			"prsim;": 8830,
			"prurel;": 8880,
			"pscr;": [55349, 56517],
			"psi;": 968,
			"puncsp;": 8200,
			"qfr;": [55349, 56622],
			"qint;": 10764,
			"qopf;": [55349, 56674],
			"qprime;": 8279,
			"qscr;": [55349, 56518],
			"quaternions;": 8461,
			"quatint;": 10774,
			"quest;": 63,
			"questeq;": 8799,
			quot: 34,
			"quot;": 34,
			"rAarr;": 8667,
			"rArr;": 8658,
			"rAtail;": 10524,
			"rBarr;": 10511,
			"rHar;": 10596,
			"race;": [8765, 817],
			"racute;": 341,
			"radic;": 8730,
			"raemptyv;": 10675,
			"rang;": 10217,
			"rangd;": 10642,
			"range;": 10661,
			"rangle;": 10217,
			raquo: 187,
			"raquo;": 187,
			"rarr;": 8594,
			"rarrap;": 10613,
			"rarrb;": 8677,
			"rarrbfs;": 10528,
			"rarrc;": 10547,
			"rarrfs;": 10526,
			"rarrhk;": 8618,
			"rarrlp;": 8620,
			"rarrpl;": 10565,
			"rarrsim;": 10612,
			"rarrtl;": 8611,
			"rarrw;": 8605,
			"ratail;": 10522,
			"ratio;": 8758,
			"rationals;": 8474,
			"rbarr;": 10509,
			"rbbrk;": 10099,
			"rbrace;": 125,
			"rbrack;": 93,
			"rbrke;": 10636,
			"rbrksld;": 10638,
			"rbrkslu;": 10640,
			"rcaron;": 345,
			"rcedil;": 343,
			"rceil;": 8969,
			"rcub;": 125,
			"rcy;": 1088,
			"rdca;": 10551,
			"rdldhar;": 10601,
			"rdquo;": 8221,
			"rdquor;": 8221,
			"rdsh;": 8627,
			"real;": 8476,
			"realine;": 8475,
			"realpart;": 8476,
			"reals;": 8477,
			"rect;": 9645,
			reg: 174,
			"reg;": 174,
			"rfisht;": 10621,
			"rfloor;": 8971,
			"rfr;": [55349, 56623],
			"rhard;": 8641,
			"rharu;": 8640,
			"rharul;": 10604,
			"rho;": 961,
			"rhov;": 1009,
			"rightarrow;": 8594,
			"rightarrowtail;": 8611,
			"rightharpoondown;": 8641,
			"rightharpoonup;": 8640,
			"rightleftarrows;": 8644,
			"rightleftharpoons;": 8652,
			"rightrightarrows;": 8649,
			"rightsquigarrow;": 8605,
			"rightthreetimes;": 8908,
			"ring;": 730,
			"risingdotseq;": 8787,
			"rlarr;": 8644,
			"rlhar;": 8652,
			"rlm;": 8207,
			"rmoust;": 9137,
			"rmoustache;": 9137,
			"rnmid;": 10990,
			"roang;": 10221,
			"roarr;": 8702,
			"robrk;": 10215,
			"ropar;": 10630,
			"ropf;": [55349, 56675],
			"roplus;": 10798,
			"rotimes;": 10805,
			"rpar;": 41,
			"rpargt;": 10644,
			"rppolint;": 10770,
			"rrarr;": 8649,
			"rsaquo;": 8250,
			"rscr;": [55349, 56519],
			"rsh;": 8625,
			"rsqb;": 93,
			"rsquo;": 8217,
			"rsquor;": 8217,
			"rthree;": 8908,
			"rtimes;": 8906,
			"rtri;": 9657,
			"rtrie;": 8885,
			"rtrif;": 9656,
			"rtriltri;": 10702,
			"ruluhar;": 10600,
			"rx;": 8478,
			"sacute;": 347,
			"sbquo;": 8218,
			"sc;": 8827,
			"scE;": 10932,
			"scap;": 10936,
			"scaron;": 353,
			"sccue;": 8829,
			"sce;": 10928,
			"scedil;": 351,
			"scirc;": 349,
			"scnE;": 10934,
			"scnap;": 10938,
			"scnsim;": 8937,
			"scpolint;": 10771,
			"scsim;": 8831,
			"scy;": 1089,
			"sdot;": 8901,
			"sdotb;": 8865,
			"sdote;": 10854,
			"seArr;": 8664,
			"searhk;": 10533,
			"searr;": 8600,
			"searrow;": 8600,
			sect: 167,
			"sect;": 167,
			"semi;": 59,
			"seswar;": 10537,
			"setminus;": 8726,
			"setmn;": 8726,
			"sext;": 10038,
			"sfr;": [55349, 56624],
			"sfrown;": 8994,
			"sharp;": 9839,
			"shchcy;": 1097,
			"shcy;": 1096,
			"shortmid;": 8739,
			"shortparallel;": 8741,
			shy: 173,
			"shy;": 173,
			"sigma;": 963,
			"sigmaf;": 962,
			"sigmav;": 962,
			"sim;": 8764,
			"simdot;": 10858,
			"sime;": 8771,
			"simeq;": 8771,
			"simg;": 10910,
			"simgE;": 10912,
			"siml;": 10909,
			"simlE;": 10911,
			"simne;": 8774,
			"simplus;": 10788,
			"simrarr;": 10610,
			"slarr;": 8592,
			"smallsetminus;": 8726,
			"smashp;": 10803,
			"smeparsl;": 10724,
			"smid;": 8739,
			"smile;": 8995,
			"smt;": 10922,
			"smte;": 10924,
			"smtes;": [10924, 65024],
			"softcy;": 1100,
			"sol;": 47,
			"solb;": 10692,
			"solbar;": 9023,
			"sopf;": [55349, 56676],
			"spades;": 9824,
			"spadesuit;": 9824,
			"spar;": 8741,
			"sqcap;": 8851,
			"sqcaps;": [8851, 65024],
			"sqcup;": 8852,
			"sqcups;": [8852, 65024],
			"sqsub;": 8847,
			"sqsube;": 8849,
			"sqsubset;": 8847,
			"sqsubseteq;": 8849,
			"sqsup;": 8848,
			"sqsupe;": 8850,
			"sqsupset;": 8848,
			"sqsupseteq;": 8850,
			"squ;": 9633,
			"square;": 9633,
			"squarf;": 9642,
			"squf;": 9642,
			"srarr;": 8594,
			"sscr;": [55349, 56520],
			"ssetmn;": 8726,
			"ssmile;": 8995,
			"sstarf;": 8902,
			"star;": 9734,
			"starf;": 9733,
			"straightepsilon;": 1013,
			"straightphi;": 981,
			"strns;": 175,
			"sub;": 8834,
			"subE;": 10949,
			"subdot;": 10941,
			"sube;": 8838,
			"subedot;": 10947,
			"submult;": 10945,
			"subnE;": 10955,
			"subne;": 8842,
			"subplus;": 10943,
			"subrarr;": 10617,
			"subset;": 8834,
			"subseteq;": 8838,
			"subseteqq;": 10949,
			"subsetneq;": 8842,
			"subsetneqq;": 10955,
			"subsim;": 10951,
			"subsub;": 10965,
			"subsup;": 10963,
			"succ;": 8827,
			"succapprox;": 10936,
			"succcurlyeq;": 8829,
			"succeq;": 10928,
			"succnapprox;": 10938,
			"succneqq;": 10934,
			"succnsim;": 8937,
			"succsim;": 8831,
			"sum;": 8721,
			"sung;": 9834,
			sup1: 185,
			"sup1;": 185,
			sup2: 178,
			"sup2;": 178,
			sup3: 179,
			"sup3;": 179,
			"sup;": 8835,
			"supE;": 10950,
			"supdot;": 10942,
			"supdsub;": 10968,
			"supe;": 8839,
			"supedot;": 10948,
			"suphsol;": 10185,
			"suphsub;": 10967,
			"suplarr;": 10619,
			"supmult;": 10946,
			"supnE;": 10956,
			"supne;": 8843,
			"supplus;": 10944,
			"supset;": 8835,
			"supseteq;": 8839,
			"supseteqq;": 10950,
			"supsetneq;": 8843,
			"supsetneqq;": 10956,
			"supsim;": 10952,
			"supsub;": 10964,
			"supsup;": 10966,
			"swArr;": 8665,
			"swarhk;": 10534,
			"swarr;": 8601,
			"swarrow;": 8601,
			"swnwar;": 10538,
			szlig: 223,
			"szlig;": 223,
			"target;": 8982,
			"tau;": 964,
			"tbrk;": 9140,
			"tcaron;": 357,
			"tcedil;": 355,
			"tcy;": 1090,
			"tdot;": 8411,
			"telrec;": 8981,
			"tfr;": [55349, 56625],
			"there4;": 8756,
			"therefore;": 8756,
			"theta;": 952,
			"thetasym;": 977,
			"thetav;": 977,
			"thickapprox;": 8776,
			"thicksim;": 8764,
			"thinsp;": 8201,
			"thkap;": 8776,
			"thksim;": 8764,
			thorn: 254,
			"thorn;": 254,
			"tilde;": 732,
			times: 215,
			"times;": 215,
			"timesb;": 8864,
			"timesbar;": 10801,
			"timesd;": 10800,
			"tint;": 8749,
			"toea;": 10536,
			"top;": 8868,
			"topbot;": 9014,
			"topcir;": 10993,
			"topf;": [55349, 56677],
			"topfork;": 10970,
			"tosa;": 10537,
			"tprime;": 8244,
			"trade;": 8482,
			"triangle;": 9653,
			"triangledown;": 9663,
			"triangleleft;": 9667,
			"trianglelefteq;": 8884,
			"triangleq;": 8796,
			"triangleright;": 9657,
			"trianglerighteq;": 8885,
			"tridot;": 9708,
			"trie;": 8796,
			"triminus;": 10810,
			"triplus;": 10809,
			"trisb;": 10701,
			"tritime;": 10811,
			"trpezium;": 9186,
			"tscr;": [55349, 56521],
			"tscy;": 1094,
			"tshcy;": 1115,
			"tstrok;": 359,
			"twixt;": 8812,
			"twoheadleftarrow;": 8606,
			"twoheadrightarrow;": 8608,
			"uArr;": 8657,
			"uHar;": 10595,
			uacute: 250,
			"uacute;": 250,
			"uarr;": 8593,
			"ubrcy;": 1118,
			"ubreve;": 365,
			ucirc: 251,
			"ucirc;": 251,
			"ucy;": 1091,
			"udarr;": 8645,
			"udblac;": 369,
			"udhar;": 10606,
			"ufisht;": 10622,
			"ufr;": [55349, 56626],
			ugrave: 249,
			"ugrave;": 249,
			"uharl;": 8639,
			"uharr;": 8638,
			"uhblk;": 9600,
			"ulcorn;": 8988,
			"ulcorner;": 8988,
			"ulcrop;": 8975,
			"ultri;": 9720,
			"umacr;": 363,
			uml: 168,
			"uml;": 168,
			"uogon;": 371,
			"uopf;": [55349, 56678],
			"uparrow;": 8593,
			"updownarrow;": 8597,
			"upharpoonleft;": 8639,
			"upharpoonright;": 8638,
			"uplus;": 8846,
			"upsi;": 965,
			"upsih;": 978,
			"upsilon;": 965,
			"upuparrows;": 8648,
			"urcorn;": 8989,
			"urcorner;": 8989,
			"urcrop;": 8974,
			"uring;": 367,
			"urtri;": 9721,
			"uscr;": [55349, 56522],
			"utdot;": 8944,
			"utilde;": 361,
			"utri;": 9653,
			"utrif;": 9652,
			"uuarr;": 8648,
			uuml: 252,
			"uuml;": 252,
			"uwangle;": 10663,
			"vArr;": 8661,
			"vBar;": 10984,
			"vBarv;": 10985,
			"vDash;": 8872,
			"vangrt;": 10652,
			"varepsilon;": 1013,
			"varkappa;": 1008,
			"varnothing;": 8709,
			"varphi;": 981,
			"varpi;": 982,
			"varpropto;": 8733,
			"varr;": 8597,
			"varrho;": 1009,
			"varsigma;": 962,
			"varsubsetneq;": [8842, 65024],
			"varsubsetneqq;": [10955, 65024],
			"varsupsetneq;": [8843, 65024],
			"varsupsetneqq;": [10956, 65024],
			"vartheta;": 977,
			"vartriangleleft;": 8882,
			"vartriangleright;": 8883,
			"vcy;": 1074,
			"vdash;": 8866,
			"vee;": 8744,
			"veebar;": 8891,
			"veeeq;": 8794,
			"vellip;": 8942,
			"verbar;": 124,
			"vert;": 124,
			"vfr;": [55349, 56627],
			"vltri;": 8882,
			"vnsub;": [8834, 8402],
			"vnsup;": [8835, 8402],
			"vopf;": [55349, 56679],
			"vprop;": 8733,
			"vrtri;": 8883,
			"vscr;": [55349, 56523],
			"vsubnE;": [10955, 65024],
			"vsubne;": [8842, 65024],
			"vsupnE;": [10956, 65024],
			"vsupne;": [8843, 65024],
			"vzigzag;": 10650,
			"wcirc;": 373,
			"wedbar;": 10847,
			"wedge;": 8743,
			"wedgeq;": 8793,
			"weierp;": 8472,
			"wfr;": [55349, 56628],
			"wopf;": [55349, 56680],
			"wp;": 8472,
			"wr;": 8768,
			"wreath;": 8768,
			"wscr;": [55349, 56524],
			"xcap;": 8898,
			"xcirc;": 9711,
			"xcup;": 8899,
			"xdtri;": 9661,
			"xfr;": [55349, 56629],
			"xhArr;": 10234,
			"xharr;": 10231,
			"xi;": 958,
			"xlArr;": 10232,
			"xlarr;": 10229,
			"xmap;": 10236,
			"xnis;": 8955,
			"xodot;": 10752,
			"xopf;": [55349, 56681],
			"xoplus;": 10753,
			"xotime;": 10754,
			"xrArr;": 10233,
			"xrarr;": 10230,
			"xscr;": [55349, 56525],
			"xsqcup;": 10758,
			"xuplus;": 10756,
			"xutri;": 9651,
			"xvee;": 8897,
			"xwedge;": 8896,
			yacute: 253,
			"yacute;": 253,
			"yacy;": 1103,
			"ycirc;": 375,
			"ycy;": 1099,
			yen: 165,
			"yen;": 165,
			"yfr;": [55349, 56630],
			"yicy;": 1111,
			"yopf;": [55349, 56682],
			"yscr;": [55349, 56526],
			"yucy;": 1102,
			yuml: 255,
			"yuml;": 255,
			"zacute;": 378,
			"zcaron;": 382,
			"zcy;": 1079,
			"zdot;": 380,
			"zeetrf;": 8488,
			"zeta;": 950,
			"zfr;": [55349, 56631],
			"zhcy;": 1078,
			"zigrarr;": 8669,
			"zopf;": [55349, 56683],
			"zscr;": [55349, 56527],
			"zwj;": 8205,
			"zwnj;": 8204,
		},
		gj =
			/(A(?:Elig;?|MP;?|acute;?|breve;|c(?:irc;?|y;)|fr;|grave;?|lpha;|macr;|nd;|o(?:gon;|pf;)|pplyFunction;|ring;?|s(?:cr;|sign;)|tilde;?|uml;?)|B(?:a(?:ckslash;|r(?:v;|wed;))|cy;|e(?:cause;|rnoullis;|ta;)|fr;|opf;|reve;|scr;|umpeq;)|C(?:Hcy;|OPY;?|a(?:cute;|p(?:;|italDifferentialD;)|yleys;)|c(?:aron;|edil;?|irc;|onint;)|dot;|e(?:dilla;|nterDot;)|fr;|hi;|ircle(?:Dot;|Minus;|Plus;|Times;)|lo(?:ckwiseContourIntegral;|seCurly(?:DoubleQuote;|Quote;))|o(?:lon(?:;|e;)|n(?:gruent;|int;|tourIntegral;)|p(?:f;|roduct;)|unterClockwiseContourIntegral;)|ross;|scr;|up(?:;|Cap;))|D(?:D(?:;|otrahd;)|Jcy;|Scy;|Zcy;|a(?:gger;|rr;|shv;)|c(?:aron;|y;)|el(?:;|ta;)|fr;|i(?:a(?:critical(?:Acute;|Do(?:t;|ubleAcute;)|Grave;|Tilde;)|mond;)|fferentialD;)|o(?:pf;|t(?:;|Dot;|Equal;)|uble(?:ContourIntegral;|Do(?:t;|wnArrow;)|L(?:eft(?:Arrow;|RightArrow;|Tee;)|ong(?:Left(?:Arrow;|RightArrow;)|RightArrow;))|Right(?:Arrow;|Tee;)|Up(?:Arrow;|DownArrow;)|VerticalBar;)|wn(?:Arrow(?:;|Bar;|UpArrow;)|Breve;|Left(?:RightVector;|TeeVector;|Vector(?:;|Bar;))|Right(?:TeeVector;|Vector(?:;|Bar;))|Tee(?:;|Arrow;)|arrow;))|s(?:cr;|trok;))|E(?:NG;|TH;?|acute;?|c(?:aron;|irc;?|y;)|dot;|fr;|grave;?|lement;|m(?:acr;|pty(?:SmallSquare;|VerySmallSquare;))|o(?:gon;|pf;)|psilon;|qu(?:al(?:;|Tilde;)|ilibrium;)|s(?:cr;|im;)|ta;|uml;?|x(?:ists;|ponentialE;))|F(?:cy;|fr;|illed(?:SmallSquare;|VerySmallSquare;)|o(?:pf;|rAll;|uriertrf;)|scr;)|G(?:Jcy;|T;?|amma(?:;|d;)|breve;|c(?:edil;|irc;|y;)|dot;|fr;|g;|opf;|reater(?:Equal(?:;|Less;)|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|scr;|t;)|H(?:ARDcy;|a(?:cek;|t;)|circ;|fr;|ilbertSpace;|o(?:pf;|rizontalLine;)|s(?:cr;|trok;)|ump(?:DownHump;|Equal;))|I(?:Ecy;|Jlig;|Ocy;|acute;?|c(?:irc;?|y;)|dot;|fr;|grave;?|m(?:;|a(?:cr;|ginaryI;)|plies;)|n(?:t(?:;|e(?:gral;|rsection;))|visible(?:Comma;|Times;))|o(?:gon;|pf;|ta;)|scr;|tilde;|u(?:kcy;|ml;?))|J(?:c(?:irc;|y;)|fr;|opf;|s(?:cr;|ercy;)|ukcy;)|K(?:Hcy;|Jcy;|appa;|c(?:edil;|y;)|fr;|opf;|scr;)|L(?:Jcy;|T;?|a(?:cute;|mbda;|ng;|placetrf;|rr;)|c(?:aron;|edil;|y;)|e(?:ft(?:A(?:ngleBracket;|rrow(?:;|Bar;|RightArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|Right(?:Arrow;|Vector;)|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;|rightarrow;)|ss(?:EqualGreater;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;))|fr;|l(?:;|eftarrow;)|midot;|o(?:ng(?:Left(?:Arrow;|RightArrow;)|RightArrow;|left(?:arrow;|rightarrow;)|rightarrow;)|pf;|wer(?:LeftArrow;|RightArrow;))|s(?:cr;|h;|trok;)|t;)|M(?:ap;|cy;|e(?:diumSpace;|llintrf;)|fr;|inusPlus;|opf;|scr;|u;)|N(?:Jcy;|acute;|c(?:aron;|edil;|y;)|e(?:gative(?:MediumSpace;|Thi(?:ckSpace;|nSpace;)|VeryThinSpace;)|sted(?:GreaterGreater;|LessLess;)|wLine;)|fr;|o(?:Break;|nBreakingSpace;|pf;|t(?:;|C(?:ongruent;|upCap;)|DoubleVerticalBar;|E(?:lement;|qual(?:;|Tilde;)|xists;)|Greater(?:;|Equal;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|Hump(?:DownHump;|Equal;)|Le(?:ftTriangle(?:;|Bar;|Equal;)|ss(?:;|Equal;|Greater;|Less;|SlantEqual;|Tilde;))|Nested(?:GreaterGreater;|LessLess;)|Precedes(?:;|Equal;|SlantEqual;)|R(?:everseElement;|ightTriangle(?:;|Bar;|Equal;))|S(?:quareSu(?:bset(?:;|Equal;)|perset(?:;|Equal;))|u(?:bset(?:;|Equal;)|cceeds(?:;|Equal;|SlantEqual;|Tilde;)|perset(?:;|Equal;)))|Tilde(?:;|Equal;|FullEqual;|Tilde;)|VerticalBar;))|scr;|tilde;?|u;)|O(?:Elig;|acute;?|c(?:irc;?|y;)|dblac;|fr;|grave;?|m(?:acr;|ega;|icron;)|opf;|penCurly(?:DoubleQuote;|Quote;)|r;|s(?:cr;|lash;?)|ti(?:lde;?|mes;)|uml;?|ver(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;))|P(?:artialD;|cy;|fr;|hi;|i;|lusMinus;|o(?:incareplane;|pf;)|r(?:;|ecedes(?:;|Equal;|SlantEqual;|Tilde;)|ime;|o(?:duct;|portion(?:;|al;)))|s(?:cr;|i;))|Q(?:UOT;?|fr;|opf;|scr;)|R(?:Barr;|EG;?|a(?:cute;|ng;|rr(?:;|tl;))|c(?:aron;|edil;|y;)|e(?:;|verse(?:E(?:lement;|quilibrium;)|UpEquilibrium;))|fr;|ho;|ight(?:A(?:ngleBracket;|rrow(?:;|Bar;|LeftArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;)|o(?:pf;|undImplies;)|rightarrow;|s(?:cr;|h;)|uleDelayed;)|S(?:H(?:CHcy;|cy;)|OFTcy;|acute;|c(?:;|aron;|edil;|irc;|y;)|fr;|hort(?:DownArrow;|LeftArrow;|RightArrow;|UpArrow;)|igma;|mallCircle;|opf;|q(?:rt;|uare(?:;|Intersection;|Su(?:bset(?:;|Equal;)|perset(?:;|Equal;))|Union;))|scr;|tar;|u(?:b(?:;|set(?:;|Equal;))|c(?:ceeds(?:;|Equal;|SlantEqual;|Tilde;)|hThat;)|m;|p(?:;|erset(?:;|Equal;)|set;)))|T(?:HORN;?|RADE;|S(?:Hcy;|cy;)|a(?:b;|u;)|c(?:aron;|edil;|y;)|fr;|h(?:e(?:refore;|ta;)|i(?:ckSpace;|nSpace;))|ilde(?:;|Equal;|FullEqual;|Tilde;)|opf;|ripleDot;|s(?:cr;|trok;))|U(?:a(?:cute;?|rr(?:;|ocir;))|br(?:cy;|eve;)|c(?:irc;?|y;)|dblac;|fr;|grave;?|macr;|n(?:der(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;)|ion(?:;|Plus;))|o(?:gon;|pf;)|p(?:Arrow(?:;|Bar;|DownArrow;)|DownArrow;|Equilibrium;|Tee(?:;|Arrow;)|arrow;|downarrow;|per(?:LeftArrow;|RightArrow;)|si(?:;|lon;))|ring;|scr;|tilde;|uml;?)|V(?:Dash;|bar;|cy;|dash(?:;|l;)|e(?:e;|r(?:bar;|t(?:;|ical(?:Bar;|Line;|Separator;|Tilde;))|yThinSpace;))|fr;|opf;|scr;|vdash;)|W(?:circ;|edge;|fr;|opf;|scr;)|X(?:fr;|i;|opf;|scr;)|Y(?:Acy;|Icy;|Ucy;|acute;?|c(?:irc;|y;)|fr;|opf;|scr;|uml;)|Z(?:Hcy;|acute;|c(?:aron;|y;)|dot;|e(?:roWidthSpace;|ta;)|fr;|opf;|scr;)|a(?:acute;?|breve;|c(?:;|E;|d;|irc;?|ute;?|y;)|elig;?|f(?:;|r;)|grave;?|l(?:e(?:fsym;|ph;)|pha;)|m(?:a(?:cr;|lg;)|p;?)|n(?:d(?:;|and;|d;|slope;|v;)|g(?:;|e;|le;|msd(?:;|a(?:a;|b;|c;|d;|e;|f;|g;|h;))|rt(?:;|vb(?:;|d;))|s(?:ph;|t;)|zarr;))|o(?:gon;|pf;)|p(?:;|E;|acir;|e;|id;|os;|prox(?:;|eq;))|ring;?|s(?:cr;|t;|ymp(?:;|eq;))|tilde;?|uml;?|w(?:conint;|int;))|b(?:Not;|a(?:ck(?:cong;|epsilon;|prime;|sim(?:;|eq;))|r(?:vee;|wed(?:;|ge;)))|brk(?:;|tbrk;)|c(?:ong;|y;)|dquo;|e(?:caus(?:;|e;)|mptyv;|psi;|rnou;|t(?:a;|h;|ween;))|fr;|ig(?:c(?:ap;|irc;|up;)|o(?:dot;|plus;|times;)|s(?:qcup;|tar;)|triangle(?:down;|up;)|uplus;|vee;|wedge;)|karow;|l(?:a(?:ck(?:lozenge;|square;|triangle(?:;|down;|left;|right;))|nk;)|k(?:1(?:2;|4;)|34;)|ock;)|n(?:e(?:;|quiv;)|ot;)|o(?:pf;|t(?:;|tom;)|wtie;|x(?:D(?:L;|R;|l;|r;)|H(?:;|D;|U;|d;|u;)|U(?:L;|R;|l;|r;)|V(?:;|H;|L;|R;|h;|l;|r;)|box;|d(?:L;|R;|l;|r;)|h(?:;|D;|U;|d;|u;)|minus;|plus;|times;|u(?:L;|R;|l;|r;)|v(?:;|H;|L;|R;|h;|l;|r;)))|prime;|r(?:eve;|vbar;?)|s(?:cr;|emi;|im(?:;|e;)|ol(?:;|b;|hsub;))|u(?:ll(?:;|et;)|mp(?:;|E;|e(?:;|q;))))|c(?:a(?:cute;|p(?:;|and;|brcup;|c(?:ap;|up;)|dot;|s;)|r(?:et;|on;))|c(?:a(?:ps;|ron;)|edil;?|irc;|ups(?:;|sm;))|dot;|e(?:dil;?|mptyv;|nt(?:;|erdot;|))|fr;|h(?:cy;|eck(?:;|mark;)|i;)|ir(?:;|E;|c(?:;|eq;|le(?:arrow(?:left;|right;)|d(?:R;|S;|ast;|circ;|dash;)))|e;|fnint;|mid;|scir;)|lubs(?:;|uit;)|o(?:lon(?:;|e(?:;|q;))|m(?:ma(?:;|t;)|p(?:;|fn;|le(?:ment;|xes;)))|n(?:g(?:;|dot;)|int;)|p(?:f;|rod;|y(?:;|sr;|)))|r(?:arr;|oss;)|s(?:cr;|u(?:b(?:;|e;)|p(?:;|e;)))|tdot;|u(?:darr(?:l;|r;)|e(?:pr;|sc;)|larr(?:;|p;)|p(?:;|brcap;|c(?:ap;|up;)|dot;|or;|s;)|r(?:arr(?:;|m;)|ly(?:eq(?:prec;|succ;)|vee;|wedge;)|ren;?|vearrow(?:left;|right;))|vee;|wed;)|w(?:conint;|int;)|ylcty;)|d(?:Arr;|Har;|a(?:gger;|leth;|rr;|sh(?:;|v;))|b(?:karow;|lac;)|c(?:aron;|y;)|d(?:;|a(?:gger;|rr;)|otseq;)|e(?:g;?|lta;|mptyv;)|f(?:isht;|r;)|har(?:l;|r;)|i(?:am(?:;|ond(?:;|suit;)|s;)|e;|gamma;|sin;|v(?:;|ide(?:;|ontimes;|)|onx;))|jcy;|lc(?:orn;|rop;)|o(?:llar;|pf;|t(?:;|eq(?:;|dot;)|minus;|plus;|square;)|ublebarwedge;|wn(?:arrow;|downarrows;|harpoon(?:left;|right;)))|r(?:bkarow;|c(?:orn;|rop;))|s(?:c(?:r;|y;)|ol;|trok;)|t(?:dot;|ri(?:;|f;))|u(?:arr;|har;)|wangle;|z(?:cy;|igrarr;))|e(?:D(?:Dot;|ot;)|a(?:cute;?|ster;)|c(?:aron;|ir(?:;|c;?)|olon;|y;)|dot;|e;|f(?:Dot;|r;)|g(?:;|rave;?|s(?:;|dot;))|l(?:;|inters;|l;|s(?:;|dot;))|m(?:acr;|pty(?:;|set;|v;)|sp(?:1(?:3;|4;)|;))|n(?:g;|sp;)|o(?:gon;|pf;)|p(?:ar(?:;|sl;)|lus;|si(?:;|lon;|v;))|q(?:c(?:irc;|olon;)|s(?:im;|lant(?:gtr;|less;))|u(?:als;|est;|iv(?:;|DD;))|vparsl;)|r(?:Dot;|arr;)|s(?:cr;|dot;|im;)|t(?:a;|h;?)|u(?:ml;?|ro;)|x(?:cl;|ist;|p(?:ectation;|onentiale;)))|f(?:allingdotseq;|cy;|emale;|f(?:ilig;|l(?:ig;|lig;)|r;)|ilig;|jlig;|l(?:at;|lig;|tns;)|nof;|o(?:pf;|r(?:all;|k(?:;|v;)))|partint;|r(?:a(?:c(?:1(?:2;?|3;|4;?|5;|6;|8;)|2(?:3;|5;)|3(?:4;?|5;|8;)|45;|5(?:6;|8;)|78;)|sl;)|own;)|scr;)|g(?:E(?:;|l;)|a(?:cute;|mma(?:;|d;)|p;)|breve;|c(?:irc;|y;)|dot;|e(?:;|l;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|l;))|l(?:;|es;)))|fr;|g(?:;|g;)|imel;|jcy;|l(?:;|E;|a;|j;)|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|opf;|rave;|s(?:cr;|im(?:;|e;|l;))|t(?:;|c(?:c;|ir;)|dot;|lPar;|quest;|r(?:a(?:pprox;|rr;)|dot;|eq(?:less;|qless;)|less;|sim;)|)|v(?:ertneqq;|nE;))|h(?:Arr;|a(?:irsp;|lf;|milt;|r(?:dcy;|r(?:;|cir;|w;)))|bar;|circ;|e(?:arts(?:;|uit;)|llip;|rcon;)|fr;|ks(?:earow;|warow;)|o(?:arr;|mtht;|ok(?:leftarrow;|rightarrow;)|pf;|rbar;)|s(?:cr;|lash;|trok;)|y(?:bull;|phen;))|i(?:acute;?|c(?:;|irc;?|y;)|e(?:cy;|xcl;?)|f(?:f;|r;)|grave;?|i(?:;|i(?:int;|nt;)|nfin;|ota;)|jlig;|m(?:a(?:cr;|g(?:e;|line;|part;)|th;)|of;|ped;)|n(?:;|care;|fin(?:;|tie;)|odot;|t(?:;|cal;|e(?:gers;|rcal;)|larhk;|prod;))|o(?:cy;|gon;|pf;|ta;)|prod;|quest;?|s(?:cr;|in(?:;|E;|dot;|s(?:;|v;)|v;))|t(?:;|ilde;)|u(?:kcy;|ml;?))|j(?:c(?:irc;|y;)|fr;|math;|opf;|s(?:cr;|ercy;)|ukcy;)|k(?:appa(?:;|v;)|c(?:edil;|y;)|fr;|green;|hcy;|jcy;|opf;|scr;)|l(?:A(?:arr;|rr;|tail;)|Barr;|E(?:;|g;)|Har;|a(?:cute;|emptyv;|gran;|mbda;|ng(?:;|d;|le;)|p;|quo;?|rr(?:;|b(?:;|fs;)|fs;|hk;|lp;|pl;|sim;|tl;)|t(?:;|ail;|e(?:;|s;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|quo(?:;|r;)|r(?:dhar;|ushar;)|sh;)|e(?:;|ft(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|leftarrows;|right(?:arrow(?:;|s;)|harpoons;|squigarrow;)|threetimes;)|g;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|r;))|g(?:;|es;)|s(?:approx;|dot;|eq(?:gtr;|qgtr;)|gtr;|sim;)))|f(?:isht;|loor;|r;)|g(?:;|E;)|h(?:ar(?:d;|u(?:;|l;))|blk;)|jcy;|l(?:;|arr;|corner;|hard;|tri;)|m(?:idot;|oust(?:;|ache;))|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|o(?:a(?:ng;|rr;)|brk;|ng(?:left(?:arrow;|rightarrow;)|mapsto;|rightarrow;)|oparrow(?:left;|right;)|p(?:ar;|f;|lus;)|times;|w(?:ast;|bar;)|z(?:;|enge;|f;))|par(?:;|lt;)|r(?:arr;|corner;|har(?:;|d;)|m;|tri;)|s(?:aquo;|cr;|h;|im(?:;|e;|g;)|q(?:b;|uo(?:;|r;))|trok;)|t(?:;|c(?:c;|ir;)|dot;|hree;|imes;|larr;|quest;|r(?:Par;|i(?:;|e;|f;))|)|ur(?:dshar;|uhar;)|v(?:ertneqq;|nE;))|m(?:DDot;|a(?:cr;?|l(?:e;|t(?:;|ese;))|p(?:;|sto(?:;|down;|left;|up;))|rker;)|c(?:omma;|y;)|dash;|easuredangle;|fr;|ho;|i(?:cro;?|d(?:;|ast;|cir;|dot;?)|nus(?:;|b;|d(?:;|u;)))|l(?:cp;|dr;)|nplus;|o(?:dels;|pf;)|p;|s(?:cr;|tpos;)|u(?:;|ltimap;|map;))|n(?:G(?:g;|t(?:;|v;))|L(?:eft(?:arrow;|rightarrow;)|l;|t(?:;|v;))|Rightarrow;|V(?:Dash;|dash;)|a(?:bla;|cute;|ng;|p(?:;|E;|id;|os;|prox;)|tur(?:;|al(?:;|s;)))|b(?:sp;?|ump(?:;|e;))|c(?:a(?:p;|ron;)|edil;|ong(?:;|dot;)|up;|y;)|dash;|e(?:;|Arr;|ar(?:hk;|r(?:;|ow;))|dot;|quiv;|s(?:ear;|im;)|xist(?:;|s;))|fr;|g(?:E;|e(?:;|q(?:;|q;|slant;)|s;)|sim;|t(?:;|r;))|h(?:Arr;|arr;|par;)|i(?:;|s(?:;|d;)|v;)|jcy;|l(?:Arr;|E;|arr;|dr;|e(?:;|ft(?:arrow;|rightarrow;)|q(?:;|q;|slant;)|s(?:;|s;))|sim;|t(?:;|ri(?:;|e;)))|mid;|o(?:pf;|t(?:;|in(?:;|E;|dot;|v(?:a;|b;|c;))|ni(?:;|v(?:a;|b;|c;))|))|p(?:ar(?:;|allel;|sl;|t;)|olint;|r(?:;|cue;|e(?:;|c(?:;|eq;))))|r(?:Arr;|arr(?:;|c;|w;)|ightarrow;|tri(?:;|e;))|s(?:c(?:;|cue;|e;|r;)|hort(?:mid;|parallel;)|im(?:;|e(?:;|q;))|mid;|par;|qsu(?:be;|pe;)|u(?:b(?:;|E;|e;|set(?:;|eq(?:;|q;)))|cc(?:;|eq;)|p(?:;|E;|e;|set(?:;|eq(?:;|q;)))))|t(?:gl;|ilde;?|lg;|riangle(?:left(?:;|eq;)|right(?:;|eq;)))|u(?:;|m(?:;|ero;|sp;))|v(?:Dash;|Harr;|ap;|dash;|g(?:e;|t;)|infin;|l(?:Arr;|e;|t(?:;|rie;))|r(?:Arr;|trie;)|sim;)|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|near;))|o(?:S;|a(?:cute;?|st;)|c(?:ir(?:;|c;?)|y;)|d(?:ash;|blac;|iv;|ot;|sold;)|elig;|f(?:cir;|r;)|g(?:on;|rave;?|t;)|h(?:bar;|m;)|int;|l(?:arr;|c(?:ir;|ross;)|ine;|t;)|m(?:acr;|ega;|i(?:cron;|d;|nus;))|opf;|p(?:ar;|erp;|lus;)|r(?:;|arr;|d(?:;|er(?:;|of;)|f;?|m;?)|igof;|or;|slope;|v;)|s(?:cr;|lash;?|ol;)|ti(?:lde;?|mes(?:;|as;))|uml;?|vbar;)|p(?:ar(?:;|a(?:;|llel;|)|s(?:im;|l;)|t;)|cy;|er(?:cnt;|iod;|mil;|p;|tenk;)|fr;|h(?:i(?:;|v;)|mmat;|one;)|i(?:;|tchfork;|v;)|l(?:an(?:ck(?:;|h;)|kv;)|us(?:;|acir;|b;|cir;|d(?:o;|u;)|e;|mn;?|sim;|two;))|m;|o(?:intint;|pf;|und;?)|r(?:;|E;|ap;|cue;|e(?:;|c(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;))|ime(?:;|s;)|n(?:E;|ap;|sim;)|o(?:d;|f(?:alar;|line;|surf;)|p(?:;|to;))|sim;|urel;)|s(?:cr;|i;)|uncsp;)|q(?:fr;|int;|opf;|prime;|scr;|u(?:at(?:ernions;|int;)|est(?:;|eq;)|ot;?))|r(?:A(?:arr;|rr;|tail;)|Barr;|Har;|a(?:c(?:e;|ute;)|dic;|emptyv;|ng(?:;|d;|e;|le;)|quo;?|rr(?:;|ap;|b(?:;|fs;)|c;|fs;|hk;|lp;|pl;|sim;|tl;|w;)|t(?:ail;|io(?:;|nals;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|ldhar;|quo(?:;|r;)|sh;)|e(?:al(?:;|ine;|part;|s;)|ct;|g;?)|f(?:isht;|loor;|r;)|h(?:ar(?:d;|u(?:;|l;))|o(?:;|v;))|i(?:ght(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|left(?:arrows;|harpoons;)|rightarrows;|squigarrow;|threetimes;)|ng;|singdotseq;)|l(?:arr;|har;|m;)|moust(?:;|ache;)|nmid;|o(?:a(?:ng;|rr;)|brk;|p(?:ar;|f;|lus;)|times;)|p(?:ar(?:;|gt;)|polint;)|rarr;|s(?:aquo;|cr;|h;|q(?:b;|uo(?:;|r;)))|t(?:hree;|imes;|ri(?:;|e;|f;|ltri;))|uluhar;|x;)|s(?:acute;|bquo;|c(?:;|E;|a(?:p;|ron;)|cue;|e(?:;|dil;)|irc;|n(?:E;|ap;|sim;)|polint;|sim;|y;)|dot(?:;|b;|e;)|e(?:Arr;|ar(?:hk;|r(?:;|ow;))|ct;?|mi;|swar;|tm(?:inus;|n;)|xt;)|fr(?:;|own;)|h(?:arp;|c(?:hcy;|y;)|ort(?:mid;|parallel;)|y;?)|i(?:gma(?:;|f;|v;)|m(?:;|dot;|e(?:;|q;)|g(?:;|E;)|l(?:;|E;)|ne;|plus;|rarr;))|larr;|m(?:a(?:llsetminus;|shp;)|eparsl;|i(?:d;|le;)|t(?:;|e(?:;|s;)))|o(?:ftcy;|l(?:;|b(?:;|ar;))|pf;)|pa(?:des(?:;|uit;)|r;)|q(?:c(?:ap(?:;|s;)|up(?:;|s;))|su(?:b(?:;|e;|set(?:;|eq;))|p(?:;|e;|set(?:;|eq;)))|u(?:;|ar(?:e;|f;)|f;))|rarr;|s(?:cr;|etmn;|mile;|tarf;)|t(?:ar(?:;|f;)|r(?:aight(?:epsilon;|phi;)|ns;))|u(?:b(?:;|E;|dot;|e(?:;|dot;)|mult;|n(?:E;|e;)|plus;|rarr;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;)))|cc(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;)|m;|ng;|p(?:1;?|2;?|3;?|;|E;|d(?:ot;|sub;)|e(?:;|dot;)|hs(?:ol;|ub;)|larr;|mult;|n(?:E;|e;)|plus;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;))))|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|nwar;)|zlig;?)|t(?:a(?:rget;|u;)|brk;|c(?:aron;|edil;|y;)|dot;|elrec;|fr;|h(?:e(?:re(?:4;|fore;)|ta(?:;|sym;|v;))|i(?:ck(?:approx;|sim;)|nsp;)|k(?:ap;|sim;)|orn;?)|i(?:lde;|mes(?:;|b(?:;|ar;)|d;|)|nt;)|o(?:ea;|p(?:;|bot;|cir;|f(?:;|ork;))|sa;)|prime;|r(?:ade;|i(?:angle(?:;|down;|left(?:;|eq;)|q;|right(?:;|eq;))|dot;|e;|minus;|plus;|sb;|time;)|pezium;)|s(?:c(?:r;|y;)|hcy;|trok;)|w(?:ixt;|ohead(?:leftarrow;|rightarrow;)))|u(?:Arr;|Har;|a(?:cute;?|rr;)|br(?:cy;|eve;)|c(?:irc;?|y;)|d(?:arr;|blac;|har;)|f(?:isht;|r;)|grave;?|h(?:ar(?:l;|r;)|blk;)|l(?:c(?:orn(?:;|er;)|rop;)|tri;)|m(?:acr;|l;?)|o(?:gon;|pf;)|p(?:arrow;|downarrow;|harpoon(?:left;|right;)|lus;|si(?:;|h;|lon;)|uparrows;)|r(?:c(?:orn(?:;|er;)|rop;)|ing;|tri;)|scr;|t(?:dot;|ilde;|ri(?:;|f;))|u(?:arr;|ml;?)|wangle;)|v(?:Arr;|Bar(?:;|v;)|Dash;|a(?:ngrt;|r(?:epsilon;|kappa;|nothing;|p(?:hi;|i;|ropto;)|r(?:;|ho;)|s(?:igma;|u(?:bsetneq(?:;|q;)|psetneq(?:;|q;)))|t(?:heta;|riangle(?:left;|right;))))|cy;|dash;|e(?:e(?:;|bar;|eq;)|llip;|r(?:bar;|t;))|fr;|ltri;|nsu(?:b;|p;)|opf;|prop;|rtri;|s(?:cr;|u(?:bn(?:E;|e;)|pn(?:E;|e;)))|zigzag;)|w(?:circ;|e(?:d(?:bar;|ge(?:;|q;))|ierp;)|fr;|opf;|p;|r(?:;|eath;)|scr;)|x(?:c(?:ap;|irc;|up;)|dtri;|fr;|h(?:Arr;|arr;)|i;|l(?:Arr;|arr;)|map;|nis;|o(?:dot;|p(?:f;|lus;)|time;)|r(?:Arr;|arr;)|s(?:cr;|qcup;)|u(?:plus;|tri;)|vee;|wedge;)|y(?:ac(?:ute;?|y;)|c(?:irc;|y;)|en;?|fr;|icy;|opf;|scr;|u(?:cy;|ml;?))|z(?:acute;|c(?:aron;|y;)|dot;|e(?:etrf;|ta;)|fr;|hcy;|igrarr;|opf;|scr;|w(?:j;|nj;)))|[\s\S]/g,
		ELe = 32,
		bLe = /[^\r"&\u0000]+/g,
		xLe = /[^\r'&\u0000]+/g,
		_Le = /[^\r\t\n\f &>\u0000]+/g,
		wLe = /[^\r\t\n\f \/>A-Z\u0000]+/g,
		ILe = /[^\r\t\n\f \/=>A-Z\u0000]+/g,
		SLe = /[^\]\r\u0000\uffff]*/g,
		BLe = /[^&<\r\u0000\uffff]*/g,
		pj = /[^<\r\u0000\uffff]*/g,
		DLe = /[^\r\u0000\uffff]*/g,
		Aj = /(?:(\/)?([a-z]+)>)|[\s\S]/g,
		mj =
			/(?:([-a-z]+)[ \t\n\f]*=[ \t\n\f]*('[^'&\r\u0000]*'|"[^"&\r\u0000]*"|[^\t\n\r\f "&'\u0000>][^&> \t\n\r\f\u0000]*[ \t\n\f]))|[\s\S]/g,
		MS = /[^\x09\x0A\x0C\x0D\x20]/,
		nU = /[^\x09\x0A\x0C\x0D\x20]/g,
		TLe = /[^\x00\x09\x0A\x0C\x0D\x20]/,
		jg = /^[\x09\x0A\x0C\x0D\x20]+/,
		FS = /\x00/g
	function Ls(e) {
		var t = 16384
		if (e.length < t) return String.fromCharCode.apply(String, e)
		for (var r = "", n = 0; n < e.length; n += t) r += String.fromCharCode.apply(String, e.slice(n, n + t))
		return r
	}
	function RLe(e) {
		for (var t = [], r = 0; r < e.length; r++) t[r] = e.charCodeAt(r)
		return t
	}
	function zr(e, t) {
		if (typeof t == "string") return e.namespaceURI === ot.HTML && e.localName === t
		var r = t[e.namespaceURI]
		return r && r[e.localName]
	}
	function yj(e) {
		return zr(e, Dj)
	}
	function Cj(e) {
		if (zr(e, Tj)) return !0
		if (e.namespaceURI === ot.MATHML && e.localName === "annotation-xml") {
			var t = e.getAttribute("encoding")
			if ((t && (t = t.toLowerCase()), t === "text/html" || t === "application/xhtml+xml")) return !0
		}
		return !1
	}
	function kLe(e) {
		return e in fj ? fj[e] : e
	}
	function vj(e) {
		for (var t = 0, r = e.length; t < r; t++) e[t][0] in dj && (e[t][0] = dj[e[t][0]])
	}
	function Ej(e) {
		for (var t = 0, r = e.length; t < r; t++)
			if (e[t][0] === "definitionurl") {
				e[t][0] = "definitionURL"
				break
			}
	}
	function iU(e) {
		for (var t = 0, r = e.length; t < r; t++) e[t][0] in uj && e[t].push(uj[e[t][0]])
	}
	function bj(e, t) {
		for (var r = 0, n = e.length; r < n; r++) {
			var i = e[r][0],
				s = e[r][1]
			t.hasAttribute(i) || t._setAttribute(i, s)
		}
	}
	Ir.ElementStack = function () {
		;(this.elements = []), (this.top = null)
	}
	Ir.ElementStack.prototype.push = function (e) {
		this.elements.push(e), (this.top = e)
	}
	Ir.ElementStack.prototype.pop = function (e) {
		this.elements.pop(), (this.top = this.elements[this.elements.length - 1])
	}
	Ir.ElementStack.prototype.popTag = function (e) {
		for (var t = this.elements.length - 1; t > 0; t--) {
			var r = this.elements[t]
			if (zr(r, e)) break
		}
		;(this.elements.length = t), (this.top = this.elements[t - 1])
	}
	Ir.ElementStack.prototype.popElementType = function (e) {
		for (var t = this.elements.length - 1; t > 0 && !(this.elements[t] instanceof e); t--);
		;(this.elements.length = t), (this.top = this.elements[t - 1])
	}
	Ir.ElementStack.prototype.popElement = function (e) {
		for (var t = this.elements.length - 1; t > 0 && this.elements[t] !== e; t--);
		;(this.elements.length = t), (this.top = this.elements[t - 1])
	}
	Ir.ElementStack.prototype.removeElement = function (e) {
		if (this.top === e) this.pop()
		else {
			var t = this.elements.lastIndexOf(e)
			t !== -1 && this.elements.splice(t, 1)
		}
	}
	Ir.ElementStack.prototype.clearToContext = function (e) {
		for (var t = this.elements.length - 1; t > 0 && !zr(this.elements[t], e); t--);
		;(this.elements.length = t + 1), (this.top = this.elements[t])
	}
	Ir.ElementStack.prototype.contains = function (e) {
		return this.inSpecificScope(e, Object.create(null))
	}
	Ir.ElementStack.prototype.inSpecificScope = function (e, t) {
		for (var r = this.elements.length - 1; r >= 0; r--) {
			var n = this.elements[r]
			if (zr(n, e)) return !0
			if (zr(n, t)) return !1
		}
		return !1
	}
	Ir.ElementStack.prototype.elementInSpecificScope = function (e, t) {
		for (var r = this.elements.length - 1; r >= 0; r--) {
			var n = this.elements[r]
			if (n === e) return !0
			if (zr(n, t)) return !1
		}
		return !1
	}
	Ir.ElementStack.prototype.elementTypeInSpecificScope = function (e, t) {
		for (var r = this.elements.length - 1; r >= 0; r--) {
			var n = this.elements[r]
			if (n instanceof e) return !0
			if (zr(n, t)) return !1
		}
		return !1
	}
	Ir.ElementStack.prototype.inScope = function (e) {
		return this.inSpecificScope(e, Xc)
	}
	Ir.ElementStack.prototype.elementInScope = function (e) {
		return this.elementInSpecificScope(e, Xc)
	}
	Ir.ElementStack.prototype.elementTypeInScope = function (e) {
		return this.elementTypeInSpecificScope(e, Xc)
	}
	Ir.ElementStack.prototype.inButtonScope = function (e) {
		return this.inSpecificScope(e, aU)
	}
	Ir.ElementStack.prototype.inListItemScope = function (e) {
		return this.inSpecificScope(e, PS)
	}
	Ir.ElementStack.prototype.inTableScope = function (e) {
		return this.inSpecificScope(e, Bj)
	}
	Ir.ElementStack.prototype.inSelectScope = function (e) {
		for (var t = this.elements.length - 1; t >= 0; t--) {
			var r = this.elements[t]
			if (r.namespaceURI !== ot.HTML) return !1
			var n = r.localName
			if (n === e) return !0
			if (n !== "optgroup" && n !== "option") return !1
		}
		return !1
	}
	Ir.ElementStack.prototype.generateImpliedEndTags = function (e, t) {
		for (var r = t ? Ij : wj, n = this.elements.length - 1; n >= 0; n--) {
			var i = this.elements[n]
			if ((e && zr(i, e)) || !zr(this.elements[n], r)) break
		}
		;(this.elements.length = n + 1), (this.top = this.elements[n])
	}
	Ir.ActiveFormattingElements = function () {
		;(this.list = []), (this.attrs = [])
	}
	Ir.ActiveFormattingElements.prototype.MARKER = { localName: "|" }
	Ir.ActiveFormattingElements.prototype.insertMarker = function () {
		this.list.push(this.MARKER), this.attrs.push(this.MARKER)
	}
	Ir.ActiveFormattingElements.prototype.push = function (e, t) {
		for (var r = 0, n = this.list.length - 1; n >= 0 && this.list[n] !== this.MARKER; n--)
			if (o(e, this.list[n], this.attrs[n]) && (r++, r === 3)) {
				this.list.splice(n, 1), this.attrs.splice(n, 1)
				break
			}
		this.list.push(e)
		for (var i = [], s = 0; s < t.length; s++) i[s] = t[s]
		this.attrs.push(i)
		function o(a, l, c) {
			if (a.localName !== l.localName || a._numattrs !== c.length) return !1
			for (var u = 0, f = c.length; u < f; u++) {
				var p = c[u][0],
					g = c[u][1]
				if (!a.hasAttribute(p) || a.getAttribute(p) !== g) return !1
			}
			return !0
		}
	}
	Ir.ActiveFormattingElements.prototype.clearToMarker = function () {
		for (var e = this.list.length - 1; e >= 0 && this.list[e] !== this.MARKER; e--);
		e < 0 && (e = 0), (this.list.length = e), (this.attrs.length = e)
	}
	Ir.ActiveFormattingElements.prototype.findElementByTag = function (e) {
		for (var t = this.list.length - 1; t >= 0; t--) {
			var r = this.list[t]
			if (r === this.MARKER) break
			if (r.localName === e) return r
		}
		return null
	}
	Ir.ActiveFormattingElements.prototype.indexOf = function (e) {
		return this.list.lastIndexOf(e)
	}
	Ir.ActiveFormattingElements.prototype.remove = function (e) {
		var t = this.list.lastIndexOf(e)
		t !== -1 && (this.list.splice(t, 1), this.attrs.splice(t, 1))
	}
	Ir.ActiveFormattingElements.prototype.replace = function (e, t, r) {
		var n = this.list.lastIndexOf(e)
		n !== -1 && ((this.list[n] = t), (this.attrs[n] = r))
	}
	Ir.ActiveFormattingElements.prototype.insertAfter = function (e, t) {
		var r = this.list.lastIndexOf(e)
		r !== -1 && (this.list.splice(r, 0, t), this.attrs.splice(r, 0, t))
	}
	function Ir(e, t, r) {
		var n = null,
			i = 0,
			s = 0,
			o = !1,
			a = !1,
			l = 0,
			c = [],
			u = "",
			f = !0,
			p = 0,
			g = Jt,
			m,
			y,
			C = "",
			v = "",
			b = [],
			w = "",
			B = "",
			M = [],
			Q = [],
			O = [],
			Y = [],
			j = [],
			ne = !1,
			q = Cw,
			me = null,
			Qe = [],
			N = new Ir.ElementStack(),
			re = new Ir.ActiveFormattingElements(),
			K = t !== void 0,
			se = null,
			Ze = null,
			It = !0
		t && (It = t.ownerDocument._scripting_enabled), r && r.scripting_enabled === !1 && (It = !1)
		var Ce = !0,
			Et = !1,
			jt,
			Ar,
			de = [],
			Tr = !1,
			tr = !1,
			Nr = {
				document: function () {
					return Ve
				},
				_asDocumentFragment: function () {
					for (var _ = Ve.createDocumentFragment(), I = Ve.firstChild; I.hasChildNodes(); )
						_.appendChild(I.firstChild)
					return _
				},
				pause: function () {
					p++
				},
				resume: function () {
					p--, this.parse("")
				},
				parse: function (_, I, L) {
					var te
					return p > 0
						? ((u += _), !0)
						: (l === 0
								? (u && ((_ = u + _), (u = "")),
									I && ((_ += "\uFFFF"), (o = !0)),
									(n = _),
									(i = _.length),
									(s = 0),
									f && ((f = !1), n.charCodeAt(0) === 65279 && (s = 1)),
									l++,
									(te = cr(L)),
									(u = n.substring(s, i)),
									l--)
								: (l++,
									c.push(n, i, s),
									(n = _),
									(i = _.length),
									(s = 0),
									cr(),
									(te = !1),
									(u = n.substring(s, i)),
									(s = c.pop()),
									(i = c.pop()),
									(n = c.pop()),
									u && ((n = u + n.substring(s)), (i = n.length), (s = 0), (u = "")),
									l--),
							te)
				},
			},
			Ve = new fLe(!0, e)
		if (((Ve._parser = Nr), (Ve._scripting_enabled = It), t)) {
			if (
				(t.ownerDocument._quirks && (Ve._quirks = !0),
				t.ownerDocument._limitedQuirks && (Ve._limitedQuirks = !0),
				t.namespaceURI === ot.HTML)
			)
				switch (t.localName) {
					case "title":
					case "textarea":
						g = Lc
						break
					case "style":
					case "xmp":
					case "iframe":
					case "noembed":
					case "noframes":
					case "script":
					case "plaintext":
						g = KC
						break
				}
			var en = Ve.createElement("html")
			Ve._appendChild(en), N.push(en), t instanceof Jr.HTMLTemplateElement && Qe.push(gg), Af()
			for (var Pr = t; Pr !== null; Pr = Pr.parentElement)
				if (Pr instanceof Jr.HTMLFormElement) {
					Ze = Pr
					break
				}
		}
		function cr(_) {
			for (var I, L, te, oe; s < i; ) {
				if (p > 0 || (_ && _())) return !0
				switch (typeof g.lookahead) {
					case "undefined":
						if (((I = n.charCodeAt(s++)), a && ((a = !1), I === 10))) {
							s++
							continue
						}
						switch (I) {
							case 13:
								s < i ? n.charCodeAt(s) === 10 && s++ : (a = !0), g(10)
								break
							case 65535:
								if (o && s === i) {
									g(kS)
									break
								}
							default:
								g(I)
								break
						}
						break
					case "number":
						I = n.charCodeAt(s)
						var Be = g.lookahead,
							st = !0
						if ((Be < 0 && ((st = !1), (Be = -Be)), Be < i - s))
							(L = st ? n.substring(s, s + Be) : null), (oe = !1)
						else if (o)
							(L = st ? n.substring(s, i) : null), (oe = !0), I === 65535 && s === i - 1 && (I = kS)
						else return !0
						g(I, L, oe)
						break
					case "string":
						;(I = n.charCodeAt(s)), (te = g.lookahead)
						var qt = n.indexOf(te, s)
						if (qt !== -1) (L = n.substring(s, qt + te.length)), (oe = !1)
						else {
							if (!o) return !0
							;(L = n.substring(s, i)), I === 65535 && s === i - 1 && (I = kS), (oe = !0)
						}
						g(I, L, oe)
						break
				}
			}
			return !1
		}
		function be(_, I) {
			for (var L = 0; L < j.length; L++) if (j[L][0] === _) return
			I !== void 0 ? j.push([_, I]) : j.push([_])
		}
		function Rr() {
			mj.lastIndex = s - 1
			var _ = mj.exec(n)
			if (!_) throw new Error("should never happen")
			var I = _[1]
			if (!I) return !1
			var L = _[2],
				te = L.length
			switch (L[0]) {
				case '"':
				case "'":
					;(L = L.substring(1, te - 1)), (s += _[0].length - 1), (g = MA)
					break
				default:
					;(g = zs), (s += _[0].length - 1), (L = L.substring(0, te - 1))
					break
			}
			for (var oe = 0; oe < j.length; oe++) if (j[oe][0] === I) return !0
			return j.push([I, L]), !0
		}
		function fe() {
			;(ne = !1), (C = ""), (j.length = 0)
		}
		function Ee() {
			;(ne = !0), (C = ""), (j.length = 0)
		}
		function bt() {
			b.length = 0
		}
		function sn() {
			w = ""
		}
		function yn() {
			B = ""
		}
		function Ei() {
			M.length = 0
		}
		function Js() {
			;(Q.length = 0), (O = null), (Y = null)
		}
		function Ju() {
			O = []
		}
		function Pc() {
			Y = []
		}
		function rr() {
			Et = !0
		}
		function MN() {
			return N.top && N.top.namespaceURI !== "http://www.w3.org/1999/xhtml"
		}
		function Gi(_) {
			return v === _
		}
		function ra() {
			if (de.length > 0) {
				var _ = Ls(de)
				if (
					((de.length = 0),
					tr &&
						((tr = !1),
						_[0] ===
							`
` && (_ = _.substring(1)),
						_.length === 0))
				)
					return
				Cn(Nm, _), (Tr = !1)
			}
			tr = !1
		}
		function zu(_) {
			_.lastIndex = s - 1
			var I = _.exec(n)
			if (I && I.index === s - 1)
				return (I = I[0]), (s += I.length - 1), o && s === i && ((I = I.slice(0, -1)), s--), I
			throw new Error("should never happen")
		}
		function ju(_) {
			_.lastIndex = s - 1
			var I = _.exec(n)[0]
			return I ? (VC(I), (s += I.length - 1), !0) : !1
		}
		function VC(_) {
			de.length > 0 && ra(),
				!(
					tr &&
					((tr = !1),
					_[0] ===
						`
` && (_ = _.substring(1)),
					_.length === 0)
				) && Cn(Nm, _)
		}
		function na() {
			if (ne) Cn(ir, C)
			else {
				var _ = C
				;(C = ""), (v = _), Cn(Ps, _, j)
			}
		}
		function HC() {
			if (s === i) return !1
			Aj.lastIndex = s
			var _ = Aj.exec(n)
			if (!_) throw new Error("should never happen")
			var I = _[2]
			if (!I) return !1
			var L = _[1]
			return L ? ((s += I.length + 2), Cn(ir, I)) : ((s += I.length + 1), (v = I), Cn(Ps, I, pLe)), !0
		}
		function WC() {
			ne ? Cn(ir, C, null, !0) : Cn(Ps, C, j, !0)
		}
		function mr() {
			Cn(gLe, Ls(Q), O ? Ls(O) : void 0, Y ? Ls(Y) : void 0)
		}
		function St() {
			ra(), q(kS), (Ve.modclock = 1)
		}
		var Cn = (Nr.insertToken = function (I, L, te, oe) {
			ra()
			var Be = N.top
			!Be || Be.namespaceURI === ot.HTML
				? q(I, L, te, oe)
				: I !== Ps && I !== Nm
					? nd(I, L, te, oe)
					: (yj(Be) && (I === Nm || (I === Ps && L !== "mglyph" && L !== "malignmark"))) ||
						  (I === Ps &&
								L === "svg" &&
								Be.namespaceURI === ot.MATHML &&
								Be.localName === "annotation-xml") ||
						  Cj(Be)
						? ((Ar = !0), q(I, L, te, oe), (Ar = !1))
						: nd(I, L, te, oe)
		})
		function La(_) {
			var I = N.top
			Ul && zr(I, Pm)
				? IA(function (L) {
						return L.createComment(_)
					})
				: (I instanceof Jr.HTMLTemplateElement && (I = I.content),
					I._appendChild(I.ownerDocument.createComment(_)))
		}
		function Ua(_) {
			var I = N.top
			if (Ul && zr(I, Pm))
				IA(function (te) {
					return te.createTextNode(_)
				})
			else {
				I instanceof Jr.HTMLTemplateElement && (I = I.content)
				var L = I.lastChild
				L && L.nodeType === rU.TEXT_NODE ? L.appendData(_) : I._appendChild(I.ownerDocument.createTextNode(_))
			}
		}
		function ug(_, I, L) {
			var te = xj.createElement(_, I, null)
			if (L) for (var oe = 0, Be = L.length; oe < Be; oe++) te._setAttribute(L[oe][0], L[oe][1])
			return te
		}
		var Ul = !1
		function Ct(_, I) {
			var L = wA(function (te) {
				return ug(te, _, I)
			})
			return zr(L, Sj) && (L._form = Ze), L
		}
		function wA(_) {
			var I
			return (
				Ul && zr(N.top, Pm)
					? (I = IA(_))
					: N.top instanceof Jr.HTMLTemplateElement
						? ((I = _(N.top.content.ownerDocument)), N.top.content._appendChild(I))
						: ((I = _(N.top.ownerDocument)), N.top._appendChild(I)),
				N.push(I),
				I
			)
		}
		function GC(_, I, L) {
			return wA(function (te) {
				var oe = te._createElementNS(_, L, null)
				if (I)
					for (var Be = 0, st = I.length; Be < st; Be++) {
						var qt = I[Be]
						qt.length === 2 ? oe._setAttribute(qt[0], qt[1]) : oe._setAttributeNS(qt[2], qt[0], qt[1])
					}
				return oe
			})
		}
		function J_(_) {
			for (var I = N.elements.length - 1; I >= 0; I--) if (N.elements[I] instanceof _) return I
			return -1
		}
		function IA(_) {
			var I,
				L,
				te = -1,
				oe = -1,
				Be
			if (
				((te = J_(Jr.HTMLTableElement)),
				(oe = J_(Jr.HTMLTemplateElement)),
				oe >= 0 && (te < 0 || oe > te)
					? (I = N.elements[oe])
					: te >= 0 && ((I = N.elements[te].parentNode), I ? (L = N.elements[te]) : (I = N.elements[te - 1])),
				I || (I = N.elements[0]),
				I instanceof Jr.HTMLTemplateElement && (I = I.content),
				(Be = _(I.ownerDocument)),
				Be.nodeType === rU.TEXT_NODE)
			) {
				var st
				if ((L ? (st = L.previousSibling) : (st = I.lastChild), st && st.nodeType === rU.TEXT_NODE))
					return st.appendData(Be.data), Be
			}
			return L ? I.insertBefore(Be, L) : I._appendChild(Be), Be
		}
		function Af() {
			for (var _ = !1, I = N.elements.length - 1; I >= 0; I--) {
				var L = N.elements[I]
				if ((I === 0 && ((_ = !0), K && (L = t)), L.namespaceURI === ot.HTML)) {
					var te = L.localName
					switch (te) {
						case "select":
							for (var oe = I; oe > 0; ) {
								var Be = N.elements[--oe]
								if (Be instanceof Jr.HTMLTemplateElement) break
								if (Be instanceof Jr.HTMLTableElement) {
									q = NA
									return
								}
							}
							q = sa
							return
						case "tr":
							q = Yr
							return
						case "tbody":
						case "tfoot":
						case "thead":
							q = ql
							return
						case "caption":
							q = qa
							return
						case "colgroup":
							q = rd
							return
						case "table":
							q = xo
							return
						case "template":
							q = Qe[Qe.length - 1]
							return
						case "body":
							q = it
							return
						case "frameset":
							q = av
							return
						case "html":
							se === null ? (q = hg) : (q = us)
							return
						default:
							if (!_) {
								if (te === "head") {
									q = vn
									return
								}
								if (te === "td" || te === "th") {
									q = js
									return
								}
							}
					}
				}
				if (_) {
					q = it
					return
				}
			}
		}
		function SA(_, I) {
			Ct(_, I), (g = dg), (me = q), (q = ds)
		}
		function FN(_, I) {
			Ct(_, I), (g = Lc), (me = q), (q = ds)
		}
		function $C(_, I) {
			return {
				elt: ug(_, re.list[I].localName, re.attrs[I]),
				attrs: re.attrs[I],
			}
		}
		function Fi() {
			if (re.list.length !== 0) {
				var _ = re.list[re.list.length - 1]
				if (_ !== re.MARKER && N.elements.lastIndexOf(_) === -1) {
					for (
						var I = re.list.length - 2;
						I >= 0 && ((_ = re.list[I]), !(_ === re.MARKER || N.elements.lastIndexOf(_) !== -1));
						I--
					);
					for (I = I + 1; I < re.list.length; I++) {
						var L = wA(function (te) {
							return $C(te, I).elt
						})
						re.list[I] = L
					}
				}
			}
		}
		var BA = { localName: "BM" }
		function YC(_) {
			if (zr(N.top, _) && re.indexOf(N.top) === -1) return N.pop(), !0
			for (var I = 0; I < 8; ) {
				I++
				var L = re.findElementByTag(_)
				if (!L) return !1
				var te = N.elements.lastIndexOf(L)
				if (te === -1) return re.remove(L), !0
				if (!N.elementInScope(L)) return !0
				for (var oe = null, Be, st = te + 1; st < N.elements.length; st++)
					if (zr(N.elements[st], Zg)) {
						;(oe = N.elements[st]), (Be = st)
						break
					}
				if (oe) {
					var qt = N.elements[te - 1]
					re.insertAfter(L, BA)
					for (var ln = oe, Qi = oe, Zs = Be, En, Vl = 0; Vl++, (ln = N.elements[--Zs]), ln !== L; ) {
						if (((En = re.indexOf(ln)), Vl > 3 && En !== -1 && (re.remove(ln), (En = -1)), En === -1)) {
							N.removeElement(ln)
							continue
						}
						var _o = $C(qt.ownerDocument, En)
						re.replace(ln, _o.elt, _o.attrs),
							(N.elements[Zs] = _o.elt),
							(ln = _o.elt),
							Qi === oe && (re.remove(BA), re.insertAfter(_o.elt, BA)),
							ln._appendChild(Qi),
							(Qi = ln)
					}
					Ul && zr(qt, Pm)
						? IA(function () {
								return Qi
							})
						: qt instanceof Jr.HTMLTemplateElement
							? qt.content._appendChild(Qi)
							: qt._appendChild(Qi)
					for (var vf = $C(oe.ownerDocument, re.indexOf(L)); oe.hasChildNodes(); )
						vf.elt._appendChild(oe.firstChild)
					oe._appendChild(vf.elt), re.remove(L), re.replace(BA, vf.elt, vf.attrs), N.removeElement(L)
					var xw = N.elements.lastIndexOf(oe)
					N.elements.splice(xw + 1, 0, vf.elt)
				} else return N.popElement(L), re.remove(L), !0
			}
			return !0
		}
		function QN() {
			N.pop(), (q = me)
		}
		function Zu() {
			delete Ve._parser,
				(N.elements.length = 0),
				Ve.defaultView && Ve.defaultView.dispatchEvent(new Jr.Event("load", {}))
		}
		function Ke(_, I) {
			;(g = I), s--
		}
		function Jt(_) {
			switch (_) {
				case 38:
					;(m = Jt), (g = Cf)
					break
				case 60:
					if (HC()) break
					g = z_
					break
				case 0:
					de.push(_), (Tr = !0)
					break
				case -1:
					St()
					break
				default:
					ju(BLe) || de.push(_)
					break
			}
		}
		function Lc(_) {
			switch (_) {
				case 38:
					;(m = Lc), (g = Cf)
					break
				case 60:
					g = PN
					break
				case 0:
					de.push(65533), (Tr = !0)
					break
				case -1:
					St()
					break
				default:
					de.push(_)
					break
			}
		}
		function dg(_) {
			switch (_) {
				case 60:
					g = ON
					break
				case 0:
					de.push(65533)
					break
				case -1:
					St()
					break
				default:
					ju(pj) || de.push(_)
					break
			}
		}
		function Uc(_) {
			switch (_) {
				case 60:
					g = TA
					break
				case 0:
					de.push(65533)
					break
				case -1:
					St()
					break
				default:
					ju(pj) || de.push(_)
					break
			}
		}
		function KC(_) {
			switch (_) {
				case 0:
					de.push(65533)
					break
				case -1:
					St()
					break
				default:
					ju(DLe) || de.push(_)
					break
			}
		}
		function z_(_) {
			switch (_) {
				case 33:
					g = Xu
					break
				case 47:
					g = NN
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					fe(), Ke(_, j_)
					break
				case 63:
					Ke(_, yf)
					break
				default:
					de.push(60), Ke(_, Jt)
					break
			}
		}
		function NN(_) {
			switch (_) {
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					Ee(), Ke(_, j_)
					break
				case 62:
					g = Jt
					break
				case -1:
					de.push(60), de.push(47), St()
					break
				default:
					Ke(_, yf)
					break
			}
		}
		function j_(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					g = zs
					break
				case 47:
					g = Oa
					break
				case 62:
					;(g = Jt), na()
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
					C += String.fromCharCode(_ + 32)
					break
				case 0:
					C += "\uFFFD"
					break
				case -1:
					St()
					break
				default:
					C += zu(wLe)
					break
			}
		}
		function PN(_) {
			_ === 47 ? (bt(), (g = LN)) : (de.push(60), Ke(_, Lc))
		}
		function LN(_) {
			switch (_) {
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					Ee(), Ke(_, UN)
					break
				default:
					de.push(60), de.push(47), Ke(_, Lc)
					break
			}
		}
		function UN(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					if (Gi(C)) {
						g = zs
						return
					}
					break
				case 47:
					if (Gi(C)) {
						g = Oa
						return
					}
					break
				case 62:
					if (Gi(C)) {
						;(g = Jt), na()
						return
					}
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
					;(C += String.fromCharCode(_ + 32)), b.push(_)
					return
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					;(C += String.fromCharCode(_)), b.push(_)
					return
				default:
					break
			}
			de.push(60), de.push(47), zg(de, b), Ke(_, Lc)
		}
		function ON(_) {
			_ === 47 ? (bt(), (g = DA)) : (de.push(60), Ke(_, dg))
		}
		function DA(_) {
			switch (_) {
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					Ee(), Ke(_, qN)
					break
				default:
					de.push(60), de.push(47), Ke(_, dg)
					break
			}
		}
		function qN(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					if (Gi(C)) {
						g = zs
						return
					}
					break
				case 47:
					if (Gi(C)) {
						g = Oa
						return
					}
					break
				case 62:
					if (Gi(C)) {
						;(g = Jt), na()
						return
					}
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
					;(C += String.fromCharCode(_ + 32)), b.push(_)
					return
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					;(C += String.fromCharCode(_)), b.push(_)
					return
				default:
					break
			}
			de.push(60), de.push(47), zg(de, b), Ke(_, dg)
		}
		function TA(_) {
			switch (_) {
				case 47:
					bt(), (g = VN)
					break
				case 33:
					;(g = WN), de.push(60), de.push(33)
					break
				default:
					de.push(60), Ke(_, Uc)
					break
			}
		}
		function VN(_) {
			switch (_) {
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					Ee(), Ke(_, HN)
					break
				default:
					de.push(60), de.push(47), Ke(_, Uc)
					break
			}
		}
		function HN(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					if (Gi(C)) {
						g = zs
						return
					}
					break
				case 47:
					if (Gi(C)) {
						g = Oa
						return
					}
					break
				case 62:
					if (Gi(C)) {
						;(g = Jt), na()
						return
					}
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
					;(C += String.fromCharCode(_ + 32)), b.push(_)
					return
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					;(C += String.fromCharCode(_)), b.push(_)
					return
				default:
					break
			}
			de.push(60), de.push(47), zg(de, b), Ke(_, Uc)
		}
		function WN(_) {
			_ === 45 ? ((g = Z_), de.push(45)) : Ke(_, Uc)
		}
		function Z_(_) {
			_ === 45 ? ((g = ew), de.push(45)) : Ke(_, Uc)
		}
		function ia(_) {
			switch (_) {
				case 45:
					;(g = X_), de.push(45)
					break
				case 60:
					g = JC
					break
				case 0:
					de.push(65533)
					break
				case -1:
					St()
					break
				default:
					de.push(_)
					break
			}
		}
		function X_(_) {
			switch (_) {
				case 45:
					;(g = ew), de.push(45)
					break
				case 60:
					g = JC
					break
				case 0:
					;(g = ia), de.push(65533)
					break
				case -1:
					St()
					break
				default:
					;(g = ia), de.push(_)
					break
			}
		}
		function ew(_) {
			switch (_) {
				case 45:
					de.push(45)
					break
				case 60:
					g = JC
					break
				case 62:
					;(g = Uc), de.push(62)
					break
				case 0:
					;(g = ia), de.push(65533)
					break
				case -1:
					St()
					break
				default:
					;(g = ia), de.push(_)
					break
			}
		}
		function JC(_) {
			switch (_) {
				case 47:
					bt(), (g = GN)
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					bt(), de.push(60), Ke(_, tw)
					break
				default:
					de.push(60), Ke(_, ia)
					break
			}
		}
		function GN(_) {
			switch (_) {
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					Ee(), Ke(_, $N)
					break
				default:
					de.push(60), de.push(47), Ke(_, ia)
					break
			}
		}
		function $N(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					if (Gi(C)) {
						g = zs
						return
					}
					break
				case 47:
					if (Gi(C)) {
						g = Oa
						return
					}
					break
				case 62:
					if (Gi(C)) {
						;(g = Jt), na()
						return
					}
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
					;(C += String.fromCharCode(_ + 32)), b.push(_)
					return
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					;(C += String.fromCharCode(_)), b.push(_)
					return
				default:
					break
			}
			de.push(60), de.push(47), zg(de, b), Ke(_, ia)
		}
		function tw(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
				case 47:
				case 62:
					Ls(b) === "script" ? (g = Ol) : (g = ia), de.push(_)
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
					b.push(_ + 32), de.push(_)
					break
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					b.push(_), de.push(_)
					break
				default:
					Ke(_, ia)
					break
			}
		}
		function Ol(_) {
			switch (_) {
				case 45:
					;(g = rw), de.push(45)
					break
				case 60:
					;(g = jC), de.push(60)
					break
				case 0:
					de.push(65533)
					break
				case -1:
					St()
					break
				default:
					de.push(_)
					break
			}
		}
		function rw(_) {
			switch (_) {
				case 45:
					;(g = zC), de.push(45)
					break
				case 60:
					;(g = jC), de.push(60)
					break
				case 0:
					;(g = Ol), de.push(65533)
					break
				case -1:
					St()
					break
				default:
					;(g = Ol), de.push(_)
					break
			}
		}
		function zC(_) {
			switch (_) {
				case 45:
					de.push(45)
					break
				case 60:
					;(g = jC), de.push(60)
					break
				case 62:
					;(g = Uc), de.push(62)
					break
				case 0:
					;(g = Ol), de.push(65533)
					break
				case -1:
					St()
					break
				default:
					;(g = Ol), de.push(_)
					break
			}
		}
		function jC(_) {
			_ === 47 ? (bt(), (g = nw), de.push(47)) : Ke(_, Ol)
		}
		function nw(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
				case 47:
				case 62:
					Ls(b) === "script" ? (g = ia) : (g = Ol), de.push(_)
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
					b.push(_ + 32), de.push(_)
					break
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
					b.push(_), de.push(_)
					break
				default:
					Ke(_, Ol)
					break
			}
		}
		function zs(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					break
				case 47:
					g = Oa
					break
				case 62:
					;(g = Jt), na()
					break
				case -1:
					St()
					break
				case 61:
					sn(), (w += String.fromCharCode(_)), (g = RA)
					break
				default:
					if (Rr()) break
					sn(), Ke(_, RA)
					break
			}
		}
		function RA(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
				case 47:
				case 62:
				case -1:
					Ke(_, YN)
					break
				case 61:
					g = ZC
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
					w += String.fromCharCode(_ + 32)
					break
				case 0:
					w += "\uFFFD"
					break
				case 34:
				case 39:
				case 60:
				default:
					w += zu(ILe)
					break
			}
		}
		function YN(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					break
				case 47:
					be(w), (g = Oa)
					break
				case 61:
					g = ZC
					break
				case 62:
					;(g = Jt), be(w), na()
					break
				case -1:
					be(w), St()
					break
				default:
					be(w), sn(), Ke(_, RA)
					break
			}
		}
		function ZC(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					break
				case 34:
					yn(), (g = fg)
					break
				case 39:
					yn(), (g = mf)
					break
				case 62:
				default:
					yn(), Ke(_, kA)
					break
			}
		}
		function fg(_) {
			switch (_) {
				case 34:
					be(w, B), (g = MA)
					break
				case 38:
					;(m = fg), (g = Cf)
					break
				case 0:
					B += "\uFFFD"
					break
				case -1:
					St()
					break
				case 10:
					B += String.fromCharCode(_)
					break
				default:
					B += zu(bLe)
					break
			}
		}
		function mf(_) {
			switch (_) {
				case 39:
					be(w, B), (g = MA)
					break
				case 38:
					;(m = mf), (g = Cf)
					break
				case 0:
					B += "\uFFFD"
					break
				case -1:
					St()
					break
				case 10:
					B += String.fromCharCode(_)
					break
				default:
					B += zu(xLe)
					break
			}
		}
		function kA(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					be(w, B), (g = zs)
					break
				case 38:
					;(m = kA), (g = Cf)
					break
				case 62:
					be(w, B), (g = Jt), na()
					break
				case 0:
					B += "\uFFFD"
					break
				case -1:
					s--, (g = Jt)
					break
				case 34:
				case 39:
				case 60:
				case 61:
				case 96:
				default:
					B += zu(_Le)
					break
			}
		}
		function MA(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					g = zs
					break
				case 47:
					g = Oa
					break
				case 62:
					;(g = Jt), na()
					break
				case -1:
					St()
					break
				default:
					Ke(_, zs)
					break
			}
		}
		function Oa(_) {
			switch (_) {
				case 62:
					;(g = Jt), WC(!0)
					break
				case -1:
					St()
					break
				default:
					Ke(_, zs)
					break
			}
		}
		function yf(_, I, L) {
			var te = I.length
			L ? (s += te - 1) : (s += te)
			var oe = I.substring(0, te - 1)
			;(oe = oe.replace(/\u0000/g, "\uFFFD")),
				(oe = oe.replace(
					/\u000D\u000A/g,
					`
`,
				)),
				(oe = oe.replace(
					/\u000D/g,
					`
`,
				)),
				Cn(Zc, oe),
				(g = Jt)
		}
		yf.lookahead = ">"
		function Xu(_, I, L) {
			if (I[0] === "-" && I[1] === "-") {
				;(s += 2), Ei(), (g = iw)
				return
			}
			I.toUpperCase() === "DOCTYPE"
				? ((s += 7), (g = uw))
				: I === "[CDATA[" && MN()
					? ((s += 7), (g = rv))
					: (g = yf)
		}
		Xu.lookahead = 7
		function iw(_) {
			switch ((Ei(), _)) {
				case 45:
					g = sw
					break
				case 62:
					;(g = Jt), Cn(Zc, Ls(M))
					break
				default:
					Ke(_, ed)
					break
			}
		}
		function sw(_) {
			switch (_) {
				case 45:
					g = FA
					break
				case 62:
					;(g = Jt), Cn(Zc, Ls(M))
					break
				case -1:
					Cn(Zc, Ls(M)), St()
					break
				default:
					M.push(45), Ke(_, ed)
					break
			}
		}
		function ed(_) {
			switch (_) {
				case 60:
					M.push(_), (g = ow)
					break
				case 45:
					g = XC
					break
				case 0:
					M.push(65533)
					break
				case -1:
					Cn(Zc, Ls(M)), St()
					break
				default:
					M.push(_)
					break
			}
		}
		function ow(_) {
			switch (_) {
				case 33:
					M.push(_), (g = aw)
					break
				case 60:
					M.push(_)
					break
				default:
					Ke(_, ed)
					break
			}
		}
		function aw(_) {
			switch (_) {
				case 45:
					g = lw
					break
				default:
					Ke(_, ed)
					break
			}
		}
		function lw(_) {
			switch (_) {
				case 45:
					g = cw
					break
				default:
					Ke(_, XC)
					break
			}
		}
		function cw(_) {
			switch (_) {
				case 62:
				case -1:
					Ke(_, FA)
					break
				default:
					Ke(_, FA)
					break
			}
		}
		function XC(_) {
			switch (_) {
				case 45:
					g = FA
					break
				case -1:
					Cn(Zc, Ls(M)), St()
					break
				default:
					M.push(45), Ke(_, ed)
					break
			}
		}
		function FA(_) {
			switch (_) {
				case 62:
					;(g = Jt), Cn(Zc, Ls(M))
					break
				case 33:
					g = KN
					break
				case 45:
					M.push(45)
					break
				case -1:
					Cn(Zc, Ls(M)), St()
					break
				default:
					M.push(45), M.push(45), Ke(_, ed)
					break
			}
		}
		function KN(_) {
			switch (_) {
				case 45:
					M.push(45), M.push(45), M.push(33), (g = XC)
					break
				case 62:
					;(g = Jt), Cn(Zc, Ls(M))
					break
				case -1:
					Cn(Zc, Ls(M)), St()
					break
				default:
					M.push(45), M.push(45), M.push(33), Ke(_, ed)
					break
			}
		}
		function uw(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					g = dw
					break
				case -1:
					Js(), rr(), mr(), St()
					break
				default:
					Ke(_, dw)
					break
			}
		}
		function dw(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
					Js(), Q.push(_ + 32), (g = ev)
					break
				case 0:
					Js(), Q.push(65533), (g = ev)
					break
				case 62:
					Js(), rr(), (g = Jt), mr()
					break
				case -1:
					Js(), rr(), mr(), St()
					break
				default:
					Js(), Q.push(_), (g = ev)
					break
			}
		}
		function ev(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					g = fw
					break
				case 62:
					;(g = Jt), mr()
					break
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
					Q.push(_ + 32)
					break
				case 0:
					Q.push(65533)
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					Q.push(_)
					break
			}
		}
		function fw(_, I, L) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					s += 1
					break
				case 62:
					;(g = Jt), (s += 1), mr()
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					;(I = I.toUpperCase()),
						I === "PUBLIC" ? ((s += 6), (g = JN)) : I === "SYSTEM" ? ((s += 6), (g = jN)) : (rr(), (g = Oc))
					break
			}
		}
		fw.lookahead = 6
		function JN(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					g = tv
					break
				case 34:
					Ju(), (g = hw)
					break
				case 39:
					Ju(), (g = gw)
					break
				case 62:
					rr(), (g = Jt), mr()
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					rr(), (g = Oc)
					break
			}
		}
		function tv(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					break
				case 34:
					Ju(), (g = hw)
					break
				case 39:
					Ju(), (g = gw)
					break
				case 62:
					rr(), (g = Jt), mr()
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					rr(), (g = Oc)
					break
			}
		}
		function hw(_) {
			switch (_) {
				case 34:
					g = pw
					break
				case 0:
					O.push(65533)
					break
				case 62:
					rr(), (g = Jt), mr()
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					O.push(_)
					break
			}
		}
		function gw(_) {
			switch (_) {
				case 39:
					g = pw
					break
				case 0:
					O.push(65533)
					break
				case 62:
					rr(), (g = Jt), mr()
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					O.push(_)
					break
			}
		}
		function pw(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					g = zN
					break
				case 62:
					;(g = Jt), mr()
					break
				case 34:
					Pc(), (g = Lr)
					break
				case 39:
					Pc(), (g = QA)
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					rr(), (g = Oc)
					break
			}
		}
		function zN(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					break
				case 62:
					;(g = Jt), mr()
					break
				case 34:
					Pc(), (g = Lr)
					break
				case 39:
					Pc(), (g = QA)
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					rr(), (g = Oc)
					break
			}
		}
		function jN(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					g = an
					break
				case 34:
					Pc(), (g = Lr)
					break
				case 39:
					Pc(), (g = QA)
					break
				case 62:
					rr(), (g = Jt), mr()
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					rr(), (g = Oc)
					break
			}
		}
		function an(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					break
				case 34:
					Pc(), (g = Lr)
					break
				case 39:
					Pc(), (g = QA)
					break
				case 62:
					rr(), (g = Jt), mr()
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					rr(), (g = Oc)
					break
			}
		}
		function Lr(_) {
			switch (_) {
				case 34:
					g = Aw
					break
				case 0:
					Y.push(65533)
					break
				case 62:
					rr(), (g = Jt), mr()
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					Y.push(_)
					break
			}
		}
		function QA(_) {
			switch (_) {
				case 39:
					g = Aw
					break
				case 0:
					Y.push(65533)
					break
				case 62:
					rr(), (g = Jt), mr()
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					Y.push(_)
					break
			}
		}
		function Aw(_) {
			switch (_) {
				case 9:
				case 10:
				case 12:
				case 32:
					break
				case 62:
					;(g = Jt), mr()
					break
				case -1:
					rr(), mr(), St()
					break
				default:
					g = Oc
					break
			}
		}
		function Oc(_) {
			switch (_) {
				case 62:
					;(g = Jt), mr()
					break
				case -1:
					mr(), St()
					break
				default:
					break
			}
		}
		function rv(_) {
			switch (_) {
				case 93:
					g = ZN
					break
				case -1:
					St()
					break
				case 0:
					Tr = !0
				default:
					ju(SLe) || de.push(_)
					break
			}
		}
		function ZN(_) {
			switch (_) {
				case 93:
					g = XN
					break
				default:
					de.push(93), Ke(_, rv)
					break
			}
		}
		function XN(_) {
			switch (_) {
				case 93:
					de.push(93)
					break
				case 62:
					ra(), (g = Jt)
					break
				default:
					de.push(93), de.push(93), Ke(_, rv)
					break
			}
		}
		function Cf(_) {
			switch ((bt(), b.push(38), _)) {
				case 9:
				case 10:
				case 12:
				case 32:
				case 60:
				case 38:
				case -1:
					Ke(_, qc)
					break
				case 35:
					b.push(_), (g = bi)
					break
				default:
					Ke(_, mw)
					break
			}
		}
		function mw(_) {
			gj.lastIndex = s
			var I = gj.exec(n)
			if (!I) throw new Error("should never happen")
			var L = I[1]
			if (!L) {
				g = qc
				return
			}
			switch (((s += L.length), zg(b, RLe(L)), m)) {
				case fg:
				case mf:
				case kA:
					if (L[L.length - 1] !== ";" && /[=A-Za-z0-9]/.test(n[s])) {
						g = qc
						return
					}
					break
				default:
					break
			}
			bt()
			var te = vLe[L]
			typeof te == "number" ? b.push(te) : zg(b, te), (g = qc)
		}
		mw.lookahead = -ELe
		function bi(_) {
			switch (((y = 0), _)) {
				case 120:
				case 88:
					b.push(_), (g = nv)
					break
				default:
					Ke(_, td)
					break
			}
		}
		function nv(_) {
			switch (_) {
				case 48:
				case 49:
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
					Ke(_, yw)
					break
				default:
					Ke(_, qc)
					break
			}
		}
		function td(_) {
			switch (_) {
				case 48:
				case 49:
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
					Ke(_, iv)
					break
				default:
					Ke(_, qc)
					break
			}
		}
		function yw(_) {
			switch (_) {
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
					;(y *= 16), (y += _ - 55)
					break
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
					;(y *= 16), (y += _ - 87)
					break
				case 48:
				case 49:
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
					;(y *= 16), (y += _ - 48)
					break
				case 59:
					g = cs
					break
				default:
					Ke(_, cs)
					break
			}
		}
		function iv(_) {
			switch (_) {
				case 48:
				case 49:
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
					;(y *= 10), (y += _ - 48)
					break
				case 59:
					g = cs
					break
				default:
					Ke(_, cs)
					break
			}
		}
		function cs(_) {
			y in hj ? (y = hj[y]) : (y > 1114111 || (y >= 55296 && y < 57344)) && (y = 65533),
				bt(),
				y <= 65535 ? b.push(y) : ((y = y - 65536), b.push(55296 + (y >> 10)), b.push(56320 + (y & 1023))),
				Ke(_, qc)
		}
		function qc(_) {
			switch (m) {
				case fg:
				case mf:
				case kA:
					B += Ls(b)
					break
				default:
					zg(de, b)
					break
			}
			Ke(_, m)
		}
		function Cw(_, I, L, te) {
			switch (_) {
				case 1:
					if (((I = I.replace(jg, "")), I.length === 0)) return
					break
				case 4:
					Ve._appendChild(Ve.createComment(I))
					return
				case 5:
					var oe = I,
						Be = L,
						st = te
					Ve.appendChild(new hLe(Ve, oe, Be, st)),
						Et ||
						oe.toLowerCase() !== "html" ||
						ALe.test(Be) ||
						(st && st.toLowerCase() === mLe) ||
						(st === void 0 && cj.test(Be))
							? (Ve._quirks = !0)
							: (yLe.test(Be) || (st !== void 0 && cj.test(Be))) && (Ve._limitedQuirks = !0),
						(q = sv)
					return
			}
			;(Ve._quirks = !0), (q = sv), q(_, I, L, te)
		}
		function sv(_, I, L, te) {
			var oe
			switch (_) {
				case 1:
					if (((I = I.replace(jg, "")), I.length === 0)) return
					break
				case 5:
					return
				case 4:
					Ve._appendChild(Ve.createComment(I))
					return
				case 2:
					if (I === "html") {
						;(oe = ug(Ve, I, L)), N.push(oe), Ve.appendChild(oe), (q = hg)
						return
					}
					break
				case 3:
					switch (I) {
						case "html":
						case "head":
						case "body":
						case "br":
							break
						default:
							return
					}
			}
			;(oe = ug(Ve, "html", null)), N.push(oe), Ve.appendChild(oe), (q = hg), q(_, I, L, te)
		}
		function hg(_, I, L, te) {
			switch (_) {
				case 1:
					if (((I = I.replace(jg, "")), I.length === 0)) return
					break
				case 5:
					return
				case 4:
					La(I)
					return
				case 2:
					switch (I) {
						case "html":
							it(_, I, L, te)
							return
						case "head":
							var oe = Ct(I, L)
							;(se = oe), (q = vn)
							return
					}
					break
				case 3:
					switch (I) {
						case "html":
						case "head":
						case "body":
						case "br":
							break
						default:
							return
					}
			}
			hg(Ps, "head", null), q(_, I, L, te)
		}
		function vn(_, I, L, te) {
			switch (_) {
				case 1:
					var oe = I.match(jg)
					if ((oe && (Ua(oe[0]), (I = I.substring(oe[0].length))), I.length === 0)) return
					break
				case 4:
					La(I)
					return
				case 5:
					return
				case 2:
					switch (I) {
						case "html":
							it(_, I, L, te)
							return
						case "meta":
						case "base":
						case "basefont":
						case "bgsound":
						case "link":
							Ct(I, L), N.pop()
							return
						case "title":
							FN(I, L)
							return
						case "noscript":
							if (!It) {
								Ct(I, L), (q = ov)
								return
							}
						case "noframes":
						case "style":
							SA(I, L)
							return
						case "script":
							wA(function (Be) {
								var st = ug(Be, I, L)
								return (
									(st._parser_inserted = !0),
									(st._force_async = !1),
									K && (st._already_started = !0),
									ra(),
									st
								)
							}),
								(g = Uc),
								(me = q),
								(q = ds)
							return
						case "template":
							Ct(I, L), re.insertMarker(), (Ce = !1), (q = gg), Qe.push(q)
							return
						case "head":
							return
					}
					break
				case 3:
					switch (I) {
						case "head":
							N.pop(), (q = us)
							return
						case "body":
						case "html":
						case "br":
							break
						case "template":
							if (!N.contains("template")) return
							N.generateImpliedEndTags(null, "thorough"),
								N.popTag("template"),
								re.clearToMarker(),
								Qe.pop(),
								Af()
							return
						default:
							return
					}
					break
			}
			vn(ir, "head", null), q(_, I, L, te)
		}
		function ov(_, I, L, te) {
			switch (_) {
				case 5:
					return
				case 4:
					vn(_, I)
					return
				case 1:
					var oe = I.match(jg)
					if ((oe && (vn(_, oe[0]), (I = I.substring(oe[0].length))), I.length === 0)) return
					break
				case 2:
					switch (I) {
						case "html":
							it(_, I, L, te)
							return
						case "basefont":
						case "bgsound":
						case "link":
						case "meta":
						case "noframes":
						case "style":
							vn(_, I, L)
							return
						case "head":
						case "noscript":
							return
					}
					break
				case 3:
					switch (I) {
						case "noscript":
							N.pop(), (q = vn)
							return
						case "br":
							break
						default:
							return
					}
					break
			}
			ov(ir, "noscript", null), q(_, I, L, te)
		}
		function us(_, I, L, te) {
			switch (_) {
				case 1:
					var oe = I.match(jg)
					if ((oe && (Ua(oe[0]), (I = I.substring(oe[0].length))), I.length === 0)) return
					break
				case 4:
					La(I)
					return
				case 5:
					return
				case 2:
					switch (I) {
						case "html":
							it(_, I, L, te)
							return
						case "body":
							Ct(I, L), (Ce = !1), (q = it)
							return
						case "frameset":
							Ct(I, L), (q = av)
							return
						case "base":
						case "basefont":
						case "bgsound":
						case "link":
						case "meta":
						case "noframes":
						case "script":
						case "style":
						case "template":
						case "title":
							N.push(se), vn(Ps, I, L), N.removeElement(se)
							return
						case "head":
							return
					}
					break
				case 3:
					switch (I) {
						case "template":
							return vn(_, I, L, te)
						case "body":
						case "html":
						case "br":
							break
						default:
							return
					}
					break
			}
			us(Ps, "body", null), (Ce = !0), q(_, I, L, te)
		}
		function it(_, I, L, te) {
			var oe, Be, st, qt
			switch (_) {
				case 1:
					if (Tr && ((I = I.replace(FS, "")), I.length === 0)) return
					Ce && MS.test(I) && (Ce = !1), Fi(), Ua(I)
					return
				case 5:
					return
				case 4:
					La(I)
					return
				case -1:
					if (Qe.length) return gg(_)
					Zu()
					return
				case 2:
					switch (I) {
						case "html":
							if (N.contains("template")) return
							bj(L, N.elements[0])
							return
						case "base":
						case "basefont":
						case "bgsound":
						case "link":
						case "meta":
						case "noframes":
						case "script":
						case "style":
						case "template":
						case "title":
							vn(Ps, I, L)
							return
						case "body":
							if (
								((oe = N.elements[1]),
								!oe || !(oe instanceof Jr.HTMLBodyElement) || N.contains("template"))
							)
								return
							;(Ce = !1), bj(L, oe)
							return
						case "frameset":
							if (!Ce || ((oe = N.elements[1]), !oe || !(oe instanceof Jr.HTMLBodyElement))) return
							for (
								oe.parentNode && oe.parentNode.removeChild(oe);
								!(N.top instanceof Jr.HTMLHtmlElement);

							)
								N.pop()
							Ct(I, L), (q = av)
							return
						case "address":
						case "article":
						case "aside":
						case "blockquote":
						case "center":
						case "details":
						case "dialog":
						case "dir":
						case "div":
						case "dl":
						case "fieldset":
						case "figcaption":
						case "figure":
						case "footer":
						case "header":
						case "hgroup":
						case "main":
						case "nav":
						case "ol":
						case "p":
						case "section":
						case "summary":
						case "ul":
							N.inButtonScope("p") && it(ir, "p"), Ct(I, L)
							return
						case "menu":
							N.inButtonScope("p") && it(ir, "p"), zr(N.top, "menuitem") && N.pop(), Ct(I, L)
							return
						case "h1":
						case "h2":
						case "h3":
						case "h4":
						case "h5":
						case "h6":
							N.inButtonScope("p") && it(ir, "p"),
								N.top instanceof Jr.HTMLHeadingElement && N.pop(),
								Ct(I, L)
							return
						case "pre":
						case "listing":
							N.inButtonScope("p") && it(ir, "p"), Ct(I, L), (tr = !0), (Ce = !1)
							return
						case "form":
							if (Ze && !N.contains("template")) return
							N.inButtonScope("p") && it(ir, "p"), (qt = Ct(I, L)), N.contains("template") || (Ze = qt)
							return
						case "li":
							for (Ce = !1, Be = N.elements.length - 1; Be >= 0; Be--) {
								if (((st = N.elements[Be]), st instanceof Jr.HTMLLIElement)) {
									it(ir, "li")
									break
								}
								if (zr(st, Zg) && !zr(st, sU)) break
							}
							N.inButtonScope("p") && it(ir, "p"), Ct(I, L)
							return
						case "dd":
						case "dt":
							for (Ce = !1, Be = N.elements.length - 1; Be >= 0; Be--) {
								if (((st = N.elements[Be]), zr(st, _j))) {
									it(ir, st.localName)
									break
								}
								if (zr(st, Zg) && !zr(st, sU)) break
							}
							N.inButtonScope("p") && it(ir, "p"), Ct(I, L)
							return
						case "plaintext":
							N.inButtonScope("p") && it(ir, "p"), Ct(I, L), (g = KC)
							return
						case "button":
							N.inScope("button") ? (it(ir, "button"), q(_, I, L, te)) : (Fi(), Ct(I, L), (Ce = !1))
							return
						case "a":
							var ln = re.findElementByTag("a")
							ln && (it(ir, I), re.remove(ln), N.removeElement(ln))
						case "b":
						case "big":
						case "code":
						case "em":
						case "font":
						case "i":
						case "s":
						case "small":
						case "strike":
						case "strong":
						case "tt":
						case "u":
							Fi(), re.push(Ct(I, L), L)
							return
						case "nobr":
							Fi(), N.inScope(I) && (it(ir, I), Fi()), re.push(Ct(I, L), L)
							return
						case "applet":
						case "marquee":
						case "object":
							Fi(), Ct(I, L), re.insertMarker(), (Ce = !1)
							return
						case "table":
							!Ve._quirks && N.inButtonScope("p") && it(ir, "p"), Ct(I, L), (Ce = !1), (q = xo)
							return
						case "area":
						case "br":
						case "embed":
						case "img":
						case "keygen":
						case "wbr":
							Fi(), Ct(I, L), N.pop(), (Ce = !1)
							return
						case "input":
							Fi(), (qt = Ct(I, L)), N.pop()
							var Qi = qt.getAttribute("type")
							;(!Qi || Qi.toLowerCase() !== "hidden") && (Ce = !1)
							return
						case "param":
						case "source":
						case "track":
							Ct(I, L), N.pop()
							return
						case "hr":
							N.inButtonScope("p") && it(ir, "p"),
								zr(N.top, "menuitem") && N.pop(),
								Ct(I, L),
								N.pop(),
								(Ce = !1)
							return
						case "image":
							it(Ps, "img", L, te)
							return
						case "textarea":
							Ct(I, L), (tr = !0), (Ce = !1), (g = Lc), (me = q), (q = ds)
							return
						case "xmp":
							N.inButtonScope("p") && it(ir, "p"), Fi(), (Ce = !1), SA(I, L)
							return
						case "iframe":
							;(Ce = !1), SA(I, L)
							return
						case "noembed":
							SA(I, L)
							return
						case "select":
							Fi(),
								Ct(I, L),
								(Ce = !1),
								q === xo || q === qa || q === ql || q === Yr || q === js ? (q = NA) : (q = sa)
							return
						case "optgroup":
						case "option":
							N.top instanceof Jr.HTMLOptionElement && it(ir, "option"), Fi(), Ct(I, L)
							return
						case "menuitem":
							zr(N.top, "menuitem") && N.pop(), Fi(), Ct(I, L)
							return
						case "rb":
						case "rtc":
							N.inScope("ruby") && N.generateImpliedEndTags(), Ct(I, L)
							return
						case "rp":
						case "rt":
							N.inScope("ruby") && N.generateImpliedEndTags("rtc"), Ct(I, L)
							return
						case "math":
							Fi(), Ej(L), iU(L), GC(I, L, ot.MATHML), te && N.pop()
							return
						case "svg":
							Fi(), vj(L), iU(L), GC(I, L, ot.SVG), te && N.pop()
							return
						case "caption":
						case "col":
						case "colgroup":
						case "frame":
						case "head":
						case "tbody":
						case "td":
						case "tfoot":
						case "th":
						case "thead":
						case "tr":
							return
					}
					Fi(), Ct(I, L)
					return
				case 3:
					switch (I) {
						case "template":
							vn(ir, I, L)
							return
						case "body":
							if (!N.inScope("body")) return
							q = Ew
							return
						case "html":
							if (!N.inScope("body")) return
							;(q = Ew), q(_, I, L)
							return
						case "address":
						case "article":
						case "aside":
						case "blockquote":
						case "button":
						case "center":
						case "details":
						case "dialog":
						case "dir":
						case "div":
						case "dl":
						case "fieldset":
						case "figcaption":
						case "figure":
						case "footer":
						case "header":
						case "hgroup":
						case "listing":
						case "main":
						case "menu":
						case "nav":
						case "ol":
						case "pre":
						case "section":
						case "summary":
						case "ul":
							if (!N.inScope(I)) return
							N.generateImpliedEndTags(), N.popTag(I)
							return
						case "form":
							if (N.contains("template")) {
								if (!N.inScope("form")) return
								N.generateImpliedEndTags(), N.popTag("form")
							} else {
								var Zs = Ze
								if (((Ze = null), !Zs || !N.elementInScope(Zs))) return
								N.generateImpliedEndTags(), N.removeElement(Zs)
							}
							return
						case "p":
							N.inButtonScope(I)
								? (N.generateImpliedEndTags(I), N.popTag(I))
								: (it(Ps, I, null), q(_, I, L, te))
							return
						case "li":
							if (!N.inListItemScope(I)) return
							N.generateImpliedEndTags(I), N.popTag(I)
							return
						case "dd":
						case "dt":
							if (!N.inScope(I)) return
							N.generateImpliedEndTags(I), N.popTag(I)
							return
						case "h1":
						case "h2":
						case "h3":
						case "h4":
						case "h5":
						case "h6":
							if (!N.elementTypeInScope(Jr.HTMLHeadingElement)) return
							N.generateImpliedEndTags(), N.popElementType(Jr.HTMLHeadingElement)
							return
						case "sarcasm":
							break
						case "a":
						case "b":
						case "big":
						case "code":
						case "em":
						case "font":
						case "i":
						case "nobr":
						case "s":
						case "small":
						case "strike":
						case "strong":
						case "tt":
						case "u":
							var En = YC(I)
							if (En) return
							break
						case "applet":
						case "marquee":
						case "object":
							if (!N.inScope(I)) return
							N.generateImpliedEndTags(), N.popTag(I), re.clearToMarker()
							return
						case "br":
							it(Ps, I, null)
							return
					}
					for (Be = N.elements.length - 1; Be >= 0; Be--)
						if (((st = N.elements[Be]), zr(st, I))) {
							N.generateImpliedEndTags(I), N.popElement(st)
							break
						} else if (zr(st, Zg)) return
					return
			}
		}
		function ds(_, I, L, te) {
			switch (_) {
				case 1:
					Ua(I)
					return
				case -1:
					N.top instanceof Jr.HTMLScriptElement && (N.top._already_started = !0), N.pop(), (q = me), q(_)
					return
				case 3:
					I === "script" ? QN() : (N.pop(), (q = me))
					return
				default:
					return
			}
		}
		function xo(_, I, L, te) {
			function oe(st) {
				for (var qt = 0, ln = st.length; qt < ln; qt++) if (st[qt][0] === "type") return st[qt][1].toLowerCase()
				return null
			}
			switch (_) {
				case 1:
					if (Ar) {
						it(_, I, L, te)
						return
					} else if (zr(N.top, Pm)) {
						;(jt = []), (me = q), (q = vw), q(_, I, L, te)
						return
					}
					break
				case 4:
					La(I)
					return
				case 5:
					return
				case 2:
					switch (I) {
						case "caption":
							N.clearToContext(QS), re.insertMarker(), Ct(I, L), (q = qa)
							return
						case "colgroup":
							N.clearToContext(QS), Ct(I, L), (q = rd)
							return
						case "col":
							xo(Ps, "colgroup", null), q(_, I, L, te)
							return
						case "tbody":
						case "tfoot":
						case "thead":
							N.clearToContext(QS), Ct(I, L), (q = ql)
							return
						case "td":
						case "th":
						case "tr":
							xo(Ps, "tbody", null), q(_, I, L, te)
							return
						case "table":
							if (!N.inTableScope(I)) return
							xo(ir, I), q(_, I, L, te)
							return
						case "style":
						case "script":
						case "template":
							vn(_, I, L, te)
							return
						case "input":
							var Be = oe(L)
							if (Be !== "hidden") break
							Ct(I, L), N.pop()
							return
						case "form":
							if (Ze || N.contains("template")) return
							;(Ze = Ct(I, L)), N.popElement(Ze)
							return
					}
					break
				case 3:
					switch (I) {
						case "table":
							if (!N.inTableScope(I)) return
							N.popTag(I), Af()
							return
						case "body":
						case "caption":
						case "col":
						case "colgroup":
						case "html":
						case "tbody":
						case "td":
						case "tfoot":
						case "th":
						case "thead":
						case "tr":
							return
						case "template":
							vn(_, I, L, te)
							return
					}
					break
				case -1:
					it(_, I, L, te)
					return
			}
			;(Ul = !0), it(_, I, L, te), (Ul = !1)
		}
		function vw(_, I, L, te) {
			if (_ === Nm) {
				if (Tr && ((I = I.replace(FS, "")), I.length === 0)) return
				jt.push(I)
			} else {
				var oe = jt.join("")
				;(jt.length = 0), MS.test(oe) ? ((Ul = !0), it(Nm, oe), (Ul = !1)) : Ua(oe), (q = me), q(_, I, L, te)
			}
		}
		function qa(_, I, L, te) {
			function oe() {
				return N.inTableScope("caption")
					? (N.generateImpliedEndTags(), N.popTag("caption"), re.clearToMarker(), (q = xo), !0)
					: !1
			}
			switch (_) {
				case 2:
					switch (I) {
						case "caption":
						case "col":
						case "colgroup":
						case "tbody":
						case "td":
						case "tfoot":
						case "th":
						case "thead":
						case "tr":
							oe() && q(_, I, L, te)
							return
					}
					break
				case 3:
					switch (I) {
						case "caption":
							oe()
							return
						case "table":
							oe() && q(_, I, L, te)
							return
						case "body":
						case "col":
						case "colgroup":
						case "html":
						case "tbody":
						case "td":
						case "tfoot":
						case "th":
						case "thead":
						case "tr":
							return
					}
					break
			}
			it(_, I, L, te)
		}
		function rd(_, I, L, te) {
			switch (_) {
				case 1:
					var oe = I.match(jg)
					if ((oe && (Ua(oe[0]), (I = I.substring(oe[0].length))), I.length === 0)) return
					break
				case 4:
					La(I)
					return
				case 5:
					return
				case 2:
					switch (I) {
						case "html":
							it(_, I, L, te)
							return
						case "col":
							Ct(I, L), N.pop()
							return
						case "template":
							vn(_, I, L, te)
							return
					}
					break
				case 3:
					switch (I) {
						case "colgroup":
							if (!zr(N.top, "colgroup")) return
							N.pop(), (q = xo)
							return
						case "col":
							return
						case "template":
							vn(_, I, L, te)
							return
					}
					break
				case -1:
					it(_, I, L, te)
					return
			}
			zr(N.top, "colgroup") && (rd(ir, "colgroup"), q(_, I, L, te))
		}
		function ql(_, I, L, te) {
			function oe() {
				;(!N.inTableScope("tbody") && !N.inTableScope("thead") && !N.inTableScope("tfoot")) ||
					(N.clearToContext(NS), ql(ir, N.top.localName, null), q(_, I, L, te))
			}
			switch (_) {
				case 2:
					switch (I) {
						case "tr":
							N.clearToContext(NS), Ct(I, L), (q = Yr)
							return
						case "th":
						case "td":
							ql(Ps, "tr", null), q(_, I, L, te)
							return
						case "caption":
						case "col":
						case "colgroup":
						case "tbody":
						case "tfoot":
						case "thead":
							oe()
							return
					}
					break
				case 3:
					switch (I) {
						case "table":
							oe()
							return
						case "tbody":
						case "tfoot":
						case "thead":
							N.inTableScope(I) && (N.clearToContext(NS), N.pop(), (q = xo))
							return
						case "body":
						case "caption":
						case "col":
						case "colgroup":
						case "html":
						case "td":
						case "th":
						case "tr":
							return
					}
					break
			}
			xo(_, I, L, te)
		}
		function Yr(_, I, L, te) {
			function oe() {
				return N.inTableScope("tr") ? (N.clearToContext(oU), N.pop(), (q = ql), !0) : !1
			}
			switch (_) {
				case 2:
					switch (I) {
						case "th":
						case "td":
							N.clearToContext(oU), Ct(I, L), (q = js), re.insertMarker()
							return
						case "caption":
						case "col":
						case "colgroup":
						case "tbody":
						case "tfoot":
						case "thead":
						case "tr":
							oe() && q(_, I, L, te)
							return
					}
					break
				case 3:
					switch (I) {
						case "tr":
							oe()
							return
						case "table":
							oe() && q(_, I, L, te)
							return
						case "tbody":
						case "tfoot":
						case "thead":
							N.inTableScope(I) && oe() && q(_, I, L, te)
							return
						case "body":
						case "caption":
						case "col":
						case "colgroup":
						case "html":
						case "td":
						case "th":
							return
					}
					break
			}
			xo(_, I, L, te)
		}
		function js(_, I, L, te) {
			switch (_) {
				case 2:
					switch (I) {
						case "caption":
						case "col":
						case "colgroup":
						case "tbody":
						case "td":
						case "tfoot":
						case "th":
						case "thead":
						case "tr":
							N.inTableScope("td")
								? (js(ir, "td"), q(_, I, L, te))
								: N.inTableScope("th") && (js(ir, "th"), q(_, I, L, te))
							return
					}
					break
				case 3:
					switch (I) {
						case "td":
						case "th":
							if (!N.inTableScope(I)) return
							N.generateImpliedEndTags(), N.popTag(I), re.clearToMarker(), (q = Yr)
							return
						case "body":
						case "caption":
						case "col":
						case "colgroup":
						case "html":
							return
						case "table":
						case "tbody":
						case "tfoot":
						case "thead":
						case "tr":
							if (!N.inTableScope(I)) return
							js(ir, N.inTableScope("td") ? "td" : "th"), q(_, I, L, te)
							return
					}
					break
			}
			it(_, I, L, te)
		}
		function sa(_, I, L, te) {
			switch (_) {
				case 1:
					if (Tr && ((I = I.replace(FS, "")), I.length === 0)) return
					Ua(I)
					return
				case 4:
					La(I)
					return
				case 5:
					return
				case -1:
					it(_, I, L, te)
					return
				case 2:
					switch (I) {
						case "html":
							it(_, I, L, te)
							return
						case "option":
							N.top instanceof Jr.HTMLOptionElement && sa(ir, I), Ct(I, L)
							return
						case "optgroup":
							N.top instanceof Jr.HTMLOptionElement && sa(ir, "option"),
								N.top instanceof Jr.HTMLOptGroupElement && sa(ir, I),
								Ct(I, L)
							return
						case "select":
							sa(ir, I)
							return
						case "input":
						case "keygen":
						case "textarea":
							if (!N.inSelectScope("select")) return
							sa(ir, "select"), q(_, I, L, te)
							return
						case "script":
						case "template":
							vn(_, I, L, te)
							return
					}
					break
				case 3:
					switch (I) {
						case "optgroup":
							N.top instanceof Jr.HTMLOptionElement &&
								N.elements[N.elements.length - 2] instanceof Jr.HTMLOptGroupElement &&
								sa(ir, "option"),
								N.top instanceof Jr.HTMLOptGroupElement && N.pop()
							return
						case "option":
							N.top instanceof Jr.HTMLOptionElement && N.pop()
							return
						case "select":
							if (!N.inSelectScope(I)) return
							N.popTag(I), Af()
							return
						case "template":
							vn(_, I, L, te)
							return
					}
					break
			}
		}
		function NA(_, I, L, te) {
			switch (I) {
				case "caption":
				case "table":
				case "tbody":
				case "tfoot":
				case "thead":
				case "tr":
				case "td":
				case "th":
					switch (_) {
						case 2:
							NA(ir, "select"), q(_, I, L, te)
							return
						case 3:
							N.inTableScope(I) && (NA(ir, "select"), q(_, I, L, te))
							return
					}
			}
			sa(_, I, L, te)
		}
		function gg(_, I, L, te) {
			function oe(Be) {
				;(q = Be), (Qe[Qe.length - 1] = q), q(_, I, L, te)
			}
			switch (_) {
				case 1:
				case 4:
				case 5:
					it(_, I, L, te)
					return
				case -1:
					N.contains("template")
						? (N.popTag("template"), re.clearToMarker(), Qe.pop(), Af(), q(_, I, L, te))
						: Zu()
					return
				case 2:
					switch (I) {
						case "base":
						case "basefont":
						case "bgsound":
						case "link":
						case "meta":
						case "noframes":
						case "script":
						case "style":
						case "template":
						case "title":
							vn(_, I, L, te)
							return
						case "caption":
						case "colgroup":
						case "tbody":
						case "tfoot":
						case "thead":
							oe(xo)
							return
						case "col":
							oe(rd)
							return
						case "tr":
							oe(ql)
							return
						case "td":
						case "th":
							oe(Yr)
							return
					}
					oe(it)
					return
				case 3:
					switch (I) {
						case "template":
							vn(_, I, L, te)
							return
						default:
							return
					}
			}
		}
		function Ew(_, I, L, te) {
			switch (_) {
				case 1:
					if (MS.test(I)) break
					it(_, I)
					return
				case 4:
					N.elements[0]._appendChild(Ve.createComment(I))
					return
				case 5:
					return
				case -1:
					Zu()
					return
				case 2:
					if (I === "html") {
						it(_, I, L, te)
						return
					}
					break
				case 3:
					if (I === "html") {
						if (K) return
						q = bw
						return
					}
					break
			}
			;(q = it), q(_, I, L, te)
		}
		function av(_, I, L, te) {
			switch (_) {
				case 1:
					;(I = I.replace(nU, "")), I.length > 0 && Ua(I)
					return
				case 4:
					La(I)
					return
				case 5:
					return
				case -1:
					Zu()
					return
				case 2:
					switch (I) {
						case "html":
							it(_, I, L, te)
							return
						case "frameset":
							Ct(I, L)
							return
						case "frame":
							Ct(I, L), N.pop()
							return
						case "noframes":
							vn(_, I, L, te)
							return
					}
					break
				case 3:
					if (I === "frameset") {
						if (K && N.top instanceof Jr.HTMLHtmlElement) return
						N.pop(), !K && !(N.top instanceof Jr.HTMLFrameSetElement) && (q = e2)
						return
					}
					break
			}
		}
		function e2(_, I, L, te) {
			switch (_) {
				case 1:
					;(I = I.replace(nU, "")), I.length > 0 && Ua(I)
					return
				case 4:
					La(I)
					return
				case 5:
					return
				case -1:
					Zu()
					return
				case 2:
					switch (I) {
						case "html":
							it(_, I, L, te)
							return
						case "noframes":
							vn(_, I, L, te)
							return
					}
					break
				case 3:
					if (I === "html") {
						q = PA
						return
					}
					break
			}
		}
		function bw(_, I, L, te) {
			switch (_) {
				case 1:
					if (MS.test(I)) break
					it(_, I, L, te)
					return
				case 4:
					Ve._appendChild(Ve.createComment(I))
					return
				case 5:
					it(_, I, L, te)
					return
				case -1:
					Zu()
					return
				case 2:
					if (I === "html") {
						it(_, I, L, te)
						return
					}
					break
			}
			;(q = it), q(_, I, L, te)
		}
		function PA(_, I, L, te) {
			switch (_) {
				case 1:
					;(I = I.replace(nU, "")), I.length > 0 && it(_, I, L, te)
					return
				case 4:
					Ve._appendChild(Ve.createComment(I))
					return
				case 5:
					it(_, I, L, te)
					return
				case -1:
					Zu()
					return
				case 2:
					switch (I) {
						case "html":
							it(_, I, L, te)
							return
						case "noframes":
							vn(_, I, L, te)
							return
					}
					break
			}
		}
		function nd(_, I, L, te) {
			function oe(ln) {
				for (var Qi = 0, Zs = ln.length; Qi < Zs; Qi++)
					switch (ln[Qi][0]) {
						case "color":
						case "face":
						case "size":
							return !0
					}
				return !1
			}
			var Be
			switch (_) {
				case 1:
					Ce && TLe.test(I) && (Ce = !1), Tr && (I = I.replace(FS, "\uFFFD")), Ua(I)
					return
				case 4:
					La(I)
					return
				case 5:
					return
				case 2:
					switch (I) {
						case "font":
							if (!oe(L)) break
						case "b":
						case "big":
						case "blockquote":
						case "body":
						case "br":
						case "center":
						case "code":
						case "dd":
						case "div":
						case "dl":
						case "dt":
						case "em":
						case "embed":
						case "h1":
						case "h2":
						case "h3":
						case "h4":
						case "h5":
						case "h6":
						case "head":
						case "hr":
						case "i":
						case "img":
						case "li":
						case "listing":
						case "menu":
						case "meta":
						case "nobr":
						case "ol":
						case "p":
						case "pre":
						case "ruby":
						case "s":
						case "small":
						case "span":
						case "strong":
						case "strike":
						case "sub":
						case "sup":
						case "table":
						case "tt":
						case "u":
						case "ul":
						case "var":
							if (K) break
							do N.pop(), (Be = N.top)
							while (Be.namespaceURI !== ot.HTML && !yj(Be) && !Cj(Be))
							Cn(_, I, L, te)
							return
					}
					;(Be = N.elements.length === 1 && K ? t : N.top),
						Be.namespaceURI === ot.MATHML ? Ej(L) : Be.namespaceURI === ot.SVG && ((I = kLe(I)), vj(L)),
						iU(L),
						GC(I, L, Be.namespaceURI),
						te && (I === "script" && (Be.namespaceURI, ot.SVG), N.pop())
					return
				case 3:
					if (((Be = N.top), I === "script" && Be.namespaceURI === ot.SVG && Be.localName === "script"))
						N.pop()
					else
						for (var st = N.elements.length - 1, qt = N.elements[st]; ; ) {
							if (qt.localName.toLowerCase() === I) {
								N.popElement(qt)
								break
							}
							if (((qt = N.elements[--st]), qt.namespaceURI === ot.HTML)) {
								q(_, I, L, te)
								break
							}
						}
					return
			}
		}
		return (
			(Nr.testTokenizer = function (_, I, L, te) {
				var oe = []
				switch (I) {
					case "PCDATA state":
						g = Jt
						break
					case "RCDATA state":
						g = Lc
						break
					case "RAWTEXT state":
						g = dg
						break
					case "PLAINTEXT state":
						g = KC
						break
				}
				if (
					(L && (v = L),
					(Cn = function (st, qt, ln, Qi) {
						switch ((ra(), st)) {
							case 1:
								oe.length > 0 && oe[oe.length - 1][0] === "Character"
									? (oe[oe.length - 1][1] += qt)
									: oe.push(["Character", qt])
								break
							case 4:
								oe.push(["Comment", qt])
								break
							case 5:
								oe.push(["DOCTYPE", qt, ln === void 0 ? null : ln, Qi === void 0 ? null : Qi, !Et])
								break
							case 2:
								for (var Zs = Object.create(null), En = 0; En < ln.length; En++) {
									var Vl = ln[En]
									Vl.length === 1 ? (Zs[Vl[0]] = "") : (Zs[Vl[0]] = Vl[1])
								}
								var _o = ["StartTag", qt, Zs]
								Qi && _o.push(!0), oe.push(_o)
								break
							case 3:
								oe.push(["EndTag", qt])
								break
							case -1:
								break
						}
					}),
					!te)
				)
					this.parse(_, !0)
				else {
					for (var Be = 0; Be < _.length; Be++) this.parse(_[Be])
					this.parse("", !0)
				}
				return oe
			}),
			Nr
		)
	}
})
var cE = x((_xt, Qj) => {
	"use strict"
	Qj.exports = Fj
	var kj = DS(),
		Mj = RS(),
		MLe = LS(),
		US = ei(),
		FLe = fS()
	function Fj(e) {
		this.contextObject = e
	}
	var QLe = {
		xml: { "": !0, "1.0": !0, "2.0": !0 },
		core: { "": !0, "2.0": !0 },
		html: { "": !0, "1.0": !0, "2.0": !0 },
		xhtml: { "": !0, "1.0": !0, "2.0": !0 },
	}
	Fj.prototype = {
		hasFeature: function (t, r) {
			var n = QLe[(t || "").toLowerCase()]
			return (n && n[r || ""]) || !1
		},
		createDocumentType: function (t, r, n) {
			return FLe.isValidQName(t) || US.InvalidCharacterError(), new Mj(this.contextObject, t, r, n)
		},
		createDocument: function (t, r, n) {
			var i = new kj(!1, null),
				s
			return (
				r ? (s = i.createElementNS(t, r)) : (s = null),
				n && i.appendChild(n),
				s && i.appendChild(s),
				t === US.NAMESPACE.HTML
					? (i._contentType = "application/xhtml+xml")
					: t === US.NAMESPACE.SVG
						? (i._contentType = "image/svg+xml")
						: (i._contentType = "application/xml"),
				i
			)
		},
		createHTMLDocument: function (t) {
			var r = new kj(!0, null)
			r.appendChild(new Mj(r, "html"))
			var n = r.createElement("html")
			r.appendChild(n)
			var i = r.createElement("head")
			if ((n.appendChild(i), t !== void 0)) {
				var s = r.createElement("title")
				i.appendChild(s), s.appendChild(r.createTextNode(t))
			}
			return n.appendChild(r.createElement("body")), (r.modclock = 1), r
		},
		mozSetOutputMutationHandler: function (e, t) {
			e.mutationHandler = t
		},
		mozGetInputMutationHandler: function (e) {
			US.nyi()
		},
		mozHTMLParser: MLe,
	}
})
var Pj = x((wxt, Nj) => {
	"use strict"
	var NLe = bS(),
		PLe = KL()
	Nj.exports = lU
	function lU(e, t) {
		;(this._window = e), (this._href = t)
	}
	lU.prototype = Object.create(PLe.prototype, {
		constructor: { value: lU },
		href: {
			get: function () {
				return this._href
			},
			set: function (e) {
				this.assign(e)
			},
		},
		assign: {
			value: function (e) {
				var t = new NLe(this._href),
					r = t.resolve(e)
				this._href = r
			},
		},
		replace: {
			value: function (e) {
				this.assign(e)
			},
		},
		reload: {
			value: function () {
				this.assign(this.href)
			},
		},
		toString: {
			value: function () {
				return this.href
			},
		},
	})
})
var Uj = x((Ixt, Lj) => {
	"use strict"
	var LLe = Object.create(null, {
		appCodeName: { value: "Mozilla" },
		appName: { value: "Netscape" },
		appVersion: { value: "4.0" },
		platform: { value: "" },
		product: { value: "Gecko" },
		productSub: { value: "20100101" },
		userAgent: { value: "" },
		vendor: { value: "" },
		vendorSub: { value: "" },
		taintEnabled: {
			value: function () {
				return !1
			},
		},
	})
	Lj.exports = LLe
})
var qj = x((Sxt, Oj) => {
	"use strict"
	var ULe = { setTimeout, clearTimeout, setInterval, clearInterval }
	Oj.exports = ULe
})
var uU = x((uE, Vj) => {
	"use strict"
	var cU = ei()
	uE = Vj.exports = {
		CSSStyleDeclaration: xS(),
		CharacterData: eE(),
		Comment: FL(),
		DOMException: aS(),
		DOMImplementation: cE(),
		DOMTokenList: mL(),
		Document: DS(),
		DocumentFragment: NL(),
		DocumentType: RS(),
		Element: Dm(),
		HTMLParser: LS(),
		NamedNodeMap: xL(),
		Node: ps(),
		NodeList: Kg(),
		NodeFilter: iE(),
		ProcessingInstruction: LL(),
		Text: kL(),
		Window: dU(),
	}
	cU.merge(uE, YL())
	cU.merge(uE, IS().elements)
	cU.merge(uE, XL().elements)
})
var dU = x((Bxt, Hj) => {
	"use strict"
	var OLe = cE(),
		qLe = XP(),
		VLe = Pj(),
		dE = ei()
	Hj.exports = OS
	function OS(e) {
		;(this.document = e || new OLe(null).createHTMLDocument("")),
			(this.document._scripting_enabled = !0),
			(this.document.defaultView = this),
			(this.location = new VLe(this, this.document._address || "about:blank"))
	}
	OS.prototype = Object.create(qLe.prototype, {
		console: { value: console },
		history: { value: { back: dE.nyi, forward: dE.nyi, go: dE.nyi } },
		navigator: { value: Uj() },
		window: {
			get: function () {
				return this
			},
		},
		self: {
			get: function () {
				return this
			},
		},
		frames: {
			get: function () {
				return this
			},
		},
		parent: {
			get: function () {
				return this
			},
		},
		top: {
			get: function () {
				return this
			},
		},
		length: { value: 0 },
		frameElement: { value: null },
		opener: { value: null },
		onload: {
			get: function () {
				return this._getEventHandler("load")
			},
			set: function (e) {
				this._setEventHandler("load", e)
			},
		},
		getComputedStyle: {
			value: function (t) {
				return t.style
			},
		},
	})
	dE.expose(qj(), OS)
	dE.expose(uU(), OS)
})
var Yj = x((Xg) => {
	"use strict"
	var Wj = cE(),
		Gj = LS(),
		Dxt = dU(),
		$j = uU()
	Xg.createDOMImplementation = function () {
		return new Wj(null)
	}
	Xg.createDocument = function (e, t) {
		if (e || t) {
			var r = new Gj()
			return r.parse(e || "", !0), r.document()
		}
		return new Wj(null).createHTMLDocument("")
	}
	Xg.createIncrementalHTMLParser = function () {
		var e = new Gj()
		return {
			write: function (t) {
				t.length > 0 &&
					e.parse(t, !1, function () {
						return !0
					})
			},
			end: function (t) {
				e.parse(t || "", !0, function () {
					return !0
				})
			},
			process: function (t) {
				return e.parse("", !1, t)
			},
			document: function () {
				return e.document()
			},
		}
	}
	Xg.createWindow = function (e, t) {
		var r = Xg.createDocument(e)
		return t !== void 0 && (r._address = t), new $j.Window(r)
	}
	Xg.impl = $j
})
var s7 = x((Rxt, i7) => {
	"use strict"
	function HLe(e) {
		for (var t = 1; t < arguments.length; t++) {
			var r = arguments[t]
			for (var n in r) r.hasOwnProperty(n) && (e[n] = r[n])
		}
		return e
	}
	function pU(e, t) {
		return Array(t + 1).join(e)
	}
	function WLe(e) {
		return e.replace(/^\n*/, "")
	}
	function GLe(e) {
		for (
			var t = e.length;
			t > 0 &&
			e[t - 1] ===
				`
`;

		)
			t--
		return e.substring(0, t)
	}
	var $Le = [
		"ADDRESS",
		"ARTICLE",
		"ASIDE",
		"AUDIO",
		"BLOCKQUOTE",
		"BODY",
		"CANVAS",
		"CENTER",
		"DD",
		"DIR",
		"DIV",
		"DL",
		"DT",
		"FIELDSET",
		"FIGCAPTION",
		"FIGURE",
		"FOOTER",
		"FORM",
		"FRAMESET",
		"H1",
		"H2",
		"H3",
		"H4",
		"H5",
		"H6",
		"HEADER",
		"HGROUP",
		"HR",
		"HTML",
		"ISINDEX",
		"LI",
		"MAIN",
		"MENU",
		"NAV",
		"NOFRAMES",
		"NOSCRIPT",
		"OL",
		"OUTPUT",
		"P",
		"PRE",
		"SECTION",
		"TABLE",
		"TBODY",
		"TD",
		"TFOOT",
		"TH",
		"THEAD",
		"TR",
		"UL",
	]
	function AU(e) {
		return mU(e, $Le)
	}
	var zj = [
		"AREA",
		"BASE",
		"BR",
		"COL",
		"COMMAND",
		"EMBED",
		"HR",
		"IMG",
		"INPUT",
		"KEYGEN",
		"LINK",
		"META",
		"PARAM",
		"SOURCE",
		"TRACK",
		"WBR",
	]
	function jj(e) {
		return mU(e, zj)
	}
	function YLe(e) {
		return Xj(e, zj)
	}
	var Zj = ["A", "TABLE", "THEAD", "TBODY", "TFOOT", "TH", "TD", "IFRAME", "SCRIPT", "AUDIO", "VIDEO"]
	function KLe(e) {
		return mU(e, Zj)
	}
	function JLe(e) {
		return Xj(e, Zj)
	}
	function mU(e, t) {
		return t.indexOf(e.nodeName) >= 0
	}
	function Xj(e, t) {
		return (
			e.getElementsByTagName &&
			t.some(function (r) {
				return e.getElementsByTagName(r).length
			})
		)
	}
	var Us = {}
	Us.paragraph = {
		filter: "p",
		replacement: function (e) {
			return (
				`

` +
				e +
				`

`
			)
		},
	}
	Us.lineBreak = {
		filter: "br",
		replacement: function (e, t, r) {
			return (
				r.br +
				`
`
			)
		},
	}
	Us.heading = {
		filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
		replacement: function (e, t, r) {
			var n = Number(t.nodeName.charAt(1))
			if (r.headingStyle === "setext" && n < 3) {
				var i = pU(n === 1 ? "=" : "-", e.length)
				return (
					`

` +
					e +
					`
` +
					i +
					`

`
				)
			} else
				return (
					`

` +
					pU("#", n) +
					" " +
					e +
					`

`
				)
		},
	}
	Us.blockquote = {
		filter: "blockquote",
		replacement: function (e) {
			return (
				(e = e.replace(/^\n+|\n+$/g, "")),
				(e = e.replace(/^/gm, "> ")),
				`

` +
					e +
					`

`
			)
		},
	}
	Us.list = {
		filter: ["ul", "ol"],
		replacement: function (e, t) {
			var r = t.parentNode
			return r.nodeName === "LI" && r.lastElementChild === t
				? `
` + e
				: `

` +
						e +
						`

`
		},
	}
	Us.listItem = {
		filter: "li",
		replacement: function (e, t, r) {
			e = e
				.replace(/^\n+/, "")
				.replace(
					/\n+$/,
					`
`,
				)
				.replace(
					/\n/gm,
					`
    `,
				)
			var n = r.bulletListMarker + "   ",
				i = t.parentNode
			if (i.nodeName === "OL") {
				var s = i.getAttribute("start"),
					o = Array.prototype.indexOf.call(i.children, t)
				n = (s ? Number(s) + o : o + 1) + ".  "
			}
			return (
				n +
				e +
				(t.nextSibling && !/\n$/.test(e)
					? `
`
					: "")
			)
		},
	}
	Us.indentedCodeBlock = {
		filter: function (e, t) {
			return (
				t.codeBlockStyle === "indented" &&
				e.nodeName === "PRE" &&
				e.firstChild &&
				e.firstChild.nodeName === "CODE"
			)
		},
		replacement: function (e, t, r) {
			return (
				`

    ` +
				t.firstChild.textContent.replace(
					/\n/g,
					`
    `,
				) +
				`

`
			)
		},
	}
	Us.fencedCodeBlock = {
		filter: function (e, t) {
			return (
				t.codeBlockStyle === "fenced" &&
				e.nodeName === "PRE" &&
				e.firstChild &&
				e.firstChild.nodeName === "CODE"
			)
		},
		replacement: function (e, t, r) {
			for (
				var n = t.firstChild.getAttribute("class") || "",
					i = (n.match(/language-(\S+)/) || [null, ""])[1],
					s = t.firstChild.textContent,
					o = r.fence.charAt(0),
					a = 3,
					l = new RegExp("^" + o + "{3,}", "gm"),
					c;
				(c = l.exec(s));

			)
				c[0].length >= a && (a = c[0].length + 1)
			var u = pU(o, a)
			return (
				`

` +
				u +
				i +
				`
` +
				s.replace(/\n$/, "") +
				`
` +
				u +
				`

`
			)
		},
	}
	Us.horizontalRule = {
		filter: "hr",
		replacement: function (e, t, r) {
			return (
				`

` +
				r.hr +
				`

`
			)
		},
	}
	Us.inlineLink = {
		filter: function (e, t) {
			return t.linkStyle === "inlined" && e.nodeName === "A" && e.getAttribute("href")
		},
		replacement: function (e, t) {
			var r = t.getAttribute("href")
			r && (r = r.replace(/([()])/g, "\\$1"))
			var n = qS(t.getAttribute("title"))
			return n && (n = ' "' + n.replace(/"/g, '\\"') + '"'), "[" + e + "](" + r + n + ")"
		},
	}
	Us.referenceLink = {
		filter: function (e, t) {
			return t.linkStyle === "referenced" && e.nodeName === "A" && e.getAttribute("href")
		},
		replacement: function (e, t, r) {
			var n = t.getAttribute("href"),
				i = qS(t.getAttribute("title"))
			i && (i = ' "' + i + '"')
			var s, o
			switch (r.linkReferenceStyle) {
				case "collapsed":
					;(s = "[" + e + "][]"), (o = "[" + e + "]: " + n + i)
					break
				case "shortcut":
					;(s = "[" + e + "]"), (o = "[" + e + "]: " + n + i)
					break
				default:
					var a = this.references.length + 1
					;(s = "[" + e + "][" + a + "]"), (o = "[" + a + "]: " + n + i)
			}
			return this.references.push(o), s
		},
		references: [],
		append: function (e) {
			var t = ""
			return (
				this.references.length &&
					((t =
						`

` +
						this.references.join(`
`) +
						`

`),
					(this.references = [])),
				t
			)
		},
	}
	Us.emphasis = {
		filter: ["em", "i"],
		replacement: function (e, t, r) {
			return e.trim() ? r.emDelimiter + e + r.emDelimiter : ""
		},
	}
	Us.strong = {
		filter: ["strong", "b"],
		replacement: function (e, t, r) {
			return e.trim() ? r.strongDelimiter + e + r.strongDelimiter : ""
		},
	}
	Us.code = {
		filter: function (e) {
			var t = e.previousSibling || e.nextSibling,
				r = e.parentNode.nodeName === "PRE" && !t
			return e.nodeName === "CODE" && !r
		},
		replacement: function (e) {
			if (!e) return ""
			e = e.replace(/\r?\n|\r/g, " ")
			for (
				var t = /^`|^ .*?[^ ].* $|`$/.test(e) ? " " : "", r = "`", n = e.match(/`+/gm) || [];
				n.indexOf(r) !== -1;

			)
				r = r + "`"
			return r + t + e + t + r
		},
	}
	Us.image = {
		filter: "img",
		replacement: function (e, t) {
			var r = qS(t.getAttribute("alt")),
				n = t.getAttribute("src") || "",
				i = qS(t.getAttribute("title")),
				s = i ? ' "' + i + '"' : ""
			return n ? "![" + r + "](" + n + s + ")" : ""
		},
	}
	function qS(e) {
		return e
			? e.replace(
					/(\n+\s*)+/g,
					`
`,
				)
			: ""
	}
	function e7(e) {
		;(this.options = e),
			(this._keep = []),
			(this._remove = []),
			(this.blankRule = { replacement: e.blankReplacement }),
			(this.keepReplacement = e.keepReplacement),
			(this.defaultRule = { replacement: e.defaultReplacement }),
			(this.array = [])
		for (var t in e.rules) this.array.push(e.rules[t])
	}
	e7.prototype = {
		add: function (e, t) {
			this.array.unshift(t)
		},
		keep: function (e) {
			this._keep.unshift({ filter: e, replacement: this.keepReplacement })
		},
		remove: function (e) {
			this._remove.unshift({
				filter: e,
				replacement: function () {
					return ""
				},
			})
		},
		forNode: function (e) {
			if (e.isBlank) return this.blankRule
			var t
			return (t = fU(this.array, e, this.options)) ||
				(t = fU(this._keep, e, this.options)) ||
				(t = fU(this._remove, e, this.options))
				? t
				: this.defaultRule
		},
		forEach: function (e) {
			for (var t = 0; t < this.array.length; t++) e(this.array[t], t)
		},
	}
	function fU(e, t, r) {
		for (var n = 0; n < e.length; n++) {
			var i = e[n]
			if (zLe(i, t, r)) return i
		}
	}
	function zLe(e, t, r) {
		var n = e.filter
		if (typeof n == "string") {
			if (n === t.nodeName.toLowerCase()) return !0
		} else if (Array.isArray(n)) {
			if (n.indexOf(t.nodeName.toLowerCase()) > -1) return !0
		} else if (typeof n == "function") {
			if (n.call(e, t, r)) return !0
		} else throw new TypeError("`filter` needs to be a string, array, or function")
	}
	function jLe(e) {
		var t = e.element,
			r = e.isBlock,
			n = e.isVoid,
			i =
				e.isPre ||
				function (f) {
					return f.nodeName === "PRE"
				}
		if (!(!t.firstChild || i(t))) {
			for (var s = null, o = !1, a = null, l = Kj(a, t, i); l !== t; ) {
				if (l.nodeType === 3 || l.nodeType === 4) {
					var c = l.data.replace(/[ \r\n\t]+/g, " ")
					if (((!s || / $/.test(s.data)) && !o && c[0] === " " && (c = c.substr(1)), !c)) {
						l = hU(l)
						continue
					}
					;(l.data = c), (s = l)
				} else if (l.nodeType === 1)
					r(l) || l.nodeName === "BR"
						? (s && (s.data = s.data.replace(/ $/, "")), (s = null), (o = !1))
						: n(l) || i(l)
							? ((s = null), (o = !0))
							: s && (o = !1)
				else {
					l = hU(l)
					continue
				}
				var u = Kj(a, l, i)
				;(a = l), (l = u)
			}
			s && ((s.data = s.data.replace(/ $/, "")), s.data || hU(s))
		}
	}
	function hU(e) {
		var t = e.nextSibling || e.parentNode
		return e.parentNode.removeChild(e), t
	}
	function Kj(e, t, r) {
		return (e && e.parentNode === t) || r(t)
			? t.nextSibling || t.parentNode
			: t.firstChild || t.nextSibling || t.parentNode
	}
	var t7 = typeof window < "u" ? window : {}
	function ZLe() {
		var e = t7.DOMParser,
			t = !1
		try {
			new e().parseFromString("", "text/html") && (t = !0)
		} catch {}
		return t
	}
	function XLe() {
		var e = function () {}
		{
			var t = Yj()
			e.prototype.parseFromString = function (r) {
				return t.createDocument(r)
			}
		}
		return e
	}
	var eUe = ZLe() ? t7.DOMParser : XLe()
	function tUe(e, t) {
		var r
		if (typeof e == "string") {
			var n = rUe().parseFromString('<x-turndown id="turndown-root">' + e + "</x-turndown>", "text/html")
			r = n.getElementById("turndown-root")
		} else r = e.cloneNode(!0)
		return (
			jLe({
				element: r,
				isBlock: AU,
				isVoid: jj,
				isPre: t.preformattedCode ? nUe : null,
			}),
			r
		)
	}
	var gU
	function rUe() {
		return (gU = gU || new eUe()), gU
	}
	function nUe(e) {
		return e.nodeName === "PRE" || e.nodeName === "CODE"
	}
	function iUe(e, t) {
		return (
			(e.isBlock = AU(e)),
			(e.isCode = e.nodeName === "CODE" || e.parentNode.isCode),
			(e.isBlank = sUe(e)),
			(e.flankingWhitespace = oUe(e, t)),
			e
		)
	}
	function sUe(e) {
		return !jj(e) && !KLe(e) && /^\s*$/i.test(e.textContent) && !YLe(e) && !JLe(e)
	}
	function oUe(e, t) {
		if (e.isBlock || (t.preformattedCode && e.isCode)) return { leading: "", trailing: "" }
		var r = aUe(e.textContent)
		return (
			r.leadingAscii && Jj("left", e, t) && (r.leading = r.leadingNonAscii),
			r.trailingAscii && Jj("right", e, t) && (r.trailing = r.trailingNonAscii),
			{ leading: r.leading, trailing: r.trailing }
		)
	}
	function aUe(e) {
		var t = e.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/)
		return {
			leading: t[1],
			leadingAscii: t[2],
			leadingNonAscii: t[3],
			trailing: t[4],
			trailingNonAscii: t[5],
			trailingAscii: t[6],
		}
	}
	function Jj(e, t, r) {
		var n, i, s
		return (
			e === "left" ? ((n = t.previousSibling), (i = / $/)) : ((n = t.nextSibling), (i = /^ /)),
			n &&
				(n.nodeType === 3
					? (s = i.test(n.nodeValue))
					: r.preformattedCode && n.nodeName === "CODE"
						? (s = !1)
						: n.nodeType === 1 && !AU(n) && (s = i.test(n.textContent))),
			s
		)
	}
	var lUe = Array.prototype.reduce,
		cUe = [
			[/\\/g, "\\\\"],
			[/\*/g, "\\*"],
			[/^-/g, "\\-"],
			[/^\+ /g, "\\+ "],
			[/^(=+)/g, "\\$1"],
			[/^(#{1,6}) /g, "\\$1 "],
			[/`/g, "\\`"],
			[/^~~~/g, "\\~~~"],
			[/\[/g, "\\["],
			[/\]/g, "\\]"],
			[/^>/g, "\\>"],
			[/_/g, "\\_"],
			[/^(\d+)\. /g, "$1\\. "],
		]
	function VS(e) {
		if (!(this instanceof VS)) return new VS(e)
		var t = {
			rules: Us,
			headingStyle: "setext",
			hr: "* * *",
			bulletListMarker: "*",
			codeBlockStyle: "indented",
			fence: "```",
			emDelimiter: "_",
			strongDelimiter: "**",
			linkStyle: "inlined",
			linkReferenceStyle: "full",
			br: "  ",
			preformattedCode: !1,
			blankReplacement: function (r, n) {
				return n.isBlock
					? `

`
					: ""
			},
			keepReplacement: function (r, n) {
				return n.isBlock
					? `

` +
							n.outerHTML +
							`

`
					: n.outerHTML
			},
			defaultReplacement: function (r, n) {
				return n.isBlock
					? `

` +
							r +
							`

`
					: r
			},
		}
		;(this.options = HLe({}, t, e)), (this.rules = new e7(this.options))
	}
	VS.prototype = {
		turndown: function (e) {
			if (!fUe(e)) throw new TypeError(e + " is not a string, or an element/document/fragment node.")
			if (e === "") return ""
			var t = r7.call(this, new tUe(e, this.options))
			return uUe.call(this, t)
		},
		use: function (e) {
			if (Array.isArray(e)) for (var t = 0; t < e.length; t++) this.use(e[t])
			else if (typeof e == "function") e(this)
			else throw new TypeError("plugin must be a Function or an Array of Functions")
			return this
		},
		addRule: function (e, t) {
			return this.rules.add(e, t), this
		},
		keep: function (e) {
			return this.rules.keep(e), this
		},
		remove: function (e) {
			return this.rules.remove(e), this
		},
		escape: function (e) {
			return cUe.reduce(function (t, r) {
				return t.replace(r[0], r[1])
			}, e)
		},
	}
	function r7(e) {
		var t = this
		return lUe.call(
			e.childNodes,
			function (r, n) {
				n = new iUe(n, t.options)
				var i = ""
				return (
					n.nodeType === 3
						? (i = n.isCode ? n.nodeValue : t.escape(n.nodeValue))
						: n.nodeType === 1 && (i = dUe.call(t, n)),
					n7(r, i)
				)
			},
			"",
		)
	}
	function uUe(e) {
		var t = this
		return (
			this.rules.forEach(function (r) {
				typeof r.append == "function" && (e = n7(e, r.append(t.options)))
			}),
			e.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "")
		)
	}
	function dUe(e) {
		var t = this.rules.forNode(e),
			r = r7.call(this, e),
			n = e.flankingWhitespace
		return (n.leading || n.trailing) && (r = r.trim()), n.leading + t.replacement(r, e, this.options) + n.trailing
	}
	function n7(e, t) {
		var r = GLe(e),
			n = WLe(t),
			i = Math.max(e.length - r.length, t.length - n.length),
			s = `

`.substring(0, i)
		return r + s + n
	}
	function fUe(e) {
		return (
			e != null &&
			(typeof e == "string" || (e.nodeType && (e.nodeType === 1 || e.nodeType === 9 || e.nodeType === 11)))
		)
	}
	i7.exports = VS
})
var c7 = x((p_t, l7) => {
	"use strict"
	function hUe() {
		;(this.__data__ = []), (this.size = 0)
	}
	l7.exports = hUe
})
var zS = x((A_t, u7) => {
	"use strict"
	function gUe(e, t) {
		return e === t || (e !== e && t !== t)
	}
	u7.exports = gUe
})
var gE = x((m_t, d7) => {
	"use strict"
	var pUe = zS()
	function AUe(e, t) {
		for (var r = e.length; r--; ) if (pUe(e[r][0], t)) return r
		return -1
	}
	d7.exports = AUe
})
var h7 = x((y_t, f7) => {
	"use strict"
	var mUe = gE(),
		yUe = Array.prototype,
		CUe = yUe.splice
	function vUe(e) {
		var t = this.__data__,
			r = mUe(t, e)
		if (r < 0) return !1
		var n = t.length - 1
		return r == n ? t.pop() : CUe.call(t, r, 1), --this.size, !0
	}
	f7.exports = vUe
})
var p7 = x((C_t, g7) => {
	"use strict"
	var EUe = gE()
	function bUe(e) {
		var t = this.__data__,
			r = EUe(t, e)
		return r < 0 ? void 0 : t[r][1]
	}
	g7.exports = bUe
})
var m7 = x((v_t, A7) => {
	"use strict"
	var xUe = gE()
	function _Ue(e) {
		return xUe(this.__data__, e) > -1
	}
	A7.exports = _Ue
})
var C7 = x((E_t, y7) => {
	"use strict"
	var wUe = gE()
	function IUe(e, t) {
		var r = this.__data__,
			n = wUe(r, e)
		return n < 0 ? (++this.size, r.push([e, t])) : (r[n][1] = t), this
	}
	y7.exports = IUe
})
var pE = x((b_t, v7) => {
	"use strict"
	var SUe = c7(),
		BUe = h7(),
		DUe = p7(),
		TUe = m7(),
		RUe = C7()
	function Lm(e) {
		var t = -1,
			r = e == null ? 0 : e.length
		for (this.clear(); ++t < r; ) {
			var n = e[t]
			this.set(n[0], n[1])
		}
	}
	Lm.prototype.clear = SUe
	Lm.prototype.delete = BUe
	Lm.prototype.get = DUe
	Lm.prototype.has = TUe
	Lm.prototype.set = RUe
	v7.exports = Lm
})
var b7 = x((x_t, E7) => {
	"use strict"
	var kUe = pE()
	function MUe() {
		;(this.__data__ = new kUe()), (this.size = 0)
	}
	E7.exports = MUe
})
var _7 = x((__t, x7) => {
	"use strict"
	function FUe(e) {
		var t = this.__data__,
			r = t.delete(e)
		return (this.size = t.size), r
	}
	x7.exports = FUe
})
var I7 = x((w_t, w7) => {
	"use strict"
	function QUe(e) {
		return this.__data__.get(e)
	}
	w7.exports = QUe
})
var B7 = x((I_t, S7) => {
	"use strict"
	function NUe(e) {
		return this.__data__.has(e)
	}
	S7.exports = NUe
})
var yU = x((S_t, D7) => {
	"use strict"
	var PUe = zA(),
		LUe = gd(),
		UUe = "[object AsyncFunction]",
		OUe = "[object Function]",
		qUe = "[object GeneratorFunction]",
		VUe = "[object Proxy]"
	function HUe(e) {
		if (!LUe(e)) return !1
		var t = PUe(e)
		return t == OUe || t == qUe || t == UUe || t == VUe
	}
	D7.exports = HUe
})
var R7 = x((B_t, T7) => {
	"use strict"
	var WUe = Ka(),
		GUe = WUe["__core-js_shared__"]
	T7.exports = GUe
})
var F7 = x((D_t, M7) => {
	"use strict"
	var CU = R7(),
		k7 = (function () {
			var e = /[^.]+$/.exec((CU && CU.keys && CU.keys.IE_PROTO) || "")
			return e ? "Symbol(src)_1." + e : ""
		})()
	function $Ue(e) {
		return !!k7 && k7 in e
	}
	M7.exports = $Ue
})
var vU = x((T_t, Q7) => {
	"use strict"
	var YUe = Function.prototype,
		KUe = YUe.toString
	function JUe(e) {
		if (e != null) {
			try {
				return KUe.call(e)
			} catch {}
			try {
				return e + ""
			} catch {}
		}
		return ""
	}
	Q7.exports = JUe
})
var P7 = x((R_t, N7) => {
	"use strict"
	var zUe = yU(),
		jUe = F7(),
		ZUe = gd(),
		XUe = vU(),
		eOe = /[\\^$.*+?()[\]{}|]/g,
		tOe = /^\[object .+?Constructor\]$/,
		rOe = Function.prototype,
		nOe = Object.prototype,
		iOe = rOe.toString,
		sOe = nOe.hasOwnProperty,
		oOe = RegExp(
			"^" +
				iOe
					.call(sOe)
					.replace(eOe, "\\$&")
					.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") +
				"$",
		)
	function aOe(e) {
		if (!ZUe(e) || jUe(e)) return !1
		var t = zUe(e) ? oOe : tOe
		return t.test(XUe(e))
	}
	N7.exports = aOe
})
var U7 = x((k_t, L7) => {
	"use strict"
	function lOe(e, t) {
		return e?.[t]
	}
	L7.exports = lOe
})
var Wf = x((M_t, O7) => {
	"use strict"
	var cOe = P7(),
		uOe = U7()
	function dOe(e, t) {
		var r = uOe(e, t)
		return cOe(r) ? r : void 0
	}
	O7.exports = dOe
})
var jS = x((F_t, q7) => {
	"use strict"
	var fOe = Wf(),
		hOe = Ka(),
		gOe = fOe(hOe, "Map")
	q7.exports = gOe
})
var AE = x((Q_t, V7) => {
	"use strict"
	var pOe = Wf(),
		AOe = pOe(Object, "create")
	V7.exports = AOe
})
var G7 = x((N_t, W7) => {
	"use strict"
	var H7 = AE()
	function mOe() {
		;(this.__data__ = H7 ? H7(null) : {}), (this.size = 0)
	}
	W7.exports = mOe
})
var Y7 = x((P_t, $7) => {
	"use strict"
	function yOe(e) {
		var t = this.has(e) && delete this.__data__[e]
		return (this.size -= t ? 1 : 0), t
	}
	$7.exports = yOe
})
var J7 = x((L_t, K7) => {
	"use strict"
	var COe = AE(),
		vOe = "__lodash_hash_undefined__",
		EOe = Object.prototype,
		bOe = EOe.hasOwnProperty
	function xOe(e) {
		var t = this.__data__
		if (COe) {
			var r = t[e]
			return r === vOe ? void 0 : r
		}
		return bOe.call(t, e) ? t[e] : void 0
	}
	K7.exports = xOe
})
var j7 = x((U_t, z7) => {
	"use strict"
	var _Oe = AE(),
		wOe = Object.prototype,
		IOe = wOe.hasOwnProperty
	function SOe(e) {
		var t = this.__data__
		return _Oe ? t[e] !== void 0 : IOe.call(t, e)
	}
	z7.exports = SOe
})
var X7 = x((O_t, Z7) => {
	"use strict"
	var BOe = AE(),
		DOe = "__lodash_hash_undefined__"
	function TOe(e, t) {
		var r = this.__data__
		return (this.size += this.has(e) ? 0 : 1), (r[e] = BOe && t === void 0 ? DOe : t), this
	}
	Z7.exports = TOe
})
var tZ = x((q_t, eZ) => {
	"use strict"
	var ROe = G7(),
		kOe = Y7(),
		MOe = J7(),
		FOe = j7(),
		QOe = X7()
	function Um(e) {
		var t = -1,
			r = e == null ? 0 : e.length
		for (this.clear(); ++t < r; ) {
			var n = e[t]
			this.set(n[0], n[1])
		}
	}
	Um.prototype.clear = ROe
	Um.prototype.delete = kOe
	Um.prototype.get = MOe
	Um.prototype.has = FOe
	Um.prototype.set = QOe
	eZ.exports = Um
})
var iZ = x((V_t, nZ) => {
	"use strict"
	var rZ = tZ(),
		NOe = pE(),
		POe = jS()
	function LOe() {
		;(this.size = 0),
			(this.__data__ = {
				hash: new rZ(),
				map: new (POe || NOe)(),
				string: new rZ(),
			})
	}
	nZ.exports = LOe
})
var oZ = x((H_t, sZ) => {
	"use strict"
	function UOe(e) {
		var t = typeof e
		return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null
	}
	sZ.exports = UOe
})
var mE = x((W_t, aZ) => {
	"use strict"
	var OOe = oZ()
	function qOe(e, t) {
		var r = e.__data__
		return OOe(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map
	}
	aZ.exports = qOe
})
var cZ = x((G_t, lZ) => {
	"use strict"
	var VOe = mE()
	function HOe(e) {
		var t = VOe(this, e).delete(e)
		return (this.size -= t ? 1 : 0), t
	}
	lZ.exports = HOe
})
var dZ = x(($_t, uZ) => {
	"use strict"
	var WOe = mE()
	function GOe(e) {
		return WOe(this, e).get(e)
	}
	uZ.exports = GOe
})
var hZ = x((Y_t, fZ) => {
	"use strict"
	var $Oe = mE()
	function YOe(e) {
		return $Oe(this, e).has(e)
	}
	fZ.exports = YOe
})
var pZ = x((K_t, gZ) => {
	"use strict"
	var KOe = mE()
	function JOe(e, t) {
		var r = KOe(this, e),
			n = r.size
		return r.set(e, t), (this.size += r.size == n ? 0 : 1), this
	}
	gZ.exports = JOe
})
var EU = x((J_t, AZ) => {
	"use strict"
	var zOe = iZ(),
		jOe = cZ(),
		ZOe = dZ(),
		XOe = hZ(),
		eqe = pZ()
	function Om(e) {
		var t = -1,
			r = e == null ? 0 : e.length
		for (this.clear(); ++t < r; ) {
			var n = e[t]
			this.set(n[0], n[1])
		}
	}
	Om.prototype.clear = zOe
	Om.prototype.delete = jOe
	Om.prototype.get = ZOe
	Om.prototype.has = XOe
	Om.prototype.set = eqe
	AZ.exports = Om
})
var yZ = x((z_t, mZ) => {
	"use strict"
	var tqe = pE(),
		rqe = jS(),
		nqe = EU(),
		iqe = 200
	function sqe(e, t) {
		var r = this.__data__
		if (r instanceof tqe) {
			var n = r.__data__
			if (!rqe || n.length < iqe - 1) return n.push([e, t]), (this.size = ++r.size), this
			r = this.__data__ = new nqe(n)
		}
		return r.set(e, t), (this.size = r.size), this
	}
	mZ.exports = sqe
})
var bU = x((j_t, CZ) => {
	"use strict"
	var oqe = pE(),
		aqe = b7(),
		lqe = _7(),
		cqe = I7(),
		uqe = B7(),
		dqe = yZ()
	function qm(e) {
		var t = (this.__data__ = new oqe(e))
		this.size = t.size
	}
	qm.prototype.clear = aqe
	qm.prototype.delete = lqe
	qm.prototype.get = cqe
	qm.prototype.has = uqe
	qm.prototype.set = dqe
	CZ.exports = qm
})
var EZ = x((Z_t, vZ) => {
	"use strict"
	var fqe = "__lodash_hash_undefined__"
	function hqe(e) {
		return this.__data__.set(e, fqe), this
	}
	vZ.exports = hqe
})
var xZ = x((X_t, bZ) => {
	"use strict"
	function gqe(e) {
		return this.__data__.has(e)
	}
	bZ.exports = gqe
})
var wZ = x((ewt, _Z) => {
	"use strict"
	var pqe = EU(),
		Aqe = EZ(),
		mqe = xZ()
	function ZS(e) {
		var t = -1,
			r = e == null ? 0 : e.length
		for (this.__data__ = new pqe(); ++t < r; ) this.add(e[t])
	}
	ZS.prototype.add = ZS.prototype.push = Aqe
	ZS.prototype.has = mqe
	_Z.exports = ZS
})
var SZ = x((twt, IZ) => {
	"use strict"
	function yqe(e, t) {
		for (var r = -1, n = e == null ? 0 : e.length; ++r < n; ) if (t(e[r], r, e)) return !0
		return !1
	}
	IZ.exports = yqe
})
var DZ = x((rwt, BZ) => {
	"use strict"
	function Cqe(e, t) {
		return e.has(t)
	}
	BZ.exports = Cqe
})
var xU = x((nwt, TZ) => {
	"use strict"
	var vqe = wZ(),
		Eqe = SZ(),
		bqe = DZ(),
		xqe = 1,
		_qe = 2
	function wqe(e, t, r, n, i, s) {
		var o = r & xqe,
			a = e.length,
			l = t.length
		if (a != l && !(o && l > a)) return !1
		var c = s.get(e),
			u = s.get(t)
		if (c && u) return c == t && u == e
		var f = -1,
			p = !0,
			g = r & _qe ? new vqe() : void 0
		for (s.set(e, t), s.set(t, e); ++f < a; ) {
			var m = e[f],
				y = t[f]
			if (n) var C = o ? n(y, m, f, t, e, s) : n(m, y, f, e, t, s)
			if (C !== void 0) {
				if (C) continue
				p = !1
				break
			}
			if (g) {
				if (
					!Eqe(t, function (v, b) {
						if (!bqe(g, b) && (m === v || i(m, v, r, n, s))) return g.push(b)
					})
				) {
					p = !1
					break
				}
			} else if (!(m === y || i(m, y, r, n, s))) {
				p = !1
				break
			}
		}
		return s.delete(e), s.delete(t), p
	}
	TZ.exports = wqe
})
var _U = x((iwt, RZ) => {
	"use strict"
	var Iqe = Ka(),
		Sqe = Iqe.Uint8Array
	RZ.exports = Sqe
})
var MZ = x((swt, kZ) => {
	"use strict"
	function Bqe(e) {
		var t = -1,
			r = Array(e.size)
		return (
			e.forEach(function (n, i) {
				r[++t] = [i, n]
			}),
			r
		)
	}
	kZ.exports = Bqe
})
var QZ = x((owt, FZ) => {
	"use strict"
	function Dqe(e) {
		var t = -1,
			r = Array(e.size)
		return (
			e.forEach(function (n) {
				r[++t] = n
			}),
			r
		)
	}
	FZ.exports = Dqe
})
var OZ = x((awt, UZ) => {
	"use strict"
	var NZ = Iv(),
		PZ = _U(),
		Tqe = zS(),
		Rqe = xU(),
		kqe = MZ(),
		Mqe = QZ(),
		Fqe = 1,
		Qqe = 2,
		Nqe = "[object Boolean]",
		Pqe = "[object Date]",
		Lqe = "[object Error]",
		Uqe = "[object Map]",
		Oqe = "[object Number]",
		qqe = "[object RegExp]",
		Vqe = "[object Set]",
		Hqe = "[object String]",
		Wqe = "[object Symbol]",
		Gqe = "[object ArrayBuffer]",
		$qe = "[object DataView]",
		LZ = NZ ? NZ.prototype : void 0,
		wU = LZ ? LZ.valueOf : void 0
	function Yqe(e, t, r, n, i, s, o) {
		switch (r) {
			case $qe:
				if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1
				;(e = e.buffer), (t = t.buffer)
			case Gqe:
				return !(e.byteLength != t.byteLength || !s(new PZ(e), new PZ(t)))
			case Nqe:
			case Pqe:
			case Oqe:
				return Tqe(+e, +t)
			case Lqe:
				return e.name == t.name && e.message == t.message
			case qqe:
			case Hqe:
				return e == t + ""
			case Uqe:
				var a = kqe
			case Vqe:
				var l = n & Fqe
				if ((a || (a = Mqe), e.size != t.size && !l)) return !1
				var c = o.get(e)
				if (c) return c == t
				;(n |= Qqe), o.set(e, t)
				var u = Rqe(a(e), a(t), n, i, s, o)
				return o.delete(e), u
			case Wqe:
				if (wU) return wU.call(e) == wU.call(t)
		}
		return !1
	}
	UZ.exports = Yqe
})
var IU = x((lwt, qZ) => {
	"use strict"
	function Kqe(e, t) {
		for (var r = -1, n = t.length, i = e.length; ++r < n; ) e[i + r] = t[r]
		return e
	}
	qZ.exports = Kqe
})
var yE = x((cwt, VZ) => {
	"use strict"
	var Jqe = Array.isArray
	VZ.exports = Jqe
})
var SU = x((uwt, HZ) => {
	"use strict"
	var zqe = IU(),
		jqe = yE()
	function Zqe(e, t, r) {
		var n = t(e)
		return jqe(e) ? n : zqe(n, r(e))
	}
	HZ.exports = Zqe
})
var GZ = x((dwt, WZ) => {
	"use strict"
	function Xqe(e, t) {
		for (var r = -1, n = e == null ? 0 : e.length, i = 0, s = []; ++r < n; ) {
			var o = e[r]
			t(o, r, e) && (s[i++] = o)
		}
		return s
	}
	WZ.exports = Xqe
})
var BU = x((fwt, $Z) => {
	"use strict"
	function eVe() {
		return []
	}
	$Z.exports = eVe
})
var XS = x((hwt, KZ) => {
	"use strict"
	var tVe = GZ(),
		rVe = BU(),
		nVe = Object.prototype,
		iVe = nVe.propertyIsEnumerable,
		YZ = Object.getOwnPropertySymbols,
		sVe = YZ
			? function (e) {
					return e == null
						? []
						: ((e = Object(e)),
							tVe(YZ(e), function (t) {
								return iVe.call(e, t)
							}))
				}
			: rVe
	KZ.exports = sVe
})
var zZ = x((gwt, JZ) => {
	"use strict"
	function oVe(e, t) {
		for (var r = -1, n = Array(e); ++r < e; ) n[r] = t(r)
		return n
	}
	JZ.exports = oVe
})
var ZZ = x((pwt, jZ) => {
	"use strict"
	var aVe = zA(),
		lVe = Tf(),
		cVe = "[object Arguments]"
	function uVe(e) {
		return lVe(e) && aVe(e) == cVe
	}
	jZ.exports = uVe
})
var rX = x((Awt, tX) => {
	"use strict"
	var XZ = ZZ(),
		dVe = Tf(),
		eX = Object.prototype,
		fVe = eX.hasOwnProperty,
		hVe = eX.propertyIsEnumerable,
		gVe = XZ(
			(function () {
				return arguments
			})(),
		)
			? XZ
			: function (e) {
					return dVe(e) && fVe.call(e, "callee") && !hVe.call(e, "callee")
				}
	tX.exports = gVe
})
var iX = x((mwt, nX) => {
	"use strict"
	function pVe() {
		return !1
	}
	nX.exports = pVe
})
var eB = x((CE, Vm) => {
	"use strict"
	var AVe = Ka(),
		mVe = iX(),
		aX = typeof CE == "object" && CE && !CE.nodeType && CE,
		sX = aX && typeof Vm == "object" && Vm && !Vm.nodeType && Vm,
		yVe = sX && sX.exports === aX,
		oX = yVe ? AVe.Buffer : void 0,
		CVe = oX ? oX.isBuffer : void 0,
		vVe = CVe || mVe
	Vm.exports = vVe
})
var cX = x((ywt, lX) => {
	"use strict"
	var EVe = 9007199254740991,
		bVe = /^(?:0|[1-9]\d*)$/
	function xVe(e, t) {
		var r = typeof e
		return (t = t ?? EVe), !!t && (r == "number" || (r != "symbol" && bVe.test(e))) && e > -1 && e % 1 == 0 && e < t
	}
	lX.exports = xVe
})
var DU = x((Cwt, uX) => {
	"use strict"
	var _Ve = 9007199254740991
	function wVe(e) {
		return typeof e == "number" && e > -1 && e % 1 == 0 && e <= _Ve
	}
	uX.exports = wVe
})
var fX = x((vwt, dX) => {
	"use strict"
	var IVe = zA(),
		SVe = DU(),
		BVe = Tf(),
		DVe = "[object Arguments]",
		TVe = "[object Array]",
		RVe = "[object Boolean]",
		kVe = "[object Date]",
		MVe = "[object Error]",
		FVe = "[object Function]",
		QVe = "[object Map]",
		NVe = "[object Number]",
		PVe = "[object Object]",
		LVe = "[object RegExp]",
		UVe = "[object Set]",
		OVe = "[object String]",
		qVe = "[object WeakMap]",
		VVe = "[object ArrayBuffer]",
		HVe = "[object DataView]",
		WVe = "[object Float32Array]",
		GVe = "[object Float64Array]",
		$Ve = "[object Int8Array]",
		YVe = "[object Int16Array]",
		KVe = "[object Int32Array]",
		JVe = "[object Uint8Array]",
		zVe = "[object Uint8ClampedArray]",
		jVe = "[object Uint16Array]",
		ZVe = "[object Uint32Array]",
		bn = {}
	bn[WVe] = bn[GVe] = bn[$Ve] = bn[YVe] = bn[KVe] = bn[JVe] = bn[zVe] = bn[jVe] = bn[ZVe] = !0
	bn[DVe] =
		bn[TVe] =
		bn[VVe] =
		bn[RVe] =
		bn[HVe] =
		bn[kVe] =
		bn[MVe] =
		bn[FVe] =
		bn[QVe] =
		bn[NVe] =
		bn[PVe] =
		bn[LVe] =
		bn[UVe] =
		bn[OVe] =
		bn[qVe] =
			!1
	function XVe(e) {
		return BVe(e) && SVe(e.length) && !!bn[IVe(e)]
	}
	dX.exports = XVe
})
var tB = x((Ewt, hX) => {
	"use strict"
	function e5e(e) {
		return function (t) {
			return e(t)
		}
	}
	hX.exports = e5e
})
var rB = x((vE, Hm) => {
	"use strict"
	var t5e = X2(),
		gX = typeof vE == "object" && vE && !vE.nodeType && vE,
		EE = gX && typeof Hm == "object" && Hm && !Hm.nodeType && Hm,
		r5e = EE && EE.exports === gX,
		TU = r5e && t5e.process,
		n5e = (function () {
			try {
				var e = EE && EE.require && EE.require("util").types
				return e || (TU && TU.binding && TU.binding("util"))
			} catch {}
		})()
	Hm.exports = n5e
})
var RU = x((bwt, mX) => {
	"use strict"
	var i5e = fX(),
		s5e = tB(),
		pX = rB(),
		AX = pX && pX.isTypedArray,
		o5e = AX ? s5e(AX) : i5e
	mX.exports = o5e
})
var kU = x((xwt, yX) => {
	"use strict"
	var a5e = zZ(),
		l5e = rX(),
		c5e = yE(),
		u5e = eB(),
		d5e = cX(),
		f5e = RU(),
		h5e = Object.prototype,
		g5e = h5e.hasOwnProperty
	function p5e(e, t) {
		var r = c5e(e),
			n = !r && l5e(e),
			i = !r && !n && u5e(e),
			s = !r && !n && !i && f5e(e),
			o = r || n || i || s,
			a = o ? a5e(e.length, String) : [],
			l = a.length
		for (var c in e)
			(t || g5e.call(e, c)) &&
				!(
					o &&
					(c == "length" ||
						(i && (c == "offset" || c == "parent")) ||
						(s && (c == "buffer" || c == "byteLength" || c == "byteOffset")) ||
						d5e(c, l))
				) &&
				a.push(c)
		return a
	}
	yX.exports = p5e
})
var nB = x((_wt, CX) => {
	"use strict"
	var A5e = Object.prototype
	function m5e(e) {
		var t = e && e.constructor,
			r = (typeof t == "function" && t.prototype) || A5e
		return e === r
	}
	CX.exports = m5e
})
var MU = x((wwt, vX) => {
	"use strict"
	function y5e(e, t) {
		return function (r) {
			return e(t(r))
		}
	}
	vX.exports = y5e
})
var bX = x((Iwt, EX) => {
	"use strict"
	var C5e = MU(),
		v5e = C5e(Object.keys, Object)
	EX.exports = v5e
})
var _X = x((Swt, xX) => {
	"use strict"
	var E5e = nB(),
		b5e = bX(),
		x5e = Object.prototype,
		_5e = x5e.hasOwnProperty
	function w5e(e) {
		if (!E5e(e)) return b5e(e)
		var t = []
		for (var r in Object(e)) _5e.call(e, r) && r != "constructor" && t.push(r)
		return t
	}
	xX.exports = w5e
})
var FU = x((Bwt, wX) => {
	"use strict"
	var I5e = yU(),
		S5e = DU()
	function B5e(e) {
		return e != null && S5e(e.length) && !I5e(e)
	}
	wX.exports = B5e
})
var iB = x((Dwt, IX) => {
	"use strict"
	var D5e = kU(),
		T5e = _X(),
		R5e = FU()
	function k5e(e) {
		return R5e(e) ? D5e(e) : T5e(e)
	}
	IX.exports = k5e
})
var QU = x((Twt, SX) => {
	"use strict"
	var M5e = SU(),
		F5e = XS(),
		Q5e = iB()
	function N5e(e) {
		return M5e(e, Q5e, F5e)
	}
	SX.exports = N5e
})
var TX = x((Rwt, DX) => {
	"use strict"
	var BX = QU(),
		P5e = 1,
		L5e = Object.prototype,
		U5e = L5e.hasOwnProperty
	function O5e(e, t, r, n, i, s) {
		var o = r & P5e,
			a = BX(e),
			l = a.length,
			c = BX(t),
			u = c.length
		if (l != u && !o) return !1
		for (var f = l; f--; ) {
			var p = a[f]
			if (!(o ? p in t : U5e.call(t, p))) return !1
		}
		var g = s.get(e),
			m = s.get(t)
		if (g && m) return g == t && m == e
		var y = !0
		s.set(e, t), s.set(t, e)
		for (var C = o; ++f < l; ) {
			p = a[f]
			var v = e[p],
				b = t[p]
			if (n) var w = o ? n(b, v, p, t, e, s) : n(v, b, p, e, t, s)
			if (!(w === void 0 ? v === b || i(v, b, r, n, s) : w)) {
				y = !1
				break
			}
			C || (C = p == "constructor")
		}
		if (y && !C) {
			var B = e.constructor,
				M = t.constructor
			B != M &&
				"constructor" in e &&
				"constructor" in t &&
				!(typeof B == "function" && B instanceof B && typeof M == "function" && M instanceof M) &&
				(y = !1)
		}
		return s.delete(e), s.delete(t), y
	}
	DX.exports = O5e
})
var kX = x((kwt, RX) => {
	"use strict"
	var q5e = Wf(),
		V5e = Ka(),
		H5e = q5e(V5e, "DataView")
	RX.exports = H5e
})
var FX = x((Mwt, MX) => {
	"use strict"
	var W5e = Wf(),
		G5e = Ka(),
		$5e = W5e(G5e, "Promise")
	MX.exports = $5e
})
var NX = x((Fwt, QX) => {
	"use strict"
	var Y5e = Wf(),
		K5e = Ka(),
		J5e = Y5e(K5e, "Set")
	QX.exports = J5e
})
var LX = x((Qwt, PX) => {
	"use strict"
	var z5e = Wf(),
		j5e = Ka(),
		Z5e = z5e(j5e, "WeakMap")
	PX.exports = Z5e
})
var bE = x((Nwt, GX) => {
	"use strict"
	var NU = kX(),
		PU = jS(),
		LU = FX(),
		UU = NX(),
		OU = LX(),
		WX = zA(),
		Wm = vU(),
		UX = "[object Map]",
		X5e = "[object Object]",
		OX = "[object Promise]",
		qX = "[object Set]",
		VX = "[object WeakMap]",
		HX = "[object DataView]",
		e3e = Wm(NU),
		t3e = Wm(PU),
		r3e = Wm(LU),
		n3e = Wm(UU),
		i3e = Wm(OU),
		ep = WX
	;((NU && ep(new NU(new ArrayBuffer(1))) != HX) ||
		(PU && ep(new PU()) != UX) ||
		(LU && ep(LU.resolve()) != OX) ||
		(UU && ep(new UU()) != qX) ||
		(OU && ep(new OU()) != VX)) &&
		(ep = function (e) {
			var t = WX(e),
				r = t == X5e ? e.constructor : void 0,
				n = r ? Wm(r) : ""
			if (n)
				switch (n) {
					case e3e:
						return HX
					case t3e:
						return UX
					case r3e:
						return OX
					case n3e:
						return qX
					case i3e:
						return VX
				}
			return t
		})
	GX.exports = ep
})
var XX = x((Pwt, ZX) => {
	"use strict"
	var qU = bU(),
		s3e = xU(),
		o3e = OZ(),
		a3e = TX(),
		$X = bE(),
		YX = yE(),
		KX = eB(),
		l3e = RU(),
		c3e = 1,
		JX = "[object Arguments]",
		zX = "[object Array]",
		sB = "[object Object]",
		u3e = Object.prototype,
		jX = u3e.hasOwnProperty
	function d3e(e, t, r, n, i, s) {
		var o = YX(e),
			a = YX(t),
			l = o ? zX : $X(e),
			c = a ? zX : $X(t)
		;(l = l == JX ? sB : l), (c = c == JX ? sB : c)
		var u = l == sB,
			f = c == sB,
			p = l == c
		if (p && KX(e)) {
			if (!KX(t)) return !1
			;(o = !0), (u = !1)
		}
		if (p && !u) return s || (s = new qU()), o || l3e(e) ? s3e(e, t, r, n, i, s) : o3e(e, t, l, r, n, i, s)
		if (!(r & c3e)) {
			var g = u && jX.call(e, "__wrapped__"),
				m = f && jX.call(t, "__wrapped__")
			if (g || m) {
				var y = g ? e.value() : e,
					C = m ? t.value() : t
				return s || (s = new qU()), i(y, C, r, n, s)
			}
		}
		return p ? (s || (s = new qU()), a3e(e, t, r, n, i, s)) : !1
	}
	ZX.exports = d3e
})
var nee = x((Lwt, ree) => {
	"use strict"
	var f3e = XX(),
		eee = Tf()
	function tee(e, t, r, n, i) {
		return e === t
			? !0
			: e == null || t == null || (!eee(e) && !eee(t))
				? e !== e && t !== t
				: f3e(e, t, r, n, tee, i)
	}
	ree.exports = tee
})
var see = x((Uwt, iee) => {
	"use strict"
	var h3e = nee()
	function g3e(e, t) {
		return h3e(e, t)
	}
	iee.exports = g3e
})
var Qn = x((Owt, oee) => {
	"use strict"
	oee.exports = {
		kClose: Symbol("close"),
		kDestroy: Symbol("destroy"),
		kDispatch: Symbol("dispatch"),
		kUrl: Symbol("url"),
		kWriting: Symbol("writing"),
		kResuming: Symbol("resuming"),
		kQueue: Symbol("queue"),
		kConnect: Symbol("connect"),
		kConnecting: Symbol("connecting"),
		kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
		kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
		kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
		kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
		kKeepAlive: Symbol("keep alive"),
		kHeadersTimeout: Symbol("headers timeout"),
		kBodyTimeout: Symbol("body timeout"),
		kServerName: Symbol("server name"),
		kLocalAddress: Symbol("local address"),
		kHost: Symbol("host"),
		kNoRef: Symbol("no ref"),
		kBodyUsed: Symbol("used"),
		kBody: Symbol("abstracted request body"),
		kRunning: Symbol("running"),
		kBlocking: Symbol("blocking"),
		kPending: Symbol("pending"),
		kSize: Symbol("size"),
		kBusy: Symbol("busy"),
		kQueued: Symbol("queued"),
		kFree: Symbol("free"),
		kConnected: Symbol("connected"),
		kClosed: Symbol("closed"),
		kNeedDrain: Symbol("need drain"),
		kReset: Symbol("reset"),
		kDestroyed: Symbol.for("nodejs.stream.destroyed"),
		kResume: Symbol("resume"),
		kOnError: Symbol("on error"),
		kMaxHeadersSize: Symbol("max headers size"),
		kRunningIdx: Symbol("running index"),
		kPendingIdx: Symbol("pending index"),
		kError: Symbol("error"),
		kClients: Symbol("clients"),
		kClient: Symbol("client"),
		kParser: Symbol("parser"),
		kOnDestroyed: Symbol("destroy callbacks"),
		kPipelining: Symbol("pipelining"),
		kSocket: Symbol("socket"),
		kHostHeader: Symbol("host header"),
		kConnector: Symbol("connector"),
		kStrictContentLength: Symbol("strict content length"),
		kMaxRedirections: Symbol("maxRedirections"),
		kMaxRequests: Symbol("maxRequestsPerClient"),
		kProxy: Symbol("proxy agent options"),
		kCounter: Symbol("socket request counter"),
		kInterceptors: Symbol("dispatch interceptors"),
		kMaxResponseSize: Symbol("max response size"),
		kHTTP2Session: Symbol("http2Session"),
		kHTTP2SessionState: Symbol("http2Session state"),
		kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
		kConstruct: Symbol("constructable"),
		kListeners: Symbol("listeners"),
		kHTTPContext: Symbol("http context"),
		kMaxConcurrentStreams: Symbol("max concurrent streams"),
		kNoProxyAgent: Symbol("no proxy agent"),
		kHttpProxyAgent: Symbol("http proxy agent"),
		kHttpsProxyAgent: Symbol("https proxy agent"),
	}
})
var Vr = x((qwt, aee) => {
	"use strict"
	var Vn = class extends Error {
			constructor(t) {
				super(t), (this.name = "UndiciError"), (this.code = "UND_ERR")
			}
		},
		VU = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "ConnectTimeoutError"),
					(this.message = t || "Connect Timeout Error"),
					(this.code = "UND_ERR_CONNECT_TIMEOUT")
			}
		},
		HU = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "HeadersTimeoutError"),
					(this.message = t || "Headers Timeout Error"),
					(this.code = "UND_ERR_HEADERS_TIMEOUT")
			}
		},
		WU = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "HeadersOverflowError"),
					(this.message = t || "Headers Overflow Error"),
					(this.code = "UND_ERR_HEADERS_OVERFLOW")
			}
		},
		GU = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "BodyTimeoutError"),
					(this.message = t || "Body Timeout Error"),
					(this.code = "UND_ERR_BODY_TIMEOUT")
			}
		},
		$U = class extends Vn {
			constructor(t, r, n, i) {
				super(t),
					(this.name = "ResponseStatusCodeError"),
					(this.message = t || "Response Status Code Error"),
					(this.code = "UND_ERR_RESPONSE_STATUS_CODE"),
					(this.body = i),
					(this.status = r),
					(this.statusCode = r),
					(this.headers = n)
			}
		},
		YU = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "InvalidArgumentError"),
					(this.message = t || "Invalid Argument Error"),
					(this.code = "UND_ERR_INVALID_ARG")
			}
		},
		KU = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "InvalidReturnValueError"),
					(this.message = t || "Invalid Return Value Error"),
					(this.code = "UND_ERR_INVALID_RETURN_VALUE")
			}
		},
		oB = class extends Vn {
			constructor(t) {
				super(t), (this.name = "AbortError"), (this.message = t || "The operation was aborted")
			}
		},
		JU = class extends oB {
			constructor(t) {
				super(t),
					(this.name = "AbortError"),
					(this.message = t || "Request aborted"),
					(this.code = "UND_ERR_ABORTED")
			}
		},
		zU = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "InformationalError"),
					(this.message = t || "Request information"),
					(this.code = "UND_ERR_INFO")
			}
		},
		jU = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "RequestContentLengthMismatchError"),
					(this.message = t || "Request body length does not match content-length header"),
					(this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH")
			}
		},
		ZU = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "ResponseContentLengthMismatchError"),
					(this.message = t || "Response body length does not match content-length header"),
					(this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH")
			}
		},
		XU = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "ClientDestroyedError"),
					(this.message = t || "The client is destroyed"),
					(this.code = "UND_ERR_DESTROYED")
			}
		},
		eO = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "ClientClosedError"),
					(this.message = t || "The client is closed"),
					(this.code = "UND_ERR_CLOSED")
			}
		},
		tO = class extends Vn {
			constructor(t, r) {
				super(t),
					(this.name = "SocketError"),
					(this.message = t || "Socket error"),
					(this.code = "UND_ERR_SOCKET"),
					(this.socket = r)
			}
		},
		rO = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "NotSupportedError"),
					(this.message = t || "Not supported error"),
					(this.code = "UND_ERR_NOT_SUPPORTED")
			}
		},
		nO = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "MissingUpstreamError"),
					(this.message = t || "No upstream has been added to the BalancedPool"),
					(this.code = "UND_ERR_BPL_MISSING_UPSTREAM")
			}
		},
		iO = class extends Error {
			constructor(t, r, n) {
				super(t),
					(this.name = "HTTPParserError"),
					(this.code = r ? `HPE_${r}` : void 0),
					(this.data = n ? n.toString() : void 0)
			}
		},
		sO = class extends Vn {
			constructor(t) {
				super(t),
					(this.name = "ResponseExceededMaxSizeError"),
					(this.message = t || "Response content exceeded max size"),
					(this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE")
			}
		},
		oO = class extends Vn {
			constructor(t, r, { headers: n, data: i }) {
				super(t),
					(this.name = "RequestRetryError"),
					(this.message = t || "Request retry error"),
					(this.code = "UND_ERR_REQ_RETRY"),
					(this.statusCode = r),
					(this.data = i),
					(this.headers = n)
			}
		},
		aO = class extends Vn {
			constructor(t, r, { headers: n, data: i }) {
				super(t),
					(this.name = "ResponseError"),
					(this.message = t || "Response error"),
					(this.code = "UND_ERR_RESPONSE"),
					(this.statusCode = r),
					(this.data = i),
					(this.headers = n)
			}
		},
		lO = class extends Vn {
			constructor(t, r, n) {
				super(r, { cause: t, ...(n ?? {}) }),
					(this.name = "SecureProxyConnectionError"),
					(this.message = r || "Secure Proxy Connection failed"),
					(this.code = "UND_ERR_PRX_TLS"),
					(this.cause = t)
			}
		}
	aee.exports = {
		AbortError: oB,
		HTTPParserError: iO,
		UndiciError: Vn,
		HeadersTimeoutError: HU,
		HeadersOverflowError: WU,
		BodyTimeoutError: GU,
		RequestContentLengthMismatchError: jU,
		ConnectTimeoutError: VU,
		ResponseStatusCodeError: $U,
		InvalidArgumentError: YU,
		InvalidReturnValueError: KU,
		RequestAbortedError: JU,
		ClientDestroyedError: XU,
		ClientClosedError: eO,
		InformationalError: zU,
		SocketError: tO,
		NotSupportedError: rO,
		ResponseContentLengthMismatchError: ZU,
		BalancedPoolMissingUpstreamError: nO,
		ResponseExceededMaxSizeError: sO,
		RequestRetryError: oO,
		ResponseError: aO,
		SecureProxyConnectionError: lO,
	}
})
var lB = x((Vwt, lee) => {
	"use strict"
	var aB = {},
		cO = [
			"Accept",
			"Accept-Encoding",
			"Accept-Language",
			"Accept-Ranges",
			"Access-Control-Allow-Credentials",
			"Access-Control-Allow-Headers",
			"Access-Control-Allow-Methods",
			"Access-Control-Allow-Origin",
			"Access-Control-Expose-Headers",
			"Access-Control-Max-Age",
			"Access-Control-Request-Headers",
			"Access-Control-Request-Method",
			"Age",
			"Allow",
			"Alt-Svc",
			"Alt-Used",
			"Authorization",
			"Cache-Control",
			"Clear-Site-Data",
			"Connection",
			"Content-Disposition",
			"Content-Encoding",
			"Content-Language",
			"Content-Length",
			"Content-Location",
			"Content-Range",
			"Content-Security-Policy",
			"Content-Security-Policy-Report-Only",
			"Content-Type",
			"Cookie",
			"Cross-Origin-Embedder-Policy",
			"Cross-Origin-Opener-Policy",
			"Cross-Origin-Resource-Policy",
			"Date",
			"Device-Memory",
			"Downlink",
			"ECT",
			"ETag",
			"Expect",
			"Expect-CT",
			"Expires",
			"Forwarded",
			"From",
			"Host",
			"If-Match",
			"If-Modified-Since",
			"If-None-Match",
			"If-Range",
			"If-Unmodified-Since",
			"Keep-Alive",
			"Last-Modified",
			"Link",
			"Location",
			"Max-Forwards",
			"Origin",
			"Permissions-Policy",
			"Pragma",
			"Proxy-Authenticate",
			"Proxy-Authorization",
			"RTT",
			"Range",
			"Referer",
			"Referrer-Policy",
			"Refresh",
			"Retry-After",
			"Sec-WebSocket-Accept",
			"Sec-WebSocket-Extensions",
			"Sec-WebSocket-Key",
			"Sec-WebSocket-Protocol",
			"Sec-WebSocket-Version",
			"Server",
			"Server-Timing",
			"Service-Worker-Allowed",
			"Service-Worker-Navigation-Preload",
			"Set-Cookie",
			"SourceMap",
			"Strict-Transport-Security",
			"Supports-Loading-Mode",
			"TE",
			"Timing-Allow-Origin",
			"Trailer",
			"Transfer-Encoding",
			"Upgrade",
			"Upgrade-Insecure-Requests",
			"User-Agent",
			"Vary",
			"Via",
			"WWW-Authenticate",
			"X-Content-Type-Options",
			"X-DNS-Prefetch-Control",
			"X-Frame-Options",
			"X-Permitted-Cross-Domain-Policies",
			"X-Powered-By",
			"X-Requested-With",
			"X-XSS-Protection",
		]
	for (let e = 0; e < cO.length; ++e) {
		let t = cO[e],
			r = t.toLowerCase()
		aB[t] = aB[r] = r
	}
	Object.setPrototypeOf(aB, null)
	lee.exports = { wellknownHeaderNames: cO, headerNameLowerCasedRecord: aB }
})
var fee = x((Hwt, dee) => {
	"use strict"
	var { wellknownHeaderNames: cee, headerNameLowerCasedRecord: p3e } = lB(),
		uO = class e {
			value = null
			left = null
			middle = null
			right = null
			code
			constructor(t, r, n) {
				if (n === void 0 || n >= t.length) throw new TypeError("Unreachable")
				if ((this.code = t.charCodeAt(n)) > 127) throw new TypeError("key must be ascii string")
				t.length !== ++n ? (this.middle = new e(t, r, n)) : (this.value = r)
			}
			add(t, r) {
				let n = t.length
				if (n === 0) throw new TypeError("Unreachable")
				let i = 0,
					s = this
				for (;;) {
					let o = t.charCodeAt(i)
					if (o > 127) throw new TypeError("key must be ascii string")
					if (s.code === o)
						if (n === ++i) {
							s.value = r
							break
						} else if (s.middle !== null) s = s.middle
						else {
							s.middle = new e(t, r, i)
							break
						}
					else if (s.code < o)
						if (s.left !== null) s = s.left
						else {
							s.left = new e(t, r, i)
							break
						}
					else if (s.right !== null) s = s.right
					else {
						s.right = new e(t, r, i)
						break
					}
				}
			}
			search(t) {
				let r = t.length,
					n = 0,
					i = this
				for (; i !== null && n < r; ) {
					let s = t[n]
					for (s <= 90 && s >= 65 && (s |= 32); i !== null; ) {
						if (s === i.code) {
							if (r === ++n) return i
							i = i.middle
							break
						}
						i = i.code < s ? i.left : i.right
					}
				}
				return null
			}
		},
		cB = class {
			node = null
			insert(t, r) {
				this.node === null ? (this.node = new uO(t, r, 0)) : this.node.add(t, r)
			}
			lookup(t) {
				return this.node?.search(t)?.value ?? null
			}
		},
		uee = new cB()
	for (let e = 0; e < cee.length; ++e) {
		let t = p3e[cee[e]]
		uee.insert(t, t)
	}
	dee.exports = { TernarySearchTree: cB, tree: uee }
})
var Xt = x((Wwt, Bee) => {
	"use strict"
	var xE = require("assert"),
		{ kDestroyed: gee, kBodyUsed: Gm, kListeners: dO, kBody: hee } = Qn(),
		{ IncomingMessage: A3e } = require("http"),
		fB = require("stream"),
		m3e = require("net"),
		{ Blob: y3e } = require("buffer"),
		C3e = require("util"),
		{ stringify: v3e } = require("querystring"),
		{ EventEmitter: E3e } = require("events"),
		{ InvalidArgumentError: Ji } = Vr(),
		{ headerNameLowerCasedRecord: b3e } = lB(),
		{ tree: pee } = fee(),
		[x3e, _3e] = process.versions.node.split(".").map((e) => Number(e)),
		dB = class {
			constructor(t) {
				;(this[hee] = t), (this[Gm] = !1)
			}
			async *[Symbol.asyncIterator]() {
				xE(!this[Gm], "disturbed"), (this[Gm] = !0), yield* this[hee]
			}
		}
	function w3e(e) {
		return hB(e)
			? (vee(e) === 0 &&
					e.on("data", function () {
						xE(!1)
					}),
				typeof e.readableDidRead != "boolean" &&
					((e[Gm] = !1),
					E3e.prototype.on.call(e, "data", function () {
						this[Gm] = !0
					})),
				e)
			: e && typeof e.pipeTo == "function"
				? new dB(e)
				: e && typeof e != "string" && !ArrayBuffer.isView(e) && Cee(e)
					? new dB(e)
					: e
	}
	function I3e() {}
	function hB(e) {
		return e && typeof e == "object" && typeof e.pipe == "function" && typeof e.on == "function"
	}
	function Aee(e) {
		if (e === null) return !1
		if (e instanceof y3e) return !0
		if (typeof e != "object") return !1
		{
			let t = e[Symbol.toStringTag]
			return (
				(t === "Blob" || t === "File") &&
				(("stream" in e && typeof e.stream == "function") ||
					("arrayBuffer" in e && typeof e.arrayBuffer == "function"))
			)
		}
	}
	function S3e(e, t) {
		if (e.includes("?") || e.includes("#"))
			throw new Error('Query params cannot be passed when url already contains "?" or "#".')
		let r = v3e(t)
		return r && (e += "?" + r), e
	}
	function mee(e) {
		let t = parseInt(e, 10)
		return t === Number(e) && t >= 0 && t <= 65535
	}
	function uB(e) {
		return (
			e != null &&
			e[0] === "h" &&
			e[1] === "t" &&
			e[2] === "t" &&
			e[3] === "p" &&
			(e[4] === ":" || (e[4] === "s" && e[5] === ":"))
		)
	}
	function yee(e) {
		if (typeof e == "string") {
			if (((e = new URL(e)), !uB(e.origin || e.protocol)))
				throw new Ji("Invalid URL protocol: the URL must start with `http:` or `https:`.")
			return e
		}
		if (!e || typeof e != "object") throw new Ji("Invalid URL: The URL argument must be a non-null object.")
		if (!(e instanceof URL)) {
			if (e.port != null && e.port !== "" && mee(e.port) === !1)
				throw new Ji("Invalid URL: port must be a valid integer or a string representation of an integer.")
			if (e.path != null && typeof e.path != "string")
				throw new Ji("Invalid URL path: the path must be a string or null/undefined.")
			if (e.pathname != null && typeof e.pathname != "string")
				throw new Ji("Invalid URL pathname: the pathname must be a string or null/undefined.")
			if (e.hostname != null && typeof e.hostname != "string")
				throw new Ji("Invalid URL hostname: the hostname must be a string or null/undefined.")
			if (e.origin != null && typeof e.origin != "string")
				throw new Ji("Invalid URL origin: the origin must be a string or null/undefined.")
			if (!uB(e.origin || e.protocol))
				throw new Ji("Invalid URL protocol: the URL must start with `http:` or `https:`.")
			let t = e.port != null ? e.port : e.protocol === "https:" ? 443 : 80,
				r = e.origin != null ? e.origin : `${e.protocol || ""}//${e.hostname || ""}:${t}`,
				n = e.path != null ? e.path : `${e.pathname || ""}${e.search || ""}`
			return (
				r[r.length - 1] === "/" && (r = r.slice(0, r.length - 1)),
				n && n[0] !== "/" && (n = `/${n}`),
				new URL(`${r}${n}`)
			)
		}
		if (!uB(e.origin || e.protocol))
			throw new Ji("Invalid URL protocol: the URL must start with `http:` or `https:`.")
		return e
	}
	function B3e(e) {
		if (((e = yee(e)), e.pathname !== "/" || e.search || e.hash)) throw new Ji("invalid url")
		return e
	}
	function D3e(e) {
		if (e[0] === "[") {
			let r = e.indexOf("]")
			return xE(r !== -1), e.substring(1, r)
		}
		let t = e.indexOf(":")
		return t === -1 ? e : e.substring(0, t)
	}
	function T3e(e) {
		if (!e) return null
		xE(typeof e == "string")
		let t = D3e(e)
		return m3e.isIP(t) ? "" : t
	}
	function R3e(e) {
		return JSON.parse(JSON.stringify(e))
	}
	function k3e(e) {
		return e != null && typeof e[Symbol.asyncIterator] == "function"
	}
	function Cee(e) {
		return e != null && (typeof e[Symbol.iterator] == "function" || typeof e[Symbol.asyncIterator] == "function")
	}
	function vee(e) {
		if (e == null) return 0
		if (hB(e)) {
			let t = e._readableState
			return t && t.objectMode === !1 && t.ended === !0 && Number.isFinite(t.length) ? t.length : null
		} else {
			if (Aee(e)) return e.size != null ? e.size : null
			if (xee(e)) return e.byteLength
		}
		return null
	}
	function Eee(e) {
		return e && !!(e.destroyed || e[gee] || fB.isDestroyed?.(e))
	}
	function M3e(e, t) {
		e == null ||
			!hB(e) ||
			Eee(e) ||
			(typeof e.destroy == "function"
				? (Object.getPrototypeOf(e).constructor === A3e && (e.socket = null), e.destroy(t))
				: t &&
					queueMicrotask(() => {
						e.emit("error", t)
					}),
			e.destroyed !== !0 && (e[gee] = !0))
	}
	var F3e = /timeout=(\d+)/
	function Q3e(e) {
		let t = e.toString().match(F3e)
		return t ? parseInt(t[1], 10) * 1e3 : null
	}
	function bee(e) {
		return typeof e == "string"
			? (b3e[e] ?? e.toLowerCase())
			: (pee.lookup(e) ?? e.toString("latin1").toLowerCase())
	}
	function N3e(e) {
		return pee.lookup(e) ?? e.toString("latin1").toLowerCase()
	}
	function P3e(e, t) {
		t === void 0 && (t = {})
		for (let r = 0; r < e.length; r += 2) {
			let n = bee(e[r]),
				i = t[n]
			if (i) typeof i == "string" && ((i = [i]), (t[n] = i)), i.push(e[r + 1].toString("utf8"))
			else {
				let s = e[r + 1]
				typeof s == "string"
					? (t[n] = s)
					: (t[n] = Array.isArray(s) ? s.map((o) => o.toString("utf8")) : s.toString("utf8"))
			}
		}
		return (
			"content-length" in t &&
				"content-disposition" in t &&
				(t["content-disposition"] = Buffer.from(t["content-disposition"]).toString("latin1")),
			t
		)
	}
	function L3e(e) {
		let t = e.length,
			r = new Array(t),
			n = !1,
			i = -1,
			s,
			o,
			a = 0
		for (let l = 0; l < e.length; l += 2)
			(s = e[l]),
				(o = e[l + 1]),
				typeof s != "string" && (s = s.toString()),
				typeof o != "string" && (o = o.toString("utf8")),
				(a = s.length),
				a === 14 && s[7] === "-" && (s === "content-length" || s.toLowerCase() === "content-length")
					? (n = !0)
					: a === 19 &&
						s[7] === "-" &&
						(s === "content-disposition" || s.toLowerCase() === "content-disposition") &&
						(i = l + 1),
				(r[l] = s),
				(r[l + 1] = o)
		return n && i !== -1 && (r[i] = Buffer.from(r[i]).toString("latin1")), r
	}
	function xee(e) {
		return e instanceof Uint8Array || Buffer.isBuffer(e)
	}
	function U3e(e, t, r) {
		if (!e || typeof e != "object") throw new Ji("handler must be an object")
		if (typeof e.onConnect != "function") throw new Ji("invalid onConnect method")
		if (typeof e.onError != "function") throw new Ji("invalid onError method")
		if (typeof e.onBodySent != "function" && e.onBodySent !== void 0) throw new Ji("invalid onBodySent method")
		if (r || t === "CONNECT") {
			if (typeof e.onUpgrade != "function") throw new Ji("invalid onUpgrade method")
		} else {
			if (typeof e.onHeaders != "function") throw new Ji("invalid onHeaders method")
			if (typeof e.onData != "function") throw new Ji("invalid onData method")
			if (typeof e.onComplete != "function") throw new Ji("invalid onComplete method")
		}
	}
	function O3e(e) {
		return !!(e && (fB.isDisturbed(e) || e[Gm]))
	}
	function q3e(e) {
		return !!(e && fB.isErrored(e))
	}
	function V3e(e) {
		return !!(e && fB.isReadable(e))
	}
	function H3e(e) {
		return {
			localAddress: e.localAddress,
			localPort: e.localPort,
			remoteAddress: e.remoteAddress,
			remotePort: e.remotePort,
			remoteFamily: e.remoteFamily,
			timeout: e.timeout,
			bytesWritten: e.bytesWritten,
			bytesRead: e.bytesRead,
		}
	}
	function W3e(e) {
		let t
		return new ReadableStream({
			async start() {
				t = e[Symbol.asyncIterator]()
			},
			async pull(r) {
				let { done: n, value: i } = await t.next()
				if (n)
					queueMicrotask(() => {
						r.close(), r.byobRequest?.respond(0)
					})
				else {
					let s = Buffer.isBuffer(i) ? i : Buffer.from(i)
					s.byteLength && r.enqueue(new Uint8Array(s))
				}
				return r.desiredSize > 0
			},
			async cancel(r) {
				await t.return()
			},
			type: "bytes",
		})
	}
	function G3e(e) {
		return (
			e &&
			typeof e == "object" &&
			typeof e.append == "function" &&
			typeof e.delete == "function" &&
			typeof e.get == "function" &&
			typeof e.getAll == "function" &&
			typeof e.has == "function" &&
			typeof e.set == "function" &&
			e[Symbol.toStringTag] === "FormData"
		)
	}
	function $3e(e, t) {
		return "addEventListener" in e
			? (e.addEventListener("abort", t, { once: !0 }), () => e.removeEventListener("abort", t))
			: (e.addListener("abort", t), () => e.removeListener("abort", t))
	}
	var Y3e = typeof String.prototype.toWellFormed == "function",
		K3e = typeof String.prototype.isWellFormed == "function"
	function _ee(e) {
		return Y3e ? `${e}`.toWellFormed() : C3e.toUSVString(e)
	}
	function J3e(e) {
		return K3e ? `${e}`.isWellFormed() : _ee(e) === `${e}`
	}
	function wee(e) {
		switch (e) {
			case 34:
			case 40:
			case 41:
			case 44:
			case 47:
			case 58:
			case 59:
			case 60:
			case 61:
			case 62:
			case 63:
			case 64:
			case 91:
			case 92:
			case 93:
			case 123:
			case 125:
				return !1
			default:
				return e >= 33 && e <= 126
		}
	}
	function z3e(e) {
		if (e.length === 0) return !1
		for (let t = 0; t < e.length; ++t) if (!wee(e.charCodeAt(t))) return !1
		return !0
	}
	var j3e = /[^\t\x20-\x7e\x80-\xff]/
	function Z3e(e) {
		return !j3e.test(e)
	}
	function X3e(e) {
		if (e == null || e === "") return { start: 0, end: null, size: null }
		let t = e ? e.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null
		return t
			? {
					start: parseInt(t[1]),
					end: t[2] ? parseInt(t[2]) : null,
					size: t[3] ? parseInt(t[3]) : null,
				}
			: null
	}
	function eHe(e, t, r) {
		return (e[dO] ??= []).push([t, r]), e.on(t, r), e
	}
	function tHe(e) {
		for (let [t, r] of e[dO] ?? []) e.removeListener(t, r)
		e[dO] = null
	}
	function rHe(e, t, r) {
		try {
			t.onError(r), xE(t.aborted)
		} catch (n) {
			e.emit("error", n)
		}
	}
	var Iee = Object.create(null)
	Iee.enumerable = !0
	var fO = {
			delete: "DELETE",
			DELETE: "DELETE",
			get: "GET",
			GET: "GET",
			head: "HEAD",
			HEAD: "HEAD",
			options: "OPTIONS",
			OPTIONS: "OPTIONS",
			post: "POST",
			POST: "POST",
			put: "PUT",
			PUT: "PUT",
		},
		See = { ...fO, patch: "patch", PATCH: "PATCH" }
	Object.setPrototypeOf(fO, null)
	Object.setPrototypeOf(See, null)
	Bee.exports = {
		kEnumerableProperty: Iee,
		nop: I3e,
		isDisturbed: O3e,
		isErrored: q3e,
		isReadable: V3e,
		toUSVString: _ee,
		isUSVString: J3e,
		isBlobLike: Aee,
		parseOrigin: B3e,
		parseURL: yee,
		getServerName: T3e,
		isStream: hB,
		isIterable: Cee,
		isAsyncIterable: k3e,
		isDestroyed: Eee,
		headerNameToString: bee,
		bufferToLowerCasedHeaderName: N3e,
		addListener: eHe,
		removeAllListeners: tHe,
		errorRequest: rHe,
		parseRawHeaders: L3e,
		parseHeaders: P3e,
		parseKeepAliveTimeout: Q3e,
		destroy: M3e,
		bodyLength: vee,
		deepClone: R3e,
		ReadableStreamFrom: W3e,
		isBuffer: xee,
		validateHandler: U3e,
		getSocketInfo: H3e,
		isFormDataLike: G3e,
		buildURL: S3e,
		addAbortListener: $3e,
		isValidHTTPToken: z3e,
		isValidHeaderValue: Z3e,
		isTokenCharCode: wee,
		parseRangeHeader: X3e,
		normalizedMethodRecordsBase: fO,
		normalizedMethodRecords: See,
		isValidPort: mee,
		isHttpOrHttpsPrefixed: uB,
		nodeMajor: x3e,
		nodeMinor: _3e,
		safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
		wrapRequestBody: w3e,
	}
})
var $m = x((Gwt, Tee) => {
	"use strict"
	var jr = require("diagnostics_channel"),
		gO = require("util"),
		gB = gO.debuglog("undici"),
		hO = gO.debuglog("fetch"),
		tp = gO.debuglog("websocket"),
		Dee = !1,
		nHe = {
			beforeConnect: jr.channel("undici:client:beforeConnect"),
			connected: jr.channel("undici:client:connected"),
			connectError: jr.channel("undici:client:connectError"),
			sendHeaders: jr.channel("undici:client:sendHeaders"),
			create: jr.channel("undici:request:create"),
			bodySent: jr.channel("undici:request:bodySent"),
			headers: jr.channel("undici:request:headers"),
			trailers: jr.channel("undici:request:trailers"),
			error: jr.channel("undici:request:error"),
			open: jr.channel("undici:websocket:open"),
			close: jr.channel("undici:websocket:close"),
			socketError: jr.channel("undici:websocket:socket_error"),
			ping: jr.channel("undici:websocket:ping"),
			pong: jr.channel("undici:websocket:pong"),
		}
	if (gB.enabled || hO.enabled) {
		let e = hO.enabled ? hO : gB
		jr.channel("undici:client:beforeConnect").subscribe((t) => {
			let {
				connectParams: { version: r, protocol: n, port: i, host: s },
			} = t
			e("connecting to %s using %s%s", `${s}${i ? `:${i}` : ""}`, n, r)
		}),
			jr.channel("undici:client:connected").subscribe((t) => {
				let {
					connectParams: { version: r, protocol: n, port: i, host: s },
				} = t
				e("connected to %s using %s%s", `${s}${i ? `:${i}` : ""}`, n, r)
			}),
			jr.channel("undici:client:connectError").subscribe((t) => {
				let {
					connectParams: { version: r, protocol: n, port: i, host: s },
					error: o,
				} = t
				e("connection to %s using %s%s errored - %s", `${s}${i ? `:${i}` : ""}`, n, r, o.message)
			}),
			jr.channel("undici:client:sendHeaders").subscribe((t) => {
				let {
					request: { method: r, path: n, origin: i },
				} = t
				e("sending request to %s %s/%s", r, i, n)
			}),
			jr.channel("undici:request:headers").subscribe((t) => {
				let {
					request: { method: r, path: n, origin: i },
					response: { statusCode: s },
				} = t
				e("received response to %s %s/%s - HTTP %d", r, i, n, s)
			}),
			jr.channel("undici:request:trailers").subscribe((t) => {
				let {
					request: { method: r, path: n, origin: i },
				} = t
				e("trailers received from %s %s/%s", r, i, n)
			}),
			jr.channel("undici:request:error").subscribe((t) => {
				let {
					request: { method: r, path: n, origin: i },
					error: s,
				} = t
				e("request to %s %s/%s errored - %s", r, i, n, s.message)
			}),
			(Dee = !0)
	}
	if (tp.enabled) {
		if (!Dee) {
			let e = gB.enabled ? gB : tp
			jr.channel("undici:client:beforeConnect").subscribe((t) => {
				let {
					connectParams: { version: r, protocol: n, port: i, host: s },
				} = t
				e("connecting to %s%s using %s%s", s, i ? `:${i}` : "", n, r)
			}),
				jr.channel("undici:client:connected").subscribe((t) => {
					let {
						connectParams: { version: r, protocol: n, port: i, host: s },
					} = t
					e("connected to %s%s using %s%s", s, i ? `:${i}` : "", n, r)
				}),
				jr.channel("undici:client:connectError").subscribe((t) => {
					let {
						connectParams: { version: r, protocol: n, port: i, host: s },
						error: o,
					} = t
					e("connection to %s%s using %s%s errored - %s", s, i ? `:${i}` : "", n, r, o.message)
				}),
				jr.channel("undici:client:sendHeaders").subscribe((t) => {
					let {
						request: { method: r, path: n, origin: i },
					} = t
					e("sending request to %s %s/%s", r, i, n)
				})
		}
		jr.channel("undici:websocket:open").subscribe((e) => {
			let {
				address: { address: t, port: r },
			} = e
			tp("connection opened %s%s", t, r ? `:${r}` : "")
		}),
			jr.channel("undici:websocket:close").subscribe((e) => {
				let { websocket: t, code: r, reason: n } = e
				tp("closed connection to %s - %s %s", t.url, r, n)
			}),
			jr.channel("undici:websocket:socket_error").subscribe((e) => {
				tp("connection errored - %s", e.message)
			}),
			jr.channel("undici:websocket:ping").subscribe((e) => {
				tp("ping received")
			}),
			jr.channel("undici:websocket:pong").subscribe((e) => {
				tp("pong received")
			})
	}
	Tee.exports = { channels: nHe }
})
var Qee = x(($wt, Fee) => {
	"use strict"
	var { InvalidArgumentError: Hn, NotSupportedError: iHe } = Vr(),
		_d = require("assert"),
		{
			isValidHTTPToken: Mee,
			isValidHeaderValue: Ree,
			isStream: sHe,
			destroy: oHe,
			isBuffer: aHe,
			isFormDataLike: lHe,
			isIterable: cHe,
			isBlobLike: uHe,
			buildURL: dHe,
			validateHandler: fHe,
			getServerName: hHe,
			normalizedMethodRecords: gHe,
		} = Xt(),
		{ channels: eu } = $m(),
		{ headerNameLowerCasedRecord: kee } = lB(),
		pHe = /[^\u0021-\u00ff]/,
		tl = Symbol("handler"),
		pO = class {
			constructor(
				t,
				{
					path: r,
					method: n,
					body: i,
					headers: s,
					query: o,
					idempotent: a,
					blocking: l,
					upgrade: c,
					headersTimeout: u,
					bodyTimeout: f,
					reset: p,
					throwOnError: g,
					expectContinue: m,
					servername: y,
				},
				C,
			) {
				if (typeof r != "string") throw new Hn("path must be a string")
				if (r[0] !== "/" && !(r.startsWith("http://") || r.startsWith("https://")) && n !== "CONNECT")
					throw new Hn("path must be an absolute URL or start with a slash")
				if (pHe.test(r)) throw new Hn("invalid request path")
				if (typeof n != "string") throw new Hn("method must be a string")
				if (gHe[n] === void 0 && !Mee(n)) throw new Hn("invalid request method")
				if (c && typeof c != "string") throw new Hn("upgrade must be a string")
				if (u != null && (!Number.isFinite(u) || u < 0)) throw new Hn("invalid headersTimeout")
				if (f != null && (!Number.isFinite(f) || f < 0)) throw new Hn("invalid bodyTimeout")
				if (p != null && typeof p != "boolean") throw new Hn("invalid reset")
				if (m != null && typeof m != "boolean") throw new Hn("invalid expectContinue")
				if (
					((this.headersTimeout = u),
					(this.bodyTimeout = f),
					(this.throwOnError = g === !0),
					(this.method = n),
					(this.abort = null),
					i == null)
				)
					this.body = null
				else if (sHe(i)) {
					this.body = i
					let v = this.body._readableState
					;(!v || !v.autoDestroy) &&
						((this.endHandler = function () {
							oHe(this)
						}),
						this.body.on("end", this.endHandler)),
						(this.errorHandler = (b) => {
							this.abort ? this.abort(b) : (this.error = b)
						}),
						this.body.on("error", this.errorHandler)
				} else if (aHe(i)) this.body = i.byteLength ? i : null
				else if (ArrayBuffer.isView(i))
					this.body = i.buffer.byteLength ? Buffer.from(i.buffer, i.byteOffset, i.byteLength) : null
				else if (i instanceof ArrayBuffer) this.body = i.byteLength ? Buffer.from(i) : null
				else if (typeof i == "string") this.body = i.length ? Buffer.from(i) : null
				else if (lHe(i) || cHe(i) || uHe(i)) this.body = i
				else
					throw new Hn(
						"body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable",
					)
				if (
					((this.completed = !1),
					(this.aborted = !1),
					(this.upgrade = c || null),
					(this.path = o ? dHe(r, o) : r),
					(this.origin = t),
					(this.idempotent = a ?? (n === "HEAD" || n === "GET")),
					(this.blocking = l ?? !1),
					(this.reset = p ?? null),
					(this.host = null),
					(this.contentLength = null),
					(this.contentType = null),
					(this.headers = []),
					(this.expectContinue = m ?? !1),
					Array.isArray(s))
				) {
					if (s.length % 2 !== 0) throw new Hn("headers array must be even")
					for (let v = 0; v < s.length; v += 2) pB(this, s[v], s[v + 1])
				} else if (s && typeof s == "object")
					if (s[Symbol.iterator])
						for (let v of s) {
							if (!Array.isArray(v) || v.length !== 2)
								throw new Hn("headers must be in key-value pair format")
							pB(this, v[0], v[1])
						}
					else {
						let v = Object.keys(s)
						for (let b = 0; b < v.length; ++b) pB(this, v[b], s[v[b]])
					}
				else if (s != null) throw new Hn("headers must be an object or an array")
				fHe(C, n, c),
					(this.servername = y || hHe(this.host)),
					(this[tl] = C),
					eu.create.hasSubscribers && eu.create.publish({ request: this })
			}
			onBodySent(t) {
				if (this[tl].onBodySent)
					try {
						return this[tl].onBodySent(t)
					} catch (r) {
						this.abort(r)
					}
			}
			onRequestSent() {
				if ((eu.bodySent.hasSubscribers && eu.bodySent.publish({ request: this }), this[tl].onRequestSent))
					try {
						return this[tl].onRequestSent()
					} catch (t) {
						this.abort(t)
					}
			}
			onConnect(t) {
				if ((_d(!this.aborted), _d(!this.completed), this.error)) t(this.error)
				else return (this.abort = t), this[tl].onConnect(t)
			}
			onResponseStarted() {
				return this[tl].onResponseStarted?.()
			}
			onHeaders(t, r, n, i) {
				_d(!this.aborted),
					_d(!this.completed),
					eu.headers.hasSubscribers &&
						eu.headers.publish({
							request: this,
							response: { statusCode: t, headers: r, statusText: i },
						})
				try {
					return this[tl].onHeaders(t, r, n, i)
				} catch (s) {
					this.abort(s)
				}
			}
			onData(t) {
				_d(!this.aborted), _d(!this.completed)
				try {
					return this[tl].onData(t)
				} catch (r) {
					return this.abort(r), !1
				}
			}
			onUpgrade(t, r, n) {
				return _d(!this.aborted), _d(!this.completed), this[tl].onUpgrade(t, r, n)
			}
			onComplete(t) {
				this.onFinally(),
					_d(!this.aborted),
					(this.completed = !0),
					eu.trailers.hasSubscribers && eu.trailers.publish({ request: this, trailers: t })
				try {
					return this[tl].onComplete(t)
				} catch (r) {
					this.onError(r)
				}
			}
			onError(t) {
				if (
					(this.onFinally(),
					eu.error.hasSubscribers && eu.error.publish({ request: this, error: t }),
					!this.aborted)
				)
					return (this.aborted = !0), this[tl].onError(t)
			}
			onFinally() {
				this.errorHandler && (this.body.off("error", this.errorHandler), (this.errorHandler = null)),
					this.endHandler && (this.body.off("end", this.endHandler), (this.endHandler = null))
			}
			addHeader(t, r) {
				return pB(this, t, r), this
			}
		}
	function pB(e, t, r) {
		if (r && typeof r == "object" && !Array.isArray(r)) throw new Hn(`invalid ${t} header`)
		if (r === void 0) return
		let n = kee[t]
		if (n === void 0 && ((n = t.toLowerCase()), kee[n] === void 0 && !Mee(n))) throw new Hn("invalid header key")
		if (Array.isArray(r)) {
			let i = []
			for (let s = 0; s < r.length; s++)
				if (typeof r[s] == "string") {
					if (!Ree(r[s])) throw new Hn(`invalid ${t} header`)
					i.push(r[s])
				} else if (r[s] === null) i.push("")
				else {
					if (typeof r[s] == "object") throw new Hn(`invalid ${t} header`)
					i.push(`${r[s]}`)
				}
			r = i
		} else if (typeof r == "string") {
			if (!Ree(r)) throw new Hn(`invalid ${t} header`)
		} else r === null ? (r = "") : (r = `${r}`)
		if (e.host === null && n === "host") {
			if (typeof r != "string") throw new Hn("invalid host header")
			e.host = r
		} else if (e.contentLength === null && n === "content-length") {
			if (((e.contentLength = parseInt(r, 10)), !Number.isFinite(e.contentLength)))
				throw new Hn("invalid content-length header")
		} else if (e.contentType === null && n === "content-type") (e.contentType = r), e.headers.push(t, r)
		else {
			if (n === "transfer-encoding" || n === "keep-alive" || n === "upgrade") throw new Hn(`invalid ${n} header`)
			if (n === "connection") {
				let i = typeof r == "string" ? r.toLowerCase() : null
				if (i !== "close" && i !== "keep-alive") throw new Hn("invalid connection header")
				i === "close" && (e.reset = !0)
			} else {
				if (n === "expect") throw new iHe("expect header not supported")
				e.headers.push(t, r)
			}
		}
	}
	Fee.exports = pO
})
var _E = x((Ywt, Nee) => {
	"use strict"
	var AHe = require("events"),
		AB = class extends AHe {
			dispatch() {
				throw new Error("not implemented")
			}
			close() {
				throw new Error("not implemented")
			}
			destroy() {
				throw new Error("not implemented")
			}
			compose(...t) {
				let r = Array.isArray(t[0]) ? t[0] : t,
					n = this.dispatch.bind(this)
				for (let i of r)
					if (i != null) {
						if (typeof i != "function")
							throw new TypeError(`invalid interceptor, expected function received ${typeof i}`)
						if (((n = i(n)), n == null || typeof n != "function" || n.length !== 2))
							throw new TypeError("invalid interceptor")
					}
				return new AO(this, n)
			}
		},
		AO = class extends AB {
			#e = null
			#t = null
			constructor(t, r) {
				super(), (this.#e = t), (this.#t = r)
			}
			dispatch(...t) {
				this.#t(...t)
			}
			close(...t) {
				return this.#e.close(...t)
			}
			destroy(...t) {
				return this.#e.destroy(...t)
			}
		}
	Nee.exports = AB
})
var zm = x((Kwt, Pee) => {
	"use strict"
	var mHe = _E(),
		{ ClientDestroyedError: mO, ClientClosedError: yHe, InvalidArgumentError: Ym } = Vr(),
		{ kDestroy: CHe, kClose: vHe, kClosed: wE, kDestroyed: Km, kDispatch: yO, kInterceptors: rp } = Qn(),
		wd = Symbol("onDestroyed"),
		Jm = Symbol("onClosed"),
		mB = Symbol("Intercepted Dispatch"),
		CO = class extends mHe {
			constructor() {
				super(), (this[Km] = !1), (this[wd] = null), (this[wE] = !1), (this[Jm] = [])
			}
			get destroyed() {
				return this[Km]
			}
			get closed() {
				return this[wE]
			}
			get interceptors() {
				return this[rp]
			}
			set interceptors(t) {
				if (t) {
					for (let r = t.length - 1; r >= 0; r--)
						if (typeof this[rp][r] != "function") throw new Ym("interceptor must be an function")
				}
				this[rp] = t
			}
			close(t) {
				if (t === void 0)
					return new Promise((n, i) => {
						this.close((s, o) => (s ? i(s) : n(o)))
					})
				if (typeof t != "function") throw new Ym("invalid callback")
				if (this[Km]) {
					queueMicrotask(() => t(new mO(), null))
					return
				}
				if (this[wE]) {
					this[Jm] ? this[Jm].push(t) : queueMicrotask(() => t(null, null))
					return
				}
				;(this[wE] = !0), this[Jm].push(t)
				let r = () => {
					let n = this[Jm]
					this[Jm] = null
					for (let i = 0; i < n.length; i++) n[i](null, null)
				}
				this[vHe]()
					.then(() => this.destroy())
					.then(() => {
						queueMicrotask(r)
					})
			}
			destroy(t, r) {
				if ((typeof t == "function" && ((r = t), (t = null)), r === void 0))
					return new Promise((i, s) => {
						this.destroy(t, (o, a) => (o ? s(o) : i(a)))
					})
				if (typeof r != "function") throw new Ym("invalid callback")
				if (this[Km]) {
					this[wd] ? this[wd].push(r) : queueMicrotask(() => r(null, null))
					return
				}
				t || (t = new mO()), (this[Km] = !0), (this[wd] = this[wd] || []), this[wd].push(r)
				let n = () => {
					let i = this[wd]
					this[wd] = null
					for (let s = 0; s < i.length; s++) i[s](null, null)
				}
				this[CHe](t).then(() => {
					queueMicrotask(n)
				})
			}
			[mB](t, r) {
				if (!this[rp] || this[rp].length === 0) return (this[mB] = this[yO]), this[yO](t, r)
				let n = this[yO].bind(this)
				for (let i = this[rp].length - 1; i >= 0; i--) n = this[rp][i](n)
				return (this[mB] = n), n(t, r)
			}
			dispatch(t, r) {
				if (!r || typeof r != "object") throw new Ym("handler must be an object")
				try {
					if (!t || typeof t != "object") throw new Ym("opts must be an object.")
					if (this[Km] || this[wd]) throw new mO()
					if (this[wE]) throw new yHe()
					return this[mB](t, r)
				} catch (n) {
					if (typeof r.onError != "function") throw new Ym("invalid onError method")
					return r.onError(n), !1
				}
			}
		}
	Pee.exports = CO
})
var IO = x((Jwt, qee) => {
	"use strict"
	var jm = 0,
		vO = 1e3,
		EO = (vO >> 1) - 1,
		Id,
		bO = Symbol("kFastTimer"),
		Sd = [],
		xO = -2,
		_O = -1,
		Uee = 0,
		Lee = 1
	function wO() {
		jm += EO
		let e = 0,
			t = Sd.length
		for (; e < t; ) {
			let r = Sd[e]
			r._state === Uee
				? ((r._idleStart = jm - EO), (r._state = Lee))
				: r._state === Lee &&
					jm >= r._idleStart + r._idleTimeout &&
					((r._state = _O), (r._idleStart = -1), r._onTimeout(r._timerArg)),
				r._state === _O ? ((r._state = xO), --t !== 0 && (Sd[e] = Sd[t])) : ++e
		}
		;(Sd.length = t), Sd.length !== 0 && Oee()
	}
	function Oee() {
		Id ? Id.refresh() : (clearTimeout(Id), (Id = setTimeout(wO, EO)), Id.unref && Id.unref())
	}
	var yB = class {
		[bO] = !0
		_state = xO
		_idleTimeout = -1
		_idleStart = -1
		_onTimeout
		_timerArg
		constructor(t, r, n) {
			;(this._onTimeout = t), (this._idleTimeout = r), (this._timerArg = n), this.refresh()
		}
		refresh() {
			this._state === xO && Sd.push(this), (!Id || Sd.length === 1) && Oee(), (this._state = Uee)
		}
		clear() {
			;(this._state = _O), (this._idleStart = -1)
		}
	}
	qee.exports = {
		setTimeout(e, t, r) {
			return t <= vO ? setTimeout(e, t, r) : new yB(e, t, r)
		},
		clearTimeout(e) {
			e[bO] ? e.clear() : clearTimeout(e)
		},
		setFastTimeout(e, t, r) {
			return new yB(e, t, r)
		},
		clearFastTimeout(e) {
			e.clear()
		},
		now() {
			return jm
		},
		tick(e = 0) {
			;(jm += e - vO + 1), wO(), wO()
		},
		reset() {
			;(jm = 0), (Sd.length = 0), clearTimeout(Id), (Id = null)
		},
		kFastTimer: bO,
	}
})
var IE = x((Zwt, $ee) => {
	"use strict"
	var EHe = require("net"),
		Vee = require("assert"),
		Gee = Xt(),
		{ InvalidArgumentError: bHe, ConnectTimeoutError: xHe } = Vr(),
		CB = IO()
	function Hee() {}
	var SO, BO
	global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)
		? (BO = class {
				constructor(t) {
					;(this._maxCachedSessions = t),
						(this._sessionCache = new Map()),
						(this._sessionRegistry = new global.FinalizationRegistry((r) => {
							if (this._sessionCache.size < this._maxCachedSessions) return
							let n = this._sessionCache.get(r)
							n !== void 0 && n.deref() === void 0 && this._sessionCache.delete(r)
						}))
				}
				get(t) {
					let r = this._sessionCache.get(t)
					return r ? r.deref() : null
				}
				set(t, r) {
					this._maxCachedSessions !== 0 &&
						(this._sessionCache.set(t, new WeakRef(r)), this._sessionRegistry.register(r, t))
				}
			})
		: (BO = class {
				constructor(t) {
					;(this._maxCachedSessions = t), (this._sessionCache = new Map())
				}
				get(t) {
					return this._sessionCache.get(t)
				}
				set(t, r) {
					if (this._maxCachedSessions !== 0) {
						if (this._sessionCache.size >= this._maxCachedSessions) {
							let { value: n } = this._sessionCache.keys().next()
							this._sessionCache.delete(n)
						}
						this._sessionCache.set(t, r)
					}
				}
			})
	function _He({ allowH2: e, maxCachedSessions: t, socketPath: r, timeout: n, session: i, ...s }) {
		if (t != null && (!Number.isInteger(t) || t < 0))
			throw new bHe("maxCachedSessions must be a positive integer or zero")
		let o = { path: r, ...s },
			a = new BO(t ?? 100)
		return (
			(n = n ?? 1e4),
			(e = e ?? !1),
			function (
				{ hostname: c, host: u, protocol: f, port: p, servername: g, localAddress: m, httpSocket: y },
				C,
			) {
				let v
				if (f === "https:") {
					SO || (SO = require("tls")), (g = g || o.servername || Gee.getServerName(u) || null)
					let w = g || c
					Vee(w)
					let B = i || a.get(w) || null
					;(p = p || 443),
						(v = SO.connect({
							highWaterMark: 16384,
							...o,
							servername: g,
							session: B,
							localAddress: m,
							ALPNProtocols: e ? ["http/1.1", "h2"] : ["http/1.1"],
							socket: y,
							port: p,
							host: c,
						})),
						v.on("session", function (M) {
							a.set(w, M)
						})
				} else
					Vee(!y, "httpSocket can only be sent on TLS update"),
						(p = p || 80),
						(v = EHe.connect({
							highWaterMark: 64 * 1024,
							...o,
							localAddress: m,
							port: p,
							host: c,
						}))
				if (o.keepAlive == null || o.keepAlive) {
					let w = o.keepAliveInitialDelay === void 0 ? 6e4 : o.keepAliveInitialDelay
					v.setKeepAlive(!0, w)
				}
				let b = wHe(new WeakRef(v), { timeout: n, hostname: c, port: p })
				return (
					v
						.setNoDelay(!0)
						.once(f === "https:" ? "secureConnect" : "connect", function () {
							if ((queueMicrotask(b), C)) {
								let w = C
								;(C = null), w(null, this)
							}
						})
						.on("error", function (w) {
							if ((queueMicrotask(b), C)) {
								let B = C
								;(C = null), B(w)
							}
						}),
					v
				)
			}
		)
	}
	var wHe =
		process.platform === "win32"
			? (e, t) => {
					if (!t.timeout) return Hee
					let r = null,
						n = null,
						i = CB.setFastTimeout(() => {
							r = setImmediate(() => {
								n = setImmediate(() => Wee(e.deref(), t))
							})
						}, t.timeout)
					return () => {
						CB.clearFastTimeout(i), clearImmediate(r), clearImmediate(n)
					}
				}
			: (e, t) => {
					if (!t.timeout) return Hee
					let r = null,
						n = CB.setFastTimeout(() => {
							r = setImmediate(() => {
								Wee(e.deref(), t)
							})
						}, t.timeout)
					return () => {
						CB.clearFastTimeout(n), clearImmediate(r)
					}
				}
	function Wee(e, t) {
		if (e == null) return
		let r = "Connect Timeout Error"
		Array.isArray(e.autoSelectFamilyAttemptedAddresses)
			? (r += ` (attempted addresses: ${e.autoSelectFamilyAttemptedAddresses.join(", ")},`)
			: (r += ` (attempted address: ${t.hostname}:${t.port},`),
			(r += ` timeout: ${t.timeout}ms)`),
			Gee.destroy(e, new xHe(r))
	}
	$ee.exports = _He
})
var Yee = x((vB) => {
	"use strict"
	Object.defineProperty(vB, "__esModule", { value: !0 })
	vB.enumToMap = void 0
	function IHe(e) {
		let t = {}
		return (
			Object.keys(e).forEach((r) => {
				let n = e[r]
				typeof n == "number" && (t[r] = n)
			}),
			t
		)
	}
	vB.enumToMap = IHe
})
var Kee = x((_e) => {
	"use strict"
	Object.defineProperty(_e, "__esModule", { value: !0 })
	_e.SPECIAL_HEADERS =
		_e.HEADER_STATE =
		_e.MINOR =
		_e.MAJOR =
		_e.CONNECTION_TOKEN_CHARS =
		_e.HEADER_CHARS =
		_e.TOKEN =
		_e.STRICT_TOKEN =
		_e.HEX =
		_e.URL_CHAR =
		_e.STRICT_URL_CHAR =
		_e.USERINFO_CHARS =
		_e.MARK =
		_e.ALPHANUM =
		_e.NUM =
		_e.HEX_MAP =
		_e.NUM_MAP =
		_e.ALPHA =
		_e.FINISH =
		_e.H_METHOD_MAP =
		_e.METHOD_MAP =
		_e.METHODS_RTSP =
		_e.METHODS_ICE =
		_e.METHODS_HTTP =
		_e.METHODS =
		_e.LENIENT_FLAGS =
		_e.FLAGS =
		_e.TYPE =
		_e.ERROR =
			void 0
	var SHe = Yee(),
		BHe
	;(function (e) {
		;(e[(e.OK = 0)] = "OK"),
			(e[(e.INTERNAL = 1)] = "INTERNAL"),
			(e[(e.STRICT = 2)] = "STRICT"),
			(e[(e.LF_EXPECTED = 3)] = "LF_EXPECTED"),
			(e[(e.UNEXPECTED_CONTENT_LENGTH = 4)] = "UNEXPECTED_CONTENT_LENGTH"),
			(e[(e.CLOSED_CONNECTION = 5)] = "CLOSED_CONNECTION"),
			(e[(e.INVALID_METHOD = 6)] = "INVALID_METHOD"),
			(e[(e.INVALID_URL = 7)] = "INVALID_URL"),
			(e[(e.INVALID_CONSTANT = 8)] = "INVALID_CONSTANT"),
			(e[(e.INVALID_VERSION = 9)] = "INVALID_VERSION"),
			(e[(e.INVALID_HEADER_TOKEN = 10)] = "INVALID_HEADER_TOKEN"),
			(e[(e.INVALID_CONTENT_LENGTH = 11)] = "INVALID_CONTENT_LENGTH"),
			(e[(e.INVALID_CHUNK_SIZE = 12)] = "INVALID_CHUNK_SIZE"),
			(e[(e.INVALID_STATUS = 13)] = "INVALID_STATUS"),
			(e[(e.INVALID_EOF_STATE = 14)] = "INVALID_EOF_STATE"),
			(e[(e.INVALID_TRANSFER_ENCODING = 15)] = "INVALID_TRANSFER_ENCODING"),
			(e[(e.CB_MESSAGE_BEGIN = 16)] = "CB_MESSAGE_BEGIN"),
			(e[(e.CB_HEADERS_COMPLETE = 17)] = "CB_HEADERS_COMPLETE"),
			(e[(e.CB_MESSAGE_COMPLETE = 18)] = "CB_MESSAGE_COMPLETE"),
			(e[(e.CB_CHUNK_HEADER = 19)] = "CB_CHUNK_HEADER"),
			(e[(e.CB_CHUNK_COMPLETE = 20)] = "CB_CHUNK_COMPLETE"),
			(e[(e.PAUSED = 21)] = "PAUSED"),
			(e[(e.PAUSED_UPGRADE = 22)] = "PAUSED_UPGRADE"),
			(e[(e.PAUSED_H2_UPGRADE = 23)] = "PAUSED_H2_UPGRADE"),
			(e[(e.USER = 24)] = "USER")
	})((BHe = _e.ERROR || (_e.ERROR = {})))
	var DHe
	;(function (e) {
		;(e[(e.BOTH = 0)] = "BOTH"), (e[(e.REQUEST = 1)] = "REQUEST"), (e[(e.RESPONSE = 2)] = "RESPONSE")
	})((DHe = _e.TYPE || (_e.TYPE = {})))
	var THe
	;(function (e) {
		;(e[(e.CONNECTION_KEEP_ALIVE = 1)] = "CONNECTION_KEEP_ALIVE"),
			(e[(e.CONNECTION_CLOSE = 2)] = "CONNECTION_CLOSE"),
			(e[(e.CONNECTION_UPGRADE = 4)] = "CONNECTION_UPGRADE"),
			(e[(e.CHUNKED = 8)] = "CHUNKED"),
			(e[(e.UPGRADE = 16)] = "UPGRADE"),
			(e[(e.CONTENT_LENGTH = 32)] = "CONTENT_LENGTH"),
			(e[(e.SKIPBODY = 64)] = "SKIPBODY"),
			(e[(e.TRAILING = 128)] = "TRAILING"),
			(e[(e.TRANSFER_ENCODING = 512)] = "TRANSFER_ENCODING")
	})((THe = _e.FLAGS || (_e.FLAGS = {})))
	var RHe
	;(function (e) {
		;(e[(e.HEADERS = 1)] = "HEADERS"),
			(e[(e.CHUNKED_LENGTH = 2)] = "CHUNKED_LENGTH"),
			(e[(e.KEEP_ALIVE = 4)] = "KEEP_ALIVE")
	})((RHe = _e.LENIENT_FLAGS || (_e.LENIENT_FLAGS = {})))
	var at
	;(function (e) {
		;(e[(e.DELETE = 0)] = "DELETE"),
			(e[(e.GET = 1)] = "GET"),
			(e[(e.HEAD = 2)] = "HEAD"),
			(e[(e.POST = 3)] = "POST"),
			(e[(e.PUT = 4)] = "PUT"),
			(e[(e.CONNECT = 5)] = "CONNECT"),
			(e[(e.OPTIONS = 6)] = "OPTIONS"),
			(e[(e.TRACE = 7)] = "TRACE"),
			(e[(e.COPY = 8)] = "COPY"),
			(e[(e.LOCK = 9)] = "LOCK"),
			(e[(e.MKCOL = 10)] = "MKCOL"),
			(e[(e.MOVE = 11)] = "MOVE"),
			(e[(e.PROPFIND = 12)] = "PROPFIND"),
			(e[(e.PROPPATCH = 13)] = "PROPPATCH"),
			(e[(e.SEARCH = 14)] = "SEARCH"),
			(e[(e.UNLOCK = 15)] = "UNLOCK"),
			(e[(e.BIND = 16)] = "BIND"),
			(e[(e.REBIND = 17)] = "REBIND"),
			(e[(e.UNBIND = 18)] = "UNBIND"),
			(e[(e.ACL = 19)] = "ACL"),
			(e[(e.REPORT = 20)] = "REPORT"),
			(e[(e.MKACTIVITY = 21)] = "MKACTIVITY"),
			(e[(e.CHECKOUT = 22)] = "CHECKOUT"),
			(e[(e.MERGE = 23)] = "MERGE"),
			(e[(e["M-SEARCH"] = 24)] = "M-SEARCH"),
			(e[(e.NOTIFY = 25)] = "NOTIFY"),
			(e[(e.SUBSCRIBE = 26)] = "SUBSCRIBE"),
			(e[(e.UNSUBSCRIBE = 27)] = "UNSUBSCRIBE"),
			(e[(e.PATCH = 28)] = "PATCH"),
			(e[(e.PURGE = 29)] = "PURGE"),
			(e[(e.MKCALENDAR = 30)] = "MKCALENDAR"),
			(e[(e.LINK = 31)] = "LINK"),
			(e[(e.UNLINK = 32)] = "UNLINK"),
			(e[(e.SOURCE = 33)] = "SOURCE"),
			(e[(e.PRI = 34)] = "PRI"),
			(e[(e.DESCRIBE = 35)] = "DESCRIBE"),
			(e[(e.ANNOUNCE = 36)] = "ANNOUNCE"),
			(e[(e.SETUP = 37)] = "SETUP"),
			(e[(e.PLAY = 38)] = "PLAY"),
			(e[(e.PAUSE = 39)] = "PAUSE"),
			(e[(e.TEARDOWN = 40)] = "TEARDOWN"),
			(e[(e.GET_PARAMETER = 41)] = "GET_PARAMETER"),
			(e[(e.SET_PARAMETER = 42)] = "SET_PARAMETER"),
			(e[(e.REDIRECT = 43)] = "REDIRECT"),
			(e[(e.RECORD = 44)] = "RECORD"),
			(e[(e.FLUSH = 45)] = "FLUSH")
	})((at = _e.METHODS || (_e.METHODS = {})))
	_e.METHODS_HTTP = [
		at.DELETE,
		at.GET,
		at.HEAD,
		at.POST,
		at.PUT,
		at.CONNECT,
		at.OPTIONS,
		at.TRACE,
		at.COPY,
		at.LOCK,
		at.MKCOL,
		at.MOVE,
		at.PROPFIND,
		at.PROPPATCH,
		at.SEARCH,
		at.UNLOCK,
		at.BIND,
		at.REBIND,
		at.UNBIND,
		at.ACL,
		at.REPORT,
		at.MKACTIVITY,
		at.CHECKOUT,
		at.MERGE,
		at["M-SEARCH"],
		at.NOTIFY,
		at.SUBSCRIBE,
		at.UNSUBSCRIBE,
		at.PATCH,
		at.PURGE,
		at.MKCALENDAR,
		at.LINK,
		at.UNLINK,
		at.PRI,
		at.SOURCE,
	]
	_e.METHODS_ICE = [at.SOURCE]
	_e.METHODS_RTSP = [
		at.OPTIONS,
		at.DESCRIBE,
		at.ANNOUNCE,
		at.SETUP,
		at.PLAY,
		at.PAUSE,
		at.TEARDOWN,
		at.GET_PARAMETER,
		at.SET_PARAMETER,
		at.REDIRECT,
		at.RECORD,
		at.FLUSH,
		at.GET,
		at.POST,
	]
	_e.METHOD_MAP = SHe.enumToMap(at)
	_e.H_METHOD_MAP = {}
	Object.keys(_e.METHOD_MAP).forEach((e) => {
		;/^H/.test(e) && (_e.H_METHOD_MAP[e] = _e.METHOD_MAP[e])
	})
	var kHe
	;(function (e) {
		;(e[(e.SAFE = 0)] = "SAFE"), (e[(e.SAFE_WITH_CB = 1)] = "SAFE_WITH_CB"), (e[(e.UNSAFE = 2)] = "UNSAFE")
	})((kHe = _e.FINISH || (_e.FINISH = {})))
	_e.ALPHA = []
	for (let e = 65; e <= 90; e++) _e.ALPHA.push(String.fromCharCode(e)), _e.ALPHA.push(String.fromCharCode(e + 32))
	_e.NUM_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9 }
	_e.HEX_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		A: 10,
		B: 11,
		C: 12,
		D: 13,
		E: 14,
		F: 15,
		a: 10,
		b: 11,
		c: 12,
		d: 13,
		e: 14,
		f: 15,
	}
	_e.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
	_e.ALPHANUM = _e.ALPHA.concat(_e.NUM)
	_e.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"]
	_e.USERINFO_CHARS = _e.ALPHANUM.concat(_e.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","])
	_e.STRICT_URL_CHAR = [
		"!",
		'"',
		"$",
		"%",
		"&",
		"'",
		"(",
		")",
		"*",
		"+",
		",",
		"-",
		".",
		"/",
		":",
		";",
		"<",
		"=",
		">",
		"@",
		"[",
		"\\",
		"]",
		"^",
		"_",
		"`",
		"{",
		"|",
		"}",
		"~",
	].concat(_e.ALPHANUM)
	_e.URL_CHAR = _e.STRICT_URL_CHAR.concat(["	", "\f"])
	for (let e = 128; e <= 255; e++) _e.URL_CHAR.push(e)
	_e.HEX = _e.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"])
	_e.STRICT_TOKEN = ["!", "#", "$", "%", "&", "'", "*", "+", "-", ".", "^", "_", "`", "|", "~"].concat(_e.ALPHANUM)
	_e.TOKEN = _e.STRICT_TOKEN.concat([" "])
	_e.HEADER_CHARS = ["	"]
	for (let e = 32; e <= 255; e++) e !== 127 && _e.HEADER_CHARS.push(e)
	_e.CONNECTION_TOKEN_CHARS = _e.HEADER_CHARS.filter((e) => e !== 44)
	_e.MAJOR = _e.NUM_MAP
	_e.MINOR = _e.MAJOR
	var Zm
	;(function (e) {
		;(e[(e.GENERAL = 0)] = "GENERAL"),
			(e[(e.CONNECTION = 1)] = "CONNECTION"),
			(e[(e.CONTENT_LENGTH = 2)] = "CONTENT_LENGTH"),
			(e[(e.TRANSFER_ENCODING = 3)] = "TRANSFER_ENCODING"),
			(e[(e.UPGRADE = 4)] = "UPGRADE"),
			(e[(e.CONNECTION_KEEP_ALIVE = 5)] = "CONNECTION_KEEP_ALIVE"),
			(e[(e.CONNECTION_CLOSE = 6)] = "CONNECTION_CLOSE"),
			(e[(e.CONNECTION_UPGRADE = 7)] = "CONNECTION_UPGRADE"),
			(e[(e.TRANSFER_ENCODING_CHUNKED = 8)] = "TRANSFER_ENCODING_CHUNKED")
	})((Zm = _e.HEADER_STATE || (_e.HEADER_STATE = {})))
	_e.SPECIAL_HEADERS = {
		connection: Zm.CONNECTION,
		"content-length": Zm.CONTENT_LENGTH,
		"proxy-connection": Zm.CONNECTION,
		"transfer-encoding": Zm.TRANSFER_ENCODING,
		upgrade: Zm.UPGRADE,
	}
})
var DO = x((tIt, Jee) => {
	"use strict"
	var { Buffer: MHe } = require("buffer")
	Jee.exports = MHe.from(
		"AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIdbGxodHRwX3NldF9sZW5pZW50X2tlZXBfYWxpdmUAIyRsbGh0dHBfc2V0X2xlbmllbnRfdHJhbnNmZXJfZW5jb2RpbmcAJBhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YALgkXAQBBAQsRAQIDBAUKBgcrLSwqKSglJyYK07MCLBYAQYjQACgCAARAAAtBiNAAQQE2AgALFAAgABAwIAAgAjYCOCAAIAE6ACgLFAAgACAALwEyIAAtAC4gABAvEAALHgEBf0HAABAyIgEQMCABQYAINgI4IAEgADoAKCABC48MAQd/AkAgAEUNACAAQQhrIgEgAEEEaygCACIAQXhxIgRqIQUCQCAAQQFxDQAgAEEDcUUNASABIAEoAgAiAGsiAUGc0AAoAgBJDQEgACAEaiEEAkACQEGg0AAoAgAgAUcEQCAAQf8BTQRAIABBA3YhAyABKAIIIgAgASgCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyABKAIYIQYgASABKAIMIgBHBEAgACABKAIIIgI2AgggAiAANgIMDAMLIAFBFGoiAygCACICRQRAIAEoAhAiAkUNAiABQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFKAIEIgBBA3FBA0cNAiAFIABBfnE2AgRBlNAAIAQ2AgAgBSAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCABKAIcIgJBAnRBvNIAaiIDKAIAIAFGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgAUYbaiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAFTw0AIAUoAgQiAEEBcUUNAAJAAkACQAJAIABBAnFFBEBBpNAAKAIAIAVGBEBBpNAAIAE2AgBBmNAAQZjQACgCACAEaiIANgIAIAEgAEEBcjYCBCABQaDQACgCAEcNBkGU0ABBADYCAEGg0ABBADYCAAwGC0Gg0AAoAgAgBUYEQEGg0AAgATYCAEGU0ABBlNAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAwGCyAAQXhxIARqIQQgAEH/AU0EQCAAQQN2IQMgBSgCCCIAIAUoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgBSgCGCEGIAUgBSgCDCIARwRAQZzQACgCABogACAFKAIIIgI2AgggAiAANgIMDAMLIAVBFGoiAygCACICRQRAIAUoAhAiAkUNAiAFQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFIABBfnE2AgQgASAEaiAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCAFKAIcIgJBAnRBvNIAaiIDKAIAIAVGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiAANgIAIABFDQELIAAgBjYCGCAFKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAFQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAEaiAENgIAIAEgBEEBcjYCBCABQaDQACgCAEcNAEGU0AAgBDYCAAwBCyAEQf8BTQRAIARBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASAEQQN2dCIDcUUEQEGM0AAgAiADcjYCACAADAELIAAoAggLIgIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCAwBC0EfIQIgBEH///8HTQRAIARBJiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAgsgASACNgIcIAFCADcCECACQQJ0QbzSAGohAAJAQZDQACgCACIDQQEgAnQiB3FFBEAgACABNgIAQZDQACADIAdyNgIAIAEgADYCGCABIAE2AgggASABNgIMDAELIARBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAAJAA0AgACIDKAIEQXhxIARGDQEgAkEddiEAIAJBAXQhAiADIABBBHFqQRBqIgcoAgAiAA0ACyAHIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggMAQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0Gs0ABBrNAAKAIAQQFrIgBBfyAAGzYCAAsLBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LQAEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABAwIAAgBDYCOCAAIAM6ACggACACOgAtIAAgATYCGAu74gECB38DfiABIAJqIQQCQCAAIgIoAgwiAA0AIAIoAgQEQCACIAE2AgQLIwBBEGsiCCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAhwiA0EBaw7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAMxgELQQ4MxQELQQ0MxAELQQ8MwwELQRAMwgELQRMMwQELQRQMwAELQRUMvwELQRYMvgELQRgMvQELQRkMvAELQRoMuwELQRsMugELQRwMuQELQR0MuAELQQgMtwELQR4MtgELQSAMtQELQR8MtAELQQcMswELQSEMsgELQSIMsQELQSMMsAELQSQMrwELQRIMrgELQREMrQELQSUMrAELQSYMqwELQScMqgELQSgMqQELQcMBDKgBC0EqDKcBC0ErDKYBC0EsDKUBC0EtDKQBC0EuDKMBC0EvDKIBC0HEAQyhAQtBMAygAQtBNAyfAQtBDAyeAQtBMQydAQtBMgycAQtBMwybAQtBOQyaAQtBNQyZAQtBxQEMmAELQQsMlwELQToMlgELQTYMlQELQQoMlAELQTcMkwELQTgMkgELQTwMkQELQTsMkAELQT0MjwELQQkMjgELQSkMjQELQT4MjAELQT8MiwELQcAADIoBC0HBAAyJAQtBwgAMiAELQcMADIcBC0HEAAyGAQtBxQAMhQELQcYADIQBC0EXDIMBC0HHAAyCAQtByAAMgQELQckADIABC0HKAAx/C0HLAAx+C0HNAAx9C0HMAAx8C0HOAAx7C0HPAAx6C0HQAAx5C0HRAAx4C0HSAAx3C0HTAAx2C0HUAAx1C0HWAAx0C0HVAAxzC0EGDHILQdcADHELQQUMcAtB2AAMbwtBBAxuC0HZAAxtC0HaAAxsC0HbAAxrC0HcAAxqC0EDDGkLQd0ADGgLQd4ADGcLQd8ADGYLQeEADGULQeAADGQLQeIADGMLQeMADGILQQIMYQtB5AAMYAtB5QAMXwtB5gAMXgtB5wAMXQtB6AAMXAtB6QAMWwtB6gAMWgtB6wAMWQtB7AAMWAtB7QAMVwtB7gAMVgtB7wAMVQtB8AAMVAtB8QAMUwtB8gAMUgtB8wAMUQtB9AAMUAtB9QAMTwtB9gAMTgtB9wAMTQtB+AAMTAtB+QAMSwtB+gAMSgtB+wAMSQtB/AAMSAtB/QAMRwtB/gAMRgtB/wAMRQtBgAEMRAtBgQEMQwtBggEMQgtBgwEMQQtBhAEMQAtBhQEMPwtBhgEMPgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADDsYBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHyAhIyUmKCorLC8wMTIzNDU2Nzk6Ozw9lANAQkRFRklLTk9QUVJTVFVWWFpbXF1eX2BhYmNkZWZnaGpsb3Bxc3V2eHl6e3x/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcsBzAHNAc4BzwGKA4kDiAOHA4QDgwOAA/sC+gL5AvgC9wL0AvMC8gLLAsECsALZAQsgASAERw3wAkHdASEDDLMDCyABIARHDcgBQcMBIQMMsgMLIAEgBEcNe0H3ACEDDLEDCyABIARHDXBB7wAhAwywAwsgASAERw1pQeoAIQMMrwMLIAEgBEcNZUHoACEDDK4DCyABIARHDWJB5gAhAwytAwsgASAERw0aQRghAwysAwsgASAERw0VQRIhAwyrAwsgASAERw1CQcUAIQMMqgMLIAEgBEcNNEE/IQMMqQMLIAEgBEcNMkE8IQMMqAMLIAEgBEcNK0ExIQMMpwMLIAItAC5BAUYNnwMMwQILQQAhAAJAAkACQCACLQAqRQ0AIAItACtFDQAgAi8BMCIDQQJxRQ0BDAILIAIvATAiA0EBcUUNAQtBASEAIAItAChBAUYNACACLwEyIgVB5ABrQeQASQ0AIAVBzAFGDQAgBUGwAkYNACADQcAAcQ0AQQAhACADQYgEcUGABEYNACADQShxQQBHIQALIAJBADsBMCACQQA6AC8gAEUN3wIgAkIANwMgDOACC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAARQ3MASAAQRVHDd0CIAJBBDYCHCACIAE2AhQgAkGwGDYCECACQRU2AgxBACEDDKQDCyABIARGBEBBBiEDDKQDCyABQQFqIQFBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAA3ZAgwcCyACQgA3AyBBEiEDDIkDCyABIARHDRZBHSEDDKEDCyABIARHBEAgAUEBaiEBQRAhAwyIAwtBByEDDKADCyACIAIpAyAiCiAEIAFrrSILfSIMQgAgCiAMWhs3AyAgCiALWA3UAkEIIQMMnwMLIAEgBEcEQCACQQk2AgggAiABNgIEQRQhAwyGAwtBCSEDDJ4DCyACKQMgQgBSDccBIAIgAi8BMEGAAXI7ATAMQgsgASAERw0/QdAAIQMMnAMLIAEgBEYEQEELIQMMnAMLIAFBAWohAUEAIQACQCACKAI4IgNFDQAgAygCUCIDRQ0AIAIgAxEAACEACyAADc8CDMYBC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ3GASAAQRVHDc0CIAJBCzYCHCACIAE2AhQgAkGCGTYCECACQRU2AgxBACEDDJoDC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ0MIABBFUcNygIgAkEaNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMmQMLQQAhAAJAIAIoAjgiA0UNACADKAJMIgNFDQAgAiADEQAAIQALIABFDcQBIABBFUcNxwIgAkELNgIcIAIgATYCFCACQZEXNgIQIAJBFTYCDEEAIQMMmAMLIAEgBEYEQEEPIQMMmAMLIAEtAAAiAEE7Rg0HIABBDUcNxAIgAUEBaiEBDMMBC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3DASAAQRVHDcICIAJBDzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJYDCwNAIAEtAABB8DVqLQAAIgBBAUcEQCAAQQJHDcECIAIoAgQhAEEAIQMgAkEANgIEIAIgACABQQFqIgEQLSIADcICDMUBCyAEIAFBAWoiAUcNAAtBEiEDDJUDC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3FASAAQRVHDb0CIAJBGzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJQDCyABIARGBEBBFiEDDJQDCyACQQo2AgggAiABNgIEQQAhAAJAIAIoAjgiA0UNACADKAJIIgNFDQAgAiADEQAAIQALIABFDcIBIABBFUcNuQIgAkEVNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMkwMLIAEgBEcEQANAIAEtAABB8DdqLQAAIgBBAkcEQAJAIABBAWsOBMQCvQIAvgK9AgsgAUEBaiEBQQghAwz8AgsgBCABQQFqIgFHDQALQRUhAwyTAwtBFSEDDJIDCwNAIAEtAABB8DlqLQAAIgBBAkcEQCAAQQFrDgTFArcCwwK4ArcCCyAEIAFBAWoiAUcNAAtBGCEDDJEDCyABIARHBEAgAkELNgIIIAIgATYCBEEHIQMM+AILQRkhAwyQAwsgAUEBaiEBDAILIAEgBEYEQEEaIQMMjwMLAkAgAS0AAEENaw4UtQG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwEAvwELQQAhAyACQQA2AhwgAkGvCzYCECACQQI2AgwgAiABQQFqNgIUDI4DCyABIARGBEBBGyEDDI4DCyABLQAAIgBBO0cEQCAAQQ1HDbECIAFBAWohAQy6AQsgAUEBaiEBC0EiIQMM8wILIAEgBEYEQEEcIQMMjAMLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43wQLAAgABAgMEBQYH0AHQAdAB0AHQAdAB0AEICQoLDA3QAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdABDg8QERIT0AELQgIhCgzAAgtCAyEKDL8CC0IEIQoMvgILQgUhCgy9AgtCBiEKDLwCC0IHIQoMuwILQgghCgy6AgtCCSEKDLkCC0IKIQoMuAILQgshCgy3AgtCDCEKDLYCC0INIQoMtQILQg4hCgy0AgtCDyEKDLMCC0IKIQoMsgILQgshCgyxAgtCDCEKDLACC0INIQoMrwILQg4hCgyuAgtCDyEKDK0CC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsON8ACvwIAAQIDBAUGB74CvgK+Ar4CvgK+Ar4CCAkKCwwNvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ag4PEBESE74CC0ICIQoMvwILQgMhCgy+AgtCBCEKDL0CC0IFIQoMvAILQgYhCgy7AgtCByEKDLoCC0IIIQoMuQILQgkhCgy4AgtCCiEKDLcCC0ILIQoMtgILQgwhCgy1AgtCDSEKDLQCC0IOIQoMswILQg8hCgyyAgtCCiEKDLECC0ILIQoMsAILQgwhCgyvAgtCDSEKDK4CC0IOIQoMrQILQg8hCgysAgsgAiACKQMgIgogBCABa60iC30iDEIAIAogDFobNwMgIAogC1gNpwJBHyEDDIkDCyABIARHBEAgAkEJNgIIIAIgATYCBEElIQMM8AILQSAhAwyIAwtBASEFIAIvATAiA0EIcUUEQCACKQMgQgBSIQULAkAgAi0ALgRAQQEhACACLQApQQVGDQEgA0HAAHFFIAVxRQ0BC0EAIQAgA0HAAHENAEECIQAgA0EIcQ0AIANBgARxBEACQCACLQAoQQFHDQAgAi0ALUEKcQ0AQQUhAAwCC0EEIQAMAQsgA0EgcUUEQAJAIAItAChBAUYNACACLwEyIgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNAEEEIQAgA0EocUUNAiADQYgEcUGABEYNAgtBACEADAELQQBBAyACKQMgUBshAAsgAEEBaw4FvgIAsAEBpAKhAgtBESEDDO0CCyACQQE6AC8MhAMLIAEgBEcNnQJBJCEDDIQDCyABIARHDRxBxgAhAwyDAwtBACEAAkAgAigCOCIDRQ0AIAMoAkQiA0UNACACIAMRAAAhAAsgAEUNJyAAQRVHDZgCIAJB0AA2AhwgAiABNgIUIAJBkRg2AhAgAkEVNgIMQQAhAwyCAwsgASAERgRAQSghAwyCAwtBACEDIAJBADYCBCACQQw2AgggAiABIAEQKiIARQ2UAiACQSc2AhwgAiABNgIUIAIgADYCDAyBAwsgASAERgRAQSkhAwyBAwsgAS0AACIAQSBGDRMgAEEJRw2VAiABQQFqIQEMFAsgASAERwRAIAFBAWohAQwWC0EqIQMM/wILIAEgBEYEQEErIQMM/wILIAEtAAAiAEEJRyAAQSBHcQ2QAiACLQAsQQhHDd0CIAJBADoALAzdAgsgASAERgRAQSwhAwz+AgsgAS0AAEEKRw2OAiABQQFqIQEMsAELIAEgBEcNigJBLyEDDPwCCwNAIAEtAAAiAEEgRwRAIABBCmsOBIQCiAKIAoQChgILIAQgAUEBaiIBRw0AC0ExIQMM+wILQTIhAyABIARGDfoCIAIoAgAiACAEIAFraiEHIAEgAGtBA2ohBgJAA0AgAEHwO2otAAAgAS0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAEEDRgRAQQYhAQziAgsgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAc2AgAM+wILIAJBADYCAAyGAgtBMyEDIAQgASIARg35AiAEIAFrIAIoAgAiAWohByAAIAFrQQhqIQYCQANAIAFB9DtqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBCEYEQEEFIQEM4QILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPoCCyACQQA2AgAgACEBDIUCC0E0IQMgBCABIgBGDfgCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgJAA0AgAUHQwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYEQEEHIQEM4AILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPkCCyACQQA2AgAgACEBDIQCCyABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRg0JDIECCyAEIAFBAWoiAUcNAAtBMCEDDPgCC0EwIQMM9wILIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBP8B/gH+Af8B/gELIAQgAUEBaiIBRw0AC0E4IQMM9wILQTghAwz2AgsDQCABLQAAIgBBIEcgAEEJR3EN9gEgBCABQQFqIgFHDQALQTwhAwz1AgsDQCABLQAAIgBBIEcEQAJAIABBCmsOBPkBBAT5AQALIABBLEYN9QEMAwsgBCABQQFqIgFHDQALQT8hAwz0AgtBwAAhAyABIARGDfMCIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEGAQGstAAAgAS0AAEEgckcNASAAQQZGDdsCIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPQCCyACQQA2AgALQTYhAwzZAgsgASAERgRAQcEAIQMM8gILIAJBDDYCCCACIAE2AgQgAi0ALEEBaw4E+wHuAewB6wHUAgsgAUEBaiEBDPoBCyABIARHBEADQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxIgBBCUYNACAAQSBGDQACQAJAAkACQCAAQeMAaw4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIQMM3AILIAFBAWohAUEyIQMM2wILIAFBAWohAUEzIQMM2gILDP4BCyAEIAFBAWoiAUcNAAtBNSEDDPACC0E1IQMM7wILIAEgBEcEQANAIAEtAABBgDxqLQAAQQFHDfcBIAQgAUEBaiIBRw0AC0E9IQMM7wILQT0hAwzuAgtBACEAAkAgAigCOCIDRQ0AIAMoAkAiA0UNACACIAMRAAAhAAsgAEUNASAAQRVHDeYBIAJBwgA2AhwgAiABNgIUIAJB4xg2AhAgAkEVNgIMQQAhAwztAgsgAUEBaiEBC0E8IQMM0gILIAEgBEYEQEHCACEDDOsCCwJAA0ACQCABLQAAQQlrDhgAAswCzALRAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAgDMAgsgBCABQQFqIgFHDQALQcIAIQMM6wILIAFBAWohASACLQAtQQFxRQ3+AQtBLCEDDNACCyABIARHDd4BQcQAIQMM6AILA0AgAS0AAEGQwABqLQAAQQFHDZwBIAQgAUEBaiIBRw0AC0HFACEDDOcCCyABLQAAIgBBIEYN/gEgAEE6Rw3AAiACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgAN3gEM3QELQccAIQMgBCABIgBGDeUCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFBkMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvwIgAUEFRg3CAiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzlAgtByAAhAyAEIAEiAEYN5AIgBCABayACKAIAIgFqIQcgACABa0EJaiEGA0AgAUGWwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw2+AkECIAFBCUYNwgIaIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOQCCyABIARGBEBByQAhAwzkAgsCQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxQe4Aaw4HAL8CvwK/Ar8CvwIBvwILIAFBAWohAUE+IQMMywILIAFBAWohAUE/IQMMygILQcoAIQMgBCABIgBGDeICIAQgAWsgAigCACIBaiEGIAAgAWtBAWohBwNAIAFBoMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvAIgAUEBRg2+AiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBjYCAAziAgtBywAhAyAEIAEiAEYN4QIgBCABayACKAIAIgFqIQcgACABa0EOaiEGA0AgAUGiwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw27AiABQQ5GDb4CIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOECC0HMACEDIAQgASIARg3gAiAEIAFrIAIoAgAiAWohByAAIAFrQQ9qIQYDQCABQcDCAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDboCQQMgAUEPRg2+AhogAUEBaiEBIAQgAEEBaiIARw0ACyACIAc2AgAM4AILQc0AIQMgBCABIgBGDd8CIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFB0MIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNuQJBBCABQQVGDb0CGiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzfAgsgASAERgRAQc4AIQMM3wILAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAvAK8ArwCvAK8ArwCvAK8ArwCvAK8ArwCAbwCvAK8AgIDvAILIAFBAWohAUHBACEDDMgCCyABQQFqIQFBwgAhAwzHAgsgAUEBaiEBQcMAIQMMxgILIAFBAWohAUHEACEDDMUCCyABIARHBEAgAkENNgIIIAIgATYCBEHFACEDDMUCC0HPACEDDN0CCwJAAkAgAS0AAEEKaw4EAZABkAEAkAELIAFBAWohAQtBKCEDDMMCCyABIARGBEBB0QAhAwzcAgsgAS0AAEEgRw0AIAFBAWohASACLQAtQQFxRQ3QAQtBFyEDDMECCyABIARHDcsBQdIAIQMM2QILQdMAIQMgASAERg3YAiACKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABB1sIAai0AAEcNxwEgAEEBRg3KASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBjYCAAzYAgsgASAERgRAQdUAIQMM2AILIAEtAABBCkcNwgEgAUEBaiEBDMoBCyABIARGBEBB1gAhAwzXAgsCQAJAIAEtAABBCmsOBADDAcMBAcMBCyABQQFqIQEMygELIAFBAWohAUHKACEDDL0CC0EAIQACQCACKAI4IgNFDQAgAygCPCIDRQ0AIAIgAxEAACEACyAADb8BQc0AIQMMvAILIAItAClBIkYNzwIMiQELIAQgASIFRgRAQdsAIQMM1AILQQAhAEEBIQFBASEGQQAhAwJAAn8CQAJAAkACQAJAAkACQCAFLQAAQTBrDgrFAcQBAAECAwQFBgjDAQtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshA0EAIQFBACEGDL0BC0EJIQNBASEAQQAhAUEAIQYMvAELIAEgBEYEQEHdACEDDNMCCyABLQAAQS5HDbgBIAFBAWohAQyIAQsgASAERw22AUHfACEDDNECCyABIARHBEAgAkEONgIIIAIgATYCBEHQACEDDLgCC0HgACEDDNACC0HhACEDIAEgBEYNzwIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGA0AgAS0AACAAQeLCAGotAABHDbEBIABBA0YNswEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMzwILQeIAIQMgASAERg3OAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYDQCABLQAAIABB5sIAai0AAEcNsAEgAEECRg2vASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAzOAgtB4wAhAyABIARGDc0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgNAIAEtAAAgAEHpwgBqLQAARw2vASAAQQNGDa0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADM0CCyABIARGBEBB5QAhAwzNAgsgAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANqgFB1gAhAwyzAgsgASAERwRAA0AgAS0AACIAQSBHBEACQAJAAkAgAEHIAGsOCwABswGzAbMBswGzAbMBswGzAQKzAQsgAUEBaiEBQdIAIQMMtwILIAFBAWohAUHTACEDDLYCCyABQQFqIQFB1AAhAwy1AgsgBCABQQFqIgFHDQALQeQAIQMMzAILQeQAIQMMywILA0AgAS0AAEHwwgBqLQAAIgBBAUcEQCAAQQJrDgOnAaYBpQGkAQsgBCABQQFqIgFHDQALQeYAIQMMygILIAFBAWogASAERw0CGkHnACEDDMkCCwNAIAEtAABB8MQAai0AACIAQQFHBEACQCAAQQJrDgSiAaEBoAEAnwELQdcAIQMMsQILIAQgAUEBaiIBRw0AC0HoACEDDMgCCyABIARGBEBB6QAhAwzIAgsCQCABLQAAIgBBCmsOGrcBmwGbAbQBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBpAGbAZsBAJkBCyABQQFqCyEBQQYhAwytAgsDQCABLQAAQfDGAGotAABBAUcNfSAEIAFBAWoiAUcNAAtB6gAhAwzFAgsgAUEBaiABIARHDQIaQesAIQMMxAILIAEgBEYEQEHsACEDDMQCCyABQQFqDAELIAEgBEYEQEHtACEDDMMCCyABQQFqCyEBQQQhAwyoAgsgASAERgRAQe4AIQMMwQILAkACQAJAIAEtAABB8MgAai0AAEEBaw4HkAGPAY4BAHwBAo0BCyABQQFqIQEMCwsgAUEBagyTAQtBACEDIAJBADYCHCACQZsSNgIQIAJBBzYCDCACIAFBAWo2AhQMwAILAkADQCABLQAAQfDIAGotAAAiAEEERwRAAkACQCAAQQFrDgeUAZMBkgGNAQAEAY0BC0HaACEDDKoCCyABQQFqIQFB3AAhAwypAgsgBCABQQFqIgFHDQALQe8AIQMMwAILIAFBAWoMkQELIAQgASIARgRAQfAAIQMMvwILIAAtAABBL0cNASAAQQFqIQEMBwsgBCABIgBGBEBB8QAhAwy+AgsgAC0AACIBQS9GBEAgAEEBaiEBQd0AIQMMpQILIAFBCmsiA0EWSw0AIAAhAUEBIAN0QYmAgAJxDfkBC0EAIQMgAkEANgIcIAIgADYCFCACQYwcNgIQIAJBBzYCDAy8AgsgASAERwRAIAFBAWohAUHeACEDDKMCC0HyACEDDLsCCyABIARGBEBB9AAhAwy7AgsCQCABLQAAQfDMAGotAABBAWsOA/cBcwCCAQtB4QAhAwyhAgsgASAERwRAA0AgAS0AAEHwygBqLQAAIgBBA0cEQAJAIABBAWsOAvkBAIUBC0HfACEDDKMCCyAEIAFBAWoiAUcNAAtB8wAhAwy6AgtB8wAhAwy5AgsgASAERwRAIAJBDzYCCCACIAE2AgRB4AAhAwygAgtB9QAhAwy4AgsgASAERgRAQfYAIQMMuAILIAJBDzYCCCACIAE2AgQLQQMhAwydAgsDQCABLQAAQSBHDY4CIAQgAUEBaiIBRw0AC0H3ACEDDLUCCyABIARGBEBB+AAhAwy1AgsgAS0AAEEgRw16IAFBAWohAQxbC0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAADXgMgAILIAEgBEYEQEH6ACEDDLMCCyABLQAAQcwARw10IAFBAWohAUETDHYLQfsAIQMgASAERg2xAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYDQCABLQAAIABB8M4Aai0AAEcNcyAAQQVGDXUgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMsQILIAEgBEYEQEH8ACEDDLECCwJAAkAgAS0AAEHDAGsODAB0dHR0dHR0dHR0AXQLIAFBAWohAUHmACEDDJgCCyABQQFqIQFB5wAhAwyXAgtB/QAhAyABIARGDa8CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDXIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADLACCyACQQA2AgAgBkEBaiEBQRAMcwtB/gAhAyABIARGDa4CIAIoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQfbOAGotAABHDXEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK8CCyACQQA2AgAgBkEBaiEBQRYMcgtB/wAhAyABIARGDa0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQfzOAGotAABHDXAgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK4CCyACQQA2AgAgBkEBaiEBQQUMcQsgASAERgRAQYABIQMMrQILIAEtAABB2QBHDW4gAUEBaiEBQQgMcAsgASAERgRAQYEBIQMMrAILAkACQCABLQAAQc4Aaw4DAG8BbwsgAUEBaiEBQesAIQMMkwILIAFBAWohAUHsACEDDJICCyABIARGBEBBggEhAwyrAgsCQAJAIAEtAABByABrDggAbm5ubm5uAW4LIAFBAWohAUHqACEDDJICCyABQQFqIQFB7QAhAwyRAgtBgwEhAyABIARGDakCIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQYDPAGotAABHDWwgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKoCCyACQQA2AgAgBkEBaiEBQQAMbQtBhAEhAyABIARGDagCIAIoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQYPPAGotAABHDWsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKkCCyACQQA2AgAgBkEBaiEBQSMMbAsgASAERgRAQYUBIQMMqAILAkACQCABLQAAQcwAaw4IAGtra2trawFrCyABQQFqIQFB7wAhAwyPAgsgAUEBaiEBQfAAIQMMjgILIAEgBEYEQEGGASEDDKcCCyABLQAAQcUARw1oIAFBAWohAQxgC0GHASEDIAEgBEYNpQIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBiM8Aai0AAEcNaCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpgILIAJBADYCACAGQQFqIQFBLQxpC0GIASEDIAEgBEYNpAIgAigCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABB0M8Aai0AAEcNZyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpQILIAJBADYCACAGQQFqIQFBKQxoCyABIARGBEBBiQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEVDF8LQZIBIQMgASAERg2aAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGhzwBqLQAARw1dIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAybAgsgAkEANgIAIAZBAWohAUEeDF4LIAEgBEYEQEGTASEDDJoCCyABLQAAQcwARw1bIAFBAWohAUEKDF0LIAEgBEYEQEGUASEDDJkCCwJAAkAgAS0AAEHBAGsODwBcXFxcXFxcXFxcXFxcAVwLIAFBAWohAUH+ACEDDIACCyABQQFqIQFB/wAhAwz/AQsgASAERgRAQZUBIQMMmAILAkACQCABLQAAQcEAaw4DAFsBWwsgAUEBaiEBQf0AIQMM/wELIAFBAWohAUGAASEDDP4BC0GWASEDIAEgBEYNlgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBp88Aai0AAEcNWSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlwILIAJBADYCACAGQQFqIQFBCwxaCyABIARGBEBBlwEhAwyWAgsCQAJAAkACQCABLQAAQS1rDiMAW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sBW1tbW1sCW1tbA1sLIAFBAWohAUH7ACEDDP8BCyABQQFqIQFB/AAhAwz+AQsgAUEBaiEBQYEBIQMM/QELIAFBAWohAUGCASEDDPwBC0GYASEDIAEgBEYNlAIgAigCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBqc8Aai0AAEcNVyAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlQILIAJBADYCACAGQQFqIQFBGQxYC0GZASEDIAEgBEYNkwIgAigCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBrs8Aai0AAEcNViAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlAILIAJBADYCACAGQQFqIQFBBgxXC0GaASEDIAEgBEYNkgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBtM8Aai0AAEcNVSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkwILIAJBADYCACAGQQFqIQFBHAxWC0GbASEDIAEgBEYNkQIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBts8Aai0AAEcNVCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkgILIAJBADYCACAGQQFqIQFBJwxVCyABIARGBEBBnAEhAwyRAgsCQAJAIAEtAABB1ABrDgIAAVQLIAFBAWohAUGGASEDDPgBCyABQQFqIQFBhwEhAwz3AQtBnQEhAyABIARGDY8CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjPAGotAABHDVIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADJACCyACQQA2AgAgBkEBaiEBQSYMUwtBngEhAyABIARGDY4CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbrPAGotAABHDVEgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI8CCyACQQA2AgAgBkEBaiEBQQMMUgtBnwEhAyABIARGDY0CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDVAgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI4CCyACQQA2AgAgBkEBaiEBQQwMUQtBoAEhAyABIARGDYwCIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQbzPAGotAABHDU8gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI0CCyACQQA2AgAgBkEBaiEBQQ0MUAsgASAERgRAQaEBIQMMjAILAkACQCABLQAAQcYAaw4LAE9PT09PT09PTwFPCyABQQFqIQFBiwEhAwzzAQsgAUEBaiEBQYwBIQMM8gELIAEgBEYEQEGiASEDDIsCCyABLQAAQdAARw1MIAFBAWohAQxGCyABIARGBEBBowEhAwyKAgsCQAJAIAEtAABByQBrDgcBTU1NTU0ATQsgAUEBaiEBQY4BIQMM8QELIAFBAWohAUEiDE0LQaQBIQMgASAERg2IAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHAzwBqLQAARw1LIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyJAgsgAkEANgIAIAZBAWohAUEdDEwLIAEgBEYEQEGlASEDDIgCCwJAAkAgAS0AAEHSAGsOAwBLAUsLIAFBAWohAUGQASEDDO8BCyABQQFqIQFBBAxLCyABIARGBEBBpgEhAwyHAgsCQAJAAkACQAJAIAEtAABBwQBrDhUATU1NTU1NTU1NTQFNTQJNTQNNTQRNCyABQQFqIQFBiAEhAwzxAQsgAUEBaiEBQYkBIQMM8AELIAFBAWohAUGKASEDDO8BCyABQQFqIQFBjwEhAwzuAQsgAUEBaiEBQZEBIQMM7QELQacBIQMgASAERg2FAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHtzwBqLQAARw1IIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyGAgsgAkEANgIAIAZBAWohAUERDEkLQagBIQMgASAERg2EAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHCzwBqLQAARw1HIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyFAgsgAkEANgIAIAZBAWohAUEsDEgLQakBIQMgASAERg2DAiACKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHFzwBqLQAARw1GIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyEAgsgAkEANgIAIAZBAWohAUErDEcLQaoBIQMgASAERg2CAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHKzwBqLQAARw1FIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyDAgsgAkEANgIAIAZBAWohAUEUDEYLIAEgBEYEQEGrASEDDIICCwJAAkACQAJAIAEtAABBwgBrDg8AAQJHR0dHR0dHR0dHRwNHCyABQQFqIQFBkwEhAwzrAQsgAUEBaiEBQZQBIQMM6gELIAFBAWohAUGVASEDDOkBCyABQQFqIQFBlgEhAwzoAQsgASAERgRAQawBIQMMgQILIAEtAABBxQBHDUIgAUEBaiEBDD0LQa0BIQMgASAERg3/ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHNzwBqLQAARw1CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyAAgsgAkEANgIAIAZBAWohAUEODEMLIAEgBEYEQEGuASEDDP8BCyABLQAAQdAARw1AIAFBAWohAUElDEILQa8BIQMgASAERg39ASACKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEHQzwBqLQAARw1AIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz+AQsgAkEANgIAIAZBAWohAUEqDEELIAEgBEYEQEGwASEDDP0BCwJAAkAgAS0AAEHVAGsOCwBAQEBAQEBAQEABQAsgAUEBaiEBQZoBIQMM5AELIAFBAWohAUGbASEDDOMBCyABIARGBEBBsQEhAwz8AQsCQAJAIAEtAABBwQBrDhQAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/AT8LIAFBAWohAUGZASEDDOMBCyABQQFqIQFBnAEhAwziAQtBsgEhAyABIARGDfoBIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQdnPAGotAABHDT0gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPsBCyACQQA2AgAgBkEBaiEBQSEMPgtBswEhAyABIARGDfkBIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQd3PAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPoBCyACQQA2AgAgBkEBaiEBQRoMPQsgASAERgRAQbQBIQMM+QELAkACQAJAIAEtAABBxQBrDhEAPT09PT09PT09AT09PT09Aj0LIAFBAWohAUGdASEDDOEBCyABQQFqIQFBngEhAwzgAQsgAUEBaiEBQZ8BIQMM3wELQbUBIQMgASAERg33ASACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHkzwBqLQAARw06IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz4AQsgAkEANgIAIAZBAWohAUEoDDsLQbYBIQMgASAERg32ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHqzwBqLQAARw05IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz3AQsgAkEANgIAIAZBAWohAUEHDDoLIAEgBEYEQEG3ASEDDPYBCwJAAkAgAS0AAEHFAGsODgA5OTk5OTk5OTk5OTkBOQsgAUEBaiEBQaEBIQMM3QELIAFBAWohAUGiASEDDNwBC0G4ASEDIAEgBEYN9AEgAigCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB7c8Aai0AAEcNNyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9QELIAJBADYCACAGQQFqIQFBEgw4C0G5ASEDIAEgBEYN8wEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8M8Aai0AAEcNNiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9AELIAJBADYCACAGQQFqIQFBIAw3C0G6ASEDIAEgBEYN8gEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8s8Aai0AAEcNNSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8wELIAJBADYCACAGQQFqIQFBDww2CyABIARGBEBBuwEhAwzyAQsCQAJAIAEtAABByQBrDgcANTU1NTUBNQsgAUEBaiEBQaUBIQMM2QELIAFBAWohAUGmASEDDNgBC0G8ASEDIAEgBEYN8AEgAigCACIAIAQgAWtqIQUgASAAa0EHaiEGAkADQCABLQAAIABB9M8Aai0AAEcNMyAAQQdGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8QELIAJBADYCACAGQQFqIQFBGww0CyABIARGBEBBvQEhAwzwAQsCQAJAAkAgAS0AAEHCAGsOEgA0NDQ0NDQ0NDQBNDQ0NDQ0AjQLIAFBAWohAUGkASEDDNgBCyABQQFqIQFBpwEhAwzXAQsgAUEBaiEBQagBIQMM1gELIAEgBEYEQEG+ASEDDO8BCyABLQAAQc4ARw0wIAFBAWohAQwsCyABIARGBEBBvwEhAwzuAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQcEAaw4VAAECAz8EBQY/Pz8HCAkKCz8MDQ4PPwsgAUEBaiEBQegAIQMM4wELIAFBAWohAUHpACEDDOIBCyABQQFqIQFB7gAhAwzhAQsgAUEBaiEBQfIAIQMM4AELIAFBAWohAUHzACEDDN8BCyABQQFqIQFB9gAhAwzeAQsgAUEBaiEBQfcAIQMM3QELIAFBAWohAUH6ACEDDNwBCyABQQFqIQFBgwEhAwzbAQsgAUEBaiEBQYQBIQMM2gELIAFBAWohAUGFASEDDNkBCyABQQFqIQFBkgEhAwzYAQsgAUEBaiEBQZgBIQMM1wELIAFBAWohAUGgASEDDNYBCyABQQFqIQFBowEhAwzVAQsgAUEBaiEBQaoBIQMM1AELIAEgBEcEQCACQRA2AgggAiABNgIEQasBIQMM1AELQcABIQMM7AELQQAhAAJAIAIoAjgiA0UNACADKAI0IgNFDQAgAiADEQAAIQALIABFDV4gAEEVRw0HIAJB0QA2AhwgAiABNgIUIAJBsBc2AhAgAkEVNgIMQQAhAwzrAQsgAUEBaiABIARHDQgaQcIBIQMM6gELA0ACQCABLQAAQQprDgQIAAALAAsgBCABQQFqIgFHDQALQcMBIQMM6QELIAEgBEcEQCACQRE2AgggAiABNgIEQQEhAwzQAQtBxAEhAwzoAQsgASAERgRAQcUBIQMM6AELAkACQCABLQAAQQprDgQBKCgAKAsgAUEBagwJCyABQQFqDAULIAEgBEYEQEHGASEDDOcBCwJAAkAgAS0AAEEKaw4XAQsLAQsLCwsLCwsLCwsLCwsLCwsLCwALCyABQQFqIQELQbABIQMMzQELIAEgBEYEQEHIASEDDOYBCyABLQAAQSBHDQkgAkEAOwEyIAFBAWohAUGzASEDDMwBCwNAIAEhAAJAIAEgBEcEQCABLQAAQTBrQf8BcSIDQQpJDQEMJwtBxwEhAwzmAQsCQCACLwEyIgFBmTNLDQAgAiABQQpsIgU7ATIgBUH+/wNxIANB//8Dc0sNACAAQQFqIQEgAiADIAVqIgM7ATIgA0H//wNxQegHSQ0BCwtBACEDIAJBADYCHCACQcEJNgIQIAJBDTYCDCACIABBAWo2AhQM5AELIAJBADYCHCACIAE2AhQgAkHwDDYCECACQRs2AgxBACEDDOMBCyACKAIEIQAgAkEANgIEIAIgACABECYiAA0BIAFBAWoLIQFBrQEhAwzIAQsgAkHBATYCHCACIAA2AgwgAiABQQFqNgIUQQAhAwzgAQsgAigCBCEAIAJBADYCBCACIAAgARAmIgANASABQQFqCyEBQa4BIQMMxQELIAJBwgE2AhwgAiAANgIMIAIgAUEBajYCFEEAIQMM3QELIAJBADYCHCACIAE2AhQgAkGXCzYCECACQQ02AgxBACEDDNwBCyACQQA2AhwgAiABNgIUIAJB4xA2AhAgAkEJNgIMQQAhAwzbAQsgAkECOgAoDKwBC0EAIQMgAkEANgIcIAJBrws2AhAgAkECNgIMIAIgAUEBajYCFAzZAQtBAiEDDL8BC0ENIQMMvgELQSYhAwy9AQtBFSEDDLwBC0EWIQMMuwELQRghAwy6AQtBHCEDDLkBC0EdIQMMuAELQSAhAwy3AQtBISEDDLYBC0EjIQMMtQELQcYAIQMMtAELQS4hAwyzAQtBPSEDDLIBC0HLACEDDLEBC0HOACEDDLABC0HYACEDDK8BC0HZACEDDK4BC0HbACEDDK0BC0HxACEDDKwBC0H0ACEDDKsBC0GNASEDDKoBC0GXASEDDKkBC0GpASEDDKgBC0GvASEDDKcBC0GxASEDDKYBCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB8Rs2AhAgAkEGNgIMDL0BCyACQQA2AgAgBkEBaiEBQSQLOgApIAIoAgQhACACQQA2AgQgAiAAIAEQJyIARQRAQeUAIQMMowELIAJB+QA2AhwgAiABNgIUIAIgADYCDEEAIQMMuwELIABBFUcEQCACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwy7AQsgAkH4ADYCHCACIAE2AhQgAkHKGDYCECACQRU2AgxBACEDDLoBCyACQQA2AhwgAiABNgIUIAJBjhs2AhAgAkEGNgIMQQAhAwy5AQsgAkEANgIcIAIgATYCFCACQf4RNgIQIAJBBzYCDEEAIQMMuAELIAJBADYCHCACIAE2AhQgAkGMHDYCECACQQc2AgxBACEDDLcBCyACQQA2AhwgAiABNgIUIAJBww82AhAgAkEHNgIMQQAhAwy2AQsgAkEANgIcIAIgATYCFCACQcMPNgIQIAJBBzYCDEEAIQMMtQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxBACEDDKIBCyACQeQANgIcIAIgATYCFCACQeMXNgIQIAJBFTYCDEEAIQMMoQELIAJBADYCACAGQQFqIQEgAi0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACEDIAJBADYCHCACIAE2AhQgAkH3CTYCECACQQg2AgwMoAELIAJBADYCACAGQQFqIQEgAi0AKUEhRg0DIAJBADYCHCACIAE2AhQgAkGbCjYCECACQQg2AgxBACEDDJ8BCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJBkDM2AhAgAkEINgIMDJ0BCyACQQA2AgAgBkEBaiEBIAItAClBI0kNACACQQA2AhwgAiABNgIUIAJB0wk2AhAgAkEINgIMQQAhAwycAQtB0QAhAwyCAQsgAS0AAEEwayIAQf8BcUEKSQRAIAIgADoAKiABQQFqIQFBzwAhAwyCAQsgAigCBCEAIAJBADYCBCACIAAgARAoIgBFDYYBIAJB3gA2AhwgAiABNgIUIAIgADYCDEEAIQMMmgELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ2GASACQdwANgIcIAIgATYCFCACIAA2AgxBACEDDJkBCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMhwELIAJB2gA2AhwgAiAFNgIUIAIgADYCDAyYAQtBACEBQQEhAwsgAiADOgArIAVBAWohAwJAAkACQCACLQAtQRBxDQACQAJAAkAgAi0AKg4DAQACBAsgBkUNAwwCCyAADQEMAgsgAUUNAQsgAigCBCEAIAJBADYCBCACIAAgAxAoIgBFBEAgAyEBDAILIAJB2AA2AhwgAiADNgIUIAIgADYCDEEAIQMMmAELIAIoAgQhACACQQA2AgQgAiAAIAMQKCIARQRAIAMhAQyHAQsgAkHZADYCHCACIAM2AhQgAiAANgIMQQAhAwyXAQtBzAAhAwx9CyAAQRVHBEAgAkEANgIcIAIgATYCFCACQZQNNgIQIAJBITYCDEEAIQMMlgELIAJB1wA2AhwgAiABNgIUIAJByRc2AhAgAkEVNgIMQQAhAwyVAQtBACEDIAJBADYCHCACIAE2AhQgAkGAETYCECACQQk2AgwMlAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0AIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMkwELQckAIQMMeQsgAkEANgIcIAIgATYCFCACQcEoNgIQIAJBBzYCDCACQQA2AgBBACEDDJEBCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAlIgBFDQAgAkHSADYCHCACIAE2AhQgAiAANgIMDJABC0HIACEDDHYLIAJBADYCACAFIQELIAJBgBI7ASogAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANAQtBxwAhAwxzCyAAQRVGBEAgAkHRADYCHCACIAE2AhQgAkHjFzYCECACQRU2AgxBACEDDIwBC0EAIQMgAkEANgIcIAIgATYCFCACQbkNNgIQIAJBGjYCDAyLAQtBACEDIAJBADYCHCACIAE2AhQgAkGgGTYCECACQR42AgwMigELIAEtAABBOkYEQCACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgBFDQEgAkHDADYCHCACIAA2AgwgAiABQQFqNgIUDIoBC0EAIQMgAkEANgIcIAIgATYCFCACQbERNgIQIAJBCjYCDAyJAQsgAUEBaiEBQTshAwxvCyACQcMANgIcIAIgADYCDCACIAFBAWo2AhQMhwELQQAhAyACQQA2AhwgAiABNgIUIAJB8A42AhAgAkEcNgIMDIYBCyACIAIvATBBEHI7ATAMZgsCQCACLwEwIgBBCHFFDQAgAi0AKEEBRw0AIAItAC1BCHFFDQMLIAIgAEH3+wNxQYAEcjsBMAwECyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE1IQMMbgsgAikDICIKQpmz5syZs+bMGVYNASACIApCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAIgCiALfDcDICAEIAFBAWoiAUcNAAtBOSEDDIUBCyACKAIEIQBBACEDIAJBADYCBCACIAAgAUEBaiIBECoiAA0MDHcLQTkhAwyDAQsgAi0AMEEgcQ0GQcUBIQMMaQtBACEDIAJBADYCBCACIAEgARAqIgBFDQQgAkE6NgIcIAIgADYCDCACIAFBAWo2AhQMgQELIAItAChBAUcNACACLQAtQQhxRQ0BC0E3IQMMZgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIABEAgAkE7NgIcIAIgADYCDCACIAFBAWo2AhQMfwsgAUEBaiEBDG4LIAJBCDoALAwECyABQQFqIQEMbQtBACEDIAJBADYCHCACIAE2AhQgAkHkEjYCECACQQQ2AgwMewsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ1sIAJBNzYCHCACIAE2AhQgAiAANgIMDHoLIAIgAi8BMEEgcjsBMAtBMCEDDF8LIAJBNjYCHCACIAE2AhQgAiAANgIMDHcLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCACLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIAJBAToALCACIAIvATAgAXI7ATAgACEBDAELIAIgAi8BMEEIcjsBMCAAIQELQTkhAwxcCyACQQA6ACwLQTQhAwxaCyABIARGBEBBLSEDDHMLAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0EtIQMMdAsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ0CIAJBLDYCHCACIAE2AhQgAiAANgIMDHMLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAS0AAEENRgRAIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAi0ALUEBcQRAQcQBIQMMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIADQEMZQtBLyEDDFcLIAJBLjYCHCACIAE2AhQgAiAANgIMDG8LQQAhAyACQQA2AhwgAiABNgIUIAJB8BQ2AhAgAkEDNgIMDG4LQQEhAwJAAkACQAJAIAItACxBBWsOBAMBAgAECyACIAIvATBBCHI7ATAMAwtBAiEDDAELQQQhAwsgAkEBOgAsIAIgAi8BMCADcjsBMAtBKiEDDFMLQQAhAyACQQA2AhwgAiABNgIUIAJB4Q82AhAgAkEKNgIMDGsLQQEhAwJAAkACQAJAAkACQCACLQAsQQJrDgcFBAQDAQIABAsgAiACLwEwQQhyOwEwDAMLQQIhAwwBC0EEIQMLIAJBAToALCACIAIvATAgA3I7ATALQSshAwxSC0EAIQMgAkEANgIcIAIgATYCFCACQasSNgIQIAJBCzYCDAxqC0EAIQMgAkEANgIcIAIgATYCFCACQf0NNgIQIAJBHTYCDAxpCyABIARHBEADQCABLQAAQSBHDUggBCABQQFqIgFHDQALQSUhAwxpC0ElIQMMaAsgAi0ALUEBcQRAQcMBIQMMTwsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKSIABEAgAkEmNgIcIAIgADYCDCACIAFBAWo2AhQMaAsgAUEBaiEBDFwLIAFBAWohASACLwEwIgBBgAFxBEBBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAEUNBiAAQRVHDR8gAkEFNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMZwsCQCAAQaAEcUGgBEcNACACLQAtQQJxDQBBACEDIAJBADYCHCACIAE2AhQgAkGWEzYCECACQQQ2AgwMZwsgAgJ/IAIvATBBFHFBFEYEQEEBIAItAChBAUYNARogAi8BMkHlAEYMAQsgAi0AKUEFRgs6AC5BACEAAkAgAigCOCIDRQ0AIAMoAiQiA0UNACACIAMRAAAhAAsCQAJAAkACQAJAIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyACQQE6AC4LIAIgAi8BMEHAAHI7ATALQSchAwxPCyACQSM2AhwgAiABNgIUIAJBpRY2AhAgAkEVNgIMQQAhAwxnC0EAIQMgAkEANgIcIAIgATYCFCACQdULNgIQIAJBETYCDAxmC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAADQELQQ4hAwxLCyAAQRVGBEAgAkECNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMZAtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMYwtBACEDIAJBADYCHCACIAE2AhQgAkGqHDYCECACQQ82AgwMYgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEgCqdqIgEQKyIARQ0AIAJBBTYCHCACIAE2AhQgAiAANgIMDGELQQ8hAwxHC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxfC0IBIQoLIAFBAWohAQJAIAIpAyAiC0L//////////w9YBEAgAiALQgSGIAqENwMgDAELQQAhAyACQQA2AhwgAiABNgIUIAJBrQk2AhAgAkEMNgIMDF4LQSQhAwxEC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxcCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAsIgBFBEAgAUEBaiEBDFILIAJBFzYCHCACIAA2AgwgAiABQQFqNgIUDFsLIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQRY2AhwgAiAANgIMIAIgAUEBajYCFAxbC0EfIQMMQQtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQLSIARQRAIAFBAWohAQxQCyACQRQ2AhwgAiAANgIMIAIgAUEBajYCFAxYCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABEC0iAEUEQCABQQFqIQEMAQsgAkETNgIcIAIgADYCDCACIAFBAWo2AhQMWAtBHiEDDD4LQQAhAyACQQA2AhwgAiABNgIUIAJBxgw2AhAgAkEjNgIMDFYLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABEC0iAEUEQCABQQFqIQEMTgsgAkERNgIcIAIgADYCDCACIAFBAWo2AhQMVQsgAkEQNgIcIAIgATYCFCACIAA2AgwMVAtBACEDIAJBADYCHCACIAE2AhQgAkHGDDYCECACQSM2AgwMUwtBACEDIAJBADYCHCACIAE2AhQgAkHAFTYCECACQQI2AgwMUgsgAigCBCEAQQAhAyACQQA2AgQCQCACIAAgARAtIgBFBEAgAUEBaiEBDAELIAJBDjYCHCACIAA2AgwgAiABQQFqNgIUDFILQRshAww4C0EAIQMgAkEANgIcIAIgATYCFCACQcYMNgIQIAJBIzYCDAxQCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABECwiAEUEQCABQQFqIQEMAQsgAkENNgIcIAIgADYCDCACIAFBAWo2AhQMUAtBGiEDDDYLQQAhAyACQQA2AhwgAiABNgIUIAJBmg82AhAgAkEiNgIMDE4LIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQQw2AhwgAiAANgIMIAIgAUEBajYCFAxOC0EZIQMMNAtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMTAsgAEEVRwRAQQAhAyACQQA2AhwgAiABNgIUIAJBgww2AhAgAkETNgIMDEwLIAJBCjYCHCACIAE2AhQgAkHkFjYCECACQRU2AgxBACEDDEsLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABIAqnaiIBECsiAARAIAJBBzYCHCACIAE2AhQgAiAANgIMDEsLQRMhAwwxCyAAQRVHBEBBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMSgsgAkEeNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMSQtBACEAAkAgAigCOCIDRQ0AIAMoAiwiA0UNACACIAMRAAAhAAsgAEUNQSAAQRVGBEAgAkEDNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMSQtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMSAtBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMRwtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMRgsgAkEAOgAvIAItAC1BBHFFDT8LIAJBADoALyACQQE6ADRBACEDDCsLQQAhAyACQQA2AhwgAkHkETYCECACQQc2AgwgAiABQQFqNgIUDEMLAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB3QEhAwxDCwJAAkAgAi0ANEEBRw0AQQAhAAJAIAIoAjgiA0UNACADKAJYIgNFDQAgAiADEQAAIQALIABFDQAgAEEVRw0BIAJB3AE2AhwgAiABNgIUIAJB1RY2AhAgAkEVNgIMQQAhAwxEC0HBASEDDCoLIAJBADYCHCACIAE2AhQgAkHpCzYCECACQR82AgxBACEDDEILAkACQCACLQAoQQFrDgIEAQALQcABIQMMKQtBuQEhAwwoCyACQQI6AC9BACEAAkAgAigCOCIDRQ0AIAMoAgAiA0UNACACIAMRAAAhAAsgAEUEQEHCASEDDCgLIABBFUcEQCACQQA2AhwgAiABNgIUIAJBpAw2AhAgAkEQNgIMQQAhAwxBCyACQdsBNgIcIAIgATYCFCACQfoWNgIQIAJBFTYCDEEAIQMMQAsgASAERgRAQdoBIQMMQAsgAS0AAEHIAEYNASACQQE6ACgLQawBIQMMJQtBvwEhAwwkCyABIARHBEAgAkEQNgIIIAIgATYCBEG+ASEDDCQLQdkBIQMMPAsgASAERgRAQdgBIQMMPAsgAS0AAEHIAEcNBCABQQFqIQFBvQEhAwwiCyABIARGBEBB1wEhAww7CwJAAkAgAS0AAEHFAGsOEAAFBQUFBQUFBQUFBQUFBQEFCyABQQFqIQFBuwEhAwwiCyABQQFqIQFBvAEhAwwhC0HWASEDIAEgBEYNOSACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGD0ABqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw6CyACKAIEIQAgAkIANwMAIAIgACAGQQFqIgEQJyIARQRAQcYBIQMMIQsgAkHVATYCHCACIAE2AhQgAiAANgIMQQAhAww5C0HUASEDIAEgBEYNOCACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGB0ABqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw5CyACQYEEOwEoIAIoAgQhACACQgA3AwAgAiAAIAZBAWoiARAnIgANAwwCCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB2Bs2AhAgAkEINgIMDDYLQboBIQMMHAsgAkHTATYCHCACIAE2AhQgAiAANgIMQQAhAww0C0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAARQ0AIABBFUYNASACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwwzC0HkACEDDBkLIAJB+AA2AhwgAiABNgIUIAJByhg2AhAgAkEVNgIMQQAhAwwxC0HSASEDIAQgASIARg0wIAQgAWsgAigCACIBaiEFIAAgAWtBBGohBgJAA0AgAC0AACABQfzPAGotAABHDQEgAUEERg0DIAFBAWohASAEIABBAWoiAEcNAAsgAiAFNgIADDELIAJBADYCHCACIAA2AhQgAkGQMzYCECACQQg2AgwgAkEANgIAQQAhAwwwCyABIARHBEAgAkEONgIIIAIgATYCBEG3ASEDDBcLQdEBIQMMLwsgAkEANgIAIAZBAWohAQtBuAEhAwwUCyABIARGBEBB0AEhAwwtCyABLQAAQTBrIgBB/wFxQQpJBEAgAiAAOgAqIAFBAWohAUG2ASEDDBQLIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0UIAJBzwE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAsgASAERgRAQc4BIQMMLAsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0VIAJBzQE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAtBtQEhAwwSCyAEIAEiBUYEQEHMASEDDCsLQQAhAEEBIQFBASEGQQAhAwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAUtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyEDQQAhAUEAIQYMAgtBCSEDQQEhAEEAIQFBACEGDAELQQAhAUEBIQMLIAIgAzoAKyAFQQFqIQMCQAJAIAItAC1BEHENAAJAAkACQCACLQAqDgMBAAIECyAGRQ0DDAILIAANAQwCCyABRQ0BCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMAwsgAkHJATYCHCACIAM2AhQgAiAANgIMQQAhAwwtCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMGAsgAkHKATYCHCACIAM2AhQgAiAANgIMQQAhAwwsCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMFgsgAkHLATYCHCACIAU2AhQgAiAANgIMDCsLQbQBIQMMEQtBACEAAkAgAigCOCIDRQ0AIAMoAjwiA0UNACACIAMRAAAhAAsCQCAABEAgAEEVRg0BIAJBADYCHCACIAE2AhQgAkGUDTYCECACQSE2AgxBACEDDCsLQbIBIQMMEQsgAkHIATYCHCACIAE2AhQgAkHJFzYCECACQRU2AgxBACEDDCkLIAJBADYCACAGQQFqIQFB9QAhAwwPCyACLQApQQVGBEBB4wAhAwwPC0HiACEDDA4LIAAhASACQQA2AgALIAJBADoALEEJIQMMDAsgAkEANgIAIAdBAWohAUHAACEDDAsLQQELOgAsIAJBADYCACAGQQFqIQELQSkhAwwIC0E4IQMMBwsCQCABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBPiEDDCELQT4hAwwgCwsgAkEAOgAsDAELQQshAwwEC0E6IQMMAwsgAUEBaiEBQS0hAwwCCyACIAE6ACwgAkEANgIAIAZBAWohAUEMIQMMAQsgAkEANgIAIAZBAWohAUEKIQMMAAsAC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwXC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwWC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwVC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwUC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwTC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwSC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwRC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwQC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwPC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwOC0EAIQMgAkEANgIcIAIgATYCFCACQcASNgIQIAJBCzYCDAwNC0EAIQMgAkEANgIcIAIgATYCFCACQZUJNgIQIAJBCzYCDAwMC0EAIQMgAkEANgIcIAIgATYCFCACQeEPNgIQIAJBCjYCDAwLC0EAIQMgAkEANgIcIAIgATYCFCACQfsPNgIQIAJBCjYCDAwKC0EAIQMgAkEANgIcIAIgATYCFCACQfEZNgIQIAJBAjYCDAwJC0EAIQMgAkEANgIcIAIgATYCFCACQcQUNgIQIAJBAjYCDAwIC0EAIQMgAkEANgIcIAIgATYCFCACQfIVNgIQIAJBAjYCDAwHCyACQQI2AhwgAiABNgIUIAJBnBo2AhAgAkEWNgIMQQAhAwwGC0EBIQMMBQtB1AAhAyABIARGDQQgCEEIaiEJIAIoAgAhBQJAAkAgASAERwRAIAVB2MIAaiEHIAQgBWogAWshACAFQX9zQQpqIgUgAWohBgNAIAEtAAAgBy0AAEcEQEECIQcMAwsgBUUEQEEAIQcgBiEBDAMLIAVBAWshBSAHQQFqIQcgBCABQQFqIgFHDQALIAAhBSAEIQELIAlBATYCACACIAU2AgAMAQsgAkEANgIAIAkgBzYCAAsgCSABNgIEIAgoAgwhACAIKAIIDgMBBAIACwALIAJBADYCHCACQbUaNgIQIAJBFzYCDCACIABBAWo2AhRBACEDDAILIAJBADYCHCACIAA2AhQgAkHKGjYCECACQQk2AgxBACEDDAELIAEgBEYEQEEiIQMMAQsgAkEJNgIIIAIgATYCBEEhIQMLIAhBEGokACADRQRAIAIoAgwhAAwBCyACIAM2AhxBACEAIAIoAgQiAUUNACACIAEgBCACKAIIEQEAIgFFDQAgAiAENgIUIAIgATYCDCABIQALIAALvgIBAn8gAEEAOgAAIABB3ABqIgFBAWtBADoAACAAQQA6AAIgAEEAOgABIAFBA2tBADoAACABQQJrQQA6AAAgAEEAOgADIAFBBGtBADoAAEEAIABrQQNxIgEgAGoiAEEANgIAQdwAIAFrQXxxIgIgAGoiAUEEa0EANgIAAkAgAkEJSQ0AIABBADYCCCAAQQA2AgQgAUEIa0EANgIAIAFBDGtBADYCACACQRlJDQAgAEEANgIYIABBADYCFCAAQQA2AhAgAEEANgIMIAFBEGtBADYCACABQRRrQQA2AgAgAUEYa0EANgIAIAFBHGtBADYCACACIABBBHFBGHIiAmsiAUEgSQ0AIAAgAmohAANAIABCADcDGCAAQgA3AxAgAEIANwMIIABCADcDACAAQSBqIQAgAUEgayIBQR9LDQALCwtWAQF/AkAgACgCDA0AAkACQAJAAkAgAC0ALw4DAQADAgsgACgCOCIBRQ0AIAEoAiwiAUUNACAAIAERAAAiAQ0DC0EADwsACyAAQcMWNgIQQQ4hAQsgAQsaACAAKAIMRQRAIABB0Rs2AhAgAEEVNgIMCwsUACAAKAIMQRVGBEAgAEEANgIMCwsUACAAKAIMQRZGBEAgAEEANgIMCwsHACAAKAIMCwcAIAAoAhALCQAgACABNgIQCwcAIAAoAhQLFwAgAEEkTwRAAAsgAEECdEGgM2ooAgALFwAgAEEuTwRAAAsgAEECdEGwNGooAgALvwkBAX9B6yghAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtXACAAQRhqQgA3AwAgAEIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABB3QE2AhwLBgAgABAyC5otAQt/IwBBEGsiCiQAQaTQACgCACIJRQRAQeTTACgCACIFRQRAQfDTAEJ/NwIAQejTAEKAgISAgIDAADcCAEHk0wAgCkEIakFwcUHYqtWqBXMiBTYCAEH40wBBADYCAEHI0wBBADYCAAtBzNMAQYDUBDYCAEGc0ABBgNQENgIAQbDQACAFNgIAQazQAEF/NgIAQdDTAEGArAM2AgADQCABQcjQAGogAUG80ABqIgI2AgAgAiABQbTQAGoiAzYCACABQcDQAGogAzYCACABQdDQAGogAUHE0ABqIgM2AgAgAyACNgIAIAFB2NAAaiABQczQAGoiAjYCACACIAM2AgAgAUHU0ABqIAI2AgAgAUEgaiIBQYACRw0AC0GM1ARBwasDNgIAQajQAEH00wAoAgA2AgBBmNAAQcCrAzYCAEGk0ABBiNQENgIAQcz/B0E4NgIAQYjUBCEJCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFNBEBBjNAAKAIAIgZBECAAQRNqQXBxIABBC0kbIgRBA3YiAHYiAUEDcQRAAkAgAUEBcSAAckEBcyICQQN0IgBBtNAAaiIBIABBvNAAaigCACIAKAIIIgNGBEBBjNAAIAZBfiACd3E2AgAMAQsgASADNgIIIAMgATYCDAsgAEEIaiEBIAAgAkEDdCICQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDBELQZTQACgCACIIIARPDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIAQQN0IgJBtNAAaiIBIAJBvNAAaigCACICKAIIIgNGBEBBjNAAIAZBfiAAd3EiBjYCAAwBCyABIAM2AgggAyABNgIMCyACIARBA3I2AgQgAEEDdCIAIARrIQUgACACaiAFNgIAIAIgBGoiBCAFQQFyNgIEIAgEQCAIQXhxQbTQAGohAEGg0AAoAgAhAwJ/QQEgCEEDdnQiASAGcUUEQEGM0AAgASAGcjYCACAADAELIAAoAggLIgEgAzYCDCAAIAM2AgggAyAANgIMIAMgATYCCAsgAkEIaiEBQaDQACAENgIAQZTQACAFNgIADBELQZDQACgCACILRQ0BIAtoQQJ0QbzSAGooAgAiACgCBEF4cSAEayEFIAAhAgNAAkAgAigCECIBRQRAIAJBFGooAgAiAUUNAQsgASgCBEF4cSAEayIDIAVJIQIgAyAFIAIbIQUgASAAIAIbIQAgASECDAELCyAAKAIYIQkgACgCDCIDIABHBEBBnNAAKAIAGiADIAAoAggiATYCCCABIAM2AgwMEAsgAEEUaiICKAIAIgFFBEAgACgCECIBRQ0DIABBEGohAgsDQCACIQcgASIDQRRqIgIoAgAiAQ0AIANBEGohAiADKAIQIgENAAsgB0EANgIADA8LQX8hBCAAQb9/Sw0AIABBE2oiAUFwcSEEQZDQACgCACIIRQ0AQQAgBGshBQJAAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBvNIAaigCACICRQRAQQAhAUEAIQMMAQtBACEBIARBGSAGQQF2a0EAIAZBH0cbdCEAQQAhAwNAAkAgAigCBEF4cSAEayIHIAVPDQAgAiEDIAciBQ0AQQAhBSACIQEMAwsgASACQRRqKAIAIgcgByACIABBHXZBBHFqQRBqKAIAIgJGGyABIAcbIQEgAEEBdCEAIAINAAsLIAEgA3JFBEBBACEDQQIgBnQiAEEAIABrciAIcSIARQ0DIABoQQJ0QbzSAGooAgAhAQsgAUUNAQsDQCABKAIEQXhxIARrIgIgBUkhACACIAUgABshBSABIAMgABshAyABKAIQIgAEfyAABSABQRRqKAIACyIBDQALCyADRQ0AIAVBlNAAKAIAIARrTw0AIAMoAhghByADIAMoAgwiAEcEQEGc0AAoAgAaIAAgAygCCCIBNgIIIAEgADYCDAwOCyADQRRqIgIoAgAiAUUEQCADKAIQIgFFDQMgA0EQaiECCwNAIAIhBiABIgBBFGoiAigCACIBDQAgAEEQaiECIAAoAhAiAQ0ACyAGQQA2AgAMDQtBlNAAKAIAIgMgBE8EQEGg0AAoAgAhAQJAIAMgBGsiAkEQTwRAIAEgBGoiACACQQFyNgIEIAEgA2ogAjYCACABIARBA3I2AgQMAQsgASADQQNyNgIEIAEgA2oiACAAKAIEQQFyNgIEQQAhAEEAIQILQZTQACACNgIAQaDQACAANgIAIAFBCGohAQwPC0GY0AAoAgAiAyAESwRAIAQgCWoiACADIARrIgFBAXI2AgRBpNAAIAA2AgBBmNAAIAE2AgAgCSAEQQNyNgIEIAlBCGohAQwPC0EAIQEgBAJ/QeTTACgCAARAQezTACgCAAwBC0Hw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBDGpBcHFB2KrVqgVzNgIAQfjTAEEANgIAQcjTAEEANgIAQYCABAsiACAEQccAaiIFaiIGQQAgAGsiB3EiAk8EQEH80wBBMDYCAAwPCwJAQcTTACgCACIBRQ0AQbzTACgCACIIIAJqIQAgACABTSAAIAhLcQ0AQQAhAUH80wBBMDYCAAwPC0HI0wAtAABBBHENBAJAAkAgCQRAQczTACEBA0AgASgCACIAIAlNBEAgACABKAIEaiAJSw0DCyABKAIIIgENAAsLQQAQMyIAQX9GDQUgAiEGQejTACgCACIBQQFrIgMgAHEEQCACIABrIAAgA2pBACABa3FqIQYLIAQgBk8NBSAGQf7///8HSw0FQcTTACgCACIDBEBBvNMAKAIAIgcgBmohASABIAdNDQYgASADSw0GCyAGEDMiASAARw0BDAcLIAYgA2sgB3EiBkH+////B0sNBCAGEDMhACAAIAEoAgAgASgCBGpGDQMgACEBCwJAIAYgBEHIAGpPDQAgAUF/Rg0AQezTACgCACIAIAUgBmtqQQAgAGtxIgBB/v///wdLBEAgASEADAcLIAAQM0F/RwRAIAAgBmohBiABIQAMBwtBACAGaxAzGgwECyABIgBBf0cNBQwDC0EAIQMMDAtBACEADAoLIABBf0cNAgtByNMAQcjTACgCAEEEcjYCAAsgAkH+////B0sNASACEDMhAEEAEDMhASAAQX9GDQEgAUF/Rg0BIAAgAU8NASABIABrIgYgBEE4ak0NAQtBvNMAQbzTACgCACAGaiIBNgIAQcDTACgCACABSQRAQcDTACABNgIACwJAAkACQEGk0AAoAgAiAgRAQczTACEBA0AgACABKAIAIgMgASgCBCIFakYNAiABKAIIIgENAAsMAgtBnNAAKAIAIgFBAEcgACABT3FFBEBBnNAAIAA2AgALQQAhAUHQ0wAgBjYCAEHM0wAgADYCAEGs0ABBfzYCAEGw0ABB5NMAKAIANgIAQdjTAEEANgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBeCAAa0EPcSIBIABqIgIgBkE4ayIDIAFrIgFBAXI2AgRBqNAAQfTTACgCADYCAEGY0AAgATYCAEGk0AAgAjYCACAAIANqQTg2AgQMAgsgACACTQ0AIAIgA0kNACABKAIMQQhxDQBBeCACa0EPcSIAIAJqIgNBmNAAKAIAIAZqIgcgAGsiAEEBcjYCBCABIAUgBmo2AgRBqNAAQfTTACgCADYCAEGY0AAgADYCAEGk0AAgAzYCACACIAdqQTg2AgQMAQsgAEGc0AAoAgBJBEBBnNAAIAA2AgALIAAgBmohA0HM0wAhAQJAAkACQANAIAMgASgCAEcEQCABKAIIIgENAQwCCwsgAS0ADEEIcUUNAQtBzNMAIQEDQCABKAIAIgMgAk0EQCADIAEoAgRqIgUgAksNAwsgASgCCCEBDAALAAsgASAANgIAIAEgASgCBCAGajYCBCAAQXggAGtBD3FqIgkgBEEDcjYCBCADQXggA2tBD3FqIgYgBCAJaiIEayEBIAIgBkYEQEGk0AAgBDYCAEGY0ABBmNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEDAgLQaDQACgCACAGRgRAQaDQACAENgIAQZTQAEGU0AAoAgAgAWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAgLIAYoAgQiBUEDcUEBRw0GIAVBeHEhCCAFQf8BTQRAIAVBA3YhAyAGKAIIIgAgBigCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBwsgAiAANgIIIAAgAjYCDAwGCyAGKAIYIQcgBiAGKAIMIgBHBEAgACAGKAIIIgI2AgggAiAANgIMDAULIAZBFGoiAigCACIFRQRAIAYoAhAiBUUNBCAGQRBqIQILA0AgAiEDIAUiAEEUaiICKAIAIgUNACAAQRBqIQIgACgCECIFDQALIANBADYCAAwEC0F4IABrQQ9xIgEgAGoiByAGQThrIgMgAWsiAUEBcjYCBCAAIANqQTg2AgQgAiAFQTcgBWtBD3FqQT9rIgMgAyACQRBqSRsiA0EjNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAc2AgAgA0EQakHU0wApAgA3AgAgA0HM0wApAgA3AghB1NMAIANBCGo2AgBB0NMAIAY2AgBBzNMAIAA2AgBB2NMAQQA2AgAgA0EkaiEBA0AgAUEHNgIAIAUgAUEEaiIBSw0ACyACIANGDQAgAyADKAIEQX5xNgIEIAMgAyACayIFNgIAIAIgBUEBcjYCBCAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIDcUUEQEGM0AAgASADcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEGQ0AAoAgAiA0EBIAF0IgZxRQRAIAAgAjYCAEGQ0AAgAyAGcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQMCQANAIAMiACgCBEF4cSAFRg0BIAFBHXYhAyABQQF0IQEgACADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAtBmNAAKAIAIgEgBE0NAEGk0AAoAgAiACAEaiICIAEgBGsiAUEBcjYCBEGY0AAgATYCAEGk0AAgAjYCACAAIARBA3I2AgQgAEEIaiEBDAgLQQAhAUH80wBBMDYCAAwHC0EAIQALIAdFDQACQCAGKAIcIgJBAnRBvNIAaiIDKAIAIAZGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAdBEEEUIAcoAhAgBkYbaiAANgIAIABFDQELIAAgBzYCGCAGKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAGQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAIaiEBIAYgCGoiBigCBCEFCyAGIAVBfnE2AgQgASAEaiABNgIAIAQgAUEBcjYCBCABQf8BTQRAIAFBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASABQQN2dCIBcUUEQEGM0AAgASACcjYCACAADAELIAAoAggLIgEgBDYCDCAAIAQ2AgggBCAANgIMIAQgATYCCAwBC0EfIQUgAUH///8HTQRAIAFBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBQsgBCAFNgIcIARCADcCECAFQQJ0QbzSAGohAEGQ0AAoAgAiAkEBIAV0IgNxRQRAIAAgBDYCAEGQ0AAgAiADcjYCACAEIAA2AhggBCAENgIIIAQgBDYCDAwBCyABQRkgBUEBdmtBACAFQR9HG3QhBSAAKAIAIQACQANAIAAiAigCBEF4cSABRg0BIAVBHXYhACAFQQF0IQUgAiAAQQRxakEQaiIDKAIAIgANAAsgAyAENgIAIAQgAjYCGCAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgCUEIaiEBDAILAkAgB0UNAAJAIAMoAhwiAUECdEG80gBqIgIoAgAgA0YEQCACIAA2AgAgAA0BQZDQACAIQX4gAXdxIgg2AgAMAgsgB0EQQRQgBygCECADRhtqIAA2AgAgAEUNAQsgACAHNgIYIAMoAhAiAQRAIAAgATYCECABIAA2AhgLIANBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAIAVBD00EQCADIAQgBWoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARqIgIgBUEBcjYCBCADIARBA3I2AgQgAiAFaiAFNgIAIAVB/wFNBEAgBUF4cUG00ABqIQACf0GM0AAoAgAiAUEBIAVBA3Z0IgVxRQRAQYzQACABIAVyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRBvNIAaiEAQQEgAXQiBCAIcUUEQCAAIAI2AgBBkNAAIAQgCHI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEEAkADQCAEIgAoAgRBeHEgBUYNASABQR12IQQgAUEBdCEBIAAgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLIANBCGohAQwBCwJAIAlFDQACQCAAKAIcIgFBAnRBvNIAaiICKAIAIABGBEAgAiADNgIAIAMNAUGQ0AAgC0F+IAF3cTYCAAwCCyAJQRBBFCAJKAIQIABGG2ogAzYCACADRQ0BCyADIAk2AhggACgCECIBBEAgAyABNgIQIAEgAzYCGAsgAEEUaigCACIBRQ0AIANBFGogATYCACABIAM2AhgLAkAgBUEPTQRAIAAgBCAFaiIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELIAAgBGoiByAFQQFyNgIEIAAgBEEDcjYCBCAFIAdqIAU2AgAgCARAIAhBeHFBtNAAaiEBQaDQACgCACEDAn9BASAIQQN2dCICIAZxRQRAQYzQACACIAZyNgIAIAEMAQsgASgCCAsiAiADNgIMIAEgAzYCCCADIAE2AgwgAyACNgIIC0Gg0AAgBzYCAEGU0AAgBTYCAAsgAEEIaiEBCyAKQRBqJAAgAQtDACAARQRAPwBBEHQPCwJAIABB//8DcQ0AIABBAEgNACAAQRB2QAAiAEF/RgRAQfzTAEEwNgIAQX8PCyAAQRB0DwsACwvcPyIAQYAICwkBAAAAAgAAAAMAQZQICwUEAAAABQBBpAgLCQYAAAAHAAAACABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv",
		"base64",
	)
})
var jee = x((rIt, zee) => {
	"use strict"
	var { Buffer: FHe } = require("buffer")
	zee.exports = FHe.from(
		"AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIdbGxodHRwX3NldF9sZW5pZW50X2tlZXBfYWxpdmUAIyRsbGh0dHBfc2V0X2xlbmllbnRfdHJhbnNmZXJfZW5jb2RpbmcAJBhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YALgkXAQBBAQsRAQIDBAUKBgcrLSwqKSglJyYK77MCLBYAQYjQACgCAARAAAtBiNAAQQE2AgALFAAgABAwIAAgAjYCOCAAIAE6ACgLFAAgACAALwEyIAAtAC4gABAvEAALHgEBf0HAABAyIgEQMCABQYAINgI4IAEgADoAKCABC48MAQd/AkAgAEUNACAAQQhrIgEgAEEEaygCACIAQXhxIgRqIQUCQCAAQQFxDQAgAEEDcUUNASABIAEoAgAiAGsiAUGc0AAoAgBJDQEgACAEaiEEAkACQEGg0AAoAgAgAUcEQCAAQf8BTQRAIABBA3YhAyABKAIIIgAgASgCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyABKAIYIQYgASABKAIMIgBHBEAgACABKAIIIgI2AgggAiAANgIMDAMLIAFBFGoiAygCACICRQRAIAEoAhAiAkUNAiABQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFKAIEIgBBA3FBA0cNAiAFIABBfnE2AgRBlNAAIAQ2AgAgBSAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCABKAIcIgJBAnRBvNIAaiIDKAIAIAFGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgAUYbaiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAFTw0AIAUoAgQiAEEBcUUNAAJAAkACQAJAIABBAnFFBEBBpNAAKAIAIAVGBEBBpNAAIAE2AgBBmNAAQZjQACgCACAEaiIANgIAIAEgAEEBcjYCBCABQaDQACgCAEcNBkGU0ABBADYCAEGg0ABBADYCAAwGC0Gg0AAoAgAgBUYEQEGg0AAgATYCAEGU0ABBlNAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAwGCyAAQXhxIARqIQQgAEH/AU0EQCAAQQN2IQMgBSgCCCIAIAUoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgBSgCGCEGIAUgBSgCDCIARwRAQZzQACgCABogACAFKAIIIgI2AgggAiAANgIMDAMLIAVBFGoiAygCACICRQRAIAUoAhAiAkUNAiAFQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFIABBfnE2AgQgASAEaiAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCAFKAIcIgJBAnRBvNIAaiIDKAIAIAVGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiAANgIAIABFDQELIAAgBjYCGCAFKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAFQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAEaiAENgIAIAEgBEEBcjYCBCABQaDQACgCAEcNAEGU0AAgBDYCAAwBCyAEQf8BTQRAIARBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASAEQQN2dCIDcUUEQEGM0AAgAiADcjYCACAADAELIAAoAggLIgIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCAwBC0EfIQIgBEH///8HTQRAIARBJiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAgsgASACNgIcIAFCADcCECACQQJ0QbzSAGohAAJAQZDQACgCACIDQQEgAnQiB3FFBEAgACABNgIAQZDQACADIAdyNgIAIAEgADYCGCABIAE2AgggASABNgIMDAELIARBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAAJAA0AgACIDKAIEQXhxIARGDQEgAkEddiEAIAJBAXQhAiADIABBBHFqQRBqIgcoAgAiAA0ACyAHIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggMAQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0Gs0ABBrNAAKAIAQQFrIgBBfyAAGzYCAAsLBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LQAEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABAwIAAgBDYCOCAAIAM6ACggACACOgAtIAAgATYCGAu74gECB38DfiABIAJqIQQCQCAAIgIoAgwiAA0AIAIoAgQEQCACIAE2AgQLIwBBEGsiCCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAhwiA0EBaw7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAMxgELQQ4MxQELQQ0MxAELQQ8MwwELQRAMwgELQRMMwQELQRQMwAELQRUMvwELQRYMvgELQRgMvQELQRkMvAELQRoMuwELQRsMugELQRwMuQELQR0MuAELQQgMtwELQR4MtgELQSAMtQELQR8MtAELQQcMswELQSEMsgELQSIMsQELQSMMsAELQSQMrwELQRIMrgELQREMrQELQSUMrAELQSYMqwELQScMqgELQSgMqQELQcMBDKgBC0EqDKcBC0ErDKYBC0EsDKUBC0EtDKQBC0EuDKMBC0EvDKIBC0HEAQyhAQtBMAygAQtBNAyfAQtBDAyeAQtBMQydAQtBMgycAQtBMwybAQtBOQyaAQtBNQyZAQtBxQEMmAELQQsMlwELQToMlgELQTYMlQELQQoMlAELQTcMkwELQTgMkgELQTwMkQELQTsMkAELQT0MjwELQQkMjgELQSkMjQELQT4MjAELQT8MiwELQcAADIoBC0HBAAyJAQtBwgAMiAELQcMADIcBC0HEAAyGAQtBxQAMhQELQcYADIQBC0EXDIMBC0HHAAyCAQtByAAMgQELQckADIABC0HKAAx/C0HLAAx+C0HNAAx9C0HMAAx8C0HOAAx7C0HPAAx6C0HQAAx5C0HRAAx4C0HSAAx3C0HTAAx2C0HUAAx1C0HWAAx0C0HVAAxzC0EGDHILQdcADHELQQUMcAtB2AAMbwtBBAxuC0HZAAxtC0HaAAxsC0HbAAxrC0HcAAxqC0EDDGkLQd0ADGgLQd4ADGcLQd8ADGYLQeEADGULQeAADGQLQeIADGMLQeMADGILQQIMYQtB5AAMYAtB5QAMXwtB5gAMXgtB5wAMXQtB6AAMXAtB6QAMWwtB6gAMWgtB6wAMWQtB7AAMWAtB7QAMVwtB7gAMVgtB7wAMVQtB8AAMVAtB8QAMUwtB8gAMUgtB8wAMUQtB9AAMUAtB9QAMTwtB9gAMTgtB9wAMTQtB+AAMTAtB+QAMSwtB+gAMSgtB+wAMSQtB/AAMSAtB/QAMRwtB/gAMRgtB/wAMRQtBgAEMRAtBgQEMQwtBggEMQgtBgwEMQQtBhAEMQAtBhQEMPwtBhgEMPgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADDsYBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHyAhIyUmKCorLC8wMTIzNDU2Nzk6Ozw9lANAQkRFRklLTk9QUVJTVFVWWFpbXF1eX2BhYmNkZWZnaGpsb3Bxc3V2eHl6e3x/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcsBzAHNAc4BzwGKA4kDiAOHA4QDgwOAA/sC+gL5AvgC9wL0AvMC8gLLAsECsALZAQsgASAERw3wAkHdASEDDLMDCyABIARHDcgBQcMBIQMMsgMLIAEgBEcNe0H3ACEDDLEDCyABIARHDXBB7wAhAwywAwsgASAERw1pQeoAIQMMrwMLIAEgBEcNZUHoACEDDK4DCyABIARHDWJB5gAhAwytAwsgASAERw0aQRghAwysAwsgASAERw0VQRIhAwyrAwsgASAERw1CQcUAIQMMqgMLIAEgBEcNNEE/IQMMqQMLIAEgBEcNMkE8IQMMqAMLIAEgBEcNK0ExIQMMpwMLIAItAC5BAUYNnwMMwQILQQAhAAJAAkACQCACLQAqRQ0AIAItACtFDQAgAi8BMCIDQQJxRQ0BDAILIAIvATAiA0EBcUUNAQtBASEAIAItAChBAUYNACACLwEyIgVB5ABrQeQASQ0AIAVBzAFGDQAgBUGwAkYNACADQcAAcQ0AQQAhACADQYgEcUGABEYNACADQShxQQBHIQALIAJBADsBMCACQQA6AC8gAEUN3wIgAkIANwMgDOACC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAARQ3MASAAQRVHDd0CIAJBBDYCHCACIAE2AhQgAkGwGDYCECACQRU2AgxBACEDDKQDCyABIARGBEBBBiEDDKQDCyABQQFqIQFBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAA3ZAgwcCyACQgA3AyBBEiEDDIkDCyABIARHDRZBHSEDDKEDCyABIARHBEAgAUEBaiEBQRAhAwyIAwtBByEDDKADCyACIAIpAyAiCiAEIAFrrSILfSIMQgAgCiAMWhs3AyAgCiALWA3UAkEIIQMMnwMLIAEgBEcEQCACQQk2AgggAiABNgIEQRQhAwyGAwtBCSEDDJ4DCyACKQMgQgBSDccBIAIgAi8BMEGAAXI7ATAMQgsgASAERw0/QdAAIQMMnAMLIAEgBEYEQEELIQMMnAMLIAFBAWohAUEAIQACQCACKAI4IgNFDQAgAygCUCIDRQ0AIAIgAxEAACEACyAADc8CDMYBC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ3GASAAQRVHDc0CIAJBCzYCHCACIAE2AhQgAkGCGTYCECACQRU2AgxBACEDDJoDC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ0MIABBFUcNygIgAkEaNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMmQMLQQAhAAJAIAIoAjgiA0UNACADKAJMIgNFDQAgAiADEQAAIQALIABFDcQBIABBFUcNxwIgAkELNgIcIAIgATYCFCACQZEXNgIQIAJBFTYCDEEAIQMMmAMLIAEgBEYEQEEPIQMMmAMLIAEtAAAiAEE7Rg0HIABBDUcNxAIgAUEBaiEBDMMBC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3DASAAQRVHDcICIAJBDzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJYDCwNAIAEtAABB8DVqLQAAIgBBAUcEQCAAQQJHDcECIAIoAgQhAEEAIQMgAkEANgIEIAIgACABQQFqIgEQLSIADcICDMUBCyAEIAFBAWoiAUcNAAtBEiEDDJUDC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3FASAAQRVHDb0CIAJBGzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJQDCyABIARGBEBBFiEDDJQDCyACQQo2AgggAiABNgIEQQAhAAJAIAIoAjgiA0UNACADKAJIIgNFDQAgAiADEQAAIQALIABFDcIBIABBFUcNuQIgAkEVNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMkwMLIAEgBEcEQANAIAEtAABB8DdqLQAAIgBBAkcEQAJAIABBAWsOBMQCvQIAvgK9AgsgAUEBaiEBQQghAwz8AgsgBCABQQFqIgFHDQALQRUhAwyTAwtBFSEDDJIDCwNAIAEtAABB8DlqLQAAIgBBAkcEQCAAQQFrDgTFArcCwwK4ArcCCyAEIAFBAWoiAUcNAAtBGCEDDJEDCyABIARHBEAgAkELNgIIIAIgATYCBEEHIQMM+AILQRkhAwyQAwsgAUEBaiEBDAILIAEgBEYEQEEaIQMMjwMLAkAgAS0AAEENaw4UtQG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwEAvwELQQAhAyACQQA2AhwgAkGvCzYCECACQQI2AgwgAiABQQFqNgIUDI4DCyABIARGBEBBGyEDDI4DCyABLQAAIgBBO0cEQCAAQQ1HDbECIAFBAWohAQy6AQsgAUEBaiEBC0EiIQMM8wILIAEgBEYEQEEcIQMMjAMLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43wQLAAgABAgMEBQYH0AHQAdAB0AHQAdAB0AEICQoLDA3QAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdABDg8QERIT0AELQgIhCgzAAgtCAyEKDL8CC0IEIQoMvgILQgUhCgy9AgtCBiEKDLwCC0IHIQoMuwILQgghCgy6AgtCCSEKDLkCC0IKIQoMuAILQgshCgy3AgtCDCEKDLYCC0INIQoMtQILQg4hCgy0AgtCDyEKDLMCC0IKIQoMsgILQgshCgyxAgtCDCEKDLACC0INIQoMrwILQg4hCgyuAgtCDyEKDK0CC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsON8ACvwIAAQIDBAUGB74CvgK+Ar4CvgK+Ar4CCAkKCwwNvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ag4PEBESE74CC0ICIQoMvwILQgMhCgy+AgtCBCEKDL0CC0IFIQoMvAILQgYhCgy7AgtCByEKDLoCC0IIIQoMuQILQgkhCgy4AgtCCiEKDLcCC0ILIQoMtgILQgwhCgy1AgtCDSEKDLQCC0IOIQoMswILQg8hCgyyAgtCCiEKDLECC0ILIQoMsAILQgwhCgyvAgtCDSEKDK4CC0IOIQoMrQILQg8hCgysAgsgAiACKQMgIgogBCABa60iC30iDEIAIAogDFobNwMgIAogC1gNpwJBHyEDDIkDCyABIARHBEAgAkEJNgIIIAIgATYCBEElIQMM8AILQSAhAwyIAwtBASEFIAIvATAiA0EIcUUEQCACKQMgQgBSIQULAkAgAi0ALgRAQQEhACACLQApQQVGDQEgA0HAAHFFIAVxRQ0BC0EAIQAgA0HAAHENAEECIQAgA0EIcQ0AIANBgARxBEACQCACLQAoQQFHDQAgAi0ALUEKcQ0AQQUhAAwCC0EEIQAMAQsgA0EgcUUEQAJAIAItAChBAUYNACACLwEyIgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNAEEEIQAgA0EocUUNAiADQYgEcUGABEYNAgtBACEADAELQQBBAyACKQMgUBshAAsgAEEBaw4FvgIAsAEBpAKhAgtBESEDDO0CCyACQQE6AC8MhAMLIAEgBEcNnQJBJCEDDIQDCyABIARHDRxBxgAhAwyDAwtBACEAAkAgAigCOCIDRQ0AIAMoAkQiA0UNACACIAMRAAAhAAsgAEUNJyAAQRVHDZgCIAJB0AA2AhwgAiABNgIUIAJBkRg2AhAgAkEVNgIMQQAhAwyCAwsgASAERgRAQSghAwyCAwtBACEDIAJBADYCBCACQQw2AgggAiABIAEQKiIARQ2UAiACQSc2AhwgAiABNgIUIAIgADYCDAyBAwsgASAERgRAQSkhAwyBAwsgAS0AACIAQSBGDRMgAEEJRw2VAiABQQFqIQEMFAsgASAERwRAIAFBAWohAQwWC0EqIQMM/wILIAEgBEYEQEErIQMM/wILIAEtAAAiAEEJRyAAQSBHcQ2QAiACLQAsQQhHDd0CIAJBADoALAzdAgsgASAERgRAQSwhAwz+AgsgAS0AAEEKRw2OAiABQQFqIQEMsAELIAEgBEcNigJBLyEDDPwCCwNAIAEtAAAiAEEgRwRAIABBCmsOBIQCiAKIAoQChgILIAQgAUEBaiIBRw0AC0ExIQMM+wILQTIhAyABIARGDfoCIAIoAgAiACAEIAFraiEHIAEgAGtBA2ohBgJAA0AgAEHwO2otAAAgAS0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAEEDRgRAQQYhAQziAgsgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAc2AgAM+wILIAJBADYCAAyGAgtBMyEDIAQgASIARg35AiAEIAFrIAIoAgAiAWohByAAIAFrQQhqIQYCQANAIAFB9DtqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBCEYEQEEFIQEM4QILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPoCCyACQQA2AgAgACEBDIUCC0E0IQMgBCABIgBGDfgCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgJAA0AgAUHQwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYEQEEHIQEM4AILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPkCCyACQQA2AgAgACEBDIQCCyABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRg0JDIECCyAEIAFBAWoiAUcNAAtBMCEDDPgCC0EwIQMM9wILIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBP8B/gH+Af8B/gELIAQgAUEBaiIBRw0AC0E4IQMM9wILQTghAwz2AgsDQCABLQAAIgBBIEcgAEEJR3EN9gEgBCABQQFqIgFHDQALQTwhAwz1AgsDQCABLQAAIgBBIEcEQAJAIABBCmsOBPkBBAT5AQALIABBLEYN9QEMAwsgBCABQQFqIgFHDQALQT8hAwz0AgtBwAAhAyABIARGDfMCIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEGAQGstAAAgAS0AAEEgckcNASAAQQZGDdsCIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPQCCyACQQA2AgALQTYhAwzZAgsgASAERgRAQcEAIQMM8gILIAJBDDYCCCACIAE2AgQgAi0ALEEBaw4E+wHuAewB6wHUAgsgAUEBaiEBDPoBCyABIARHBEADQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxIgBBCUYNACAAQSBGDQACQAJAAkACQCAAQeMAaw4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIQMM3AILIAFBAWohAUEyIQMM2wILIAFBAWohAUEzIQMM2gILDP4BCyAEIAFBAWoiAUcNAAtBNSEDDPACC0E1IQMM7wILIAEgBEcEQANAIAEtAABBgDxqLQAAQQFHDfcBIAQgAUEBaiIBRw0AC0E9IQMM7wILQT0hAwzuAgtBACEAAkAgAigCOCIDRQ0AIAMoAkAiA0UNACACIAMRAAAhAAsgAEUNASAAQRVHDeYBIAJBwgA2AhwgAiABNgIUIAJB4xg2AhAgAkEVNgIMQQAhAwztAgsgAUEBaiEBC0E8IQMM0gILIAEgBEYEQEHCACEDDOsCCwJAA0ACQCABLQAAQQlrDhgAAswCzALRAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAgDMAgsgBCABQQFqIgFHDQALQcIAIQMM6wILIAFBAWohASACLQAtQQFxRQ3+AQtBLCEDDNACCyABIARHDd4BQcQAIQMM6AILA0AgAS0AAEGQwABqLQAAQQFHDZwBIAQgAUEBaiIBRw0AC0HFACEDDOcCCyABLQAAIgBBIEYN/gEgAEE6Rw3AAiACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgAN3gEM3QELQccAIQMgBCABIgBGDeUCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFBkMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvwIgAUEFRg3CAiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzlAgtByAAhAyAEIAEiAEYN5AIgBCABayACKAIAIgFqIQcgACABa0EJaiEGA0AgAUGWwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw2+AkECIAFBCUYNwgIaIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOQCCyABIARGBEBByQAhAwzkAgsCQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxQe4Aaw4HAL8CvwK/Ar8CvwIBvwILIAFBAWohAUE+IQMMywILIAFBAWohAUE/IQMMygILQcoAIQMgBCABIgBGDeICIAQgAWsgAigCACIBaiEGIAAgAWtBAWohBwNAIAFBoMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvAIgAUEBRg2+AiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBjYCAAziAgtBywAhAyAEIAEiAEYN4QIgBCABayACKAIAIgFqIQcgACABa0EOaiEGA0AgAUGiwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw27AiABQQ5GDb4CIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOECC0HMACEDIAQgASIARg3gAiAEIAFrIAIoAgAiAWohByAAIAFrQQ9qIQYDQCABQcDCAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDboCQQMgAUEPRg2+AhogAUEBaiEBIAQgAEEBaiIARw0ACyACIAc2AgAM4AILQc0AIQMgBCABIgBGDd8CIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFB0MIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNuQJBBCABQQVGDb0CGiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzfAgsgASAERgRAQc4AIQMM3wILAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAvAK8ArwCvAK8ArwCvAK8ArwCvAK8ArwCAbwCvAK8AgIDvAILIAFBAWohAUHBACEDDMgCCyABQQFqIQFBwgAhAwzHAgsgAUEBaiEBQcMAIQMMxgILIAFBAWohAUHEACEDDMUCCyABIARHBEAgAkENNgIIIAIgATYCBEHFACEDDMUCC0HPACEDDN0CCwJAAkAgAS0AAEEKaw4EAZABkAEAkAELIAFBAWohAQtBKCEDDMMCCyABIARGBEBB0QAhAwzcAgsgAS0AAEEgRw0AIAFBAWohASACLQAtQQFxRQ3QAQtBFyEDDMECCyABIARHDcsBQdIAIQMM2QILQdMAIQMgASAERg3YAiACKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABB1sIAai0AAEcNxwEgAEEBRg3KASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBjYCAAzYAgsgASAERgRAQdUAIQMM2AILIAEtAABBCkcNwgEgAUEBaiEBDMoBCyABIARGBEBB1gAhAwzXAgsCQAJAIAEtAABBCmsOBADDAcMBAcMBCyABQQFqIQEMygELIAFBAWohAUHKACEDDL0CC0EAIQACQCACKAI4IgNFDQAgAygCPCIDRQ0AIAIgAxEAACEACyAADb8BQc0AIQMMvAILIAItAClBIkYNzwIMiQELIAQgASIFRgRAQdsAIQMM1AILQQAhAEEBIQFBASEGQQAhAwJAAn8CQAJAAkACQAJAAkACQCAFLQAAQTBrDgrFAcQBAAECAwQFBgjDAQtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshA0EAIQFBACEGDL0BC0EJIQNBASEAQQAhAUEAIQYMvAELIAEgBEYEQEHdACEDDNMCCyABLQAAQS5HDbgBIAFBAWohAQyIAQsgASAERw22AUHfACEDDNECCyABIARHBEAgAkEONgIIIAIgATYCBEHQACEDDLgCC0HgACEDDNACC0HhACEDIAEgBEYNzwIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGA0AgAS0AACAAQeLCAGotAABHDbEBIABBA0YNswEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMzwILQeIAIQMgASAERg3OAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYDQCABLQAAIABB5sIAai0AAEcNsAEgAEECRg2vASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAzOAgtB4wAhAyABIARGDc0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgNAIAEtAAAgAEHpwgBqLQAARw2vASAAQQNGDa0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADM0CCyABIARGBEBB5QAhAwzNAgsgAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANqgFB1gAhAwyzAgsgASAERwRAA0AgAS0AACIAQSBHBEACQAJAAkAgAEHIAGsOCwABswGzAbMBswGzAbMBswGzAQKzAQsgAUEBaiEBQdIAIQMMtwILIAFBAWohAUHTACEDDLYCCyABQQFqIQFB1AAhAwy1AgsgBCABQQFqIgFHDQALQeQAIQMMzAILQeQAIQMMywILA0AgAS0AAEHwwgBqLQAAIgBBAUcEQCAAQQJrDgOnAaYBpQGkAQsgBCABQQFqIgFHDQALQeYAIQMMygILIAFBAWogASAERw0CGkHnACEDDMkCCwNAIAEtAABB8MQAai0AACIAQQFHBEACQCAAQQJrDgSiAaEBoAEAnwELQdcAIQMMsQILIAQgAUEBaiIBRw0AC0HoACEDDMgCCyABIARGBEBB6QAhAwzIAgsCQCABLQAAIgBBCmsOGrcBmwGbAbQBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBpAGbAZsBAJkBCyABQQFqCyEBQQYhAwytAgsDQCABLQAAQfDGAGotAABBAUcNfSAEIAFBAWoiAUcNAAtB6gAhAwzFAgsgAUEBaiABIARHDQIaQesAIQMMxAILIAEgBEYEQEHsACEDDMQCCyABQQFqDAELIAEgBEYEQEHtACEDDMMCCyABQQFqCyEBQQQhAwyoAgsgASAERgRAQe4AIQMMwQILAkACQAJAIAEtAABB8MgAai0AAEEBaw4HkAGPAY4BAHwBAo0BCyABQQFqIQEMCwsgAUEBagyTAQtBACEDIAJBADYCHCACQZsSNgIQIAJBBzYCDCACIAFBAWo2AhQMwAILAkADQCABLQAAQfDIAGotAAAiAEEERwRAAkACQCAAQQFrDgeUAZMBkgGNAQAEAY0BC0HaACEDDKoCCyABQQFqIQFB3AAhAwypAgsgBCABQQFqIgFHDQALQe8AIQMMwAILIAFBAWoMkQELIAQgASIARgRAQfAAIQMMvwILIAAtAABBL0cNASAAQQFqIQEMBwsgBCABIgBGBEBB8QAhAwy+AgsgAC0AACIBQS9GBEAgAEEBaiEBQd0AIQMMpQILIAFBCmsiA0EWSw0AIAAhAUEBIAN0QYmAgAJxDfkBC0EAIQMgAkEANgIcIAIgADYCFCACQYwcNgIQIAJBBzYCDAy8AgsgASAERwRAIAFBAWohAUHeACEDDKMCC0HyACEDDLsCCyABIARGBEBB9AAhAwy7AgsCQCABLQAAQfDMAGotAABBAWsOA/cBcwCCAQtB4QAhAwyhAgsgASAERwRAA0AgAS0AAEHwygBqLQAAIgBBA0cEQAJAIABBAWsOAvkBAIUBC0HfACEDDKMCCyAEIAFBAWoiAUcNAAtB8wAhAwy6AgtB8wAhAwy5AgsgASAERwRAIAJBDzYCCCACIAE2AgRB4AAhAwygAgtB9QAhAwy4AgsgASAERgRAQfYAIQMMuAILIAJBDzYCCCACIAE2AgQLQQMhAwydAgsDQCABLQAAQSBHDY4CIAQgAUEBaiIBRw0AC0H3ACEDDLUCCyABIARGBEBB+AAhAwy1AgsgAS0AAEEgRw16IAFBAWohAQxbC0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAADXgMgAILIAEgBEYEQEH6ACEDDLMCCyABLQAAQcwARw10IAFBAWohAUETDHYLQfsAIQMgASAERg2xAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYDQCABLQAAIABB8M4Aai0AAEcNcyAAQQVGDXUgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMsQILIAEgBEYEQEH8ACEDDLECCwJAAkAgAS0AAEHDAGsODAB0dHR0dHR0dHR0AXQLIAFBAWohAUHmACEDDJgCCyABQQFqIQFB5wAhAwyXAgtB/QAhAyABIARGDa8CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDXIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADLACCyACQQA2AgAgBkEBaiEBQRAMcwtB/gAhAyABIARGDa4CIAIoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQfbOAGotAABHDXEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK8CCyACQQA2AgAgBkEBaiEBQRYMcgtB/wAhAyABIARGDa0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQfzOAGotAABHDXAgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK4CCyACQQA2AgAgBkEBaiEBQQUMcQsgASAERgRAQYABIQMMrQILIAEtAABB2QBHDW4gAUEBaiEBQQgMcAsgASAERgRAQYEBIQMMrAILAkACQCABLQAAQc4Aaw4DAG8BbwsgAUEBaiEBQesAIQMMkwILIAFBAWohAUHsACEDDJICCyABIARGBEBBggEhAwyrAgsCQAJAIAEtAABByABrDggAbm5ubm5uAW4LIAFBAWohAUHqACEDDJICCyABQQFqIQFB7QAhAwyRAgtBgwEhAyABIARGDakCIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQYDPAGotAABHDWwgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKoCCyACQQA2AgAgBkEBaiEBQQAMbQtBhAEhAyABIARGDagCIAIoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQYPPAGotAABHDWsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKkCCyACQQA2AgAgBkEBaiEBQSMMbAsgASAERgRAQYUBIQMMqAILAkACQCABLQAAQcwAaw4IAGtra2trawFrCyABQQFqIQFB7wAhAwyPAgsgAUEBaiEBQfAAIQMMjgILIAEgBEYEQEGGASEDDKcCCyABLQAAQcUARw1oIAFBAWohAQxgC0GHASEDIAEgBEYNpQIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBiM8Aai0AAEcNaCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpgILIAJBADYCACAGQQFqIQFBLQxpC0GIASEDIAEgBEYNpAIgAigCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABB0M8Aai0AAEcNZyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpQILIAJBADYCACAGQQFqIQFBKQxoCyABIARGBEBBiQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEVDF8LQZIBIQMgASAERg2aAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGhzwBqLQAARw1dIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAybAgsgAkEANgIAIAZBAWohAUEeDF4LIAEgBEYEQEGTASEDDJoCCyABLQAAQcwARw1bIAFBAWohAUEKDF0LIAEgBEYEQEGUASEDDJkCCwJAAkAgAS0AAEHBAGsODwBcXFxcXFxcXFxcXFxcAVwLIAFBAWohAUH+ACEDDIACCyABQQFqIQFB/wAhAwz/AQsgASAERgRAQZUBIQMMmAILAkACQCABLQAAQcEAaw4DAFsBWwsgAUEBaiEBQf0AIQMM/wELIAFBAWohAUGAASEDDP4BC0GWASEDIAEgBEYNlgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBp88Aai0AAEcNWSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlwILIAJBADYCACAGQQFqIQFBCwxaCyABIARGBEBBlwEhAwyWAgsCQAJAAkACQCABLQAAQS1rDiMAW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sBW1tbW1sCW1tbA1sLIAFBAWohAUH7ACEDDP8BCyABQQFqIQFB/AAhAwz+AQsgAUEBaiEBQYEBIQMM/QELIAFBAWohAUGCASEDDPwBC0GYASEDIAEgBEYNlAIgAigCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBqc8Aai0AAEcNVyAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlQILIAJBADYCACAGQQFqIQFBGQxYC0GZASEDIAEgBEYNkwIgAigCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBrs8Aai0AAEcNViAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlAILIAJBADYCACAGQQFqIQFBBgxXC0GaASEDIAEgBEYNkgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBtM8Aai0AAEcNVSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkwILIAJBADYCACAGQQFqIQFBHAxWC0GbASEDIAEgBEYNkQIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBts8Aai0AAEcNVCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkgILIAJBADYCACAGQQFqIQFBJwxVCyABIARGBEBBnAEhAwyRAgsCQAJAIAEtAABB1ABrDgIAAVQLIAFBAWohAUGGASEDDPgBCyABQQFqIQFBhwEhAwz3AQtBnQEhAyABIARGDY8CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjPAGotAABHDVIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADJACCyACQQA2AgAgBkEBaiEBQSYMUwtBngEhAyABIARGDY4CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbrPAGotAABHDVEgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI8CCyACQQA2AgAgBkEBaiEBQQMMUgtBnwEhAyABIARGDY0CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDVAgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI4CCyACQQA2AgAgBkEBaiEBQQwMUQtBoAEhAyABIARGDYwCIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQbzPAGotAABHDU8gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI0CCyACQQA2AgAgBkEBaiEBQQ0MUAsgASAERgRAQaEBIQMMjAILAkACQCABLQAAQcYAaw4LAE9PT09PT09PTwFPCyABQQFqIQFBiwEhAwzzAQsgAUEBaiEBQYwBIQMM8gELIAEgBEYEQEGiASEDDIsCCyABLQAAQdAARw1MIAFBAWohAQxGCyABIARGBEBBowEhAwyKAgsCQAJAIAEtAABByQBrDgcBTU1NTU0ATQsgAUEBaiEBQY4BIQMM8QELIAFBAWohAUEiDE0LQaQBIQMgASAERg2IAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHAzwBqLQAARw1LIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyJAgsgAkEANgIAIAZBAWohAUEdDEwLIAEgBEYEQEGlASEDDIgCCwJAAkAgAS0AAEHSAGsOAwBLAUsLIAFBAWohAUGQASEDDO8BCyABQQFqIQFBBAxLCyABIARGBEBBpgEhAwyHAgsCQAJAAkACQAJAIAEtAABBwQBrDhUATU1NTU1NTU1NTQFNTQJNTQNNTQRNCyABQQFqIQFBiAEhAwzxAQsgAUEBaiEBQYkBIQMM8AELIAFBAWohAUGKASEDDO8BCyABQQFqIQFBjwEhAwzuAQsgAUEBaiEBQZEBIQMM7QELQacBIQMgASAERg2FAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHtzwBqLQAARw1IIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyGAgsgAkEANgIAIAZBAWohAUERDEkLQagBIQMgASAERg2EAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHCzwBqLQAARw1HIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyFAgsgAkEANgIAIAZBAWohAUEsDEgLQakBIQMgASAERg2DAiACKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHFzwBqLQAARw1GIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyEAgsgAkEANgIAIAZBAWohAUErDEcLQaoBIQMgASAERg2CAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHKzwBqLQAARw1FIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyDAgsgAkEANgIAIAZBAWohAUEUDEYLIAEgBEYEQEGrASEDDIICCwJAAkACQAJAIAEtAABBwgBrDg8AAQJHR0dHR0dHR0dHRwNHCyABQQFqIQFBkwEhAwzrAQsgAUEBaiEBQZQBIQMM6gELIAFBAWohAUGVASEDDOkBCyABQQFqIQFBlgEhAwzoAQsgASAERgRAQawBIQMMgQILIAEtAABBxQBHDUIgAUEBaiEBDD0LQa0BIQMgASAERg3/ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHNzwBqLQAARw1CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyAAgsgAkEANgIAIAZBAWohAUEODEMLIAEgBEYEQEGuASEDDP8BCyABLQAAQdAARw1AIAFBAWohAUElDEILQa8BIQMgASAERg39ASACKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEHQzwBqLQAARw1AIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz+AQsgAkEANgIAIAZBAWohAUEqDEELIAEgBEYEQEGwASEDDP0BCwJAAkAgAS0AAEHVAGsOCwBAQEBAQEBAQEABQAsgAUEBaiEBQZoBIQMM5AELIAFBAWohAUGbASEDDOMBCyABIARGBEBBsQEhAwz8AQsCQAJAIAEtAABBwQBrDhQAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/AT8LIAFBAWohAUGZASEDDOMBCyABQQFqIQFBnAEhAwziAQtBsgEhAyABIARGDfoBIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQdnPAGotAABHDT0gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPsBCyACQQA2AgAgBkEBaiEBQSEMPgtBswEhAyABIARGDfkBIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQd3PAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPoBCyACQQA2AgAgBkEBaiEBQRoMPQsgASAERgRAQbQBIQMM+QELAkACQAJAIAEtAABBxQBrDhEAPT09PT09PT09AT09PT09Aj0LIAFBAWohAUGdASEDDOEBCyABQQFqIQFBngEhAwzgAQsgAUEBaiEBQZ8BIQMM3wELQbUBIQMgASAERg33ASACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHkzwBqLQAARw06IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz4AQsgAkEANgIAIAZBAWohAUEoDDsLQbYBIQMgASAERg32ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHqzwBqLQAARw05IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz3AQsgAkEANgIAIAZBAWohAUEHDDoLIAEgBEYEQEG3ASEDDPYBCwJAAkAgAS0AAEHFAGsODgA5OTk5OTk5OTk5OTkBOQsgAUEBaiEBQaEBIQMM3QELIAFBAWohAUGiASEDDNwBC0G4ASEDIAEgBEYN9AEgAigCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB7c8Aai0AAEcNNyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9QELIAJBADYCACAGQQFqIQFBEgw4C0G5ASEDIAEgBEYN8wEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8M8Aai0AAEcNNiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9AELIAJBADYCACAGQQFqIQFBIAw3C0G6ASEDIAEgBEYN8gEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8s8Aai0AAEcNNSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8wELIAJBADYCACAGQQFqIQFBDww2CyABIARGBEBBuwEhAwzyAQsCQAJAIAEtAABByQBrDgcANTU1NTUBNQsgAUEBaiEBQaUBIQMM2QELIAFBAWohAUGmASEDDNgBC0G8ASEDIAEgBEYN8AEgAigCACIAIAQgAWtqIQUgASAAa0EHaiEGAkADQCABLQAAIABB9M8Aai0AAEcNMyAAQQdGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8QELIAJBADYCACAGQQFqIQFBGww0CyABIARGBEBBvQEhAwzwAQsCQAJAAkAgAS0AAEHCAGsOEgA0NDQ0NDQ0NDQBNDQ0NDQ0AjQLIAFBAWohAUGkASEDDNgBCyABQQFqIQFBpwEhAwzXAQsgAUEBaiEBQagBIQMM1gELIAEgBEYEQEG+ASEDDO8BCyABLQAAQc4ARw0wIAFBAWohAQwsCyABIARGBEBBvwEhAwzuAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQcEAaw4VAAECAz8EBQY/Pz8HCAkKCz8MDQ4PPwsgAUEBaiEBQegAIQMM4wELIAFBAWohAUHpACEDDOIBCyABQQFqIQFB7gAhAwzhAQsgAUEBaiEBQfIAIQMM4AELIAFBAWohAUHzACEDDN8BCyABQQFqIQFB9gAhAwzeAQsgAUEBaiEBQfcAIQMM3QELIAFBAWohAUH6ACEDDNwBCyABQQFqIQFBgwEhAwzbAQsgAUEBaiEBQYQBIQMM2gELIAFBAWohAUGFASEDDNkBCyABQQFqIQFBkgEhAwzYAQsgAUEBaiEBQZgBIQMM1wELIAFBAWohAUGgASEDDNYBCyABQQFqIQFBowEhAwzVAQsgAUEBaiEBQaoBIQMM1AELIAEgBEcEQCACQRA2AgggAiABNgIEQasBIQMM1AELQcABIQMM7AELQQAhAAJAIAIoAjgiA0UNACADKAI0IgNFDQAgAiADEQAAIQALIABFDV4gAEEVRw0HIAJB0QA2AhwgAiABNgIUIAJBsBc2AhAgAkEVNgIMQQAhAwzrAQsgAUEBaiABIARHDQgaQcIBIQMM6gELA0ACQCABLQAAQQprDgQIAAALAAsgBCABQQFqIgFHDQALQcMBIQMM6QELIAEgBEcEQCACQRE2AgggAiABNgIEQQEhAwzQAQtBxAEhAwzoAQsgASAERgRAQcUBIQMM6AELAkACQCABLQAAQQprDgQBKCgAKAsgAUEBagwJCyABQQFqDAULIAEgBEYEQEHGASEDDOcBCwJAAkAgAS0AAEEKaw4XAQsLAQsLCwsLCwsLCwsLCwsLCwsLCwALCyABQQFqIQELQbABIQMMzQELIAEgBEYEQEHIASEDDOYBCyABLQAAQSBHDQkgAkEAOwEyIAFBAWohAUGzASEDDMwBCwNAIAEhAAJAIAEgBEcEQCABLQAAQTBrQf8BcSIDQQpJDQEMJwtBxwEhAwzmAQsCQCACLwEyIgFBmTNLDQAgAiABQQpsIgU7ATIgBUH+/wNxIANB//8Dc0sNACAAQQFqIQEgAiADIAVqIgM7ATIgA0H//wNxQegHSQ0BCwtBACEDIAJBADYCHCACQcEJNgIQIAJBDTYCDCACIABBAWo2AhQM5AELIAJBADYCHCACIAE2AhQgAkHwDDYCECACQRs2AgxBACEDDOMBCyACKAIEIQAgAkEANgIEIAIgACABECYiAA0BIAFBAWoLIQFBrQEhAwzIAQsgAkHBATYCHCACIAA2AgwgAiABQQFqNgIUQQAhAwzgAQsgAigCBCEAIAJBADYCBCACIAAgARAmIgANASABQQFqCyEBQa4BIQMMxQELIAJBwgE2AhwgAiAANgIMIAIgAUEBajYCFEEAIQMM3QELIAJBADYCHCACIAE2AhQgAkGXCzYCECACQQ02AgxBACEDDNwBCyACQQA2AhwgAiABNgIUIAJB4xA2AhAgAkEJNgIMQQAhAwzbAQsgAkECOgAoDKwBC0EAIQMgAkEANgIcIAJBrws2AhAgAkECNgIMIAIgAUEBajYCFAzZAQtBAiEDDL8BC0ENIQMMvgELQSYhAwy9AQtBFSEDDLwBC0EWIQMMuwELQRghAwy6AQtBHCEDDLkBC0EdIQMMuAELQSAhAwy3AQtBISEDDLYBC0EjIQMMtQELQcYAIQMMtAELQS4hAwyzAQtBPSEDDLIBC0HLACEDDLEBC0HOACEDDLABC0HYACEDDK8BC0HZACEDDK4BC0HbACEDDK0BC0HxACEDDKwBC0H0ACEDDKsBC0GNASEDDKoBC0GXASEDDKkBC0GpASEDDKgBC0GvASEDDKcBC0GxASEDDKYBCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB8Rs2AhAgAkEGNgIMDL0BCyACQQA2AgAgBkEBaiEBQSQLOgApIAIoAgQhACACQQA2AgQgAiAAIAEQJyIARQRAQeUAIQMMowELIAJB+QA2AhwgAiABNgIUIAIgADYCDEEAIQMMuwELIABBFUcEQCACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwy7AQsgAkH4ADYCHCACIAE2AhQgAkHKGDYCECACQRU2AgxBACEDDLoBCyACQQA2AhwgAiABNgIUIAJBjhs2AhAgAkEGNgIMQQAhAwy5AQsgAkEANgIcIAIgATYCFCACQf4RNgIQIAJBBzYCDEEAIQMMuAELIAJBADYCHCACIAE2AhQgAkGMHDYCECACQQc2AgxBACEDDLcBCyACQQA2AhwgAiABNgIUIAJBww82AhAgAkEHNgIMQQAhAwy2AQsgAkEANgIcIAIgATYCFCACQcMPNgIQIAJBBzYCDEEAIQMMtQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxBACEDDKIBCyACQeQANgIcIAIgATYCFCACQeMXNgIQIAJBFTYCDEEAIQMMoQELIAJBADYCACAGQQFqIQEgAi0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACEDIAJBADYCHCACIAE2AhQgAkH3CTYCECACQQg2AgwMoAELIAJBADYCACAGQQFqIQEgAi0AKUEhRg0DIAJBADYCHCACIAE2AhQgAkGbCjYCECACQQg2AgxBACEDDJ8BCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJBkDM2AhAgAkEINgIMDJ0BCyACQQA2AgAgBkEBaiEBIAItAClBI0kNACACQQA2AhwgAiABNgIUIAJB0wk2AhAgAkEINgIMQQAhAwycAQtB0QAhAwyCAQsgAS0AAEEwayIAQf8BcUEKSQRAIAIgADoAKiABQQFqIQFBzwAhAwyCAQsgAigCBCEAIAJBADYCBCACIAAgARAoIgBFDYYBIAJB3gA2AhwgAiABNgIUIAIgADYCDEEAIQMMmgELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ2GASACQdwANgIcIAIgATYCFCACIAA2AgxBACEDDJkBCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMhwELIAJB2gA2AhwgAiAFNgIUIAIgADYCDAyYAQtBACEBQQEhAwsgAiADOgArIAVBAWohAwJAAkACQCACLQAtQRBxDQACQAJAAkAgAi0AKg4DAQACBAsgBkUNAwwCCyAADQEMAgsgAUUNAQsgAigCBCEAIAJBADYCBCACIAAgAxAoIgBFBEAgAyEBDAILIAJB2AA2AhwgAiADNgIUIAIgADYCDEEAIQMMmAELIAIoAgQhACACQQA2AgQgAiAAIAMQKCIARQRAIAMhAQyHAQsgAkHZADYCHCACIAM2AhQgAiAANgIMQQAhAwyXAQtBzAAhAwx9CyAAQRVHBEAgAkEANgIcIAIgATYCFCACQZQNNgIQIAJBITYCDEEAIQMMlgELIAJB1wA2AhwgAiABNgIUIAJByRc2AhAgAkEVNgIMQQAhAwyVAQtBACEDIAJBADYCHCACIAE2AhQgAkGAETYCECACQQk2AgwMlAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0AIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMkwELQckAIQMMeQsgAkEANgIcIAIgATYCFCACQcEoNgIQIAJBBzYCDCACQQA2AgBBACEDDJEBCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAlIgBFDQAgAkHSADYCHCACIAE2AhQgAiAANgIMDJABC0HIACEDDHYLIAJBADYCACAFIQELIAJBgBI7ASogAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANAQtBxwAhAwxzCyAAQRVGBEAgAkHRADYCHCACIAE2AhQgAkHjFzYCECACQRU2AgxBACEDDIwBC0EAIQMgAkEANgIcIAIgATYCFCACQbkNNgIQIAJBGjYCDAyLAQtBACEDIAJBADYCHCACIAE2AhQgAkGgGTYCECACQR42AgwMigELIAEtAABBOkYEQCACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgBFDQEgAkHDADYCHCACIAA2AgwgAiABQQFqNgIUDIoBC0EAIQMgAkEANgIcIAIgATYCFCACQbERNgIQIAJBCjYCDAyJAQsgAUEBaiEBQTshAwxvCyACQcMANgIcIAIgADYCDCACIAFBAWo2AhQMhwELQQAhAyACQQA2AhwgAiABNgIUIAJB8A42AhAgAkEcNgIMDIYBCyACIAIvATBBEHI7ATAMZgsCQCACLwEwIgBBCHFFDQAgAi0AKEEBRw0AIAItAC1BCHFFDQMLIAIgAEH3+wNxQYAEcjsBMAwECyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE1IQMMbgsgAikDICIKQpmz5syZs+bMGVYNASACIApCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAIgCiALfDcDICAEIAFBAWoiAUcNAAtBOSEDDIUBCyACKAIEIQBBACEDIAJBADYCBCACIAAgAUEBaiIBECoiAA0MDHcLQTkhAwyDAQsgAi0AMEEgcQ0GQcUBIQMMaQtBACEDIAJBADYCBCACIAEgARAqIgBFDQQgAkE6NgIcIAIgADYCDCACIAFBAWo2AhQMgQELIAItAChBAUcNACACLQAtQQhxRQ0BC0E3IQMMZgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIABEAgAkE7NgIcIAIgADYCDCACIAFBAWo2AhQMfwsgAUEBaiEBDG4LIAJBCDoALAwECyABQQFqIQEMbQtBACEDIAJBADYCHCACIAE2AhQgAkHkEjYCECACQQQ2AgwMewsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ1sIAJBNzYCHCACIAE2AhQgAiAANgIMDHoLIAIgAi8BMEEgcjsBMAtBMCEDDF8LIAJBNjYCHCACIAE2AhQgAiAANgIMDHcLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCACLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIAJBAToALCACIAIvATAgAXI7ATAgACEBDAELIAIgAi8BMEEIcjsBMCAAIQELQTkhAwxcCyACQQA6ACwLQTQhAwxaCyABIARGBEBBLSEDDHMLAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0EtIQMMdAsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ0CIAJBLDYCHCACIAE2AhQgAiAANgIMDHMLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAS0AAEENRgRAIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAi0ALUEBcQRAQcQBIQMMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIADQEMZQtBLyEDDFcLIAJBLjYCHCACIAE2AhQgAiAANgIMDG8LQQAhAyACQQA2AhwgAiABNgIUIAJB8BQ2AhAgAkEDNgIMDG4LQQEhAwJAAkACQAJAIAItACxBBWsOBAMBAgAECyACIAIvATBBCHI7ATAMAwtBAiEDDAELQQQhAwsgAkEBOgAsIAIgAi8BMCADcjsBMAtBKiEDDFMLQQAhAyACQQA2AhwgAiABNgIUIAJB4Q82AhAgAkEKNgIMDGsLQQEhAwJAAkACQAJAAkACQCACLQAsQQJrDgcFBAQDAQIABAsgAiACLwEwQQhyOwEwDAMLQQIhAwwBC0EEIQMLIAJBAToALCACIAIvATAgA3I7ATALQSshAwxSC0EAIQMgAkEANgIcIAIgATYCFCACQasSNgIQIAJBCzYCDAxqC0EAIQMgAkEANgIcIAIgATYCFCACQf0NNgIQIAJBHTYCDAxpCyABIARHBEADQCABLQAAQSBHDUggBCABQQFqIgFHDQALQSUhAwxpC0ElIQMMaAsgAi0ALUEBcQRAQcMBIQMMTwsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKSIABEAgAkEmNgIcIAIgADYCDCACIAFBAWo2AhQMaAsgAUEBaiEBDFwLIAFBAWohASACLwEwIgBBgAFxBEBBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAEUNBiAAQRVHDR8gAkEFNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMZwsCQCAAQaAEcUGgBEcNACACLQAtQQJxDQBBACEDIAJBADYCHCACIAE2AhQgAkGWEzYCECACQQQ2AgwMZwsgAgJ/IAIvATBBFHFBFEYEQEEBIAItAChBAUYNARogAi8BMkHlAEYMAQsgAi0AKUEFRgs6AC5BACEAAkAgAigCOCIDRQ0AIAMoAiQiA0UNACACIAMRAAAhAAsCQAJAAkACQAJAIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyACQQE6AC4LIAIgAi8BMEHAAHI7ATALQSchAwxPCyACQSM2AhwgAiABNgIUIAJBpRY2AhAgAkEVNgIMQQAhAwxnC0EAIQMgAkEANgIcIAIgATYCFCACQdULNgIQIAJBETYCDAxmC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAADQELQQ4hAwxLCyAAQRVGBEAgAkECNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMZAtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMYwtBACEDIAJBADYCHCACIAE2AhQgAkGqHDYCECACQQ82AgwMYgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEgCqdqIgEQKyIARQ0AIAJBBTYCHCACIAE2AhQgAiAANgIMDGELQQ8hAwxHC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxfC0IBIQoLIAFBAWohAQJAIAIpAyAiC0L//////////w9YBEAgAiALQgSGIAqENwMgDAELQQAhAyACQQA2AhwgAiABNgIUIAJBrQk2AhAgAkEMNgIMDF4LQSQhAwxEC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxcCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAsIgBFBEAgAUEBaiEBDFILIAJBFzYCHCACIAA2AgwgAiABQQFqNgIUDFsLIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQRY2AhwgAiAANgIMIAIgAUEBajYCFAxbC0EfIQMMQQtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQLSIARQRAIAFBAWohAQxQCyACQRQ2AhwgAiAANgIMIAIgAUEBajYCFAxYCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABEC0iAEUEQCABQQFqIQEMAQsgAkETNgIcIAIgADYCDCACIAFBAWo2AhQMWAtBHiEDDD4LQQAhAyACQQA2AhwgAiABNgIUIAJBxgw2AhAgAkEjNgIMDFYLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABEC0iAEUEQCABQQFqIQEMTgsgAkERNgIcIAIgADYCDCACIAFBAWo2AhQMVQsgAkEQNgIcIAIgATYCFCACIAA2AgwMVAtBACEDIAJBADYCHCACIAE2AhQgAkHGDDYCECACQSM2AgwMUwtBACEDIAJBADYCHCACIAE2AhQgAkHAFTYCECACQQI2AgwMUgsgAigCBCEAQQAhAyACQQA2AgQCQCACIAAgARAtIgBFBEAgAUEBaiEBDAELIAJBDjYCHCACIAA2AgwgAiABQQFqNgIUDFILQRshAww4C0EAIQMgAkEANgIcIAIgATYCFCACQcYMNgIQIAJBIzYCDAxQCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABECwiAEUEQCABQQFqIQEMAQsgAkENNgIcIAIgADYCDCACIAFBAWo2AhQMUAtBGiEDDDYLQQAhAyACQQA2AhwgAiABNgIUIAJBmg82AhAgAkEiNgIMDE4LIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQQw2AhwgAiAANgIMIAIgAUEBajYCFAxOC0EZIQMMNAtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMTAsgAEEVRwRAQQAhAyACQQA2AhwgAiABNgIUIAJBgww2AhAgAkETNgIMDEwLIAJBCjYCHCACIAE2AhQgAkHkFjYCECACQRU2AgxBACEDDEsLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABIAqnaiIBECsiAARAIAJBBzYCHCACIAE2AhQgAiAANgIMDEsLQRMhAwwxCyAAQRVHBEBBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMSgsgAkEeNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMSQtBACEAAkAgAigCOCIDRQ0AIAMoAiwiA0UNACACIAMRAAAhAAsgAEUNQSAAQRVGBEAgAkEDNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMSQtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMSAtBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMRwtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMRgsgAkEAOgAvIAItAC1BBHFFDT8LIAJBADoALyACQQE6ADRBACEDDCsLQQAhAyACQQA2AhwgAkHkETYCECACQQc2AgwgAiABQQFqNgIUDEMLAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB3QEhAwxDCwJAAkAgAi0ANEEBRw0AQQAhAAJAIAIoAjgiA0UNACADKAJYIgNFDQAgAiADEQAAIQALIABFDQAgAEEVRw0BIAJB3AE2AhwgAiABNgIUIAJB1RY2AhAgAkEVNgIMQQAhAwxEC0HBASEDDCoLIAJBADYCHCACIAE2AhQgAkHpCzYCECACQR82AgxBACEDDEILAkACQCACLQAoQQFrDgIEAQALQcABIQMMKQtBuQEhAwwoCyACQQI6AC9BACEAAkAgAigCOCIDRQ0AIAMoAgAiA0UNACACIAMRAAAhAAsgAEUEQEHCASEDDCgLIABBFUcEQCACQQA2AhwgAiABNgIUIAJBpAw2AhAgAkEQNgIMQQAhAwxBCyACQdsBNgIcIAIgATYCFCACQfoWNgIQIAJBFTYCDEEAIQMMQAsgASAERgRAQdoBIQMMQAsgAS0AAEHIAEYNASACQQE6ACgLQawBIQMMJQtBvwEhAwwkCyABIARHBEAgAkEQNgIIIAIgATYCBEG+ASEDDCQLQdkBIQMMPAsgASAERgRAQdgBIQMMPAsgAS0AAEHIAEcNBCABQQFqIQFBvQEhAwwiCyABIARGBEBB1wEhAww7CwJAAkAgAS0AAEHFAGsOEAAFBQUFBQUFBQUFBQUFBQEFCyABQQFqIQFBuwEhAwwiCyABQQFqIQFBvAEhAwwhC0HWASEDIAEgBEYNOSACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGD0ABqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw6CyACKAIEIQAgAkIANwMAIAIgACAGQQFqIgEQJyIARQRAQcYBIQMMIQsgAkHVATYCHCACIAE2AhQgAiAANgIMQQAhAww5C0HUASEDIAEgBEYNOCACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGB0ABqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw5CyACQYEEOwEoIAIoAgQhACACQgA3AwAgAiAAIAZBAWoiARAnIgANAwwCCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB2Bs2AhAgAkEINgIMDDYLQboBIQMMHAsgAkHTATYCHCACIAE2AhQgAiAANgIMQQAhAww0C0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAARQ0AIABBFUYNASACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwwzC0HkACEDDBkLIAJB+AA2AhwgAiABNgIUIAJByhg2AhAgAkEVNgIMQQAhAwwxC0HSASEDIAQgASIARg0wIAQgAWsgAigCACIBaiEFIAAgAWtBBGohBgJAA0AgAC0AACABQfzPAGotAABHDQEgAUEERg0DIAFBAWohASAEIABBAWoiAEcNAAsgAiAFNgIADDELIAJBADYCHCACIAA2AhQgAkGQMzYCECACQQg2AgwgAkEANgIAQQAhAwwwCyABIARHBEAgAkEONgIIIAIgATYCBEG3ASEDDBcLQdEBIQMMLwsgAkEANgIAIAZBAWohAQtBuAEhAwwUCyABIARGBEBB0AEhAwwtCyABLQAAQTBrIgBB/wFxQQpJBEAgAiAAOgAqIAFBAWohAUG2ASEDDBQLIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0UIAJBzwE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAsgASAERgRAQc4BIQMMLAsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0VIAJBzQE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAtBtQEhAwwSCyAEIAEiBUYEQEHMASEDDCsLQQAhAEEBIQFBASEGQQAhAwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAUtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyEDQQAhAUEAIQYMAgtBCSEDQQEhAEEAIQFBACEGDAELQQAhAUEBIQMLIAIgAzoAKyAFQQFqIQMCQAJAIAItAC1BEHENAAJAAkACQCACLQAqDgMBAAIECyAGRQ0DDAILIAANAQwCCyABRQ0BCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMAwsgAkHJATYCHCACIAM2AhQgAiAANgIMQQAhAwwtCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMGAsgAkHKATYCHCACIAM2AhQgAiAANgIMQQAhAwwsCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMFgsgAkHLATYCHCACIAU2AhQgAiAANgIMDCsLQbQBIQMMEQtBACEAAkAgAigCOCIDRQ0AIAMoAjwiA0UNACACIAMRAAAhAAsCQCAABEAgAEEVRg0BIAJBADYCHCACIAE2AhQgAkGUDTYCECACQSE2AgxBACEDDCsLQbIBIQMMEQsgAkHIATYCHCACIAE2AhQgAkHJFzYCECACQRU2AgxBACEDDCkLIAJBADYCACAGQQFqIQFB9QAhAwwPCyACLQApQQVGBEBB4wAhAwwPC0HiACEDDA4LIAAhASACQQA2AgALIAJBADoALEEJIQMMDAsgAkEANgIAIAdBAWohAUHAACEDDAsLQQELOgAsIAJBADYCACAGQQFqIQELQSkhAwwIC0E4IQMMBwsCQCABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBPiEDDCELQT4hAwwgCwsgAkEAOgAsDAELQQshAwwEC0E6IQMMAwsgAUEBaiEBQS0hAwwCCyACIAE6ACwgAkEANgIAIAZBAWohAUEMIQMMAQsgAkEANgIAIAZBAWohAUEKIQMMAAsAC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwXC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwWC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwVC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwUC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwTC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwSC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwRC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwQC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwPC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwOC0EAIQMgAkEANgIcIAIgATYCFCACQcASNgIQIAJBCzYCDAwNC0EAIQMgAkEANgIcIAIgATYCFCACQZUJNgIQIAJBCzYCDAwMC0EAIQMgAkEANgIcIAIgATYCFCACQeEPNgIQIAJBCjYCDAwLC0EAIQMgAkEANgIcIAIgATYCFCACQfsPNgIQIAJBCjYCDAwKC0EAIQMgAkEANgIcIAIgATYCFCACQfEZNgIQIAJBAjYCDAwJC0EAIQMgAkEANgIcIAIgATYCFCACQcQUNgIQIAJBAjYCDAwIC0EAIQMgAkEANgIcIAIgATYCFCACQfIVNgIQIAJBAjYCDAwHCyACQQI2AhwgAiABNgIUIAJBnBo2AhAgAkEWNgIMQQAhAwwGC0EBIQMMBQtB1AAhAyABIARGDQQgCEEIaiEJIAIoAgAhBQJAAkAgASAERwRAIAVB2MIAaiEHIAQgBWogAWshACAFQX9zQQpqIgUgAWohBgNAIAEtAAAgBy0AAEcEQEECIQcMAwsgBUUEQEEAIQcgBiEBDAMLIAVBAWshBSAHQQFqIQcgBCABQQFqIgFHDQALIAAhBSAEIQELIAlBATYCACACIAU2AgAMAQsgAkEANgIAIAkgBzYCAAsgCSABNgIEIAgoAgwhACAIKAIIDgMBBAIACwALIAJBADYCHCACQbUaNgIQIAJBFzYCDCACIABBAWo2AhRBACEDDAILIAJBADYCHCACIAA2AhQgAkHKGjYCECACQQk2AgxBACEDDAELIAEgBEYEQEEiIQMMAQsgAkEJNgIIIAIgATYCBEEhIQMLIAhBEGokACADRQRAIAIoAgwhAAwBCyACIAM2AhxBACEAIAIoAgQiAUUNACACIAEgBCACKAIIEQEAIgFFDQAgAiAENgIUIAIgATYCDCABIQALIAALvgIBAn8gAEEAOgAAIABB3ABqIgFBAWtBADoAACAAQQA6AAIgAEEAOgABIAFBA2tBADoAACABQQJrQQA6AAAgAEEAOgADIAFBBGtBADoAAEEAIABrQQNxIgEgAGoiAEEANgIAQdwAIAFrQXxxIgIgAGoiAUEEa0EANgIAAkAgAkEJSQ0AIABBADYCCCAAQQA2AgQgAUEIa0EANgIAIAFBDGtBADYCACACQRlJDQAgAEEANgIYIABBADYCFCAAQQA2AhAgAEEANgIMIAFBEGtBADYCACABQRRrQQA2AgAgAUEYa0EANgIAIAFBHGtBADYCACACIABBBHFBGHIiAmsiAUEgSQ0AIAAgAmohAANAIABCADcDGCAAQgA3AxAgAEIANwMIIABCADcDACAAQSBqIQAgAUEgayIBQR9LDQALCwtWAQF/AkAgACgCDA0AAkACQAJAAkAgAC0ALw4DAQADAgsgACgCOCIBRQ0AIAEoAiwiAUUNACAAIAERAAAiAQ0DC0EADwsACyAAQcMWNgIQQQ4hAQsgAQsaACAAKAIMRQRAIABB0Rs2AhAgAEEVNgIMCwsUACAAKAIMQRVGBEAgAEEANgIMCwsUACAAKAIMQRZGBEAgAEEANgIMCwsHACAAKAIMCwcAIAAoAhALCQAgACABNgIQCwcAIAAoAhQLFwAgAEEkTwRAAAsgAEECdEGgM2ooAgALFwAgAEEuTwRAAAsgAEECdEGwNGooAgALvwkBAX9B6yghAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtzACAAQRBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAA/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQTBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQSBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQd0BNgIcCwYAIAAQMguaLQELfyMAQRBrIgokAEGk0AAoAgAiCUUEQEHk0wAoAgAiBUUEQEHw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBCGpBcHFB2KrVqgVzIgU2AgBB+NMAQQA2AgBByNMAQQA2AgALQczTAEGA1AQ2AgBBnNAAQYDUBDYCAEGw0AAgBTYCAEGs0ABBfzYCAEHQ0wBBgKwDNgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBjNQEQcGrAzYCAEGo0ABB9NMAKAIANgIAQZjQAEHAqwM2AgBBpNAAQYjUBDYCAEHM/wdBODYCAEGI1AQhCQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQewBTQRAQYzQACgCACIGQRAgAEETakFwcSAAQQtJGyIEQQN2IgB2IgFBA3EEQAJAIAFBAXEgAHJBAXMiAkEDdCIAQbTQAGoiASAAQbzQAGooAgAiACgCCCIDRgRAQYzQACAGQX4gAndxNgIADAELIAEgAzYCCCADIAE2AgwLIABBCGohASAAIAJBA3QiAkEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwRC0GU0AAoAgAiCCAETw0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cWgiAEEDdCICQbTQAGoiASACQbzQAGooAgAiAigCCCIDRgRAQYzQACAGQX4gAHdxIgY2AgAMAQsgASADNgIIIAMgATYCDAsgAiAEQQNyNgIEIABBA3QiACAEayEFIAAgAmogBTYCACACIARqIgQgBUEBcjYCBCAIBEAgCEF4cUG00ABqIQBBoNAAKAIAIQMCf0EBIAhBA3Z0IgEgBnFFBEBBjNAAIAEgBnI2AgAgAAwBCyAAKAIICyIBIAM2AgwgACADNgIIIAMgADYCDCADIAE2AggLIAJBCGohAUGg0AAgBDYCAEGU0AAgBTYCAAwRC0GQ0AAoAgAiC0UNASALaEECdEG80gBqKAIAIgAoAgRBeHEgBGshBSAAIQIDQAJAIAIoAhAiAUUEQCACQRRqKAIAIgFFDQELIAEoAgRBeHEgBGsiAyAFSSECIAMgBSACGyEFIAEgACACGyEAIAEhAgwBCwsgACgCGCEJIAAoAgwiAyAARwRAQZzQACgCABogAyAAKAIIIgE2AgggASADNgIMDBALIABBFGoiAigCACIBRQRAIAAoAhAiAUUNAyAAQRBqIQILA0AgAiEHIAEiA0EUaiICKAIAIgENACADQRBqIQIgAygCECIBDQALIAdBADYCAAwPC0F/IQQgAEG/f0sNACAAQRNqIgFBcHEhBEGQ0AAoAgAiCEUNAEEAIARrIQUCQAJAAkACf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QbzSAGooAgAiAkUEQEEAIQFBACEDDAELQQAhASAEQRkgBkEBdmtBACAGQR9HG3QhAEEAIQMDQAJAIAIoAgRBeHEgBGsiByAFTw0AIAIhAyAHIgUNAEEAIQUgAiEBDAMLIAEgAkEUaigCACIHIAcgAiAAQR12QQRxakEQaigCACICRhsgASAHGyEBIABBAXQhACACDQALCyABIANyRQRAQQAhA0ECIAZ0IgBBACAAa3IgCHEiAEUNAyAAaEECdEG80gBqKAIAIQELIAFFDQELA0AgASgCBEF4cSAEayICIAVJIQAgAiAFIAAbIQUgASADIAAbIQMgASgCECIABH8gAAUgAUEUaigCAAsiAQ0ACwsgA0UNACAFQZTQACgCACAEa08NACADKAIYIQcgAyADKAIMIgBHBEBBnNAAKAIAGiAAIAMoAggiATYCCCABIAA2AgwMDgsgA0EUaiICKAIAIgFFBEAgAygCECIBRQ0DIANBEGohAgsDQCACIQYgASIAQRRqIgIoAgAiAQ0AIABBEGohAiAAKAIQIgENAAsgBkEANgIADA0LQZTQACgCACIDIARPBEBBoNAAKAIAIQECQCADIARrIgJBEE8EQCABIARqIgAgAkEBcjYCBCABIANqIAI2AgAgASAEQQNyNgIEDAELIAEgA0EDcjYCBCABIANqIgAgACgCBEEBcjYCBEEAIQBBACECC0GU0AAgAjYCAEGg0AAgADYCACABQQhqIQEMDwtBmNAAKAIAIgMgBEsEQCAEIAlqIgAgAyAEayIBQQFyNgIEQaTQACAANgIAQZjQACABNgIAIAkgBEEDcjYCBCAJQQhqIQEMDwtBACEBIAQCf0Hk0wAoAgAEQEHs0wAoAgAMAQtB8NMAQn83AgBB6NMAQoCAhICAgMAANwIAQeTTACAKQQxqQXBxQdiq1aoFczYCAEH40wBBADYCAEHI0wBBADYCAEGAgAQLIgAgBEHHAGoiBWoiBkEAIABrIgdxIgJPBEBB/NMAQTA2AgAMDwsCQEHE0wAoAgAiAUUNAEG80wAoAgAiCCACaiEAIAAgAU0gACAIS3ENAEEAIQFB/NMAQTA2AgAMDwtByNMALQAAQQRxDQQCQAJAIAkEQEHM0wAhAQNAIAEoAgAiACAJTQRAIAAgASgCBGogCUsNAwsgASgCCCIBDQALC0EAEDMiAEF/Rg0FIAIhBkHo0wAoAgAiAUEBayIDIABxBEAgAiAAayAAIANqQQAgAWtxaiEGCyAEIAZPDQUgBkH+////B0sNBUHE0wAoAgAiAwRAQbzTACgCACIHIAZqIQEgASAHTQ0GIAEgA0sNBgsgBhAzIgEgAEcNAQwHCyAGIANrIAdxIgZB/v///wdLDQQgBhAzIQAgACABKAIAIAEoAgRqRg0DIAAhAQsCQCAGIARByABqTw0AIAFBf0YNAEHs0wAoAgAiACAFIAZrakEAIABrcSIAQf7///8HSwRAIAEhAAwHCyAAEDNBf0cEQCAAIAZqIQYgASEADAcLQQAgBmsQMxoMBAsgASIAQX9HDQUMAwtBACEDDAwLQQAhAAwKCyAAQX9HDQILQcjTAEHI0wAoAgBBBHI2AgALIAJB/v///wdLDQEgAhAzIQBBABAzIQEgAEF/Rg0BIAFBf0YNASAAIAFPDQEgASAAayIGIARBOGpNDQELQbzTAEG80wAoAgAgBmoiATYCAEHA0wAoAgAgAUkEQEHA0wAgATYCAAsCQAJAAkBBpNAAKAIAIgIEQEHM0wAhAQNAIAAgASgCACIDIAEoAgQiBWpGDQIgASgCCCIBDQALDAILQZzQACgCACIBQQBHIAAgAU9xRQRAQZzQACAANgIAC0EAIQFB0NMAIAY2AgBBzNMAIAA2AgBBrNAAQX82AgBBsNAAQeTTACgCADYCAEHY0wBBADYCAANAIAFByNAAaiABQbzQAGoiAjYCACACIAFBtNAAaiIDNgIAIAFBwNAAaiADNgIAIAFB0NAAaiABQcTQAGoiAzYCACADIAI2AgAgAUHY0ABqIAFBzNAAaiICNgIAIAIgAzYCACABQdTQAGogAjYCACABQSBqIgFBgAJHDQALQXggAGtBD3EiASAAaiICIAZBOGsiAyABayIBQQFyNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAI2AgAgACADakE4NgIEDAILIAAgAk0NACACIANJDQAgASgCDEEIcQ0AQXggAmtBD3EiACACaiIDQZjQACgCACAGaiIHIABrIgBBAXI2AgQgASAFIAZqNgIEQajQAEH00wAoAgA2AgBBmNAAIAA2AgBBpNAAIAM2AgAgAiAHakE4NgIEDAELIABBnNAAKAIASQRAQZzQACAANgIACyAAIAZqIQNBzNMAIQECQAJAAkADQCADIAEoAgBHBEAgASgCCCIBDQEMAgsLIAEtAAxBCHFFDQELQczTACEBA0AgASgCACIDIAJNBEAgAyABKAIEaiIFIAJLDQMLIAEoAgghAQwACwALIAEgADYCACABIAEoAgQgBmo2AgQgAEF4IABrQQ9xaiIJIARBA3I2AgQgA0F4IANrQQ9xaiIGIAQgCWoiBGshASACIAZGBEBBpNAAIAQ2AgBBmNAAQZjQACgCACABaiIANgIAIAQgAEEBcjYCBAwIC0Gg0AAoAgAgBkYEQEGg0AAgBDYCAEGU0ABBlNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwICyAGKAIEIgVBA3FBAUcNBiAFQXhxIQggBUH/AU0EQCAFQQN2IQMgBigCCCIAIAYoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAcLIAIgADYCCCAAIAI2AgwMBgsgBigCGCEHIAYgBigCDCIARwRAIAAgBigCCCICNgIIIAIgADYCDAwFCyAGQRRqIgIoAgAiBUUEQCAGKAIQIgVFDQQgBkEQaiECCwNAIAIhAyAFIgBBFGoiAigCACIFDQAgAEEQaiECIAAoAhAiBQ0ACyADQQA2AgAMBAtBeCAAa0EPcSIBIABqIgcgBkE4ayIDIAFrIgFBAXI2AgQgACADakE4NgIEIAIgBUE3IAVrQQ9xakE/ayIDIAMgAkEQakkbIgNBIzYCBEGo0ABB9NMAKAIANgIAQZjQACABNgIAQaTQACAHNgIAIANBEGpB1NMAKQIANwIAIANBzNMAKQIANwIIQdTTACADQQhqNgIAQdDTACAGNgIAQczTACAANgIAQdjTAEEANgIAIANBJGohAQNAIAFBBzYCACAFIAFBBGoiAUsNAAsgAiADRg0AIAMgAygCBEF+cTYCBCADIAMgAmsiBTYCACACIAVBAXI2AgQgBUH/AU0EQCAFQXhxQbTQAGohAAJ/QYzQACgCACIBQQEgBUEDdnQiA3FFBEBBjNAAIAEgA3I2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEG80gBqIQBBkNAAKAIAIgNBASABdCIGcUUEQCAAIAI2AgBBkNAAIAMgBnI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEDAkADQCADIgAoAgRBeHEgBUYNASABQR12IQMgAUEBdCEBIAAgA0EEcWpBEGoiBigCACIDDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLQZjQACgCACIBIARNDQBBpNAAKAIAIgAgBGoiAiABIARrIgFBAXI2AgRBmNAAIAE2AgBBpNAAIAI2AgAgACAEQQNyNgIEIABBCGohAQwIC0EAIQFB/NMAQTA2AgAMBwtBACEACyAHRQ0AAkAgBigCHCICQQJ0QbzSAGoiAygCACAGRgRAIAMgADYCACAADQFBkNAAQZDQACgCAEF+IAJ3cTYCAAwCCyAHQRBBFCAHKAIQIAZGG2ogADYCACAARQ0BCyAAIAc2AhggBigCECICBEAgACACNgIQIAIgADYCGAsgBkEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgCGohASAGIAhqIgYoAgQhBQsgBiAFQX5xNgIEIAEgBGogATYCACAEIAFBAXI2AgQgAUH/AU0EQCABQXhxQbTQAGohAAJ/QYzQACgCACICQQEgAUEDdnQiAXFFBEBBjNAAIAEgAnI2AgAgAAwBCyAAKAIICyIBIAQ2AgwgACAENgIIIAQgADYCDCAEIAE2AggMAQtBHyEFIAFB////B00EQCABQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQULIAQgBTYCHCAEQgA3AhAgBUECdEG80gBqIQBBkNAAKAIAIgJBASAFdCIDcUUEQCAAIAQ2AgBBkNAAIAIgA3I2AgAgBCAANgIYIAQgBDYCCCAEIAQ2AgwMAQsgAUEZIAVBAXZrQQAgBUEfRxt0IQUgACgCACEAAkADQCAAIgIoAgRBeHEgAUYNASAFQR12IQAgBUEBdCEFIAIgAEEEcWpBEGoiAygCACIADQALIAMgBDYCACAEIAI2AhggBCAENgIMIAQgBDYCCAwBCyACKAIIIgAgBDYCDCACIAQ2AgggBEEANgIYIAQgAjYCDCAEIAA2AggLIAlBCGohAQwCCwJAIAdFDQACQCADKAIcIgFBAnRBvNIAaiICKAIAIANGBEAgAiAANgIAIAANAUGQ0AAgCEF+IAF3cSIINgIADAILIAdBEEEUIAcoAhAgA0YbaiAANgIAIABFDQELIAAgBzYCGCADKAIQIgEEQCAAIAE2AhAgASAANgIYCyADQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAFQQ9NBEAgAyAEIAVqIgBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQMAQsgAyAEaiICIAVBAXI2AgQgAyAEQQNyNgIEIAIgBWogBTYCACAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIFcUUEQEGM0AAgASAFcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEEBIAF0IgQgCHFFBEAgACACNgIAQZDQACAEIAhyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhBAJAA0AgBCIAKAIEQXhxIAVGDQEgAUEddiEEIAFBAXQhASAAIARBBHFqQRBqIgYoAgAiBA0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIICyADQQhqIQEMAQsCQCAJRQ0AAkAgACgCHCIBQQJ0QbzSAGoiAigCACAARgRAIAIgAzYCACADDQFBkNAAIAtBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAARhtqIAM2AgAgA0UNAQsgAyAJNgIYIAAoAhAiAQRAIAMgATYCECABIAM2AhgLIABBFGooAgAiAUUNACADQRRqIAE2AgAgASADNgIYCwJAIAVBD00EQCAAIAQgBWoiAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBCyAAIARqIgcgBUEBcjYCBCAAIARBA3I2AgQgBSAHaiAFNgIAIAgEQCAIQXhxQbTQAGohAUGg0AAoAgAhAwJ/QQEgCEEDdnQiAiAGcUUEQEGM0AAgAiAGcjYCACABDAELIAEoAggLIgIgAzYCDCABIAM2AgggAyABNgIMIAMgAjYCCAtBoNAAIAc2AgBBlNAAIAU2AgALIABBCGohAQsgCkEQaiQAIAELQwAgAEUEQD8AQRB0DwsCQCAAQf//A3ENACAAQQBIDQAgAEEQdkAAIgBBf0YEQEH80wBBMDYCAEF/DwsgAEEQdA8LAAsL3D8iAEGACAsJAQAAAAIAAAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==",
		"base64",
	)
})
var SE = x((nIt, ste) => {
	"use strict"
	var Zee = ["GET", "HEAD", "POST"],
		QHe = new Set(Zee),
		NHe = [101, 204, 205, 304],
		Xee = [301, 302, 303, 307, 308],
		PHe = new Set(Xee),
		ete = [
			"1",
			"7",
			"9",
			"11",
			"13",
			"15",
			"17",
			"19",
			"20",
			"21",
			"22",
			"23",
			"25",
			"37",
			"42",
			"43",
			"53",
			"69",
			"77",
			"79",
			"87",
			"95",
			"101",
			"102",
			"103",
			"104",
			"109",
			"110",
			"111",
			"113",
			"115",
			"117",
			"119",
			"123",
			"135",
			"137",
			"139",
			"143",
			"161",
			"179",
			"389",
			"427",
			"465",
			"512",
			"513",
			"514",
			"515",
			"526",
			"530",
			"531",
			"532",
			"540",
			"548",
			"554",
			"556",
			"563",
			"587",
			"601",
			"636",
			"989",
			"990",
			"993",
			"995",
			"1719",
			"1720",
			"1723",
			"2049",
			"3659",
			"4045",
			"4190",
			"5060",
			"5061",
			"6000",
			"6566",
			"6665",
			"6666",
			"6667",
			"6668",
			"6669",
			"6679",
			"6697",
			"10080",
		],
		LHe = new Set(ete),
		tte = [
			"",
			"no-referrer",
			"no-referrer-when-downgrade",
			"same-origin",
			"origin",
			"strict-origin",
			"origin-when-cross-origin",
			"strict-origin-when-cross-origin",
			"unsafe-url",
		],
		UHe = new Set(tte),
		OHe = ["follow", "manual", "error"],
		rte = ["GET", "HEAD", "OPTIONS", "TRACE"],
		qHe = new Set(rte),
		VHe = ["navigate", "same-origin", "no-cors", "cors"],
		HHe = ["omit", "same-origin", "include"],
		WHe = ["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"],
		GHe = ["content-encoding", "content-language", "content-location", "content-type", "content-length"],
		$He = ["half"],
		nte = ["CONNECT", "TRACE", "TRACK"],
		YHe = new Set(nte),
		ite = [
			"audio",
			"audioworklet",
			"font",
			"image",
			"manifest",
			"paintworklet",
			"script",
			"style",
			"track",
			"video",
			"xslt",
			"",
		],
		KHe = new Set(ite)
	ste.exports = {
		subresource: ite,
		forbiddenMethods: nte,
		requestBodyHeader: GHe,
		referrerPolicy: tte,
		requestRedirect: OHe,
		requestMode: VHe,
		requestCredentials: HHe,
		requestCache: WHe,
		redirectStatus: Xee,
		corsSafeListedMethods: Zee,
		nullBodyStatus: NHe,
		safeMethods: rte,
		badPorts: ete,
		requestDuplex: $He,
		subresourceSet: KHe,
		badPortsSet: LHe,
		redirectStatusSet: PHe,
		corsSafeListedMethodsSet: QHe,
		safeMethodsSet: qHe,
		forbiddenMethodsSet: YHe,
		referrerPolicySet: UHe,
	}
})
var RO = x((iIt, ote) => {
	"use strict"
	var TO = Symbol.for("undici.globalOrigin.1")
	function JHe() {
		return globalThis[TO]
	}
	function zHe(e) {
		if (e === void 0) {
			Object.defineProperty(globalThis, TO, {
				value: void 0,
				writable: !0,
				enumerable: !1,
				configurable: !1,
			})
			return
		}
		let t = new URL(e)
		if (t.protocol !== "http:" && t.protocol !== "https:")
			throw new TypeError(`Only http & https urls are allowed, received ${t.protocol}`)
		Object.defineProperty(globalThis, TO, {
			value: t,
			writable: !0,
			enumerable: !1,
			configurable: !1,
		})
	}
	ote.exports = { getGlobalOrigin: JHe, setGlobalOrigin: zHe }
})
var No = x((sIt, hte) => {
	"use strict"
	var bB = require("assert"),
		jHe = new TextEncoder(),
		BE = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/,
		ZHe = /[\u000A\u000D\u0009\u0020]/,
		XHe = /[\u0009\u000A\u000C\u000D\u0020]/g,
		eWe = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/
	function tWe(e) {
		bB(e.protocol === "data:")
		let t = cte(e, !0)
		t = t.slice(5)
		let r = { position: 0 },
			n = Xm(",", t, r),
			i = n.length
		if (((n = aWe(n, !0, !0)), r.position >= t.length)) return "failure"
		r.position++
		let s = t.slice(i + 1),
			o = ute(s)
		if (/;(\u0020){0,}base64$/i.test(n)) {
			let l = fte(o)
			if (((o = nWe(l)), o === "failure")) return "failure"
			;(n = n.slice(0, -6)), (n = n.replace(/(\u0020)+$/, "")), (n = n.slice(0, -1))
		}
		n.startsWith(";") && (n = "text/plain" + n)
		let a = kO(n)
		return a === "failure" && (a = kO("text/plain;charset=US-ASCII")), { mimeType: a, body: o }
	}
	function cte(e, t = !1) {
		if (!t) return e.href
		let r = e.href,
			n = e.hash.length,
			i = n === 0 ? r : r.substring(0, r.length - n)
		return !n && r.endsWith("#") ? i.slice(0, -1) : i
	}
	function xB(e, t, r) {
		let n = ""
		for (; r.position < t.length && e(t[r.position]); ) (n += t[r.position]), r.position++
		return n
	}
	function Xm(e, t, r) {
		let n = t.indexOf(e, r.position),
			i = r.position
		return n === -1 ? ((r.position = t.length), t.slice(i)) : ((r.position = n), t.slice(i, r.position))
	}
	function ute(e) {
		let t = jHe.encode(e)
		return rWe(t)
	}
	function ate(e) {
		return (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102)
	}
	function lte(e) {
		return e >= 48 && e <= 57 ? e - 48 : (e & 223) - 55
	}
	function rWe(e) {
		let t = e.length,
			r = new Uint8Array(t),
			n = 0
		for (let i = 0; i < t; ++i) {
			let s = e[i]
			s !== 37
				? (r[n++] = s)
				: s === 37 && !(ate(e[i + 1]) && ate(e[i + 2]))
					? (r[n++] = 37)
					: ((r[n++] = (lte(e[i + 1]) << 4) | lte(e[i + 2])), (i += 2))
		}
		return t === n ? r : r.subarray(0, n)
	}
	function kO(e) {
		e = EB(e, !0, !0)
		let t = { position: 0 },
			r = Xm("/", e, t)
		if (r.length === 0 || !BE.test(r) || t.position > e.length) return "failure"
		t.position++
		let n = Xm(";", e, t)
		if (((n = EB(n, !1, !0)), n.length === 0 || !BE.test(n))) return "failure"
		let i = r.toLowerCase(),
			s = n.toLowerCase(),
			o = { type: i, subtype: s, parameters: new Map(), essence: `${i}/${s}` }
		for (; t.position < e.length; ) {
			t.position++, xB((c) => ZHe.test(c), e, t)
			let a = xB((c) => c !== ";" && c !== "=", e, t)
			if (((a = a.toLowerCase()), t.position < e.length)) {
				if (e[t.position] === ";") continue
				t.position++
			}
			if (t.position > e.length) break
			let l = null
			if (e[t.position] === '"') (l = dte(e, t, !0)), Xm(";", e, t)
			else if (((l = Xm(";", e, t)), (l = EB(l, !1, !0)), l.length === 0)) continue
			a.length !== 0 &&
				BE.test(a) &&
				(l.length === 0 || eWe.test(l)) &&
				!o.parameters.has(a) &&
				o.parameters.set(a, l)
		}
		return o
	}
	function nWe(e) {
		e = e.replace(XHe, "")
		let t = e.length
		if (
			(t % 4 === 0 && e.charCodeAt(t - 1) === 61 && (--t, e.charCodeAt(t - 1) === 61 && --t),
			t % 4 === 1 || /[^+/0-9A-Za-z]/.test(e.length === t ? e : e.substring(0, t)))
		)
			return "failure"
		let r = Buffer.from(e, "base64")
		return new Uint8Array(r.buffer, r.byteOffset, r.byteLength)
	}
	function dte(e, t, r) {
		let n = t.position,
			i = ""
		for (
			bB(e[t.position] === '"'), t.position++;
			(i += xB((o) => o !== '"' && o !== "\\", e, t)), !(t.position >= e.length);

		) {
			let s = e[t.position]
			if ((t.position++, s === "\\")) {
				if (t.position >= e.length) {
					i += "\\"
					break
				}
				;(i += e[t.position]), t.position++
			} else {
				bB(s === '"')
				break
			}
		}
		return r ? i : e.slice(n, t.position)
	}
	function iWe(e) {
		bB(e !== "failure")
		let { parameters: t, essence: r } = e,
			n = r
		for (let [i, s] of t.entries())
			(n += ";"),
				(n += i),
				(n += "="),
				BE.test(s) || ((s = s.replace(/(\\|")/g, "\\$1")), (s = '"' + s), (s += '"')),
				(n += s)
		return n
	}
	function sWe(e) {
		return e === 13 || e === 10 || e === 9 || e === 32
	}
	function EB(e, t = !0, r = !0) {
		return MO(e, t, r, sWe)
	}
	function oWe(e) {
		return e === 13 || e === 10 || e === 9 || e === 12 || e === 32
	}
	function aWe(e, t = !0, r = !0) {
		return MO(e, t, r, oWe)
	}
	function MO(e, t, r, n) {
		let i = 0,
			s = e.length - 1
		if (t) for (; i < e.length && n(e.charCodeAt(i)); ) i++
		if (r) for (; s > 0 && n(e.charCodeAt(s)); ) s--
		return i === 0 && s === e.length - 1 ? e : e.slice(i, s + 1)
	}
	function fte(e) {
		let t = e.length
		if (65535 > t) return String.fromCharCode.apply(null, e)
		let r = "",
			n = 0,
			i = 65535
		for (; n < t; ) n + i > t && (i = t - n), (r += String.fromCharCode.apply(null, e.subarray(n, (n += i))))
		return r
	}
	function lWe(e) {
		switch (e.essence) {
			case "application/ecmascript":
			case "application/javascript":
			case "application/x-ecmascript":
			case "application/x-javascript":
			case "text/ecmascript":
			case "text/javascript":
			case "text/javascript1.0":
			case "text/javascript1.1":
			case "text/javascript1.2":
			case "text/javascript1.3":
			case "text/javascript1.4":
			case "text/javascript1.5":
			case "text/jscript":
			case "text/livescript":
			case "text/x-ecmascript":
			case "text/x-javascript":
				return "text/javascript"
			case "application/json":
			case "text/json":
				return "application/json"
			case "image/svg+xml":
				return "image/svg+xml"
			case "text/xml":
			case "application/xml":
				return "application/xml"
		}
		return e.subtype.endsWith("+json") ? "application/json" : e.subtype.endsWith("+xml") ? "application/xml" : ""
	}
	hte.exports = {
		dataURLProcessor: tWe,
		URLSerializer: cte,
		collectASequenceOfCodePoints: xB,
		collectASequenceOfCodePointsFast: Xm,
		stringPercentDecode: ute,
		parseMIMEType: kO,
		collectAnHTTPQuotedString: dte,
		serializeAMimeType: iWe,
		removeChars: MO,
		removeHTTPWhitespace: EB,
		minimizeSupportedMimeType: lWe,
		HTTP_TOKEN_CODEPOINTS: BE,
		isomorphicDecode: fte,
	}
})
var ys = x((oIt, gte) => {
	"use strict"
	var { types: tu, inspect: cWe } = require("util"),
		{ markAsUncloneable: uWe } = require("worker_threads"),
		{ toUSVString: dWe } = Xt(),
		xe = {}
	xe.converters = {}
	xe.util = {}
	xe.errors = {}
	xe.errors.exception = function (e) {
		return new TypeError(`${e.header}: ${e.message}`)
	}
	xe.errors.conversionFailed = function (e) {
		let t = e.types.length === 1 ? "" : " one of",
			r = `${e.argument} could not be converted to${t}: ${e.types.join(", ")}.`
		return xe.errors.exception({ header: e.prefix, message: r })
	}
	xe.errors.invalidArgument = function (e) {
		return xe.errors.exception({
			header: e.prefix,
			message: `"${e.value}" is an invalid ${e.type}.`,
		})
	}
	xe.brandCheck = function (e, t, r) {
		if (r?.strict !== !1) {
			if (!(e instanceof t)) {
				let n = new TypeError("Illegal invocation")
				throw ((n.code = "ERR_INVALID_THIS"), n)
			}
		} else if (e?.[Symbol.toStringTag] !== t.prototype[Symbol.toStringTag]) {
			let n = new TypeError("Illegal invocation")
			throw ((n.code = "ERR_INVALID_THIS"), n)
		}
	}
	xe.argumentLengthCheck = function ({ length: e }, t, r) {
		if (e < t)
			throw xe.errors.exception({
				message: `${t} argument${t !== 1 ? "s" : ""} required, but${e ? " only" : ""} ${e} found.`,
				header: r,
			})
	}
	xe.illegalConstructor = function () {
		throw xe.errors.exception({
			header: "TypeError",
			message: "Illegal constructor",
		})
	}
	xe.util.Type = function (e) {
		switch (typeof e) {
			case "undefined":
				return "Undefined"
			case "boolean":
				return "Boolean"
			case "string":
				return "String"
			case "symbol":
				return "Symbol"
			case "number":
				return "Number"
			case "bigint":
				return "BigInt"
			case "function":
			case "object":
				return e === null ? "Null" : "Object"
		}
	}
	xe.util.markAsUncloneable = uWe || (() => {})
	xe.util.ConvertToInt = function (e, t, r, n) {
		let i, s
		t === 64
			? ((i = Math.pow(2, 53) - 1), r === "unsigned" ? (s = 0) : (s = Math.pow(-2, 53) + 1))
			: r === "unsigned"
				? ((s = 0), (i = Math.pow(2, t) - 1))
				: ((s = Math.pow(-2, t) - 1), (i = Math.pow(2, t - 1) - 1))
		let o = Number(e)
		if ((o === 0 && (o = 0), n?.enforceRange === !0)) {
			if (Number.isNaN(o) || o === Number.POSITIVE_INFINITY || o === Number.NEGATIVE_INFINITY)
				throw xe.errors.exception({
					header: "Integer conversion",
					message: `Could not convert ${xe.util.Stringify(e)} to an integer.`,
				})
			if (((o = xe.util.IntegerPart(o)), o < s || o > i))
				throw xe.errors.exception({
					header: "Integer conversion",
					message: `Value must be between ${s}-${i}, got ${o}.`,
				})
			return o
		}
		return !Number.isNaN(o) && n?.clamp === !0
			? ((o = Math.min(Math.max(o, s), i)), Math.floor(o) % 2 === 0 ? (o = Math.floor(o)) : (o = Math.ceil(o)), o)
			: Number.isNaN(o) ||
				  (o === 0 && Object.is(0, o)) ||
				  o === Number.POSITIVE_INFINITY ||
				  o === Number.NEGATIVE_INFINITY
				? 0
				: ((o = xe.util.IntegerPart(o)),
					(o = o % Math.pow(2, t)),
					r === "signed" && o >= Math.pow(2, t) - 1 ? o - Math.pow(2, t) : o)
	}
	xe.util.IntegerPart = function (e) {
		let t = Math.floor(Math.abs(e))
		return e < 0 ? -1 * t : t
	}
	xe.util.Stringify = function (e) {
		switch (xe.util.Type(e)) {
			case "Symbol":
				return `Symbol(${e.description})`
			case "Object":
				return cWe(e)
			case "String":
				return `"${e}"`
			default:
				return `${e}`
		}
	}
	xe.sequenceConverter = function (e) {
		return (t, r, n, i) => {
			if (xe.util.Type(t) !== "Object")
				throw xe.errors.exception({
					header: r,
					message: `${n} (${xe.util.Stringify(t)}) is not iterable.`,
				})
			let s = typeof i == "function" ? i() : t?.[Symbol.iterator]?.(),
				o = [],
				a = 0
			if (s === void 0 || typeof s.next != "function")
				throw xe.errors.exception({
					header: r,
					message: `${n} is not iterable.`,
				})
			for (;;) {
				let { done: l, value: c } = s.next()
				if (l) break
				o.push(e(c, r, `${n}[${a++}]`))
			}
			return o
		}
	}
	xe.recordConverter = function (e, t) {
		return (r, n, i) => {
			if (xe.util.Type(r) !== "Object")
				throw xe.errors.exception({
					header: n,
					message: `${i} ("${xe.util.Type(r)}") is not an Object.`,
				})
			let s = {}
			if (!tu.isProxy(r)) {
				let a = [...Object.getOwnPropertyNames(r), ...Object.getOwnPropertySymbols(r)]
				for (let l of a) {
					let c = e(l, n, i),
						u = t(r[l], n, i)
					s[c] = u
				}
				return s
			}
			let o = Reflect.ownKeys(r)
			for (let a of o)
				if (Reflect.getOwnPropertyDescriptor(r, a)?.enumerable) {
					let c = e(a, n, i),
						u = t(r[a], n, i)
					s[c] = u
				}
			return s
		}
	}
	xe.interfaceConverter = function (e) {
		return (t, r, n, i) => {
			if (i?.strict !== !1 && !(t instanceof e))
				throw xe.errors.exception({
					header: r,
					message: `Expected ${n} ("${xe.util.Stringify(t)}") to be an instance of ${e.name}.`,
				})
			return t
		}
	}
	xe.dictionaryConverter = function (e) {
		return (t, r, n) => {
			let i = xe.util.Type(t),
				s = {}
			if (i === "Null" || i === "Undefined") return s
			if (i !== "Object")
				throw xe.errors.exception({
					header: r,
					message: `Expected ${t} to be one of: Null, Undefined, Object.`,
				})
			for (let o of e) {
				let { key: a, defaultValue: l, required: c, converter: u } = o
				if (c === !0 && !Object.hasOwn(t, a))
					throw xe.errors.exception({
						header: r,
						message: `Missing required key "${a}".`,
					})
				let f = t[a],
					p = Object.hasOwn(o, "defaultValue")
				if ((p && f !== null && (f ??= l()), c || p || f !== void 0)) {
					if (((f = u(f, r, `${n}.${a}`)), o.allowedValues && !o.allowedValues.includes(f)))
						throw xe.errors.exception({
							header: r,
							message: `${f} is not an accepted type. Expected one of ${o.allowedValues.join(", ")}.`,
						})
					s[a] = f
				}
			}
			return s
		}
	}
	xe.nullableConverter = function (e) {
		return (t, r, n) => (t === null ? t : e(t, r, n))
	}
	xe.converters.DOMString = function (e, t, r, n) {
		if (e === null && n?.legacyNullToEmptyString) return ""
		if (typeof e == "symbol")
			throw xe.errors.exception({
				header: t,
				message: `${r} is a symbol, which cannot be converted to a DOMString.`,
			})
		return String(e)
	}
	xe.converters.ByteString = function (e, t, r) {
		let n = xe.converters.DOMString(e, t, r)
		for (let i = 0; i < n.length; i++)
			if (n.charCodeAt(i) > 255)
				throw new TypeError(
					`Cannot convert argument to a ByteString because the character at index ${i} has a value of ${n.charCodeAt(
						i,
					)} which is greater than 255.`,
				)
		return n
	}
	xe.converters.USVString = dWe
	xe.converters.boolean = function (e) {
		return !!e
	}
	xe.converters.any = function (e) {
		return e
	}
	xe.converters["long long"] = function (e, t, r) {
		return xe.util.ConvertToInt(e, 64, "signed", void 0, t, r)
	}
	xe.converters["unsigned long long"] = function (e, t, r) {
		return xe.util.ConvertToInt(e, 64, "unsigned", void 0, t, r)
	}
	xe.converters["unsigned long"] = function (e, t, r) {
		return xe.util.ConvertToInt(e, 32, "unsigned", void 0, t, r)
	}
	xe.converters["unsigned short"] = function (e, t, r, n) {
		return xe.util.ConvertToInt(e, 16, "unsigned", n, t, r)
	}
	xe.converters.ArrayBuffer = function (e, t, r, n) {
		if (xe.util.Type(e) !== "Object" || !tu.isAnyArrayBuffer(e))
			throw xe.errors.conversionFailed({
				prefix: t,
				argument: `${r} ("${xe.util.Stringify(e)}")`,
				types: ["ArrayBuffer"],
			})
		if (n?.allowShared === !1 && tu.isSharedArrayBuffer(e))
			throw xe.errors.exception({
				header: "ArrayBuffer",
				message: "SharedArrayBuffer is not allowed.",
			})
		if (e.resizable || e.growable)
			throw xe.errors.exception({
				header: "ArrayBuffer",
				message: "Received a resizable ArrayBuffer.",
			})
		return e
	}
	xe.converters.TypedArray = function (e, t, r, n, i) {
		if (xe.util.Type(e) !== "Object" || !tu.isTypedArray(e) || e.constructor.name !== t.name)
			throw xe.errors.conversionFailed({
				prefix: r,
				argument: `${n} ("${xe.util.Stringify(e)}")`,
				types: [t.name],
			})
		if (i?.allowShared === !1 && tu.isSharedArrayBuffer(e.buffer))
			throw xe.errors.exception({
				header: "ArrayBuffer",
				message: "SharedArrayBuffer is not allowed.",
			})
		if (e.buffer.resizable || e.buffer.growable)
			throw xe.errors.exception({
				header: "ArrayBuffer",
				message: "Received a resizable ArrayBuffer.",
			})
		return e
	}
	xe.converters.DataView = function (e, t, r, n) {
		if (xe.util.Type(e) !== "Object" || !tu.isDataView(e))
			throw xe.errors.exception({
				header: t,
				message: `${r} is not a DataView.`,
			})
		if (n?.allowShared === !1 && tu.isSharedArrayBuffer(e.buffer))
			throw xe.errors.exception({
				header: "ArrayBuffer",
				message: "SharedArrayBuffer is not allowed.",
			})
		if (e.buffer.resizable || e.buffer.growable)
			throw xe.errors.exception({
				header: "ArrayBuffer",
				message: "Received a resizable ArrayBuffer.",
			})
		return e
	}
	xe.converters.BufferSource = function (e, t, r, n) {
		if (tu.isAnyArrayBuffer(e)) return xe.converters.ArrayBuffer(e, t, r, { ...n, allowShared: !1 })
		if (tu.isTypedArray(e))
			return xe.converters.TypedArray(e, e.constructor, t, r, {
				...n,
				allowShared: !1,
			})
		if (tu.isDataView(e)) return xe.converters.DataView(e, t, r, { ...n, allowShared: !1 })
		throw xe.errors.conversionFailed({
			prefix: t,
			argument: `${r} ("${xe.util.Stringify(e)}")`,
			types: ["BufferSource"],
		})
	}
	xe.converters["sequence<ByteString>"] = xe.sequenceConverter(xe.converters.ByteString)
	xe.converters["sequence<sequence<ByteString>>"] = xe.sequenceConverter(xe.converters["sequence<ByteString>"])
	xe.converters["record<ByteString, ByteString>"] = xe.recordConverter(
		xe.converters.ByteString,
		xe.converters.ByteString,
	)
	gte.exports = { webidl: xe }
})
var ga = x((aIt, Bte) => {
	"use strict"
	var { Transform: fWe } = require("stream"),
		pte = require("zlib"),
		{ redirectStatusSet: hWe, referrerPolicySet: gWe, badPortsSet: pWe } = SE(),
		{ getGlobalOrigin: Ate } = RO(),
		{
			collectASequenceOfCodePoints: np,
			collectAnHTTPQuotedString: AWe,
			removeChars: mWe,
			parseMIMEType: yWe,
		} = No(),
		{ performance: CWe } = require("perf_hooks"),
		{ isBlobLike: vWe, ReadableStreamFrom: EWe, isValidHTTPToken: mte, normalizedMethodRecordsBase: bWe } = Xt(),
		ip = require("assert"),
		{ isUint8Array: xWe } = require("util/types"),
		{ webidl: DE } = ys(),
		yte = [],
		wB
	try {
		wB = require("crypto")
		let e = ["sha256", "sha384", "sha512"]
		yte = wB.getHashes().filter((t) => e.includes(t))
	} catch {}
	function Cte(e) {
		let t = e.urlList,
			r = t.length
		return r === 0 ? null : t[r - 1].toString()
	}
	function _We(e, t) {
		if (!hWe.has(e.status)) return null
		let r = e.headersList.get("location", !0)
		return (
			r !== null && Ete(r) && (vte(r) || (r = wWe(r)), (r = new URL(r, Cte(e)))), r && !r.hash && (r.hash = t), r
		)
	}
	function vte(e) {
		for (let t = 0; t < e.length; ++t) {
			let r = e.charCodeAt(t)
			if (r > 126 || r < 32) return !1
		}
		return !0
	}
	function wWe(e) {
		return Buffer.from(e, "binary").toString("utf8")
	}
	function RE(e) {
		return e.urlList[e.urlList.length - 1]
	}
	function IWe(e) {
		let t = RE(e)
		return Ite(t) && pWe.has(t.port) ? "blocked" : "allowed"
	}
	function SWe(e) {
		return e instanceof Error || e?.constructor?.name === "Error" || e?.constructor?.name === "DOMException"
	}
	function BWe(e) {
		for (let t = 0; t < e.length; ++t) {
			let r = e.charCodeAt(t)
			if (!(r === 9 || (r >= 32 && r <= 126) || (r >= 128 && r <= 255))) return !1
		}
		return !0
	}
	var DWe = mte
	function Ete(e) {
		return (
			(e[0] === "	" ||
				e[0] === " " ||
				e[e.length - 1] === "	" ||
				e[e.length - 1] === " " ||
				e.includes(`
`) ||
				e.includes("\r") ||
				e.includes("\0")) === !1
		)
	}
	function TWe(e, t) {
		let { headersList: r } = t,
			n = (r.get("referrer-policy", !0) ?? "").split(","),
			i = ""
		if (n.length > 0)
			for (let s = n.length; s !== 0; s--) {
				let o = n[s - 1].trim()
				if (gWe.has(o)) {
					i = o
					break
				}
			}
		i !== "" && (e.referrerPolicy = i)
	}
	function RWe() {
		return "allowed"
	}
	function kWe() {
		return "success"
	}
	function MWe() {
		return "success"
	}
	function FWe(e) {
		let t = null
		;(t = e.mode), e.headersList.set("sec-fetch-mode", t, !0)
	}
	function QWe(e) {
		let t = e.origin
		if (!(t === "client" || t === void 0)) {
			if (e.responseTainting === "cors" || e.mode === "websocket") e.headersList.append("origin", t, !0)
			else if (e.method !== "GET" && e.method !== "HEAD") {
				switch (e.referrerPolicy) {
					case "no-referrer":
						t = null
						break
					case "no-referrer-when-downgrade":
					case "strict-origin":
					case "strict-origin-when-cross-origin":
						e.origin && QO(e.origin) && !QO(RE(e)) && (t = null)
						break
					case "same-origin":
						IB(e, RE(e)) || (t = null)
						break
					default:
				}
				e.headersList.append("origin", t, !0)
			}
		}
	}
	function e0(e, t) {
		return e
	}
	function NWe(e, t, r) {
		return !e?.startTime || e.startTime < t
			? {
					domainLookupStartTime: t,
					domainLookupEndTime: t,
					connectionStartTime: t,
					connectionEndTime: t,
					secureConnectionStartTime: t,
					ALPNNegotiatedProtocol: e?.ALPNNegotiatedProtocol,
				}
			: {
					domainLookupStartTime: e0(e.domainLookupStartTime, r),
					domainLookupEndTime: e0(e.domainLookupEndTime, r),
					connectionStartTime: e0(e.connectionStartTime, r),
					connectionEndTime: e0(e.connectionEndTime, r),
					secureConnectionStartTime: e0(e.secureConnectionStartTime, r),
					ALPNNegotiatedProtocol: e.ALPNNegotiatedProtocol,
				}
	}
	function PWe(e) {
		return e0(CWe.now(), e)
	}
	function LWe(e) {
		return {
			startTime: e.startTime ?? 0,
			redirectStartTime: 0,
			redirectEndTime: 0,
			postRedirectStartTime: e.startTime ?? 0,
			finalServiceWorkerStartTime: 0,
			finalNetworkResponseStartTime: 0,
			finalNetworkRequestStartTime: 0,
			endTime: 0,
			encodedBodySize: 0,
			decodedBodySize: 0,
			finalConnectionTimingInfo: null,
		}
	}
	function bte() {
		return { referrerPolicy: "strict-origin-when-cross-origin" }
	}
	function UWe(e) {
		return { referrerPolicy: e.referrerPolicy }
	}
	function OWe(e) {
		let t = e.referrerPolicy
		ip(t)
		let r = null
		if (e.referrer === "client") {
			let a = Ate()
			if (!a || a.origin === "null") return "no-referrer"
			r = new URL(a)
		} else e.referrer instanceof URL && (r = e.referrer)
		let n = FO(r),
			i = FO(r, !0)
		n.toString().length > 4096 && (n = i)
		let s = IB(e, n),
			o = TE(n) && !TE(e.url)
		switch (t) {
			case "origin":
				return i ?? FO(r, !0)
			case "unsafe-url":
				return n
			case "same-origin":
				return s ? i : "no-referrer"
			case "origin-when-cross-origin":
				return s ? n : i
			case "strict-origin-when-cross-origin": {
				let a = RE(e)
				return IB(n, a) ? n : TE(n) && !TE(a) ? "no-referrer" : i
			}
			case "strict-origin":
			case "no-referrer-when-downgrade":
			default:
				return o ? "no-referrer" : i
		}
	}
	function FO(e, t) {
		return (
			ip(e instanceof URL),
			(e = new URL(e)),
			e.protocol === "file:" || e.protocol === "about:" || e.protocol === "blank:"
				? "no-referrer"
				: ((e.username = ""), (e.password = ""), (e.hash = ""), t && ((e.pathname = ""), (e.search = "")), e)
		)
	}
	function TE(e) {
		if (!(e instanceof URL)) return !1
		if (e.href === "about:blank" || e.href === "about:srcdoc" || e.protocol === "data:" || e.protocol === "file:")
			return !0
		return t(e.origin)
		function t(r) {
			if (r == null || r === "null") return !1
			let n = new URL(r)
			return !!(
				n.protocol === "https:" ||
				n.protocol === "wss:" ||
				/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(n.hostname) ||
				n.hostname === "localhost" ||
				n.hostname.includes("localhost.") ||
				n.hostname.endsWith(".localhost")
			)
		}
	}
	function qWe(e, t) {
		if (wB === void 0) return !0
		let r = xte(t)
		if (r === "no metadata" || r.length === 0) return !0
		let n = HWe(r),
			i = WWe(r, n)
		for (let s of i) {
			let o = s.algo,
				a = s.hash,
				l = wB.createHash(o).update(e).digest("base64")
			if (
				(l[l.length - 1] === "=" && (l[l.length - 2] === "=" ? (l = l.slice(0, -2)) : (l = l.slice(0, -1))),
				GWe(l, a))
			)
				return !0
		}
		return !1
	}
	var VWe = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i
	function xte(e) {
		let t = [],
			r = !0
		for (let n of e.split(" ")) {
			r = !1
			let i = VWe.exec(n)
			if (i === null || i.groups === void 0 || i.groups.algo === void 0) continue
			let s = i.groups.algo.toLowerCase()
			yte.includes(s) && t.push(i.groups)
		}
		return r === !0 ? "no metadata" : t
	}
	function HWe(e) {
		let t = e[0].algo
		if (t[3] === "5") return t
		for (let r = 1; r < e.length; ++r) {
			let n = e[r]
			if (n.algo[3] === "5") {
				t = "sha512"
				break
			} else {
				if (t[3] === "3") continue
				n.algo[3] === "3" && (t = "sha384")
			}
		}
		return t
	}
	function WWe(e, t) {
		if (e.length === 1) return e
		let r = 0
		for (let n = 0; n < e.length; ++n) e[n].algo === t && (e[r++] = e[n])
		return (e.length = r), e
	}
	function GWe(e, t) {
		if (e.length !== t.length) return !1
		for (let r = 0; r < e.length; ++r)
			if (e[r] !== t[r]) {
				if ((e[r] === "+" && t[r] === "-") || (e[r] === "/" && t[r] === "_")) continue
				return !1
			}
		return !0
	}
	function $We(e) {}
	function IB(e, t) {
		return (
			(e.origin === t.origin && e.origin === "null") ||
			(e.protocol === t.protocol && e.hostname === t.hostname && e.port === t.port)
		)
	}
	function YWe() {
		let e, t
		return {
			promise: new Promise((n, i) => {
				;(e = n), (t = i)
			}),
			resolve: e,
			reject: t,
		}
	}
	function KWe(e) {
		return e.controller.state === "aborted"
	}
	function JWe(e) {
		return e.controller.state === "aborted" || e.controller.state === "terminated"
	}
	function zWe(e) {
		return bWe[e.toLowerCase()] ?? e
	}
	function jWe(e) {
		let t = JSON.stringify(e)
		if (t === void 0) throw new TypeError("Value is not JSON serializable")
		return ip(typeof t == "string"), t
	}
	var ZWe = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))
	function _te(e, t, r = 0, n = 1) {
		class i {
			#e
			#t
			#i
			constructor(o, a) {
				;(this.#e = o), (this.#t = a), (this.#i = 0)
			}
			next() {
				if (typeof this != "object" || this === null || !(#e in this))
					throw new TypeError(`'next' called on an object that does not implement interface ${e} Iterator.`)
				let o = this.#i,
					a = this.#e[t],
					l = a.length
				if (o >= l) return { value: void 0, done: !0 }
				let { [r]: c, [n]: u } = a[o]
				this.#i = o + 1
				let f
				switch (this.#t) {
					case "key":
						f = c
						break
					case "value":
						f = u
						break
					case "key+value":
						f = [c, u]
						break
				}
				return { value: f, done: !1 }
			}
		}
		return (
			delete i.prototype.constructor,
			Object.setPrototypeOf(i.prototype, ZWe),
			Object.defineProperties(i.prototype, {
				[Symbol.toStringTag]: {
					writable: !1,
					enumerable: !1,
					configurable: !0,
					value: `${e} Iterator`,
				},
				next: { writable: !0, enumerable: !0, configurable: !0 },
			}),
			function (s, o) {
				return new i(s, o)
			}
		)
	}
	function XWe(e, t, r, n = 0, i = 1) {
		let s = _te(e, r, n, i),
			o = {
				keys: {
					writable: !0,
					enumerable: !0,
					configurable: !0,
					value: function () {
						return DE.brandCheck(this, t), s(this, "key")
					},
				},
				values: {
					writable: !0,
					enumerable: !0,
					configurable: !0,
					value: function () {
						return DE.brandCheck(this, t), s(this, "value")
					},
				},
				entries: {
					writable: !0,
					enumerable: !0,
					configurable: !0,
					value: function () {
						return DE.brandCheck(this, t), s(this, "key+value")
					},
				},
				forEach: {
					writable: !0,
					enumerable: !0,
					configurable: !0,
					value: function (l, c = globalThis) {
						if (
							(DE.brandCheck(this, t),
							DE.argumentLengthCheck(arguments, 1, `${e}.forEach`),
							typeof l != "function")
						)
							throw new TypeError(
								`Failed to execute 'forEach' on '${e}': parameter 1 is not of type 'Function'.`,
							)
						for (let { 0: u, 1: f } of s(this, "key+value")) l.call(c, f, u, this)
					},
				},
			}
		return Object.defineProperties(t.prototype, {
			...o,
			[Symbol.iterator]: {
				writable: !0,
				enumerable: !1,
				configurable: !0,
				value: o.entries.value,
			},
		})
	}
	async function e4e(e, t, r) {
		let n = t,
			i = r,
			s
		try {
			s = e.stream.getReader()
		} catch (o) {
			i(o)
			return
		}
		try {
			n(await wte(s))
		} catch (o) {
			i(o)
		}
	}
	function t4e(e) {
		return e instanceof ReadableStream || (e[Symbol.toStringTag] === "ReadableStream" && typeof e.tee == "function")
	}
	function r4e(e) {
		try {
			e.close(), e.byobRequest?.respond(0)
		} catch (t) {
			if (
				!t.message.includes("Controller is already closed") &&
				!t.message.includes("ReadableStream is already closed")
			)
				throw t
		}
	}
	var n4e = /[^\x00-\xFF]/
	function _B(e) {
		return ip(!n4e.test(e)), e
	}
	async function wte(e) {
		let t = [],
			r = 0
		for (;;) {
			let { done: n, value: i } = await e.read()
			if (n) return Buffer.concat(t, r)
			if (!xWe(i)) throw new TypeError("Received non-Uint8Array chunk")
			t.push(i), (r += i.length)
		}
	}
	function i4e(e) {
		ip("protocol" in e)
		let t = e.protocol
		return t === "about:" || t === "blob:" || t === "data:"
	}
	function QO(e) {
		return (
			(typeof e == "string" &&
				e[5] === ":" &&
				e[0] === "h" &&
				e[1] === "t" &&
				e[2] === "t" &&
				e[3] === "p" &&
				e[4] === "s") ||
			e.protocol === "https:"
		)
	}
	function Ite(e) {
		ip("protocol" in e)
		let t = e.protocol
		return t === "http:" || t === "https:"
	}
	function s4e(e, t) {
		let r = e
		if (!r.startsWith("bytes")) return "failure"
		let n = { position: 5 }
		if ((t && np((l) => l === "	" || l === " ", r, n), r.charCodeAt(n.position) !== 61)) return "failure"
		n.position++, t && np((l) => l === "	" || l === " ", r, n)
		let i = np(
				(l) => {
					let c = l.charCodeAt(0)
					return c >= 48 && c <= 57
				},
				r,
				n,
			),
			s = i.length ? Number(i) : null
		if ((t && np((l) => l === "	" || l === " ", r, n), r.charCodeAt(n.position) !== 45)) return "failure"
		n.position++, t && np((l) => l === "	" || l === " ", r, n)
		let o = np(
				(l) => {
					let c = l.charCodeAt(0)
					return c >= 48 && c <= 57
				},
				r,
				n,
			),
			a = o.length ? Number(o) : null
		return n.position < r.length || (a === null && s === null) || s > a
			? "failure"
			: { rangeStartValue: s, rangeEndValue: a }
	}
	function o4e(e, t, r) {
		let n = "bytes "
		return (n += _B(`${e}`)), (n += "-"), (n += _B(`${t}`)), (n += "/"), (n += _B(`${r}`)), n
	}
	var NO = class extends fWe {
		#e
		constructor(t) {
			super(), (this.#e = t)
		}
		_transform(t, r, n) {
			if (!this._inflateStream) {
				if (t.length === 0) {
					n()
					return
				}
				;(this._inflateStream = (t[0] & 15) === 8 ? pte.createInflate(this.#e) : pte.createInflateRaw(this.#e)),
					this._inflateStream.on("data", this.push.bind(this)),
					this._inflateStream.on("end", () => this.push(null)),
					this._inflateStream.on("error", (i) => this.destroy(i))
			}
			this._inflateStream.write(t, r, n)
		}
		_final(t) {
			this._inflateStream && (this._inflateStream.end(), (this._inflateStream = null)), t()
		}
	}
	function a4e(e) {
		return new NO(e)
	}
	function l4e(e) {
		let t = null,
			r = null,
			n = null,
			i = Ste("content-type", e)
		if (i === null) return "failure"
		for (let s of i) {
			let o = yWe(s)
			o === "failure" ||
				o.essence === "*/*" ||
				((n = o),
				n.essence !== r
					? ((t = null), n.parameters.has("charset") && (t = n.parameters.get("charset")), (r = n.essence))
					: !n.parameters.has("charset") && t !== null && n.parameters.set("charset", t))
		}
		return n ?? "failure"
	}
	function c4e(e) {
		let t = e,
			r = { position: 0 },
			n = [],
			i = ""
		for (; r.position < t.length; ) {
			if (((i += np((s) => s !== '"' && s !== ",", t, r)), r.position < t.length))
				if (t.charCodeAt(r.position) === 34) {
					if (((i += AWe(t, r)), r.position < t.length)) continue
				} else ip(t.charCodeAt(r.position) === 44), r.position++
			;(i = mWe(i, !0, !0, (s) => s === 9 || s === 32)), n.push(i), (i = "")
		}
		return n
	}
	function Ste(e, t) {
		let r = t.get(e, !0)
		return r === null ? null : c4e(r)
	}
	var u4e = new TextDecoder()
	function d4e(e) {
		return e.length === 0
			? ""
			: (e[0] === 239 && e[1] === 187 && e[2] === 191 && (e = e.subarray(3)), u4e.decode(e))
	}
	var PO = class {
			get baseUrl() {
				return Ate()
			}
			get origin() {
				return this.baseUrl?.origin
			}
			policyContainer = bte()
		},
		LO = class {
			settingsObject = new PO()
		},
		f4e = new LO()
	Bte.exports = {
		isAborted: KWe,
		isCancelled: JWe,
		isValidEncodedURL: vte,
		createDeferredPromise: YWe,
		ReadableStreamFrom: EWe,
		tryUpgradeRequestToAPotentiallyTrustworthyURL: $We,
		clampAndCoarsenConnectionTimingInfo: NWe,
		coarsenedSharedCurrentTime: PWe,
		determineRequestsReferrer: OWe,
		makePolicyContainer: bte,
		clonePolicyContainer: UWe,
		appendFetchMetadata: FWe,
		appendRequestOriginHeader: QWe,
		TAOCheck: MWe,
		corsCheck: kWe,
		crossOriginResourcePolicyCheck: RWe,
		createOpaqueTimingInfo: LWe,
		setRequestReferrerPolicyOnRedirect: TWe,
		isValidHTTPToken: mte,
		requestBadPort: IWe,
		requestCurrentURL: RE,
		responseURL: Cte,
		responseLocationURL: _We,
		isBlobLike: vWe,
		isURLPotentiallyTrustworthy: TE,
		isValidReasonPhrase: BWe,
		sameOrigin: IB,
		normalizeMethod: zWe,
		serializeJavascriptValueToJSONString: jWe,
		iteratorMixin: XWe,
		createIterator: _te,
		isValidHeaderName: DWe,
		isValidHeaderValue: Ete,
		isErrorLike: SWe,
		fullyReadBody: e4e,
		bytesMatch: qWe,
		isReadableStreamLike: t4e,
		readableStreamClose: r4e,
		isomorphicEncode: _B,
		urlIsLocal: i4e,
		urlHasHttpsScheme: QO,
		urlIsHttpHttpsScheme: Ite,
		readAllBytes: wte,
		simpleRangeHeaderValue: s4e,
		buildContentRange: o4e,
		parseMetadata: xte,
		createInflate: a4e,
		extractMimeType: l4e,
		getDecodeSplit: Ste,
		utf8DecodeBytes: d4e,
		environmentSettingsObject: f4e,
	}
})
var Gf = x((lIt, Dte) => {
	"use strict"
	Dte.exports = {
		kUrl: Symbol("url"),
		kHeaders: Symbol("headers"),
		kSignal: Symbol("signal"),
		kState: Symbol("state"),
		kDispatcher: Symbol("dispatcher"),
	}
})
var OO = x((cIt, Tte) => {
	"use strict"
	var { Blob: h4e, File: g4e } = require("buffer"),
		{ kState: Bd } = Gf(),
		{ webidl: ru } = ys(),
		UO = class e {
			constructor(t, r, n = {}) {
				let i = r,
					s = n.type,
					o = n.lastModified ?? Date.now()
				this[Bd] = { blobLike: t, name: i, type: s, lastModified: o }
			}
			stream(...t) {
				return ru.brandCheck(this, e), this[Bd].blobLike.stream(...t)
			}
			arrayBuffer(...t) {
				return ru.brandCheck(this, e), this[Bd].blobLike.arrayBuffer(...t)
			}
			slice(...t) {
				return ru.brandCheck(this, e), this[Bd].blobLike.slice(...t)
			}
			text(...t) {
				return ru.brandCheck(this, e), this[Bd].blobLike.text(...t)
			}
			get size() {
				return ru.brandCheck(this, e), this[Bd].blobLike.size
			}
			get type() {
				return ru.brandCheck(this, e), this[Bd].blobLike.type
			}
			get name() {
				return ru.brandCheck(this, e), this[Bd].name
			}
			get lastModified() {
				return ru.brandCheck(this, e), this[Bd].lastModified
			}
			get [Symbol.toStringTag]() {
				return "File"
			}
		}
	ru.converters.Blob = ru.interfaceConverter(h4e)
	function p4e(e) {
		return (
			e instanceof g4e ||
			(e &&
				(typeof e.stream == "function" || typeof e.arrayBuffer == "function") &&
				e[Symbol.toStringTag] === "File")
		)
	}
	Tte.exports = { FileLike: UO, isFileLike: p4e }
})
var ME = x((uIt, Qte) => {
	"use strict"
	var { isBlobLike: SB, iteratorMixin: A4e } = ga(),
		{ kState: no } = Gf(),
		{ kEnumerableProperty: t0 } = Xt(),
		{ FileLike: Rte, isFileLike: m4e } = OO(),
		{ webidl: fn } = ys(),
		{ File: Fte } = require("buffer"),
		kte = require("util"),
		Mte = globalThis.File ?? Fte,
		kE = class e {
			constructor(t) {
				if ((fn.util.markAsUncloneable(this), t !== void 0))
					throw fn.errors.conversionFailed({
						prefix: "FormData constructor",
						argument: "Argument 1",
						types: ["undefined"],
					})
				this[no] = []
			}
			append(t, r, n = void 0) {
				fn.brandCheck(this, e)
				let i = "FormData.append"
				if ((fn.argumentLengthCheck(arguments, 2, i), arguments.length === 3 && !SB(r)))
					throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'")
				;(t = fn.converters.USVString(t, i, "name")),
					(r = SB(r)
						? fn.converters.Blob(r, i, "value", { strict: !1 })
						: fn.converters.USVString(r, i, "value")),
					(n = arguments.length === 3 ? fn.converters.USVString(n, i, "filename") : void 0)
				let s = qO(t, r, n)
				this[no].push(s)
			}
			delete(t) {
				fn.brandCheck(this, e)
				let r = "FormData.delete"
				fn.argumentLengthCheck(arguments, 1, r),
					(t = fn.converters.USVString(t, r, "name")),
					(this[no] = this[no].filter((n) => n.name !== t))
			}
			get(t) {
				fn.brandCheck(this, e)
				let r = "FormData.get"
				fn.argumentLengthCheck(arguments, 1, r), (t = fn.converters.USVString(t, r, "name"))
				let n = this[no].findIndex((i) => i.name === t)
				return n === -1 ? null : this[no][n].value
			}
			getAll(t) {
				fn.brandCheck(this, e)
				let r = "FormData.getAll"
				return (
					fn.argumentLengthCheck(arguments, 1, r),
					(t = fn.converters.USVString(t, r, "name")),
					this[no].filter((n) => n.name === t).map((n) => n.value)
				)
			}
			has(t) {
				fn.brandCheck(this, e)
				let r = "FormData.has"
				return (
					fn.argumentLengthCheck(arguments, 1, r),
					(t = fn.converters.USVString(t, r, "name")),
					this[no].findIndex((n) => n.name === t) !== -1
				)
			}
			set(t, r, n = void 0) {
				fn.brandCheck(this, e)
				let i = "FormData.set"
				if ((fn.argumentLengthCheck(arguments, 2, i), arguments.length === 3 && !SB(r)))
					throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'")
				;(t = fn.converters.USVString(t, i, "name")),
					(r = SB(r)
						? fn.converters.Blob(r, i, "name", { strict: !1 })
						: fn.converters.USVString(r, i, "name")),
					(n = arguments.length === 3 ? fn.converters.USVString(n, i, "name") : void 0)
				let s = qO(t, r, n),
					o = this[no].findIndex((a) => a.name === t)
				o !== -1
					? (this[no] = [...this[no].slice(0, o), s, ...this[no].slice(o + 1).filter((a) => a.name !== t)])
					: this[no].push(s)
			}
			[kte.inspect.custom](t, r) {
				let n = this[no].reduce(
					(s, o) => (
						s[o.name]
							? Array.isArray(s[o.name])
								? s[o.name].push(o.value)
								: (s[o.name] = [s[o.name], o.value])
							: (s[o.name] = o.value),
						s
					),
					{ __proto__: null },
				)
				;(r.depth ??= t), (r.colors ??= !0)
				let i = kte.formatWithOptions(r, n)
				return `FormData ${i.slice(i.indexOf("]") + 2)}`
			}
		}
	A4e("FormData", kE, no, "name", "value")
	Object.defineProperties(kE.prototype, {
		append: t0,
		delete: t0,
		get: t0,
		getAll: t0,
		has: t0,
		set: t0,
		[Symbol.toStringTag]: { value: "FormData", configurable: !0 },
	})
	function qO(e, t, r) {
		if (typeof t != "string") {
			if (
				(m4e(t) ||
					(t =
						t instanceof Blob
							? new Mte([t], "blob", { type: t.type })
							: new Rte(t, "blob", { type: t.type })),
				r !== void 0)
			) {
				let n = { type: t.type, lastModified: t.lastModified }
				t = t instanceof Fte ? new Mte([t], r, n) : new Rte(t, r, n)
			}
		}
		return { name: e, value: t }
	}
	Qte.exports = { FormData: kE, makeEntry: qO }
})
var qte = x((dIt, Ote) => {
	"use strict"
	var { isUSVString: Nte, bufferToLowerCasedHeaderName: y4e } = Xt(),
		{ utf8DecodeBytes: C4e } = ga(),
		{ HTTP_TOKEN_CODEPOINTS: v4e, isomorphicDecode: Pte } = No(),
		{ isFileLike: E4e } = OO(),
		{ makeEntry: b4e } = ME(),
		BB = require("assert"),
		{ File: x4e } = require("buffer"),
		_4e = globalThis.File ?? x4e,
		w4e = Buffer.from('form-data; name="'),
		Lte = Buffer.from("; filename"),
		I4e = Buffer.from("--"),
		S4e = Buffer.from(`--\r
`)
	function B4e(e) {
		for (let t = 0; t < e.length; ++t) if (e.charCodeAt(t) & -128) return !1
		return !0
	}
	function D4e(e) {
		let t = e.length
		if (t < 27 || t > 70) return !1
		for (let r = 0; r < t; ++r) {
			let n = e.charCodeAt(r)
			if (
				!(
					(n >= 48 && n <= 57) ||
					(n >= 65 && n <= 90) ||
					(n >= 97 && n <= 122) ||
					n === 39 ||
					n === 45 ||
					n === 95
				)
			)
				return !1
		}
		return !0
	}
	function T4e(e, t) {
		BB(t !== "failure" && t.essence === "multipart/form-data")
		let r = t.parameters.get("boundary")
		if (r === void 0) return "failure"
		let n = Buffer.from(`--${r}`, "utf8"),
			i = [],
			s = { position: 0 }
		for (; e[s.position] === 13 && e[s.position + 1] === 10; ) s.position += 2
		let o = e.length
		for (; e[o - 1] === 10 && e[o - 2] === 13; ) o -= 2
		for (o !== e.length && (e = e.subarray(0, o)); ; ) {
			if (e.subarray(s.position, s.position + n.length).equals(n)) s.position += n.length
			else return "failure"
			if ((s.position === e.length - 2 && DB(e, I4e, s)) || (s.position === e.length - 4 && DB(e, S4e, s)))
				return i
			if (e[s.position] !== 13 || e[s.position + 1] !== 10) return "failure"
			s.position += 2
			let a = R4e(e, s)
			if (a === "failure") return "failure"
			let { name: l, filename: c, contentType: u, encoding: f } = a
			s.position += 2
			let p
			{
				let m = e.indexOf(n.subarray(2), s.position)
				if (m === -1) return "failure"
				;(p = e.subarray(s.position, m - 4)),
					(s.position += p.length),
					f === "base64" && (p = Buffer.from(p.toString(), "base64"))
			}
			if (e[s.position] !== 13 || e[s.position + 1] !== 10) return "failure"
			s.position += 2
			let g
			c !== null
				? ((u ??= "text/plain"), B4e(u) || (u = ""), (g = new _4e([p], c, { type: u })))
				: (g = C4e(Buffer.from(p))),
				BB(Nte(l)),
				BB((typeof g == "string" && Nte(g)) || E4e(g)),
				i.push(b4e(l, g, c))
		}
	}
	function R4e(e, t) {
		let r = null,
			n = null,
			i = null,
			s = null
		for (;;) {
			if (e[t.position] === 13 && e[t.position + 1] === 10)
				return r === null ? "failure" : { name: r, filename: n, contentType: i, encoding: s }
			let o = r0((a) => a !== 10 && a !== 13 && a !== 58, e, t)
			if (((o = VO(o, !0, !0, (a) => a === 9 || a === 32)), !v4e.test(o.toString()) || e[t.position] !== 58))
				return "failure"
			switch ((t.position++, r0((a) => a === 32 || a === 9, e, t), y4e(o))) {
				case "content-disposition": {
					if (((r = n = null), !DB(e, w4e, t) || ((t.position += 17), (r = Ute(e, t)), r === null)))
						return "failure"
					if (DB(e, Lte, t)) {
						let a = t.position + Lte.length
						if (
							(e[a] === 42 && ((t.position += 1), (a += 1)),
							e[a] !== 61 || e[a + 1] !== 34 || ((t.position += 12), (n = Ute(e, t)), n === null))
						)
							return "failure"
					}
					break
				}
				case "content-type": {
					let a = r0((l) => l !== 10 && l !== 13, e, t)
					;(a = VO(a, !1, !0, (l) => l === 9 || l === 32)), (i = Pte(a))
					break
				}
				case "content-transfer-encoding": {
					let a = r0((l) => l !== 10 && l !== 13, e, t)
					;(a = VO(a, !1, !0, (l) => l === 9 || l === 32)), (s = Pte(a))
					break
				}
				default:
					r0((a) => a !== 10 && a !== 13, e, t)
			}
			if (e[t.position] !== 13 && e[t.position + 1] !== 10) return "failure"
			t.position += 2
		}
	}
	function Ute(e, t) {
		BB(e[t.position - 1] === 34)
		let r = r0((n) => n !== 10 && n !== 13 && n !== 34, e, t)
		return e[t.position] !== 34
			? null
			: (t.position++,
				(r = new TextDecoder()
					.decode(r)
					.replace(
						/%0A/gi,
						`
`,
					)
					.replace(/%0D/gi, "\r")
					.replace(/%22/g, '"')),
				r)
	}
	function r0(e, t, r) {
		let n = r.position
		for (; n < t.length && e(t[n]); ) ++n
		return t.subarray(r.position, (r.position = n))
	}
	function VO(e, t, r, n) {
		let i = 0,
			s = e.length - 1
		if (t) for (; i < e.length && n(e[i]); ) i++
		if (r) for (; s > 0 && n(e[s]); ) s--
		return i === 0 && s === e.length - 1 ? e : e.subarray(i, s + 1)
	}
	function DB(e, t, r) {
		if (e.length < t.length) return !1
		for (let n = 0; n < t.length; n++) if (t[n] !== e[r.position + n]) return !1
		return !0
	}
	Ote.exports = { multipartFormDataParser: T4e, validateBoundary: D4e }
})
var s0 = x((fIt, Jte) => {
	"use strict"
	var FE = Xt(),
		{
			ReadableStreamFrom: k4e,
			isBlobLike: Vte,
			isReadableStreamLike: M4e,
			readableStreamClose: F4e,
			createDeferredPromise: Q4e,
			fullyReadBody: N4e,
			extractMimeType: P4e,
			utf8DecodeBytes: Gte,
		} = ga(),
		{ FormData: Hte } = ME(),
		{ kState: i0 } = Gf(),
		{ webidl: L4e } = ys(),
		{ Blob: U4e } = require("buffer"),
		HO = require("assert"),
		{ isErrored: $te, isDisturbed: O4e } = require("stream"),
		{ isArrayBuffer: q4e } = require("util/types"),
		{ serializeAMimeType: V4e } = No(),
		{ multipartFormDataParser: H4e } = qte(),
		WO
	try {
		let e = require("crypto")
		WO = (t) => e.randomInt(0, t)
	} catch {
		WO = (e) => Math.floor(Math.random(e))
	}
	var TB = new TextEncoder()
	function W4e() {}
	var GO = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0,
		$O
	GO &&
		($O = new FinalizationRegistry((e) => {
			let t = e.deref()
			t && !t.locked && !O4e(t) && !$te(t) && t.cancel("Response object has been garbage collected").catch(W4e)
		}))
	function Yte(e, t = !1) {
		let r = null
		e instanceof ReadableStream
			? (r = e)
			: Vte(e)
				? (r = e.stream())
				: (r = new ReadableStream({
						async pull(l) {
							let c = typeof i == "string" ? TB.encode(i) : i
							c.byteLength && l.enqueue(c), queueMicrotask(() => F4e(l))
						},
						start() {},
						type: "bytes",
					})),
			HO(M4e(r))
		let n = null,
			i = null,
			s = null,
			o = null
		if (typeof e == "string") (i = e), (o = "text/plain;charset=UTF-8")
		else if (e instanceof URLSearchParams)
			(i = e.toString()), (o = "application/x-www-form-urlencoded;charset=UTF-8")
		else if (q4e(e)) i = new Uint8Array(e.slice())
		else if (ArrayBuffer.isView(e)) i = new Uint8Array(e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength))
		else if (FE.isFormDataLike(e)) {
			let l = `----formdata-undici-0${`${WO(1e11)}`.padStart(11, "0")}`,
				c = `--${l}\r
Content-Disposition: form-data`
			let u = (C) => C.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"),
				f = (C) =>
					C.replace(
						/\r?\n|\r/g,
						`\r
`,
					),
				p = [],
				g = new Uint8Array([13, 10])
			s = 0
			let m = !1
			for (let [C, v] of e)
				if (typeof v == "string") {
					let b = TB.encode(
						c +
							`; name="${u(f(C))}"\r
\r
${f(v)}\r
`,
					)
					p.push(b), (s += b.byteLength)
				} else {
					let b = TB.encode(
						`${c}; name="${u(f(C))}"` +
							(v.name ? `; filename="${u(v.name)}"` : "") +
							`\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`,
					)
					p.push(b, v, g), typeof v.size == "number" ? (s += b.byteLength + v.size + g.byteLength) : (m = !0)
				}
			let y = TB.encode(`--${l}--`)
			p.push(y),
				(s += y.byteLength),
				m && (s = null),
				(i = e),
				(n = async function* () {
					for (let C of p) C.stream ? yield* C.stream() : yield C
				}),
				(o = `multipart/form-data; boundary=${l}`)
		} else if (Vte(e)) (i = e), (s = e.size), e.type && (o = e.type)
		else if (typeof e[Symbol.asyncIterator] == "function") {
			if (t) throw new TypeError("keepalive")
			if (FE.isDisturbed(e) || e.locked)
				throw new TypeError("Response body object should not be disturbed or locked")
			r = e instanceof ReadableStream ? e : k4e(e)
		}
		if (((typeof i == "string" || FE.isBuffer(i)) && (s = Buffer.byteLength(i)), n != null)) {
			let l
			r = new ReadableStream({
				async start() {
					l = n(e)[Symbol.asyncIterator]()
				},
				async pull(c) {
					let { value: u, done: f } = await l.next()
					if (f)
						queueMicrotask(() => {
							c.close(), c.byobRequest?.respond(0)
						})
					else if (!$te(r)) {
						let p = new Uint8Array(u)
						p.byteLength && c.enqueue(p)
					}
					return c.desiredSize > 0
				},
				async cancel(c) {
					await l.return()
				},
				type: "bytes",
			})
		}
		return [{ stream: r, source: i, length: s }, o]
	}
	function G4e(e, t = !1) {
		return (
			e instanceof ReadableStream &&
				(HO(!FE.isDisturbed(e), "The body has already been consumed."), HO(!e.locked, "The stream is locked.")),
			Yte(e, t)
		)
	}
	function $4e(e, t) {
		let [r, n] = t.stream.tee()
		return GO && $O.register(e, new WeakRef(r)), (t.stream = r), { stream: n, length: t.length, source: t.source }
	}
	function Y4e(e) {
		if (e.aborted) throw new DOMException("The operation was aborted.", "AbortError")
	}
	function K4e(e) {
		return {
			blob() {
				return n0(
					this,
					(r) => {
						let n = Wte(this)
						return n === null ? (n = "") : n && (n = V4e(n)), new U4e([r], { type: n })
					},
					e,
				)
			},
			arrayBuffer() {
				return n0(this, (r) => new Uint8Array(r).buffer, e)
			},
			text() {
				return n0(this, Gte, e)
			},
			json() {
				return n0(this, z4e, e)
			},
			formData() {
				return n0(
					this,
					(r) => {
						let n = Wte(this)
						if (n !== null)
							switch (n.essence) {
								case "multipart/form-data": {
									let i = H4e(r, n)
									if (i === "failure") throw new TypeError("Failed to parse body as FormData.")
									let s = new Hte()
									return (s[i0] = i), s
								}
								case "application/x-www-form-urlencoded": {
									let i = new URLSearchParams(r.toString()),
										s = new Hte()
									for (let [o, a] of i) s.append(o, a)
									return s
								}
							}
						throw new TypeError(
							'Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".',
						)
					},
					e,
				)
			},
			bytes() {
				return n0(this, (r) => new Uint8Array(r), e)
			},
		}
	}
	function J4e(e) {
		Object.assign(e.prototype, K4e(e))
	}
	async function n0(e, t, r) {
		if ((L4e.brandCheck(e, r), Kte(e))) throw new TypeError("Body is unusable: Body has already been read")
		Y4e(e[i0])
		let n = Q4e(),
			i = (o) => n.reject(o),
			s = (o) => {
				try {
					n.resolve(t(o))
				} catch (a) {
					i(a)
				}
			}
		return e[i0].body == null ? (s(Buffer.allocUnsafe(0)), n.promise) : (await N4e(e[i0].body, s, i), n.promise)
	}
	function Kte(e) {
		let t = e[i0].body
		return t != null && (t.stream.locked || FE.isDisturbed(t.stream))
	}
	function z4e(e) {
		return JSON.parse(Gte(e))
	}
	function Wte(e) {
		let t = e[i0].headersList,
			r = P4e(t)
		return r === "failure" ? null : r
	}
	Jte.exports = {
		extractBody: Yte,
		safelyExtractBody: G4e,
		cloneBody: $4e,
		mixinBody: J4e,
		streamRegistry: $O,
		hasFinalizationRegistry: GO,
		bodyUnusable: Kte,
	}
})
var ore = x((hIt, sre) => {
	"use strict"
	var ht = require("assert"),
		Bt = Xt(),
		{ channels: zte } = $m(),
		YO = IO(),
		{
			RequestContentLengthMismatchError: sp,
			ResponseContentLengthMismatchError: j4e,
			RequestAbortedError: rre,
			HeadersTimeoutError: Z4e,
			HeadersOverflowError: X4e,
			SocketError: NB,
			InformationalError: o0,
			BodyTimeoutError: eGe,
			HTTPParserError: tGe,
			ResponseExceededMaxSizeError: rGe,
		} = Vr(),
		{
			kUrl: nre,
			kReset: Po,
			kClient: jO,
			kParser: ri,
			kBlocking: PE,
			kRunning: Os,
			kPending: nGe,
			kSize: jte,
			kWriting: Yf,
			kQueue: nc,
			kNoRef: QE,
			kKeepAliveDefaultTimeout: iGe,
			kHostHeader: sGe,
			kPendingIdx: oGe,
			kRunningIdx: rl,
			kError: nl,
			kPipelining: FB,
			kSocket: a0,
			kKeepAliveTimeoutValue: PB,
			kMaxHeadersSize: KO,
			kKeepAliveMaxTimeout: aGe,
			kKeepAliveTimeoutThreshold: lGe,
			kHeadersTimeout: cGe,
			kBodyTimeout: uGe,
			kStrictContentLength: ZO,
			kMaxRequests: Zte,
			kCounter: dGe,
			kMaxResponseSize: fGe,
			kOnError: hGe,
			kResume: $f,
			kHTTPContext: ire,
		} = Qn(),
		nu = Kee(),
		gGe = Buffer.alloc(0),
		RB = Buffer[Symbol.species],
		kB = Bt.addListener,
		pGe = Bt.removeAllListeners,
		JO
	async function AGe() {
		let e = process.env.JEST_WORKER_ID ? DO() : void 0,
			t
		try {
			t = await WebAssembly.compile(jee())
		} catch {
			t = await WebAssembly.compile(e || DO())
		}
		return await WebAssembly.instantiate(t, {
			env: {
				wasm_on_url: (r, n, i) => 0,
				wasm_on_status: (r, n, i) => {
					ht(Oi.ptr === r)
					let s = n - su + iu.byteOffset
					return Oi.onStatus(new RB(iu.buffer, s, i)) || 0
				},
				wasm_on_message_begin: (r) => (ht(Oi.ptr === r), Oi.onMessageBegin() || 0),
				wasm_on_header_field: (r, n, i) => {
					ht(Oi.ptr === r)
					let s = n - su + iu.byteOffset
					return Oi.onHeaderField(new RB(iu.buffer, s, i)) || 0
				},
				wasm_on_header_value: (r, n, i) => {
					ht(Oi.ptr === r)
					let s = n - su + iu.byteOffset
					return Oi.onHeaderValue(new RB(iu.buffer, s, i)) || 0
				},
				wasm_on_headers_complete: (r, n, i, s) => (ht(Oi.ptr === r), Oi.onHeadersComplete(n, !!i, !!s) || 0),
				wasm_on_body: (r, n, i) => {
					ht(Oi.ptr === r)
					let s = n - su + iu.byteOffset
					return Oi.onBody(new RB(iu.buffer, s, i)) || 0
				},
				wasm_on_message_complete: (r) => (ht(Oi.ptr === r), Oi.onMessageComplete() || 0),
			},
		})
	}
	var zO = null,
		XO = AGe()
	XO.catch()
	var Oi = null,
		iu = null,
		MB = 0,
		su = null,
		mGe = 0,
		NE = 1,
		l0 = 2 | NE,
		QB = 4 | NE,
		eq = 8 | mGe,
		tq = class {
			constructor(t, r, { exports: n }) {
				ht(Number.isFinite(t[KO]) && t[KO] > 0),
					(this.llhttp = n),
					(this.ptr = this.llhttp.llhttp_alloc(nu.TYPE.RESPONSE)),
					(this.client = t),
					(this.socket = r),
					(this.timeout = null),
					(this.timeoutValue = null),
					(this.timeoutType = null),
					(this.statusCode = null),
					(this.statusText = ""),
					(this.upgrade = !1),
					(this.headers = []),
					(this.headersSize = 0),
					(this.headersMaxSize = t[KO]),
					(this.shouldKeepAlive = !1),
					(this.paused = !1),
					(this.resume = this.resume.bind(this)),
					(this.bytesRead = 0),
					(this.keepAlive = ""),
					(this.contentLength = ""),
					(this.connection = ""),
					(this.maxResponseSize = t[fGe])
			}
			setTimeout(t, r) {
				t !== this.timeoutValue || (r & NE) ^ (this.timeoutType & NE)
					? (this.timeout && (YO.clearTimeout(this.timeout), (this.timeout = null)),
						t &&
							(r & NE
								? (this.timeout = YO.setFastTimeout(Xte, t, new WeakRef(this)))
								: ((this.timeout = setTimeout(Xte, t, new WeakRef(this))), this.timeout.unref())),
						(this.timeoutValue = t))
					: this.timeout && this.timeout.refresh && this.timeout.refresh(),
					(this.timeoutType = r)
			}
			resume() {
				this.socket.destroyed ||
					!this.paused ||
					(ht(this.ptr != null),
					ht(Oi == null),
					this.llhttp.llhttp_resume(this.ptr),
					ht(this.timeoutType === QB),
					this.timeout && this.timeout.refresh && this.timeout.refresh(),
					(this.paused = !1),
					this.execute(this.socket.read() || gGe),
					this.readMore())
			}
			readMore() {
				for (; !this.paused && this.ptr; ) {
					let t = this.socket.read()
					if (t === null) break
					this.execute(t)
				}
			}
			execute(t) {
				ht(this.ptr != null), ht(Oi == null), ht(!this.paused)
				let { socket: r, llhttp: n } = this
				t.length > MB && (su && n.free(su), (MB = Math.ceil(t.length / 4096) * 4096), (su = n.malloc(MB))),
					new Uint8Array(n.memory.buffer, su, MB).set(t)
				try {
					let i
					try {
						;(iu = t), (Oi = this), (i = n.llhttp_execute(this.ptr, su, t.length))
					} catch (o) {
						throw o
					} finally {
						;(Oi = null), (iu = null)
					}
					let s = n.llhttp_get_error_pos(this.ptr) - su
					if (i === nu.ERROR.PAUSED_UPGRADE) this.onUpgrade(t.slice(s))
					else if (i === nu.ERROR.PAUSED) (this.paused = !0), r.unshift(t.slice(s))
					else if (i !== nu.ERROR.OK) {
						let o = n.llhttp_get_error_reason(this.ptr),
							a = ""
						if (o) {
							let l = new Uint8Array(n.memory.buffer, o).indexOf(0)
							a =
								"Response does not match the HTTP/1.1 protocol (" +
								Buffer.from(n.memory.buffer, o, l).toString() +
								")"
						}
						throw new tGe(a, nu.ERROR[i], t.slice(s))
					}
				} catch (i) {
					Bt.destroy(r, i)
				}
			}
			destroy() {
				ht(this.ptr != null),
					ht(Oi == null),
					this.llhttp.llhttp_free(this.ptr),
					(this.ptr = null),
					this.timeout && YO.clearTimeout(this.timeout),
					(this.timeout = null),
					(this.timeoutValue = null),
					(this.timeoutType = null),
					(this.paused = !1)
			}
			onStatus(t) {
				this.statusText = t.toString()
			}
			onMessageBegin() {
				let { socket: t, client: r } = this
				if (t.destroyed) return -1
				let n = r[nc][r[rl]]
				if (!n) return -1
				n.onResponseStarted()
			}
			onHeaderField(t) {
				let r = this.headers.length
				r & 1 ? (this.headers[r - 1] = Buffer.concat([this.headers[r - 1], t])) : this.headers.push(t),
					this.trackHeader(t.length)
			}
			onHeaderValue(t) {
				let r = this.headers.length
				;(r & 1) === 1
					? (this.headers.push(t), (r += 1))
					: (this.headers[r - 1] = Buffer.concat([this.headers[r - 1], t]))
				let n = this.headers[r - 2]
				if (n.length === 10) {
					let i = Bt.bufferToLowerCasedHeaderName(n)
					i === "keep-alive"
						? (this.keepAlive += t.toString())
						: i === "connection" && (this.connection += t.toString())
				} else
					n.length === 14 &&
						Bt.bufferToLowerCasedHeaderName(n) === "content-length" &&
						(this.contentLength += t.toString())
				this.trackHeader(t.length)
			}
			trackHeader(t) {
				;(this.headersSize += t), this.headersSize >= this.headersMaxSize && Bt.destroy(this.socket, new X4e())
			}
			onUpgrade(t) {
				let { upgrade: r, client: n, socket: i, headers: s, statusCode: o } = this
				ht(r), ht(n[a0] === i), ht(!i.destroyed), ht(!this.paused), ht((s.length & 1) === 0)
				let a = n[nc][n[rl]]
				ht(a),
					ht(a.upgrade || a.method === "CONNECT"),
					(this.statusCode = null),
					(this.statusText = ""),
					(this.shouldKeepAlive = null),
					(this.headers = []),
					(this.headersSize = 0),
					i.unshift(t),
					i[ri].destroy(),
					(i[ri] = null),
					(i[jO] = null),
					(i[nl] = null),
					pGe(i),
					(n[a0] = null),
					(n[ire] = null),
					(n[nc][n[rl]++] = null),
					n.emit("disconnect", n[nre], [n], new o0("upgrade"))
				try {
					a.onUpgrade(o, s, i)
				} catch (l) {
					Bt.destroy(i, l)
				}
				n[$f]()
			}
			onHeadersComplete(t, r, n) {
				let { client: i, socket: s, headers: o, statusText: a } = this
				if (s.destroyed) return -1
				let l = i[nc][i[rl]]
				if (!l) return -1
				if ((ht(!this.upgrade), ht(this.statusCode < 200), t === 100))
					return Bt.destroy(s, new NB("bad response", Bt.getSocketInfo(s))), -1
				if (r && !l.upgrade) return Bt.destroy(s, new NB("bad upgrade", Bt.getSocketInfo(s))), -1
				if (
					(ht(this.timeoutType === l0),
					(this.statusCode = t),
					(this.shouldKeepAlive =
						n || (l.method === "HEAD" && !s[Po] && this.connection.toLowerCase() === "keep-alive")),
					this.statusCode >= 200)
				) {
					let u = l.bodyTimeout != null ? l.bodyTimeout : i[uGe]
					this.setTimeout(u, QB)
				} else this.timeout && this.timeout.refresh && this.timeout.refresh()
				if (l.method === "CONNECT") return ht(i[Os] === 1), (this.upgrade = !0), 2
				if (r) return ht(i[Os] === 1), (this.upgrade = !0), 2
				if (
					(ht((this.headers.length & 1) === 0),
					(this.headers = []),
					(this.headersSize = 0),
					this.shouldKeepAlive && i[FB])
				) {
					let u = this.keepAlive ? Bt.parseKeepAliveTimeout(this.keepAlive) : null
					if (u != null) {
						let f = Math.min(u - i[lGe], i[aGe])
						f <= 0 ? (s[Po] = !0) : (i[PB] = f)
					} else i[PB] = i[iGe]
				} else s[Po] = !0
				let c = l.onHeaders(t, o, this.resume, a) === !1
				return l.aborted
					? -1
					: l.method === "HEAD" || t < 200
						? 1
						: (s[PE] && ((s[PE] = !1), i[$f]()), c ? nu.ERROR.PAUSED : 0)
			}
			onBody(t) {
				let { client: r, socket: n, statusCode: i, maxResponseSize: s } = this
				if (n.destroyed) return -1
				let o = r[nc][r[rl]]
				if (
					(ht(o),
					ht(this.timeoutType === QB),
					this.timeout && this.timeout.refresh && this.timeout.refresh(),
					ht(i >= 200),
					s > -1 && this.bytesRead + t.length > s)
				)
					return Bt.destroy(n, new rGe()), -1
				if (((this.bytesRead += t.length), o.onData(t) === !1)) return nu.ERROR.PAUSED
			}
			onMessageComplete() {
				let {
					client: t,
					socket: r,
					statusCode: n,
					upgrade: i,
					headers: s,
					contentLength: o,
					bytesRead: a,
					shouldKeepAlive: l,
				} = this
				if (r.destroyed && (!n || l)) return -1
				if (i) return
				ht(n >= 100), ht((this.headers.length & 1) === 0)
				let c = t[nc][t[rl]]
				if (
					(ht(c),
					(this.statusCode = null),
					(this.statusText = ""),
					(this.bytesRead = 0),
					(this.contentLength = ""),
					(this.keepAlive = ""),
					(this.connection = ""),
					(this.headers = []),
					(this.headersSize = 0),
					!(n < 200))
				) {
					if (c.method !== "HEAD" && o && a !== parseInt(o, 10)) return Bt.destroy(r, new j4e()), -1
					if ((c.onComplete(s), (t[nc][t[rl]++] = null), r[Yf]))
						return ht(t[Os] === 0), Bt.destroy(r, new o0("reset")), nu.ERROR.PAUSED
					if (l) {
						if (r[Po] && t[Os] === 0) return Bt.destroy(r, new o0("reset")), nu.ERROR.PAUSED
						t[FB] == null || t[FB] === 1 ? setImmediate(() => t[$f]()) : t[$f]()
					} else return Bt.destroy(r, new o0("reset")), nu.ERROR.PAUSED
				}
			}
		}
	function Xte(e) {
		let { socket: t, timeoutType: r, client: n, paused: i } = e.deref()
		r === l0
			? (!t[Yf] || t.writableNeedDrain || n[Os] > 1) &&
				(ht(!i, "cannot be paused while waiting for headers"), Bt.destroy(t, new Z4e()))
			: r === QB
				? i || Bt.destroy(t, new eGe())
				: r === eq && (ht(n[Os] === 0 && n[PB]), Bt.destroy(t, new o0("socket idle timeout")))
	}
	async function yGe(e, t) {
		;(e[a0] = t),
			zO || ((zO = await XO), (XO = null)),
			(t[QE] = !1),
			(t[Yf] = !1),
			(t[Po] = !1),
			(t[PE] = !1),
			(t[ri] = new tq(e, t, zO)),
			kB(t, "error", function (n) {
				ht(n.code !== "ERR_TLS_CERT_ALTNAME_INVALID")
				let i = this[ri]
				if (n.code === "ECONNRESET" && i.statusCode && !i.shouldKeepAlive) {
					i.onMessageComplete()
					return
				}
				;(this[nl] = n), this[jO][hGe](n)
			}),
			kB(t, "readable", function () {
				let n = this[ri]
				n && n.readMore()
			}),
			kB(t, "end", function () {
				let n = this[ri]
				if (n.statusCode && !n.shouldKeepAlive) {
					n.onMessageComplete()
					return
				}
				Bt.destroy(this, new NB("other side closed", Bt.getSocketInfo(this)))
			}),
			kB(t, "close", function () {
				let n = this[jO],
					i = this[ri]
				i &&
					(!this[nl] && i.statusCode && !i.shouldKeepAlive && i.onMessageComplete(),
					this[ri].destroy(),
					(this[ri] = null))
				let s = this[nl] || new NB("closed", Bt.getSocketInfo(this))
				if (((n[a0] = null), (n[ire] = null), n.destroyed)) {
					ht(n[nGe] === 0)
					let o = n[nc].splice(n[rl])
					for (let a = 0; a < o.length; a++) {
						let l = o[a]
						Bt.errorRequest(n, l, s)
					}
				} else if (n[Os] > 0 && s.code !== "UND_ERR_INFO") {
					let o = n[nc][n[rl]]
					;(n[nc][n[rl]++] = null), Bt.errorRequest(n, o, s)
				}
				;(n[oGe] = n[rl]), ht(n[Os] === 0), n.emit("disconnect", n[nre], [n], s), n[$f]()
			})
		let r = !1
		return (
			t.on("close", () => {
				r = !0
			}),
			{
				version: "h1",
				defaultPipelining: 1,
				write(...n) {
					return EGe(e, ...n)
				},
				resume() {
					CGe(e)
				},
				destroy(n, i) {
					r ? queueMicrotask(i) : t.destroy(n).on("close", i)
				},
				get destroyed() {
					return t.destroyed
				},
				busy(n) {
					return !!(
						t[Yf] ||
						t[Po] ||
						t[PE] ||
						(n &&
							((e[Os] > 0 && !n.idempotent) ||
								(e[Os] > 0 && (n.upgrade || n.method === "CONNECT")) ||
								(e[Os] > 0 &&
									Bt.bodyLength(n.body) !== 0 &&
									(Bt.isStream(n.body) || Bt.isAsyncIterable(n.body) || Bt.isFormDataLike(n.body)))))
					)
				},
			}
		)
	}
	function CGe(e) {
		let t = e[a0]
		if (t && !t.destroyed) {
			if (
				(e[jte] === 0
					? !t[QE] && t.unref && (t.unref(), (t[QE] = !0))
					: t[QE] && t.ref && (t.ref(), (t[QE] = !1)),
				e[jte] === 0)
			)
				t[ri].timeoutType !== eq && t[ri].setTimeout(e[PB], eq)
			else if (e[Os] > 0 && t[ri].statusCode < 200 && t[ri].timeoutType !== l0) {
				let r = e[nc][e[rl]],
					n = r.headersTimeout != null ? r.headersTimeout : e[cGe]
				t[ri].setTimeout(n, l0)
			}
		}
	}
	function vGe(e) {
		return e !== "GET" && e !== "HEAD" && e !== "OPTIONS" && e !== "TRACE" && e !== "CONNECT"
	}
	function EGe(e, t) {
		let { method: r, path: n, host: i, upgrade: s, blocking: o, reset: a } = t,
			{ body: l, headers: c, contentLength: u } = t,
			f = r === "PUT" || r === "POST" || r === "PATCH" || r === "QUERY" || r === "PROPFIND" || r === "PROPPATCH"
		if (Bt.isFormDataLike(l)) {
			JO || (JO = s0().extractBody)
			let [C, v] = JO(l)
			t.contentType == null && c.push("content-type", v), (l = C.stream), (u = C.length)
		} else Bt.isBlobLike(l) && t.contentType == null && l.type && c.push("content-type", l.type)
		l && typeof l.read == "function" && l.read(0)
		let p = Bt.bodyLength(l)
		if (
			((u = p ?? u),
			u === null && (u = t.contentLength),
			u === 0 && !f && (u = null),
			vGe(r) && u > 0 && t.contentLength !== null && t.contentLength !== u)
		) {
			if (e[ZO]) return Bt.errorRequest(e, t, new sp()), !1
			process.emitWarning(new sp())
		}
		let g = e[a0],
			m = (C) => {
				t.aborted ||
					t.completed ||
					(Bt.errorRequest(e, t, C || new rre()), Bt.destroy(l), Bt.destroy(g, new o0("aborted")))
			}
		try {
			t.onConnect(m)
		} catch (C) {
			Bt.errorRequest(e, t, C)
		}
		if (t.aborted) return !1
		r === "HEAD" && (g[Po] = !0),
			(s || r === "CONNECT") && (g[Po] = !0),
			a != null && (g[Po] = a),
			e[Zte] && g[dGe]++ >= e[Zte] && (g[Po] = !0),
			o && (g[PE] = !0)
		let y = `${r} ${n} HTTP/1.1\r
`
		if (
			(typeof i == "string"
				? (y += `host: ${i}\r
`)
				: (y += e[sGe]),
			s
				? (y += `connection: upgrade\r
upgrade: ${s}\r
`)
				: e[FB] && !g[Po]
					? (y += `connection: keep-alive\r
`)
					: (y += `connection: close\r
`),
			Array.isArray(c))
		)
			for (let C = 0; C < c.length; C += 2) {
				let v = c[C + 0],
					b = c[C + 1]
				if (Array.isArray(b))
					for (let w = 0; w < b.length; w++)
						y += `${v}: ${b[w]}\r
`
				else
					y += `${v}: ${b}\r
`
			}
		return (
			zte.sendHeaders.hasSubscribers && zte.sendHeaders.publish({ request: t, headers: y, socket: g }),
			!l || p === 0
				? ere(m, null, e, t, g, u, y, f)
				: Bt.isBuffer(l)
					? ere(m, l, e, t, g, u, y, f)
					: Bt.isBlobLike(l)
						? typeof l.stream == "function"
							? tre(m, l.stream(), e, t, g, u, y, f)
							: xGe(m, l, e, t, g, u, y, f)
						: Bt.isStream(l)
							? bGe(m, l, e, t, g, u, y, f)
							: Bt.isIterable(l)
								? tre(m, l, e, t, g, u, y, f)
								: ht(!1),
			!0
		)
	}
	function bGe(e, t, r, n, i, s, o, a) {
		ht(s !== 0 || r[Os] === 0, "stream body cannot be pipelined")
		let l = !1,
			c = new LB({
				abort: e,
				socket: i,
				request: n,
				contentLength: s,
				client: r,
				expectsPayload: a,
				header: o,
			}),
			u = function (m) {
				if (!l)
					try {
						!c.write(m) && this.pause && this.pause()
					} catch (y) {
						Bt.destroy(this, y)
					}
			},
			f = function () {
				l || (t.resume && t.resume())
			},
			p = function () {
				if (
					(queueMicrotask(() => {
						t.removeListener("error", g)
					}),
					!l)
				) {
					let m = new rre()
					queueMicrotask(() => g(m))
				}
			},
			g = function (m) {
				if (!l) {
					if (
						((l = !0),
						ht(i.destroyed || (i[Yf] && r[Os] <= 1)),
						i.off("drain", f).off("error", g),
						t.removeListener("data", u).removeListener("end", g).removeListener("close", p),
						!m)
					)
						try {
							c.end()
						} catch (y) {
							m = y
						}
					c.destroy(m),
						m && (m.code !== "UND_ERR_INFO" || m.message !== "reset") ? Bt.destroy(t, m) : Bt.destroy(t)
				}
			}
		t.on("data", u).on("end", g).on("error", g).on("close", p),
			t.resume && t.resume(),
			i.on("drain", f).on("error", g),
			(t.errorEmitted ?? t.errored)
				? setImmediate(() => g(t.errored))
				: (t.endEmitted ?? t.readableEnded) && setImmediate(() => g(null)),
			(t.closeEmitted ?? t.closed) && setImmediate(p)
	}
	function ere(e, t, r, n, i, s, o, a) {
		try {
			t
				? Bt.isBuffer(t) &&
					(ht(s === t.byteLength, "buffer body must have content length"),
					i.cork(),
					i.write(
						`${o}content-length: ${s}\r
\r
`,
						"latin1",
					),
					i.write(t),
					i.uncork(),
					n.onBodySent(t),
					!a && n.reset !== !1 && (i[Po] = !0))
				: s === 0
					? i.write(
							`${o}content-length: 0\r
\r
`,
							"latin1",
						)
					: (ht(s === null, "no body must not have content length"),
						i.write(
							`${o}\r
`,
							"latin1",
						)),
				n.onRequestSent(),
				r[$f]()
		} catch (l) {
			e(l)
		}
	}
	async function xGe(e, t, r, n, i, s, o, a) {
		ht(s === t.size, "blob body must have content length")
		try {
			if (s != null && s !== t.size) throw new sp()
			let l = Buffer.from(await t.arrayBuffer())
			i.cork(),
				i.write(
					`${o}content-length: ${s}\r
\r
`,
					"latin1",
				),
				i.write(l),
				i.uncork(),
				n.onBodySent(l),
				n.onRequestSent(),
				!a && n.reset !== !1 && (i[Po] = !0),
				r[$f]()
		} catch (l) {
			e(l)
		}
	}
	async function tre(e, t, r, n, i, s, o, a) {
		ht(s !== 0 || r[Os] === 0, "iterator body cannot be pipelined")
		let l = null
		function c() {
			if (l) {
				let p = l
				;(l = null), p()
			}
		}
		let u = () =>
			new Promise((p, g) => {
				ht(l === null), i[nl] ? g(i[nl]) : (l = p)
			})
		i.on("close", c).on("drain", c)
		let f = new LB({
			abort: e,
			socket: i,
			request: n,
			contentLength: s,
			client: r,
			expectsPayload: a,
			header: o,
		})
		try {
			for await (let p of t) {
				if (i[nl]) throw i[nl]
				f.write(p) || (await u())
			}
			f.end()
		} catch (p) {
			f.destroy(p)
		} finally {
			i.off("close", c).off("drain", c)
		}
	}
	var LB = class {
		constructor({ abort: t, socket: r, request: n, contentLength: i, client: s, expectsPayload: o, header: a }) {
			;(this.socket = r),
				(this.request = n),
				(this.contentLength = i),
				(this.client = s),
				(this.bytesWritten = 0),
				(this.expectsPayload = o),
				(this.header = a),
				(this.abort = t),
				(r[Yf] = !0)
		}
		write(t) {
			let {
				socket: r,
				request: n,
				contentLength: i,
				client: s,
				bytesWritten: o,
				expectsPayload: a,
				header: l,
			} = this
			if (r[nl]) throw r[nl]
			if (r.destroyed) return !1
			let c = Buffer.byteLength(t)
			if (!c) return !0
			if (i !== null && o + c > i) {
				if (s[ZO]) throw new sp()
				process.emitWarning(new sp())
			}
			r.cork(),
				o === 0 &&
					(!a && n.reset !== !1 && (r[Po] = !0),
					i === null
						? r.write(
								`${l}transfer-encoding: chunked\r
`,
								"latin1",
							)
						: r.write(
								`${l}content-length: ${i}\r
\r
`,
								"latin1",
							)),
				i === null &&
					r.write(
						`\r
${c.toString(16)}\r
`,
						"latin1",
					),
				(this.bytesWritten += c)
			let u = r.write(t)
			return (
				r.uncork(),
				n.onBodySent(t),
				u || (r[ri].timeout && r[ri].timeoutType === l0 && r[ri].timeout.refresh && r[ri].timeout.refresh()),
				u
			)
		}
		end() {
			let {
				socket: t,
				contentLength: r,
				client: n,
				bytesWritten: i,
				expectsPayload: s,
				header: o,
				request: a,
			} = this
			if ((a.onRequestSent(), (t[Yf] = !1), t[nl])) throw t[nl]
			if (!t.destroyed) {
				if (
					(i === 0
						? s
							? t.write(
									`${o}content-length: 0\r
\r
`,
									"latin1",
								)
							: t.write(
									`${o}\r
`,
									"latin1",
								)
						: r === null &&
							t.write(
								`\r
0\r
\r
`,
								"latin1",
							),
					r !== null && i !== r)
				) {
					if (n[ZO]) throw new sp()
					process.emitWarning(new sp())
				}
				t[ri].timeout && t[ri].timeoutType === l0 && t[ri].timeout.refresh && t[ri].timeout.refresh(), n[$f]()
			}
		}
		destroy(t) {
			let { socket: r, client: n, abort: i } = this
			;(r[Yf] = !1), t && (ht(n[Os] <= 1, "pipeline should only contain this request"), i(t))
		}
	}
	sre.exports = yGe
})
var gre = x((gIt, hre) => {
	"use strict"
	var il = require("assert"),
		{ pipeline: _Ge } = require("stream"),
		dr = Xt(),
		{
			RequestContentLengthMismatchError: rq,
			RequestAbortedError: are,
			SocketError: LE,
			InformationalError: nq,
		} = Vr(),
		{
			kUrl: UB,
			kReset: qB,
			kClient: c0,
			kRunning: VB,
			kPending: wGe,
			kQueue: Kf,
			kPendingIdx: iq,
			kRunningIdx: ic,
			kError: oc,
			kSocket: zi,
			kStrictContentLength: IGe,
			kOnError: sq,
			kMaxConcurrentStreams: fre,
			kHTTP2Session: sc,
			kResume: Jf,
			kSize: SGe,
			kHTTPContext: BGe,
		} = Qn(),
		Dd = Symbol("open streams"),
		lre,
		cre = !1,
		OB
	try {
		OB = require("http2")
	} catch {
		OB = { constants: {} }
	}
	var {
		constants: {
			HTTP2_HEADER_AUTHORITY: DGe,
			HTTP2_HEADER_METHOD: TGe,
			HTTP2_HEADER_PATH: RGe,
			HTTP2_HEADER_SCHEME: kGe,
			HTTP2_HEADER_CONTENT_LENGTH: MGe,
			HTTP2_HEADER_EXPECT: FGe,
			HTTP2_HEADER_STATUS: QGe,
		},
	} = OB
	function NGe(e) {
		let t = []
		for (let [r, n] of Object.entries(e))
			if (Array.isArray(n)) for (let i of n) t.push(Buffer.from(r), Buffer.from(i))
			else t.push(Buffer.from(r), Buffer.from(n))
		return t
	}
	async function PGe(e, t) {
		;(e[zi] = t),
			cre ||
				((cre = !0),
				process.emitWarning("H2 support is experimental, expect them to change at any time.", {
					code: "UNDICI-H2",
				}))
		let r = OB.connect(e[UB], {
			createConnection: () => t,
			peerMaxConcurrentStreams: e[fre],
		})
		;(r[Dd] = 0),
			(r[c0] = e),
			(r[zi] = t),
			dr.addListener(r, "error", UGe),
			dr.addListener(r, "frameError", OGe),
			dr.addListener(r, "end", qGe),
			dr.addListener(r, "goaway", VGe),
			dr.addListener(r, "close", function () {
				let { [c0]: i } = this,
					{ [zi]: s } = i,
					o = this[zi][oc] || this[oc] || new LE("closed", dr.getSocketInfo(s))
				if (((i[sc] = null), i.destroyed)) {
					il(i[wGe] === 0)
					let a = i[Kf].splice(i[ic])
					for (let l = 0; l < a.length; l++) {
						let c = a[l]
						dr.errorRequest(i, c, o)
					}
				}
			}),
			r.unref(),
			(e[sc] = r),
			(t[sc] = r),
			dr.addListener(t, "error", function (i) {
				il(i.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), (this[oc] = i), this[c0][sq](i)
			}),
			dr.addListener(t, "end", function () {
				dr.destroy(this, new LE("other side closed", dr.getSocketInfo(this)))
			}),
			dr.addListener(t, "close", function () {
				let i = this[oc] || new LE("closed", dr.getSocketInfo(this))
				;(e[zi] = null),
					this[sc] != null && this[sc].destroy(i),
					(e[iq] = e[ic]),
					il(e[VB] === 0),
					e.emit("disconnect", e[UB], [e], i),
					e[Jf]()
			})
		let n = !1
		return (
			t.on("close", () => {
				n = !0
			}),
			{
				version: "h2",
				defaultPipelining: 1 / 0,
				write(...i) {
					return WGe(e, ...i)
				},
				resume() {
					LGe(e)
				},
				destroy(i, s) {
					n ? queueMicrotask(s) : t.destroy(i).on("close", s)
				},
				get destroyed() {
					return t.destroyed
				},
				busy() {
					return !1
				},
			}
		)
	}
	function LGe(e) {
		let t = e[zi]
		t?.destroyed === !1 && (e[SGe] === 0 && e[fre] === 0 ? (t.unref(), e[sc].unref()) : (t.ref(), e[sc].ref()))
	}
	function UGe(e) {
		il(e.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), (this[zi][oc] = e), this[c0][sq](e)
	}
	function OGe(e, t, r) {
		if (r === 0) {
			let n = new nq(`HTTP/2: "frameError" received - type ${e}, code ${t}`)
			;(this[zi][oc] = n), this[c0][sq](n)
		}
	}
	function qGe() {
		let e = new LE("other side closed", dr.getSocketInfo(this[zi]))
		this.destroy(e), dr.destroy(this[zi], e)
	}
	function VGe(e) {
		let t = this[oc] || new LE(`HTTP/2: "GOAWAY" frame received with code ${e}`, dr.getSocketInfo(this)),
			r = this[c0]
		if (
			((r[zi] = null),
			(r[BGe] = null),
			this[sc] != null && (this[sc].destroy(t), (this[sc] = null)),
			dr.destroy(this[zi], t),
			r[ic] < r[Kf].length)
		) {
			let n = r[Kf][r[ic]]
			;(r[Kf][r[ic]++] = null), dr.errorRequest(r, n, t), (r[iq] = r[ic])
		}
		il(r[VB] === 0), r.emit("disconnect", r[UB], [r], t), r[Jf]()
	}
	function HGe(e) {
		return e !== "GET" && e !== "HEAD" && e !== "OPTIONS" && e !== "TRACE" && e !== "CONNECT"
	}
	function WGe(e, t) {
		let r = e[sc],
			{ method: n, path: i, host: s, upgrade: o, expectContinue: a, signal: l, headers: c } = t,
			{ body: u } = t
		if (o) return dr.errorRequest(e, t, new Error("Upgrade not supported for H2")), !1
		let f = {}
		for (let B = 0; B < c.length; B += 2) {
			let M = c[B + 0],
				Q = c[B + 1]
			if (Array.isArray(Q)) for (let O = 0; O < Q.length; O++) f[M] ? (f[M] += `,${Q[O]}`) : (f[M] = Q[O])
			else f[M] = Q
		}
		let p,
			{ hostname: g, port: m } = e[UB]
		;(f[DGe] = s || `${g}${m ? `:${m}` : ""}`), (f[TGe] = n)
		let y = (B) => {
			t.aborted ||
				t.completed ||
				((B = B || new are()),
				dr.errorRequest(e, t, B),
				p != null && dr.destroy(p, B),
				dr.destroy(u, B),
				(e[Kf][e[ic]++] = null),
				e[Jf]())
		}
		try {
			t.onConnect(y)
		} catch (B) {
			dr.errorRequest(e, t, B)
		}
		if (t.aborted) return !1
		if (n === "CONNECT")
			return (
				r.ref(),
				(p = r.request(f, { endStream: !1, signal: l })),
				p.id && !p.pending
					? (t.onUpgrade(null, null, p), ++r[Dd], (e[Kf][e[ic]++] = null))
					: p.once("ready", () => {
							t.onUpgrade(null, null, p), ++r[Dd], (e[Kf][e[ic]++] = null)
						}),
				p.once("close", () => {
					;(r[Dd] -= 1), r[Dd] === 0 && r.unref()
				}),
				!0
			)
		;(f[RGe] = i), (f[kGe] = "https")
		let C = n === "PUT" || n === "POST" || n === "PATCH"
		u && typeof u.read == "function" && u.read(0)
		let v = dr.bodyLength(u)
		if (dr.isFormDataLike(u)) {
			lre ??= s0().extractBody
			let [B, M] = lre(u)
			;(f["content-type"] = M), (u = B.stream), (v = B.length)
		}
		if (
			(v == null && (v = t.contentLength),
			(v === 0 || !C) && (v = null),
			HGe(n) && v > 0 && t.contentLength != null && t.contentLength !== v)
		) {
			if (e[IGe]) return dr.errorRequest(e, t, new rq()), !1
			process.emitWarning(new rq())
		}
		v != null && (il(u, "no body must not have content length"), (f[MGe] = `${v}`)), r.ref()
		let b = n === "GET" || n === "HEAD" || u === null
		return (
			a
				? ((f[FGe] = "100-continue"), (p = r.request(f, { endStream: b, signal: l })), p.once("continue", w))
				: ((p = r.request(f, { endStream: b, signal: l })), w()),
			++r[Dd],
			p.once("response", (B) => {
				let { [QGe]: M, ...Q } = B
				if ((t.onResponseStarted(), t.aborted)) {
					let O = new are()
					dr.errorRequest(e, t, O), dr.destroy(p, O)
					return
				}
				t.onHeaders(Number(M), NGe(Q), p.resume.bind(p), "") === !1 && p.pause(),
					p.on("data", (O) => {
						t.onData(O) === !1 && p.pause()
					})
			}),
			p.once("end", () => {
				;(p.state?.state == null || p.state.state < 6) && t.onComplete([]),
					r[Dd] === 0 && r.unref(),
					y(new nq("HTTP/2: stream half-closed (remote)")),
					(e[Kf][e[ic]++] = null),
					(e[iq] = e[ic]),
					e[Jf]()
			}),
			p.once("close", () => {
				;(r[Dd] -= 1), r[Dd] === 0 && r.unref()
			}),
			p.once("error", function (B) {
				y(B)
			}),
			p.once("frameError", (B, M) => {
				y(new nq(`HTTP/2: "frameError" received - type ${B}, code ${M}`))
			}),
			!0
		)
		function w() {
			!u || v === 0
				? ure(y, p, null, e, t, e[zi], v, C)
				: dr.isBuffer(u)
					? ure(y, p, u, e, t, e[zi], v, C)
					: dr.isBlobLike(u)
						? typeof u.stream == "function"
							? dre(y, p, u.stream(), e, t, e[zi], v, C)
							: $Ge(y, p, u, e, t, e[zi], v, C)
						: dr.isStream(u)
							? GGe(y, e[zi], C, p, u, e, t, v)
							: dr.isIterable(u)
								? dre(y, p, u, e, t, e[zi], v, C)
								: il(!1)
		}
	}
	function ure(e, t, r, n, i, s, o, a) {
		try {
			r != null &&
				dr.isBuffer(r) &&
				(il(o === r.byteLength, "buffer body must have content length"),
				t.cork(),
				t.write(r),
				t.uncork(),
				t.end(),
				i.onBodySent(r)),
				a || (s[qB] = !0),
				i.onRequestSent(),
				n[Jf]()
		} catch (l) {
			e(l)
		}
	}
	function GGe(e, t, r, n, i, s, o, a) {
		il(a !== 0 || s[VB] === 0, "stream body cannot be pipelined")
		let l = _Ge(i, n, (u) => {
			u ? (dr.destroy(l, u), e(u)) : (dr.removeAllListeners(l), o.onRequestSent(), r || (t[qB] = !0), s[Jf]())
		})
		dr.addListener(l, "data", c)
		function c(u) {
			o.onBodySent(u)
		}
	}
	async function $Ge(e, t, r, n, i, s, o, a) {
		il(o === r.size, "blob body must have content length")
		try {
			if (o != null && o !== r.size) throw new rq()
			let l = Buffer.from(await r.arrayBuffer())
			t.cork(), t.write(l), t.uncork(), t.end(), i.onBodySent(l), i.onRequestSent(), a || (s[qB] = !0), n[Jf]()
		} catch (l) {
			e(l)
		}
	}
	async function dre(e, t, r, n, i, s, o, a) {
		il(o !== 0 || n[VB] === 0, "iterator body cannot be pipelined")
		let l = null
		function c() {
			if (l) {
				let f = l
				;(l = null), f()
			}
		}
		let u = () =>
			new Promise((f, p) => {
				il(l === null), s[oc] ? p(s[oc]) : (l = f)
			})
		t.on("close", c).on("drain", c)
		try {
			for await (let f of r) {
				if (s[oc]) throw s[oc]
				let p = t.write(f)
				i.onBodySent(f), p || (await u())
			}
			t.end(), i.onRequestSent(), a || (s[qB] = !0), n[Jf]()
		} catch (f) {
			e(f)
		} finally {
			t.off("close", c).off("drain", c)
		}
	}
	hre.exports = PGe
})
var WB = x((pIt, mre) => {
	"use strict"
	var ou = Xt(),
		{ kBodyUsed: UE } = Qn(),
		aq = require("assert"),
		{ InvalidArgumentError: YGe } = Vr(),
		KGe = require("events"),
		JGe = [300, 301, 302, 303, 307, 308],
		pre = Symbol("body"),
		HB = class {
			constructor(t) {
				;(this[pre] = t), (this[UE] = !1)
			}
			async *[Symbol.asyncIterator]() {
				aq(!this[UE], "disturbed"), (this[UE] = !0), yield* this[pre]
			}
		},
		oq = class {
			constructor(t, r, n, i) {
				if (r != null && (!Number.isInteger(r) || r < 0))
					throw new YGe("maxRedirections must be a positive number")
				ou.validateHandler(i, n.method, n.upgrade),
					(this.dispatch = t),
					(this.location = null),
					(this.abort = null),
					(this.opts = { ...n, maxRedirections: 0 }),
					(this.maxRedirections = r),
					(this.handler = i),
					(this.history = []),
					(this.redirectionLimitReached = !1),
					ou.isStream(this.opts.body)
						? (ou.bodyLength(this.opts.body) === 0 &&
								this.opts.body.on("data", function () {
									aq(!1)
								}),
							typeof this.opts.body.readableDidRead != "boolean" &&
								((this.opts.body[UE] = !1),
								KGe.prototype.on.call(this.opts.body, "data", function () {
									this[UE] = !0
								})))
						: this.opts.body && typeof this.opts.body.pipeTo == "function"
							? (this.opts.body = new HB(this.opts.body))
							: this.opts.body &&
								typeof this.opts.body != "string" &&
								!ArrayBuffer.isView(this.opts.body) &&
								ou.isIterable(this.opts.body) &&
								(this.opts.body = new HB(this.opts.body))
			}
			onConnect(t) {
				;(this.abort = t), this.handler.onConnect(t, { history: this.history })
			}
			onUpgrade(t, r, n) {
				this.handler.onUpgrade(t, r, n)
			}
			onError(t) {
				this.handler.onError(t)
			}
			onHeaders(t, r, n, i) {
				if (
					((this.location =
						this.history.length >= this.maxRedirections || ou.isDisturbed(this.opts.body)
							? null
							: zGe(t, r)),
					this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections)
				) {
					this.request && this.request.abort(new Error("max redirects")),
						(this.redirectionLimitReached = !0),
						this.abort(new Error("max redirects"))
					return
				}
				if ((this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location))
					return this.handler.onHeaders(t, r, n, i)
				let {
						origin: s,
						pathname: o,
						search: a,
					} = ou.parseURL(
						new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)),
					),
					l = a ? `${o}${a}` : o
				;(this.opts.headers = jGe(this.opts.headers, t === 303, this.opts.origin !== s)),
					(this.opts.path = l),
					(this.opts.origin = s),
					(this.opts.maxRedirections = 0),
					(this.opts.query = null),
					t === 303 && this.opts.method !== "HEAD" && ((this.opts.method = "GET"), (this.opts.body = null))
			}
			onData(t) {
				if (!this.location) return this.handler.onData(t)
			}
			onComplete(t) {
				this.location
					? ((this.location = null), (this.abort = null), this.dispatch(this.opts, this))
					: this.handler.onComplete(t)
			}
			onBodySent(t) {
				this.handler.onBodySent && this.handler.onBodySent(t)
			}
		}
	function zGe(e, t) {
		if (JGe.indexOf(e) === -1) return null
		for (let r = 0; r < t.length; r += 2)
			if (t[r].length === 8 && ou.headerNameToString(t[r]) === "location") return t[r + 1]
	}
	function Are(e, t, r) {
		if (e.length === 4) return ou.headerNameToString(e) === "host"
		if (t && ou.headerNameToString(e).startsWith("content-")) return !0
		if (r && (e.length === 13 || e.length === 6 || e.length === 19)) {
			let n = ou.headerNameToString(e)
			return n === "authorization" || n === "cookie" || n === "proxy-authorization"
		}
		return !1
	}
	function jGe(e, t, r) {
		let n = []
		if (Array.isArray(e)) for (let i = 0; i < e.length; i += 2) Are(e[i], t, r) || n.push(e[i], e[i + 1])
		else if (e && typeof e == "object") for (let i of Object.keys(e)) Are(i, t, r) || n.push(i, e[i])
		else aq(e == null, "headers must be an object or an array")
		return n
	}
	mre.exports = oq
})
var GB = x((AIt, yre) => {
	"use strict"
	var ZGe = WB()
	function XGe({ maxRedirections: e }) {
		return (t) =>
			function (n, i) {
				let { maxRedirections: s = e } = n
				if (!s) return t(n, i)
				let o = new ZGe(t, s, n, i)
				return (n = { ...n, maxRedirections: 0 }), t(n, o)
			}
	}
	yre.exports = XGe
})
var $E = x((mIt, Bre) => {
	"use strict"
	var Td = require("assert"),
		_re = require("net"),
		e8e = require("http"),
		op = Xt(),
		{ channels: u0 } = $m(),
		t8e = Qee(),
		r8e = zm(),
		{ InvalidArgumentError: pi, InformationalError: n8e, ClientDestroyedError: i8e } = Vr(),
		s8e = IE(),
		{
			kUrl: au,
			kServerName: zf,
			kClient: o8e,
			kBusy: lq,
			kConnect: a8e,
			kResuming: ap,
			kRunning: WE,
			kPending: GE,
			kSize: HE,
			kQueue: ac,
			kConnected: l8e,
			kConnecting: d0,
			kNeedDrain: Zf,
			kKeepAliveDefaultTimeout: Cre,
			kHostHeader: c8e,
			kPendingIdx: lc,
			kRunningIdx: Rd,
			kError: u8e,
			kPipelining: $B,
			kKeepAliveTimeoutValue: d8e,
			kMaxHeadersSize: f8e,
			kKeepAliveMaxTimeout: h8e,
			kKeepAliveTimeoutThreshold: g8e,
			kHeadersTimeout: p8e,
			kBodyTimeout: A8e,
			kStrictContentLength: m8e,
			kConnector: OE,
			kMaxRedirections: y8e,
			kMaxRequests: cq,
			kCounter: C8e,
			kClose: v8e,
			kDestroy: E8e,
			kDispatch: b8e,
			kInterceptors: vre,
			kLocalAddress: qE,
			kMaxResponseSize: x8e,
			kOnError: _8e,
			kHTTPContext: Ai,
			kMaxConcurrentStreams: w8e,
			kResume: VE,
		} = Qn(),
		I8e = ore(),
		S8e = gre(),
		Ere = !1,
		jf = Symbol("kClosedResolve"),
		bre = () => {}
	function wre(e) {
		return e[$B] ?? e[Ai]?.defaultPipelining ?? 1
	}
	var uq = class extends r8e {
			constructor(
				t,
				{
					interceptors: r,
					maxHeaderSize: n,
					headersTimeout: i,
					socketTimeout: s,
					requestTimeout: o,
					connectTimeout: a,
					bodyTimeout: l,
					idleTimeout: c,
					keepAlive: u,
					keepAliveTimeout: f,
					maxKeepAliveTimeout: p,
					keepAliveMaxTimeout: g,
					keepAliveTimeoutThreshold: m,
					socketPath: y,
					pipelining: C,
					tls: v,
					strictContentLength: b,
					maxCachedSessions: w,
					maxRedirections: B,
					connect: M,
					maxRequestsPerClient: Q,
					localAddress: O,
					maxResponseSize: Y,
					autoSelectFamily: j,
					autoSelectFamilyAttemptTimeout: ne,
					maxConcurrentStreams: q,
					allowH2: me,
				} = {},
			) {
				if ((super(), u !== void 0)) throw new pi("unsupported keepAlive, use pipelining=0 instead")
				if (s !== void 0) throw new pi("unsupported socketTimeout, use headersTimeout & bodyTimeout instead")
				if (o !== void 0) throw new pi("unsupported requestTimeout, use headersTimeout & bodyTimeout instead")
				if (c !== void 0) throw new pi("unsupported idleTimeout, use keepAliveTimeout instead")
				if (p !== void 0) throw new pi("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead")
				if (n != null && !Number.isFinite(n)) throw new pi("invalid maxHeaderSize")
				if (y != null && typeof y != "string") throw new pi("invalid socketPath")
				if (a != null && (!Number.isFinite(a) || a < 0)) throw new pi("invalid connectTimeout")
				if (f != null && (!Number.isFinite(f) || f <= 0)) throw new pi("invalid keepAliveTimeout")
				if (g != null && (!Number.isFinite(g) || g <= 0)) throw new pi("invalid keepAliveMaxTimeout")
				if (m != null && !Number.isFinite(m)) throw new pi("invalid keepAliveTimeoutThreshold")
				if (i != null && (!Number.isInteger(i) || i < 0))
					throw new pi("headersTimeout must be a positive integer or zero")
				if (l != null && (!Number.isInteger(l) || l < 0))
					throw new pi("bodyTimeout must be a positive integer or zero")
				if (M != null && typeof M != "function" && typeof M != "object")
					throw new pi("connect must be a function or an object")
				if (B != null && (!Number.isInteger(B) || B < 0))
					throw new pi("maxRedirections must be a positive number")
				if (Q != null && (!Number.isInteger(Q) || Q < 0))
					throw new pi("maxRequestsPerClient must be a positive number")
				if (O != null && (typeof O != "string" || _re.isIP(O) === 0))
					throw new pi("localAddress must be valid string IP address")
				if (Y != null && (!Number.isInteger(Y) || Y < -1))
					throw new pi("maxResponseSize must be a positive number")
				if (ne != null && (!Number.isInteger(ne) || ne < -1))
					throw new pi("autoSelectFamilyAttemptTimeout must be a positive number")
				if (me != null && typeof me != "boolean") throw new pi("allowH2 must be a valid boolean value")
				if (q != null && (typeof q != "number" || q < 1))
					throw new pi("maxConcurrentStreams must be a positive integer, greater than 0")
				typeof M != "function" &&
					(M = s8e({
						...v,
						maxCachedSessions: w,
						allowH2: me,
						socketPath: y,
						timeout: a,
						...(j ? { autoSelectFamily: j, autoSelectFamilyAttemptTimeout: ne } : void 0),
						...M,
					})),
					r?.Client && Array.isArray(r.Client)
						? ((this[vre] = r.Client),
							Ere ||
								((Ere = !0),
								process.emitWarning(
									"Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.",
									{ code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED" },
								)))
						: (this[vre] = [B8e({ maxRedirections: B })]),
					(this[au] = op.parseOrigin(t)),
					(this[OE] = M),
					(this[$B] = C ?? 1),
					(this[f8e] = n || e8e.maxHeaderSize),
					(this[Cre] = f ?? 4e3),
					(this[h8e] = g ?? 6e5),
					(this[g8e] = m ?? 2e3),
					(this[d8e] = this[Cre]),
					(this[zf] = null),
					(this[qE] = O ?? null),
					(this[ap] = 0),
					(this[Zf] = 0),
					(this[c8e] = `host: ${this[au].hostname}${this[au].port ? `:${this[au].port}` : ""}\r
`),
					(this[A8e] = l ?? 3e5),
					(this[p8e] = i ?? 3e5),
					(this[m8e] = b ?? !0),
					(this[y8e] = B),
					(this[cq] = Q),
					(this[jf] = null),
					(this[x8e] = Y > -1 ? Y : -1),
					(this[w8e] = q ?? 100),
					(this[Ai] = null),
					(this[ac] = []),
					(this[Rd] = 0),
					(this[lc] = 0),
					(this[VE] = (Qe) => dq(this, Qe)),
					(this[_8e] = (Qe) => Ire(this, Qe))
			}
			get pipelining() {
				return this[$B]
			}
			set pipelining(t) {
				;(this[$B] = t), this[VE](!0)
			}
			get [GE]() {
				return this[ac].length - this[lc]
			}
			get [WE]() {
				return this[lc] - this[Rd]
			}
			get [HE]() {
				return this[ac].length - this[Rd]
			}
			get [l8e]() {
				return !!this[Ai] && !this[d0] && !this[Ai].destroyed
			}
			get [lq]() {
				return !!(this[Ai]?.busy(null) || this[HE] >= (wre(this) || 1) || this[GE] > 0)
			}
			[a8e](t) {
				Sre(this), this.once("connect", t)
			}
			[b8e](t, r) {
				let n = t.origin || this[au].origin,
					i = new t8e(n, t, r)
				return (
					this[ac].push(i),
					this[ap] ||
						(op.bodyLength(i.body) == null && op.isIterable(i.body)
							? ((this[ap] = 1), queueMicrotask(() => dq(this)))
							: this[VE](!0)),
					this[ap] && this[Zf] !== 2 && this[lq] && (this[Zf] = 2),
					this[Zf] < 2
				)
			}
			async [v8e]() {
				return new Promise((t) => {
					this[HE] ? (this[jf] = t) : t(null)
				})
			}
			async [E8e](t) {
				return new Promise((r) => {
					let n = this[ac].splice(this[lc])
					for (let s = 0; s < n.length; s++) {
						let o = n[s]
						op.errorRequest(this, o, t)
					}
					let i = () => {
						this[jf] && (this[jf](), (this[jf] = null)), r(null)
					}
					this[Ai] ? (this[Ai].destroy(t, i), (this[Ai] = null)) : queueMicrotask(i), this[VE]()
				})
			}
		},
		B8e = GB()
	function Ire(e, t) {
		if (e[WE] === 0 && t.code !== "UND_ERR_INFO" && t.code !== "UND_ERR_SOCKET") {
			Td(e[lc] === e[Rd])
			let r = e[ac].splice(e[Rd])
			for (let n = 0; n < r.length; n++) {
				let i = r[n]
				op.errorRequest(e, i, t)
			}
			Td(e[HE] === 0)
		}
	}
	async function Sre(e) {
		Td(!e[d0]), Td(!e[Ai])
		let { host: t, hostname: r, protocol: n, port: i } = e[au]
		if (r[0] === "[") {
			let s = r.indexOf("]")
			Td(s !== -1)
			let o = r.substring(1, s)
			Td(_re.isIP(o)), (r = o)
		}
		;(e[d0] = !0),
			u0.beforeConnect.hasSubscribers &&
				u0.beforeConnect.publish({
					connectParams: {
						host: t,
						hostname: r,
						protocol: n,
						port: i,
						version: e[Ai]?.version,
						servername: e[zf],
						localAddress: e[qE],
					},
					connector: e[OE],
				})
		try {
			let s = await new Promise((o, a) => {
				e[OE](
					{
						host: t,
						hostname: r,
						protocol: n,
						port: i,
						servername: e[zf],
						localAddress: e[qE],
					},
					(l, c) => {
						l ? a(l) : o(c)
					},
				)
			})
			if (e.destroyed) {
				op.destroy(s.on("error", bre), new i8e())
				return
			}
			Td(s)
			try {
				e[Ai] = s.alpnProtocol === "h2" ? await S8e(e, s) : await I8e(e, s)
			} catch (o) {
				throw (s.destroy().on("error", bre), o)
			}
			;(e[d0] = !1),
				(s[C8e] = 0),
				(s[cq] = e[cq]),
				(s[o8e] = e),
				(s[u8e] = null),
				u0.connected.hasSubscribers &&
					u0.connected.publish({
						connectParams: {
							host: t,
							hostname: r,
							protocol: n,
							port: i,
							version: e[Ai]?.version,
							servername: e[zf],
							localAddress: e[qE],
						},
						connector: e[OE],
						socket: s,
					}),
				e.emit("connect", e[au], [e])
		} catch (s) {
			if (e.destroyed) return
			if (
				((e[d0] = !1),
				u0.connectError.hasSubscribers &&
					u0.connectError.publish({
						connectParams: {
							host: t,
							hostname: r,
							protocol: n,
							port: i,
							version: e[Ai]?.version,
							servername: e[zf],
							localAddress: e[qE],
						},
						connector: e[OE],
						error: s,
					}),
				s.code === "ERR_TLS_CERT_ALTNAME_INVALID")
			)
				for (Td(e[WE] === 0); e[GE] > 0 && e[ac][e[lc]].servername === e[zf]; ) {
					let o = e[ac][e[lc]++]
					op.errorRequest(e, o, s)
				}
			else Ire(e, s)
			e.emit("connectionError", e[au], [e], s)
		}
		e[VE]()
	}
	function xre(e) {
		;(e[Zf] = 0), e.emit("drain", e[au], [e])
	}
	function dq(e, t) {
		e[ap] !== 2 &&
			((e[ap] = 2),
			D8e(e, t),
			(e[ap] = 0),
			e[Rd] > 256 && (e[ac].splice(0, e[Rd]), (e[lc] -= e[Rd]), (e[Rd] = 0)))
	}
	function D8e(e, t) {
		for (;;) {
			if (e.destroyed) {
				Td(e[GE] === 0)
				return
			}
			if (e[jf] && !e[HE]) {
				e[jf](), (e[jf] = null)
				return
			}
			if ((e[Ai] && e[Ai].resume(), e[lq])) e[Zf] = 2
			else if (e[Zf] === 2) {
				t ? ((e[Zf] = 1), queueMicrotask(() => xre(e))) : xre(e)
				continue
			}
			if (e[GE] === 0 || e[WE] >= (wre(e) || 1)) return
			let r = e[ac][e[lc]]
			if (e[au].protocol === "https:" && e[zf] !== r.servername) {
				if (e[WE] > 0) return
				;(e[zf] = r.servername),
					e[Ai]?.destroy(new n8e("servername changed"), () => {
						;(e[Ai] = null), dq(e)
					})
			}
			if (e[d0]) return
			if (!e[Ai]) {
				Sre(e)
				return
			}
			if (e[Ai].destroyed || e[Ai].busy(r)) return
			!r.aborted && e[Ai].write(r) ? e[lc]++ : e[ac].splice(e[lc], 1)
		}
	}
	Bre.exports = uq
})
var fq = x((CIt, Dre) => {
	"use strict"
	var YB = class {
		constructor() {
			;(this.bottom = 0), (this.top = 0), (this.list = new Array(2048)), (this.next = null)
		}
		isEmpty() {
			return this.top === this.bottom
		}
		isFull() {
			return ((this.top + 1) & 2047) === this.bottom
		}
		push(t) {
			;(this.list[this.top] = t), (this.top = (this.top + 1) & 2047)
		}
		shift() {
			let t = this.list[this.bottom]
			return t === void 0
				? null
				: ((this.list[this.bottom] = void 0), (this.bottom = (this.bottom + 1) & 2047), t)
		}
	}
	Dre.exports = class {
		constructor() {
			this.head = this.tail = new YB()
		}
		isEmpty() {
			return this.head.isEmpty()
		}
		push(t) {
			this.head.isFull() && (this.head = this.head.next = new YB()), this.head.push(t)
		}
		shift() {
			let t = this.tail,
				r = t.shift()
			return t.isEmpty() && t.next !== null && (this.tail = t.next), r
		}
	}
})
var Rre = x((vIt, Tre) => {
	"use strict"
	var { kFree: T8e, kConnected: R8e, kPending: k8e, kQueued: M8e, kRunning: F8e, kSize: Q8e } = Qn(),
		lp = Symbol("pool"),
		hq = class {
			constructor(t) {
				this[lp] = t
			}
			get connected() {
				return this[lp][R8e]
			}
			get free() {
				return this[lp][T8e]
			}
			get pending() {
				return this[lp][k8e]
			}
			get queued() {
				return this[lp][M8e]
			}
			get running() {
				return this[lp][F8e]
			}
			get size() {
				return this[lp][Q8e]
			}
		}
	Tre.exports = hq
})
var Cq = x((EIt, qre) => {
	"use strict"
	var N8e = zm(),
		P8e = fq(),
		{
			kConnected: gq,
			kSize: kre,
			kRunning: Mre,
			kPending: Fre,
			kQueued: YE,
			kBusy: L8e,
			kFree: U8e,
			kUrl: O8e,
			kClose: q8e,
			kDestroy: V8e,
			kDispatch: H8e,
		} = Qn(),
		W8e = Rre(),
		Lo = Symbol("clients"),
		io = Symbol("needDrain"),
		KE = Symbol("queue"),
		pq = Symbol("closed resolve"),
		Aq = Symbol("onDrain"),
		Qre = Symbol("onConnect"),
		Nre = Symbol("onDisconnect"),
		Pre = Symbol("onConnectionError"),
		mq = Symbol("get dispatcher"),
		Ure = Symbol("add client"),
		Ore = Symbol("remove client"),
		Lre = Symbol("stats"),
		yq = class extends N8e {
			constructor() {
				super(), (this[KE] = new P8e()), (this[Lo] = []), (this[YE] = 0)
				let t = this
				;(this[Aq] = function (n, i) {
					let s = t[KE],
						o = !1
					for (; !o; ) {
						let a = s.shift()
						if (!a) break
						t[YE]--, (o = !this.dispatch(a.opts, a.handler))
					}
					;(this[io] = o),
						!this[io] && t[io] && ((t[io] = !1), t.emit("drain", n, [t, ...i])),
						t[pq] && s.isEmpty() && Promise.all(t[Lo].map((a) => a.close())).then(t[pq])
				}),
					(this[Qre] = (r, n) => {
						t.emit("connect", r, [t, ...n])
					}),
					(this[Nre] = (r, n, i) => {
						t.emit("disconnect", r, [t, ...n], i)
					}),
					(this[Pre] = (r, n, i) => {
						t.emit("connectionError", r, [t, ...n], i)
					}),
					(this[Lre] = new W8e(this))
			}
			get [L8e]() {
				return this[io]
			}
			get [gq]() {
				return this[Lo].filter((t) => t[gq]).length
			}
			get [U8e]() {
				return this[Lo].filter((t) => t[gq] && !t[io]).length
			}
			get [Fre]() {
				let t = this[YE]
				for (let { [Fre]: r } of this[Lo]) t += r
				return t
			}
			get [Mre]() {
				let t = 0
				for (let { [Mre]: r } of this[Lo]) t += r
				return t
			}
			get [kre]() {
				let t = this[YE]
				for (let { [kre]: r } of this[Lo]) t += r
				return t
			}
			get stats() {
				return this[Lre]
			}
			async [q8e]() {
				this[KE].isEmpty()
					? await Promise.all(this[Lo].map((t) => t.close()))
					: await new Promise((t) => {
							this[pq] = t
						})
			}
			async [V8e](t) {
				for (;;) {
					let r = this[KE].shift()
					if (!r) break
					r.handler.onError(t)
				}
				await Promise.all(this[Lo].map((r) => r.destroy(t)))
			}
			[H8e](t, r) {
				let n = this[mq]()
				return (
					n
						? n.dispatch(t, r) || ((n[io] = !0), (this[io] = !this[mq]()))
						: ((this[io] = !0), this[KE].push({ opts: t, handler: r }), this[YE]++),
					!this[io]
				)
			}
			[Ure](t) {
				return (
					t
						.on("drain", this[Aq])
						.on("connect", this[Qre])
						.on("disconnect", this[Nre])
						.on("connectionError", this[Pre]),
					this[Lo].push(t),
					this[io] &&
						queueMicrotask(() => {
							this[io] && this[Aq](t[O8e], [this, t])
						}),
					this
				)
			}
			[Ore](t) {
				t.close(() => {
					let r = this[Lo].indexOf(t)
					r !== -1 && this[Lo].splice(r, 1)
				}),
					(this[io] = this[Lo].some((r) => !r[io] && r.closed !== !0 && r.destroyed !== !0))
			}
		}
	qre.exports = {
		PoolBase: yq,
		kClients: Lo,
		kNeedDrain: io,
		kAddClient: Ure,
		kRemoveClient: Ore,
		kGetDispatcher: mq,
	}
})
var f0 = x((bIt, $re) => {
	"use strict"
	var { PoolBase: G8e, kClients: Vre, kNeedDrain: $8e, kAddClient: Y8e, kGetDispatcher: K8e } = Cq(),
		J8e = $E(),
		{ InvalidArgumentError: vq } = Vr(),
		Hre = Xt(),
		{ kUrl: Wre, kInterceptors: z8e } = Qn(),
		j8e = IE(),
		Eq = Symbol("options"),
		bq = Symbol("connections"),
		Gre = Symbol("factory")
	function Z8e(e, t) {
		return new J8e(e, t)
	}
	var xq = class extends G8e {
		constructor(
			t,
			{
				connections: r,
				factory: n = Z8e,
				connect: i,
				connectTimeout: s,
				tls: o,
				maxCachedSessions: a,
				socketPath: l,
				autoSelectFamily: c,
				autoSelectFamilyAttemptTimeout: u,
				allowH2: f,
				...p
			} = {},
		) {
			if ((super(), r != null && (!Number.isFinite(r) || r < 0))) throw new vq("invalid connections")
			if (typeof n != "function") throw new vq("factory must be a function.")
			if (i != null && typeof i != "function" && typeof i != "object")
				throw new vq("connect must be a function or an object")
			typeof i != "function" &&
				(i = j8e({
					...o,
					maxCachedSessions: a,
					allowH2: f,
					socketPath: l,
					timeout: s,
					...(c ? { autoSelectFamily: c, autoSelectFamilyAttemptTimeout: u } : void 0),
					...i,
				})),
				(this[z8e] = p.interceptors?.Pool && Array.isArray(p.interceptors.Pool) ? p.interceptors.Pool : []),
				(this[bq] = r || null),
				(this[Wre] = Hre.parseOrigin(t)),
				(this[Eq] = { ...Hre.deepClone(p), connect: i, allowH2: f }),
				(this[Eq].interceptors = p.interceptors ? { ...p.interceptors } : void 0),
				(this[Gre] = n)
		}
		[K8e]() {
			for (let t of this[Vre]) if (!t[$8e]) return t
			if (!this[bq] || this[Vre].length < this[bq]) {
				let t = this[Gre](this[Wre], this[Eq])
				return this[Y8e](t), t
			}
		}
	}
	$re.exports = xq
})
var jre = x((xIt, zre) => {
	"use strict"
	var { BalancedPoolMissingUpstreamError: X8e, InvalidArgumentError: e6e } = Vr(),
		{
			PoolBase: t6e,
			kClients: qs,
			kNeedDrain: JE,
			kAddClient: r6e,
			kRemoveClient: n6e,
			kGetDispatcher: i6e,
		} = Cq(),
		s6e = f0(),
		{ kUrl: _q, kInterceptors: o6e } = Qn(),
		{ parseOrigin: Yre } = Xt(),
		Kre = Symbol("factory"),
		KB = Symbol("options"),
		Jre = Symbol("kGreatestCommonDivisor"),
		cp = Symbol("kCurrentWeight"),
		up = Symbol("kIndex"),
		sl = Symbol("kWeight"),
		JB = Symbol("kMaxWeightPerServer"),
		zB = Symbol("kErrorPenalty")
	function a6e(e, t) {
		if (e === 0) return t
		for (; t !== 0; ) {
			let r = t
			;(t = e % t), (e = r)
		}
		return e
	}
	function l6e(e, t) {
		return new s6e(e, t)
	}
	var wq = class extends t6e {
		constructor(t = [], { factory: r = l6e, ...n } = {}) {
			if (
				(super(),
				(this[KB] = n),
				(this[up] = -1),
				(this[cp] = 0),
				(this[JB] = this[KB].maxWeightPerServer || 100),
				(this[zB] = this[KB].errorPenalty || 15),
				Array.isArray(t) || (t = [t]),
				typeof r != "function")
			)
				throw new e6e("factory must be a function.")
			;(this[o6e] =
				n.interceptors?.BalancedPool && Array.isArray(n.interceptors.BalancedPool)
					? n.interceptors.BalancedPool
					: []),
				(this[Kre] = r)
			for (let i of t) this.addUpstream(i)
			this._updateBalancedPoolStats()
		}
		addUpstream(t) {
			let r = Yre(t).origin
			if (this[qs].find((i) => i[_q].origin === r && i.closed !== !0 && i.destroyed !== !0)) return this
			let n = this[Kre](r, Object.assign({}, this[KB]))
			this[r6e](n),
				n.on("connect", () => {
					n[sl] = Math.min(this[JB], n[sl] + this[zB])
				}),
				n.on("connectionError", () => {
					;(n[sl] = Math.max(1, n[sl] - this[zB])), this._updateBalancedPoolStats()
				}),
				n.on("disconnect", (...i) => {
					let s = i[2]
					s &&
						s.code === "UND_ERR_SOCKET" &&
						((n[sl] = Math.max(1, n[sl] - this[zB])), this._updateBalancedPoolStats())
				})
			for (let i of this[qs]) i[sl] = this[JB]
			return this._updateBalancedPoolStats(), this
		}
		_updateBalancedPoolStats() {
			let t = 0
			for (let r = 0; r < this[qs].length; r++) t = a6e(this[qs][r][sl], t)
			this[Jre] = t
		}
		removeUpstream(t) {
			let r = Yre(t).origin,
				n = this[qs].find((i) => i[_q].origin === r && i.closed !== !0 && i.destroyed !== !0)
			return n && this[n6e](n), this
		}
		get upstreams() {
			return this[qs].filter((t) => t.closed !== !0 && t.destroyed !== !0).map((t) => t[_q].origin)
		}
		[i6e]() {
			if (this[qs].length === 0) throw new X8e()
			if (
				!this[qs].find((s) => !s[JE] && s.closed !== !0 && s.destroyed !== !0) ||
				this[qs].map((s) => s[JE]).reduce((s, o) => s && o, !0)
			)
				return
			let n = 0,
				i = this[qs].findIndex((s) => !s[JE])
			for (; n++ < this[qs].length; ) {
				this[up] = (this[up] + 1) % this[qs].length
				let s = this[qs][this[up]]
				if (
					(s[sl] > this[qs][i][sl] && !s[JE] && (i = this[up]),
					this[up] === 0 && ((this[cp] = this[cp] - this[Jre]), this[cp] <= 0 && (this[cp] = this[JB])),
					s[sl] >= this[cp] && !s[JE])
				)
					return s
			}
			return (this[cp] = this[qs][i][sl]), (this[up] = i), this[qs][i]
		}
	}
	zre.exports = wq
})
var h0 = x((_It, ine) => {
	"use strict"
	var { InvalidArgumentError: jB } = Vr(),
		{ kClients: Xf, kRunning: Zre, kClose: c6e, kDestroy: u6e, kDispatch: d6e, kInterceptors: f6e } = Qn(),
		h6e = zm(),
		g6e = f0(),
		p6e = $E(),
		A6e = Xt(),
		m6e = GB(),
		Xre = Symbol("onConnect"),
		ene = Symbol("onDisconnect"),
		tne = Symbol("onConnectionError"),
		y6e = Symbol("maxRedirections"),
		rne = Symbol("onDrain"),
		nne = Symbol("factory"),
		Iq = Symbol("options")
	function C6e(e, t) {
		return t && t.connections === 1 ? new p6e(e, t) : new g6e(e, t)
	}
	var Sq = class extends h6e {
		constructor({ factory: t = C6e, maxRedirections: r = 0, connect: n, ...i } = {}) {
			if ((super(), typeof t != "function")) throw new jB("factory must be a function.")
			if (n != null && typeof n != "function" && typeof n != "object")
				throw new jB("connect must be a function or an object")
			if (!Number.isInteger(r) || r < 0) throw new jB("maxRedirections must be a positive number")
			n && typeof n != "function" && (n = { ...n }),
				(this[f6e] =
					i.interceptors?.Agent && Array.isArray(i.interceptors.Agent)
						? i.interceptors.Agent
						: [m6e({ maxRedirections: r })]),
				(this[Iq] = { ...A6e.deepClone(i), connect: n }),
				(this[Iq].interceptors = i.interceptors ? { ...i.interceptors } : void 0),
				(this[y6e] = r),
				(this[nne] = t),
				(this[Xf] = new Map()),
				(this[rne] = (s, o) => {
					this.emit("drain", s, [this, ...o])
				}),
				(this[Xre] = (s, o) => {
					this.emit("connect", s, [this, ...o])
				}),
				(this[ene] = (s, o, a) => {
					this.emit("disconnect", s, [this, ...o], a)
				}),
				(this[tne] = (s, o, a) => {
					this.emit("connectionError", s, [this, ...o], a)
				})
		}
		get [Zre]() {
			let t = 0
			for (let r of this[Xf].values()) t += r[Zre]
			return t
		}
		[d6e](t, r) {
			let n
			if (t.origin && (typeof t.origin == "string" || t.origin instanceof URL)) n = String(t.origin)
			else throw new jB("opts.origin must be a non-empty string or URL.")
			let i = this[Xf].get(n)
			return (
				i ||
					((i = this[nne](t.origin, this[Iq])
						.on("drain", this[rne])
						.on("connect", this[Xre])
						.on("disconnect", this[ene])
						.on("connectionError", this[tne])),
					this[Xf].set(n, i)),
				i.dispatch(t, r)
			)
		}
		async [c6e]() {
			let t = []
			for (let r of this[Xf].values()) t.push(r.close())
			this[Xf].clear(), await Promise.all(t)
		}
		async [u6e](t) {
			let r = []
			for (let n of this[Xf].values()) r.push(n.destroy(t))
			this[Xf].clear(), await Promise.all(r)
		}
	}
	ine.exports = Sq
})
var Tq = x((wIt, lne) => {
	"use strict"
	var { kProxy: v6e, kClose: E6e, kDestroy: b6e, kInterceptors: x6e } = Qn(),
		{ URL: zE } = require("url"),
		_6e = h0(),
		w6e = f0(),
		I6e = zm(),
		{ InvalidArgumentError: eD, RequestAbortedError: S6e, SecureProxyConnectionError: B6e } = Vr(),
		sne = IE(),
		ZB = Symbol("proxy agent"),
		XB = Symbol("proxy client"),
		jE = Symbol("proxy headers"),
		Bq = Symbol("request tls settings"),
		one = Symbol("proxy tls settings"),
		ane = Symbol("connect endpoint function")
	function D6e(e) {
		return e === "https:" ? 443 : 80
	}
	function T6e(e, t) {
		return new w6e(e, t)
	}
	var R6e = () => {},
		Dq = class extends I6e {
			constructor(t) {
				if ((super(), !t || (typeof t == "object" && !(t instanceof zE) && !t.uri)))
					throw new eD("Proxy uri is mandatory")
				let { clientFactory: r = T6e } = t
				if (typeof r != "function") throw new eD("Proxy opts.clientFactory must be a function.")
				let n = this.#e(t),
					{ href: i, origin: s, port: o, protocol: a, username: l, password: c, hostname: u } = n
				if (
					((this[v6e] = { uri: i, protocol: a }),
					(this[x6e] =
						t.interceptors?.ProxyAgent && Array.isArray(t.interceptors.ProxyAgent)
							? t.interceptors.ProxyAgent
							: []),
					(this[Bq] = t.requestTls),
					(this[one] = t.proxyTls),
					(this[jE] = t.headers || {}),
					t.auth && t.token)
				)
					throw new eD("opts.auth cannot be used in combination with opts.token")
				t.auth
					? (this[jE]["proxy-authorization"] = `Basic ${t.auth}`)
					: t.token
						? (this[jE]["proxy-authorization"] = t.token)
						: l &&
							c &&
							(this[jE]["proxy-authorization"] = `Basic ${Buffer.from(
								`${decodeURIComponent(l)}:${decodeURIComponent(c)}`,
							).toString("base64")}`)
				let f = sne({ ...t.proxyTls })
				;(this[ane] = sne({ ...t.requestTls })),
					(this[XB] = r(n, { connect: f })),
					(this[ZB] = new _6e({
						...t,
						connect: async (p, g) => {
							let m = p.host
							p.port || (m += `:${D6e(p.protocol)}`)
							try {
								let { socket: y, statusCode: C } = await this[XB].connect({
									origin: s,
									port: o,
									path: m,
									signal: p.signal,
									headers: { ...this[jE], host: p.host },
									servername: this[one]?.servername || u,
								})
								if (
									(C !== 200 &&
										(y.on("error", R6e).destroy(),
										g(new S6e(`Proxy response (${C}) !== 200 when HTTP Tunneling`))),
									p.protocol !== "https:")
								) {
									g(null, y)
									return
								}
								let v
								this[Bq] ? (v = this[Bq].servername) : (v = p.servername),
									this[ane]({ ...p, servername: v, httpSocket: y }, g)
							} catch (y) {
								y.code === "ERR_TLS_CERT_ALTNAME_INVALID" ? g(new B6e(y)) : g(y)
							}
						},
					}))
			}
			dispatch(t, r) {
				let n = k6e(t.headers)
				if ((M6e(n), n && !("host" in n) && !("Host" in n))) {
					let { host: i } = new zE(t.origin)
					n.host = i
				}
				return this[ZB].dispatch({ ...t, headers: n }, r)
			}
			#e(t) {
				return typeof t == "string" ? new zE(t) : t instanceof zE ? t : new zE(t.uri)
			}
			async [E6e]() {
				await this[ZB].close(), await this[XB].close()
			}
			async [b6e]() {
				await this[ZB].destroy(), await this[XB].destroy()
			}
		}
	function k6e(e) {
		if (Array.isArray(e)) {
			let t = {}
			for (let r = 0; r < e.length; r += 2) t[e[r]] = e[r + 1]
			return t
		}
		return e
	}
	function M6e(e) {
		if (e && Object.keys(e).find((r) => r.toLowerCase() === "proxy-authorization"))
			throw new eD("Proxy-Authorization should be sent in ProxyAgent constructor")
	}
	lne.exports = Dq
})
var gne = x((IIt, hne) => {
	"use strict"
	var F6e = zm(),
		{
			kClose: Q6e,
			kDestroy: N6e,
			kClosed: cne,
			kDestroyed: une,
			kDispatch: P6e,
			kNoProxyAgent: ZE,
			kHttpProxyAgent: eh,
			kHttpsProxyAgent: dp,
		} = Qn(),
		dne = Tq(),
		L6e = h0(),
		U6e = { "http:": 80, "https:": 443 },
		fne = !1,
		Rq = class extends F6e {
			#e = null
			#t = null
			#i = null
			constructor(t = {}) {
				super(),
					(this.#i = t),
					fne ||
						((fne = !0),
						process.emitWarning("EnvHttpProxyAgent is experimental, expect them to change at any time.", {
							code: "UNDICI-EHPA",
						}))
				let { httpProxy: r, httpsProxy: n, noProxy: i, ...s } = t
				this[ZE] = new L6e(s)
				let o = r ?? process.env.http_proxy ?? process.env.HTTP_PROXY
				o ? (this[eh] = new dne({ ...s, uri: o })) : (this[eh] = this[ZE])
				let a = n ?? process.env.https_proxy ?? process.env.HTTPS_PROXY
				a ? (this[dp] = new dne({ ...s, uri: a })) : (this[dp] = this[eh]), this.#l()
			}
			[P6e](t, r) {
				let n = new URL(t.origin)
				return this.#n(n).dispatch(t, r)
			}
			async [Q6e]() {
				await this[ZE].close(),
					this[eh][cne] || (await this[eh].close()),
					this[dp][cne] || (await this[dp].close())
			}
			async [N6e](t) {
				await this[ZE].destroy(t),
					this[eh][une] || (await this[eh].destroy(t)),
					this[dp][une] || (await this[dp].destroy(t))
			}
			#n(t) {
				let { protocol: r, host: n, port: i } = t
				return (
					(n = n.replace(/:\d*$/, "").toLowerCase()),
					(i = Number.parseInt(i, 10) || U6e[r] || 0),
					this.#r(n, i) ? (r === "https:" ? this[dp] : this[eh]) : this[ZE]
				)
			}
			#r(t, r) {
				if ((this.#o && this.#l(), this.#t.length === 0)) return !0
				if (this.#e === "*") return !1
				for (let n = 0; n < this.#t.length; n++) {
					let i = this.#t[n]
					if (!(i.port && i.port !== r)) {
						if (/^[.*]/.test(i.hostname)) {
							if (t.endsWith(i.hostname.replace(/^\*/, ""))) return !1
						} else if (t === i.hostname) return !1
					}
				}
				return !0
			}
			#l() {
				let t = this.#i.noProxy ?? this.#u,
					r = t.split(/[,\s]/),
					n = []
				for (let i = 0; i < r.length; i++) {
					let s = r[i]
					if (!s) continue
					let o = s.match(/^(.+):(\d+)$/)
					n.push({
						hostname: (o ? o[1] : s).toLowerCase(),
						port: o ? Number.parseInt(o[2], 10) : 0,
					})
				}
				;(this.#e = t), (this.#t = n)
			}
			get #o() {
				return this.#i.noProxy !== void 0 ? !1 : this.#e !== this.#u
			}
			get #u() {
				return process.env.no_proxy ?? process.env.NO_PROXY ?? ""
			}
		}
	hne.exports = Rq
})
var tD = x((SIt, yne) => {
	"use strict"
	var g0 = require("assert"),
		{ kRetryHandlerDefaultRetry: pne } = Qn(),
		{ RequestRetryError: XE } = Vr(),
		{ isDisturbed: Ane, parseHeaders: O6e, parseRangeHeader: mne, wrapRequestBody: q6e } = Xt()
	function V6e(e) {
		let t = Date.now()
		return new Date(e).getTime() - t
	}
	var kq = class e {
		constructor(t, r) {
			let { retryOptions: n, ...i } = t,
				{
					retry: s,
					maxRetries: o,
					maxTimeout: a,
					minTimeout: l,
					timeoutFactor: c,
					methods: u,
					errorCodes: f,
					retryAfter: p,
					statusCodes: g,
				} = n ?? {}
			;(this.dispatch = r.dispatch),
				(this.handler = r.handler),
				(this.opts = { ...i, body: q6e(t.body) }),
				(this.abort = null),
				(this.aborted = !1),
				(this.retryOpts = {
					retry: s ?? e[pne],
					retryAfter: p ?? !0,
					maxTimeout: a ?? 30 * 1e3,
					minTimeout: l ?? 500,
					timeoutFactor: c ?? 2,
					maxRetries: o ?? 5,
					methods: u ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
					statusCodes: g ?? [500, 502, 503, 504, 429],
					errorCodes: f ?? [
						"ECONNRESET",
						"ECONNREFUSED",
						"ENOTFOUND",
						"ENETDOWN",
						"ENETUNREACH",
						"EHOSTDOWN",
						"EHOSTUNREACH",
						"EPIPE",
						"UND_ERR_SOCKET",
					],
				}),
				(this.retryCount = 0),
				(this.retryCountCheckpoint = 0),
				(this.start = 0),
				(this.end = null),
				(this.etag = null),
				(this.resume = null),
				this.handler.onConnect((m) => {
					;(this.aborted = !0), this.abort ? this.abort(m) : (this.reason = m)
				})
		}
		onRequestSent() {
			this.handler.onRequestSent && this.handler.onRequestSent()
		}
		onUpgrade(t, r, n) {
			this.handler.onUpgrade && this.handler.onUpgrade(t, r, n)
		}
		onConnect(t) {
			this.aborted ? t(this.reason) : (this.abort = t)
		}
		onBodySent(t) {
			if (this.handler.onBodySent) return this.handler.onBodySent(t)
		}
		static [pne](t, { state: r, opts: n }, i) {
			let { statusCode: s, code: o, headers: a } = t,
				{ method: l, retryOptions: c } = n,
				{
					maxRetries: u,
					minTimeout: f,
					maxTimeout: p,
					timeoutFactor: g,
					statusCodes: m,
					errorCodes: y,
					methods: C,
				} = c,
				{ counter: v } = r
			if (o && o !== "UND_ERR_REQ_RETRY" && !y.includes(o)) {
				i(t)
				return
			}
			if (Array.isArray(C) && !C.includes(l)) {
				i(t)
				return
			}
			if (s != null && Array.isArray(m) && !m.includes(s)) {
				i(t)
				return
			}
			if (v > u) {
				i(t)
				return
			}
			let b = a?.["retry-after"]
			b && ((b = Number(b)), (b = Number.isNaN(b) ? V6e(b) : b * 1e3))
			let w = b > 0 ? Math.min(b, p) : Math.min(f * g ** (v - 1), p)
			setTimeout(() => i(null), w)
		}
		onHeaders(t, r, n, i) {
			let s = O6e(r)
			if (((this.retryCount += 1), t >= 300))
				return this.retryOpts.statusCodes.includes(t) === !1
					? this.handler.onHeaders(t, r, n, i)
					: (this.abort(
							new XE("Request failed", t, {
								headers: s,
								data: { count: this.retryCount },
							}),
						),
						!1)
			if (this.resume != null) {
				if (((this.resume = null), t !== 206 && (this.start > 0 || t !== 200)))
					return (
						this.abort(
							new XE(
								"server does not support the range header and the payload was partially consumed",
								t,
								{ headers: s, data: { count: this.retryCount } },
							),
						),
						!1
					)
				let a = mne(s["content-range"])
				if (!a)
					return (
						this.abort(
							new XE("Content-Range mismatch", t, {
								headers: s,
								data: { count: this.retryCount },
							}),
						),
						!1
					)
				if (this.etag != null && this.etag !== s.etag)
					return (
						this.abort(
							new XE("ETag mismatch", t, {
								headers: s,
								data: { count: this.retryCount },
							}),
						),
						!1
					)
				let { start: l, size: c, end: u = c - 1 } = a
				return (
					g0(this.start === l, "content-range mismatch"),
					g0(this.end == null || this.end === u, "content-range mismatch"),
					(this.resume = n),
					!0
				)
			}
			if (this.end == null) {
				if (t === 206) {
					let a = mne(s["content-range"])
					if (a == null) return this.handler.onHeaders(t, r, n, i)
					let { start: l, size: c, end: u = c - 1 } = a
					g0(l != null && Number.isFinite(l), "content-range mismatch"),
						g0(u != null && Number.isFinite(u), "invalid content-length"),
						(this.start = l),
						(this.end = u)
				}
				if (this.end == null) {
					let a = s["content-length"]
					this.end = a != null ? Number(a) - 1 : null
				}
				return (
					g0(Number.isFinite(this.start)),
					g0(this.end == null || Number.isFinite(this.end), "invalid content-length"),
					(this.resume = n),
					(this.etag = s.etag != null ? s.etag : null),
					this.etag != null && this.etag.startsWith("W/") && (this.etag = null),
					this.handler.onHeaders(t, r, n, i)
				)
			}
			let o = new XE("Request failed", t, {
				headers: s,
				data: { count: this.retryCount },
			})
			return this.abort(o), !1
		}
		onData(t) {
			return (this.start += t.length), this.handler.onData(t)
		}
		onComplete(t) {
			return (this.retryCount = 0), this.handler.onComplete(t)
		}
		onError(t) {
			if (this.aborted || Ane(this.opts.body)) return this.handler.onError(t)
			this.retryCount - this.retryCountCheckpoint > 0
				? (this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint))
				: (this.retryCount += 1),
				this.retryOpts.retry(
					t,
					{
						state: { counter: this.retryCount },
						opts: { retryOptions: this.retryOpts, ...this.opts },
					},
					r.bind(this),
				)
			function r(n) {
				if (n != null || this.aborted || Ane(this.opts.body)) return this.handler.onError(n)
				if (this.start !== 0) {
					let i = { range: `bytes=${this.start}-${this.end ?? ""}` }
					this.etag != null && (i["if-match"] = this.etag),
						(this.opts = {
							...this.opts,
							headers: { ...this.opts.headers, ...i },
						})
				}
				try {
					;(this.retryCountCheckpoint = this.retryCount), this.dispatch(this.opts, this)
				} catch (i) {
					this.handler.onError(i)
				}
			}
		}
	}
	yne.exports = kq
})
var vne = x((BIt, Cne) => {
	"use strict"
	var H6e = _E(),
		W6e = tD(),
		Mq = class extends H6e {
			#e = null
			#t = null
			constructor(t, r = {}) {
				super(r), (this.#e = t), (this.#t = r)
			}
			dispatch(t, r) {
				let n = new W6e(
					{ ...t, retryOptions: this.#t },
					{ dispatch: this.#e.dispatch.bind(this.#e), handler: r },
				)
				return this.#e.dispatch(t, n)
			}
			close() {
				return this.#e.close()
			}
			destroy() {
				return this.#e.destroy()
			}
		}
	Cne.exports = Mq
})
var Uq = x((DIt, Dne) => {
	"use strict"
	var wne = require("assert"),
		{ Readable: G6e } = require("stream"),
		{ RequestAbortedError: Ine, NotSupportedError: $6e, InvalidArgumentError: Y6e, AbortError: Fq } = Vr(),
		Sne = Xt(),
		{ ReadableStreamFrom: K6e } = Xt(),
		pa = Symbol("kConsume"),
		eb = Symbol("kReading"),
		th = Symbol("kBody"),
		Ene = Symbol("kAbort"),
		Bne = Symbol("kContentType"),
		bne = Symbol("kContentLength"),
		J6e = () => {},
		Qq = class extends G6e {
			constructor({ resume: t, abort: r, contentType: n = "", contentLength: i, highWaterMark: s = 64 * 1024 }) {
				super({ autoDestroy: !0, read: t, highWaterMark: s }),
					(this._readableState.dataEmitted = !1),
					(this[Ene] = r),
					(this[pa] = null),
					(this[th] = null),
					(this[Bne] = n),
					(this[bne] = i),
					(this[eb] = !1)
			}
			destroy(t) {
				return !t && !this._readableState.endEmitted && (t = new Ine()), t && this[Ene](), super.destroy(t)
			}
			_destroy(t, r) {
				this[eb]
					? r(t)
					: setImmediate(() => {
							r(t)
						})
			}
			on(t, ...r) {
				return (t === "data" || t === "readable") && (this[eb] = !0), super.on(t, ...r)
			}
			addListener(t, ...r) {
				return this.on(t, ...r)
			}
			off(t, ...r) {
				let n = super.off(t, ...r)
				return (
					(t === "data" || t === "readable") &&
						(this[eb] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0),
					n
				)
			}
			removeListener(t, ...r) {
				return this.off(t, ...r)
			}
			push(t) {
				return this[pa] && t !== null ? (Pq(this[pa], t), this[eb] ? super.push(t) : !0) : super.push(t)
			}
			async text() {
				return tb(this, "text")
			}
			async json() {
				return tb(this, "json")
			}
			async blob() {
				return tb(this, "blob")
			}
			async bytes() {
				return tb(this, "bytes")
			}
			async arrayBuffer() {
				return tb(this, "arrayBuffer")
			}
			async formData() {
				throw new $6e()
			}
			get bodyUsed() {
				return Sne.isDisturbed(this)
			}
			get body() {
				return (
					this[th] || ((this[th] = K6e(this)), this[pa] && (this[th].getReader(), wne(this[th].locked))),
					this[th]
				)
			}
			async dump(t) {
				let r = Number.isFinite(t?.limit) ? t.limit : 131072,
					n = t?.signal
				if (n != null && (typeof n != "object" || !("aborted" in n)))
					throw new Y6e("signal must be an AbortSignal")
				return (
					n?.throwIfAborted(),
					this._readableState.closeEmitted
						? null
						: await new Promise((i, s) => {
								this[bne] > r && this.destroy(new Fq())
								let o = () => {
									this.destroy(n.reason ?? new Fq())
								}
								n?.addEventListener("abort", o),
									this.on("close", function () {
										n?.removeEventListener("abort", o),
											n?.aborted ? s(n.reason ?? new Fq()) : i(null)
									})
										.on("error", J6e)
										.on("data", function (a) {
											;(r -= a.length), r <= 0 && this.destroy()
										})
										.resume()
							})
				)
			}
		}
	function z6e(e) {
		return (e[th] && e[th].locked === !0) || e[pa]
	}
	function j6e(e) {
		return Sne.isDisturbed(e) || z6e(e)
	}
	async function tb(e, t) {
		return (
			wne(!e[pa]),
			new Promise((r, n) => {
				if (j6e(e)) {
					let i = e._readableState
					i.destroyed && i.closeEmitted === !1
						? e
								.on("error", (s) => {
									n(s)
								})
								.on("close", () => {
									n(new TypeError("unusable"))
								})
						: n(i.errored ?? new TypeError("unusable"))
				} else
					queueMicrotask(() => {
						;(e[pa] = {
							type: t,
							stream: e,
							resolve: r,
							reject: n,
							length: 0,
							body: [],
						}),
							e
								.on("error", function (i) {
									Lq(this[pa], i)
								})
								.on("close", function () {
									this[pa].body !== null && Lq(this[pa], new Ine())
								}),
							Z6e(e[pa])
					})
			})
		)
	}
	function Z6e(e) {
		if (e.body === null) return
		let { _readableState: t } = e.stream
		if (t.bufferIndex) {
			let r = t.bufferIndex,
				n = t.buffer.length
			for (let i = r; i < n; i++) Pq(e, t.buffer[i])
		} else for (let r of t.buffer) Pq(e, r)
		for (
			t.endEmitted
				? _ne(this[pa])
				: e.stream.on("end", function () {
						_ne(this[pa])
					}),
				e.stream.resume();
			e.stream.read() != null;

		);
	}
	function Nq(e, t) {
		if (e.length === 0 || t === 0) return ""
		let r = e.length === 1 ? e[0] : Buffer.concat(e, t),
			n = r.length,
			i = n > 2 && r[0] === 239 && r[1] === 187 && r[2] === 191 ? 3 : 0
		return r.utf8Slice(i, n)
	}
	function xne(e, t) {
		if (e.length === 0 || t === 0) return new Uint8Array(0)
		if (e.length === 1) return new Uint8Array(e[0])
		let r = new Uint8Array(Buffer.allocUnsafeSlow(t).buffer),
			n = 0
		for (let i = 0; i < e.length; ++i) {
			let s = e[i]
			r.set(s, n), (n += s.length)
		}
		return r
	}
	function _ne(e) {
		let { type: t, body: r, resolve: n, stream: i, length: s } = e
		try {
			t === "text"
				? n(Nq(r, s))
				: t === "json"
					? n(JSON.parse(Nq(r, s)))
					: t === "arrayBuffer"
						? n(xne(r, s).buffer)
						: t === "blob"
							? n(new Blob(r, { type: i[Bne] }))
							: t === "bytes" && n(xne(r, s)),
				Lq(e)
		} catch (o) {
			i.destroy(o)
		}
	}
	function Pq(e, t) {
		;(e.length += t.length), e.body.push(t)
	}
	function Lq(e, t) {
		e.body !== null &&
			(t ? e.reject(t) : e.resolve(),
			(e.type = null),
			(e.stream = null),
			(e.resolve = null),
			(e.reject = null),
			(e.length = 0),
			(e.body = null))
	}
	Dne.exports = { Readable: Qq, chunksDecode: Nq }
})
var Oq = x((TIt, Fne) => {
	"use strict"
	var X6e = require("assert"),
		{ ResponseStatusCodeError: Tne } = Vr(),
		{ chunksDecode: Rne } = Uq(),
		e9e = 128 * 1024
	async function t9e({ callback: e, body: t, contentType: r, statusCode: n, statusMessage: i, headers: s }) {
		X6e(t)
		let o = [],
			a = 0
		try {
			for await (let f of t)
				if ((o.push(f), (a += f.length), a > e9e)) {
					;(o = []), (a = 0)
					break
				}
		} catch {
			;(o = []), (a = 0)
		}
		let l = `Response status code ${n}${i ? `: ${i}` : ""}`
		if (n === 204 || !r || !a) {
			queueMicrotask(() => e(new Tne(l, n, s)))
			return
		}
		let c = Error.stackTraceLimit
		Error.stackTraceLimit = 0
		let u
		try {
			kne(r) ? (u = JSON.parse(Rne(o, a))) : Mne(r) && (u = Rne(o, a))
		} catch {
		} finally {
			Error.stackTraceLimit = c
		}
		queueMicrotask(() => e(new Tne(l, n, s, u)))
	}
	var kne = (e) =>
			e.length > 15 &&
			e[11] === "/" &&
			e[0] === "a" &&
			e[1] === "p" &&
			e[2] === "p" &&
			e[3] === "l" &&
			e[4] === "i" &&
			e[5] === "c" &&
			e[6] === "a" &&
			e[7] === "t" &&
			e[8] === "i" &&
			e[9] === "o" &&
			e[10] === "n" &&
			e[12] === "j" &&
			e[13] === "s" &&
			e[14] === "o" &&
			e[15] === "n",
		Mne = (e) => e.length > 4 && e[4] === "/" && e[0] === "t" && e[1] === "e" && e[2] === "x" && e[3] === "t"
	Fne.exports = {
		getResolveErrorBodyCallback: t9e,
		isContentTypeApplicationJson: kne,
		isContentTypeText: Mne,
	}
})
var Pne = x((RIt, qq) => {
	"use strict"
	var r9e = require("assert"),
		{ Readable: n9e } = Uq(),
		{ InvalidArgumentError: p0, RequestAbortedError: Qne } = Vr(),
		Aa = Xt(),
		{ getResolveErrorBodyCallback: i9e } = Oq(),
		{ AsyncResource: s9e } = require("async_hooks"),
		rD = class extends s9e {
			constructor(t, r) {
				if (!t || typeof t != "object") throw new p0("invalid opts")
				let {
					signal: n,
					method: i,
					opaque: s,
					body: o,
					onInfo: a,
					responseHeaders: l,
					throwOnError: c,
					highWaterMark: u,
				} = t
				try {
					if (typeof r != "function") throw new p0("invalid callback")
					if (u && (typeof u != "number" || u < 0)) throw new p0("invalid highWaterMark")
					if (n && typeof n.on != "function" && typeof n.addEventListener != "function")
						throw new p0("signal must be an EventEmitter or EventTarget")
					if (i === "CONNECT") throw new p0("invalid method")
					if (a && typeof a != "function") throw new p0("invalid onInfo callback")
					super("UNDICI_REQUEST")
				} catch (f) {
					throw (Aa.isStream(o) && Aa.destroy(o.on("error", Aa.nop), f), f)
				}
				;(this.method = i),
					(this.responseHeaders = l || null),
					(this.opaque = s || null),
					(this.callback = r),
					(this.res = null),
					(this.abort = null),
					(this.body = o),
					(this.trailers = {}),
					(this.context = null),
					(this.onInfo = a || null),
					(this.throwOnError = c),
					(this.highWaterMark = u),
					(this.signal = n),
					(this.reason = null),
					(this.removeAbortListener = null),
					Aa.isStream(o) &&
						o.on("error", (f) => {
							this.onError(f)
						}),
					this.signal &&
						(this.signal.aborted
							? (this.reason = this.signal.reason ?? new Qne())
							: (this.removeAbortListener = Aa.addAbortListener(this.signal, () => {
									;(this.reason = this.signal.reason ?? new Qne()),
										this.res
											? Aa.destroy(this.res.on("error", Aa.nop), this.reason)
											: this.abort && this.abort(this.reason),
										this.removeAbortListener &&
											(this.res?.off("close", this.removeAbortListener),
											this.removeAbortListener(),
											(this.removeAbortListener = null))
								})))
			}
			onConnect(t, r) {
				if (this.reason) {
					t(this.reason)
					return
				}
				r9e(this.callback), (this.abort = t), (this.context = r)
			}
			onHeaders(t, r, n, i) {
				let { callback: s, opaque: o, abort: a, context: l, responseHeaders: c, highWaterMark: u } = this,
					f = c === "raw" ? Aa.parseRawHeaders(r) : Aa.parseHeaders(r)
				if (t < 200) {
					this.onInfo && this.onInfo({ statusCode: t, headers: f })
					return
				}
				let p = c === "raw" ? Aa.parseHeaders(r) : f,
					g = p["content-type"],
					m = p["content-length"],
					y = new n9e({
						resume: n,
						abort: a,
						contentType: g,
						contentLength: this.method !== "HEAD" && m ? Number(m) : null,
						highWaterMark: u,
					})
				this.removeAbortListener && y.on("close", this.removeAbortListener),
					(this.callback = null),
					(this.res = y),
					s !== null &&
						(this.throwOnError && t >= 400
							? this.runInAsyncScope(i9e, null, {
									callback: s,
									body: y,
									contentType: g,
									statusCode: t,
									statusMessage: i,
									headers: f,
								})
							: this.runInAsyncScope(s, null, null, {
									statusCode: t,
									headers: f,
									trailers: this.trailers,
									opaque: o,
									body: y,
									context: l,
								}))
			}
			onData(t) {
				return this.res.push(t)
			}
			onComplete(t) {
				Aa.parseHeaders(t, this.trailers), this.res.push(null)
			}
			onError(t) {
				let { res: r, callback: n, body: i, opaque: s } = this
				n &&
					((this.callback = null),
					queueMicrotask(() => {
						this.runInAsyncScope(n, null, t, { opaque: s })
					})),
					r &&
						((this.res = null),
						queueMicrotask(() => {
							Aa.destroy(r, t)
						})),
					i && ((this.body = null), Aa.destroy(i, t)),
					this.removeAbortListener &&
						(r?.off("close", this.removeAbortListener),
						this.removeAbortListener(),
						(this.removeAbortListener = null))
			}
		}
	function Nne(e, t) {
		if (t === void 0)
			return new Promise((r, n) => {
				Nne.call(this, e, (i, s) => (i ? n(i) : r(s)))
			})
		try {
			this.dispatch(e, new rD(e, t))
		} catch (r) {
			if (typeof t != "function") throw r
			let n = e?.opaque
			queueMicrotask(() => t(r, { opaque: n }))
		}
	}
	qq.exports = Nne
	qq.exports.RequestHandler = rD
})
var rb = x((kIt, One) => {
	"use strict"
	var { addAbortListener: o9e } = Xt(),
		{ RequestAbortedError: a9e } = Vr(),
		A0 = Symbol("kListener"),
		lu = Symbol("kSignal")
	function Lne(e) {
		e.abort ? e.abort(e[lu]?.reason) : (e.reason = e[lu]?.reason ?? new a9e()), Une(e)
	}
	function l9e(e, t) {
		if (((e.reason = null), (e[lu] = null), (e[A0] = null), !!t)) {
			if (t.aborted) {
				Lne(e)
				return
			}
			;(e[lu] = t),
				(e[A0] = () => {
					Lne(e)
				}),
				o9e(e[lu], e[A0])
		}
	}
	function Une(e) {
		e[lu] &&
			("removeEventListener" in e[lu]
				? e[lu].removeEventListener("abort", e[A0])
				: e[lu].removeListener("abort", e[A0]),
			(e[lu] = null),
			(e[A0] = null))
	}
	One.exports = { addSignal: l9e, removeSignal: Une }
})
var Wne = x((MIt, Hne) => {
	"use strict"
	var c9e = require("assert"),
		{ finished: u9e, PassThrough: d9e } = require("stream"),
		{ InvalidArgumentError: m0, InvalidReturnValueError: f9e } = Vr(),
		cc = Xt(),
		{ getResolveErrorBodyCallback: h9e } = Oq(),
		{ AsyncResource: g9e } = require("async_hooks"),
		{ addSignal: p9e, removeSignal: qne } = rb(),
		Vq = class extends g9e {
			constructor(t, r, n) {
				if (!t || typeof t != "object") throw new m0("invalid opts")
				let { signal: i, method: s, opaque: o, body: a, onInfo: l, responseHeaders: c, throwOnError: u } = t
				try {
					if (typeof n != "function") throw new m0("invalid callback")
					if (typeof r != "function") throw new m0("invalid factory")
					if (i && typeof i.on != "function" && typeof i.addEventListener != "function")
						throw new m0("signal must be an EventEmitter or EventTarget")
					if (s === "CONNECT") throw new m0("invalid method")
					if (l && typeof l != "function") throw new m0("invalid onInfo callback")
					super("UNDICI_STREAM")
				} catch (f) {
					throw (cc.isStream(a) && cc.destroy(a.on("error", cc.nop), f), f)
				}
				;(this.responseHeaders = c || null),
					(this.opaque = o || null),
					(this.factory = r),
					(this.callback = n),
					(this.res = null),
					(this.abort = null),
					(this.context = null),
					(this.trailers = null),
					(this.body = a),
					(this.onInfo = l || null),
					(this.throwOnError = u || !1),
					cc.isStream(a) &&
						a.on("error", (f) => {
							this.onError(f)
						}),
					p9e(this, i)
			}
			onConnect(t, r) {
				if (this.reason) {
					t(this.reason)
					return
				}
				c9e(this.callback), (this.abort = t), (this.context = r)
			}
			onHeaders(t, r, n, i) {
				let { factory: s, opaque: o, context: a, callback: l, responseHeaders: c } = this,
					u = c === "raw" ? cc.parseRawHeaders(r) : cc.parseHeaders(r)
				if (t < 200) {
					this.onInfo && this.onInfo({ statusCode: t, headers: u })
					return
				}
				this.factory = null
				let f
				if (this.throwOnError && t >= 400) {
					let m = (c === "raw" ? cc.parseHeaders(r) : u)["content-type"]
					;(f = new d9e()),
						(this.callback = null),
						this.runInAsyncScope(h9e, null, {
							callback: l,
							body: f,
							contentType: m,
							statusCode: t,
							statusMessage: i,
							headers: u,
						})
				} else {
					if (s === null) return
					if (
						((f = this.runInAsyncScope(s, null, {
							statusCode: t,
							headers: u,
							opaque: o,
							context: a,
						})),
						!f || typeof f.write != "function" || typeof f.end != "function" || typeof f.on != "function")
					)
						throw new f9e("expected Writable")
					u9e(f, { readable: !1 }, (g) => {
						let { callback: m, res: y, opaque: C, trailers: v, abort: b } = this
						;(this.res = null),
							(g || !y.readable) && cc.destroy(y, g),
							(this.callback = null),
							this.runInAsyncScope(m, null, g || null, {
								opaque: C,
								trailers: v,
							}),
							g && b()
					})
				}
				return (
					f.on("drain", n),
					(this.res = f),
					(f.writableNeedDrain !== void 0 ? f.writableNeedDrain : f._writableState?.needDrain) !== !0
				)
			}
			onData(t) {
				let { res: r } = this
				return r ? r.write(t) : !0
			}
			onComplete(t) {
				let { res: r } = this
				qne(this), r && ((this.trailers = cc.parseHeaders(t)), r.end())
			}
			onError(t) {
				let { res: r, callback: n, opaque: i, body: s } = this
				qne(this),
					(this.factory = null),
					r
						? ((this.res = null), cc.destroy(r, t))
						: n &&
							((this.callback = null),
							queueMicrotask(() => {
								this.runInAsyncScope(n, null, t, { opaque: i })
							})),
					s && ((this.body = null), cc.destroy(s, t))
			}
		}
	function Vne(e, t, r) {
		if (r === void 0)
			return new Promise((n, i) => {
				Vne.call(this, e, t, (s, o) => (s ? i(s) : n(o)))
			})
		try {
			this.dispatch(e, new Vq(e, t, r))
		} catch (n) {
			if (typeof r != "function") throw n
			let i = e?.opaque
			queueMicrotask(() => r(n, { opaque: i }))
		}
	}
	Hne.exports = Vne
})
var Kne = x((FIt, Yne) => {
	"use strict"
	var { Readable: $ne, Duplex: A9e, PassThrough: m9e } = require("stream"),
		{ InvalidArgumentError: nb, InvalidReturnValueError: y9e, RequestAbortedError: Hq } = Vr(),
		ol = Xt(),
		{ AsyncResource: C9e } = require("async_hooks"),
		{ addSignal: v9e, removeSignal: E9e } = rb(),
		Gne = require("assert"),
		y0 = Symbol("resume"),
		Wq = class extends $ne {
			constructor() {
				super({ autoDestroy: !0 }), (this[y0] = null)
			}
			_read() {
				let { [y0]: t } = this
				t && ((this[y0] = null), t())
			}
			_destroy(t, r) {
				this._read(), r(t)
			}
		},
		Gq = class extends $ne {
			constructor(t) {
				super({ autoDestroy: !0 }), (this[y0] = t)
			}
			_read() {
				this[y0]()
			}
			_destroy(t, r) {
				!t && !this._readableState.endEmitted && (t = new Hq()), r(t)
			}
		},
		$q = class extends C9e {
			constructor(t, r) {
				if (!t || typeof t != "object") throw new nb("invalid opts")
				if (typeof r != "function") throw new nb("invalid handler")
				let { signal: n, method: i, opaque: s, onInfo: o, responseHeaders: a } = t
				if (n && typeof n.on != "function" && typeof n.addEventListener != "function")
					throw new nb("signal must be an EventEmitter or EventTarget")
				if (i === "CONNECT") throw new nb("invalid method")
				if (o && typeof o != "function") throw new nb("invalid onInfo callback")
				super("UNDICI_PIPELINE"),
					(this.opaque = s || null),
					(this.responseHeaders = a || null),
					(this.handler = r),
					(this.abort = null),
					(this.context = null),
					(this.onInfo = o || null),
					(this.req = new Wq().on("error", ol.nop)),
					(this.ret = new A9e({
						readableObjectMode: t.objectMode,
						autoDestroy: !0,
						read: () => {
							let { body: l } = this
							l?.resume && l.resume()
						},
						write: (l, c, u) => {
							let { req: f } = this
							f.push(l, c) || f._readableState.destroyed ? u() : (f[y0] = u)
						},
						destroy: (l, c) => {
							let { body: u, req: f, res: p, ret: g, abort: m } = this
							!l && !g._readableState.endEmitted && (l = new Hq()),
								m && l && m(),
								ol.destroy(u, l),
								ol.destroy(f, l),
								ol.destroy(p, l),
								E9e(this),
								c(l)
						},
					}).on("prefinish", () => {
						let { req: l } = this
						l.push(null)
					})),
					(this.res = null),
					v9e(this, n)
			}
			onConnect(t, r) {
				let { ret: n, res: i } = this
				if (this.reason) {
					t(this.reason)
					return
				}
				Gne(!i, "pipeline cannot be retried"), Gne(!n.destroyed), (this.abort = t), (this.context = r)
			}
			onHeaders(t, r, n) {
				let { opaque: i, handler: s, context: o } = this
				if (t < 200) {
					if (this.onInfo) {
						let l = this.responseHeaders === "raw" ? ol.parseRawHeaders(r) : ol.parseHeaders(r)
						this.onInfo({ statusCode: t, headers: l })
					}
					return
				}
				this.res = new Gq(n)
				let a
				try {
					this.handler = null
					let l = this.responseHeaders === "raw" ? ol.parseRawHeaders(r) : ol.parseHeaders(r)
					a = this.runInAsyncScope(s, null, {
						statusCode: t,
						headers: l,
						opaque: i,
						body: this.res,
						context: o,
					})
				} catch (l) {
					throw (this.res.on("error", ol.nop), l)
				}
				if (!a || typeof a.on != "function") throw new y9e("expected Readable")
				a
					.on("data", (l) => {
						let { ret: c, body: u } = this
						!c.push(l) && u.pause && u.pause()
					})
					.on("error", (l) => {
						let { ret: c } = this
						ol.destroy(c, l)
					})
					.on("end", () => {
						let { ret: l } = this
						l.push(null)
					})
					.on("close", () => {
						let { ret: l } = this
						l._readableState.ended || ol.destroy(l, new Hq())
					}),
					(this.body = a)
			}
			onData(t) {
				let { res: r } = this
				return r.push(t)
			}
			onComplete(t) {
				let { res: r } = this
				r.push(null)
			}
			onError(t) {
				let { ret: r } = this
				;(this.handler = null), ol.destroy(r, t)
			}
		}
	function b9e(e, t) {
		try {
			let r = new $q(e, t)
			return this.dispatch({ ...e, body: r.req }, r), r.ret
		} catch (r) {
			return new m9e().destroy(r)
		}
	}
	Yne.exports = b9e
})
var eie = x((QIt, Xne) => {
	"use strict"
	var { InvalidArgumentError: Yq, SocketError: x9e } = Vr(),
		{ AsyncResource: _9e } = require("async_hooks"),
		Jne = Xt(),
		{ addSignal: w9e, removeSignal: zne } = rb(),
		jne = require("assert"),
		Kq = class extends _9e {
			constructor(t, r) {
				if (!t || typeof t != "object") throw new Yq("invalid opts")
				if (typeof r != "function") throw new Yq("invalid callback")
				let { signal: n, opaque: i, responseHeaders: s } = t
				if (n && typeof n.on != "function" && typeof n.addEventListener != "function")
					throw new Yq("signal must be an EventEmitter or EventTarget")
				super("UNDICI_UPGRADE"),
					(this.responseHeaders = s || null),
					(this.opaque = i || null),
					(this.callback = r),
					(this.abort = null),
					(this.context = null),
					w9e(this, n)
			}
			onConnect(t, r) {
				if (this.reason) {
					t(this.reason)
					return
				}
				jne(this.callback), (this.abort = t), (this.context = null)
			}
			onHeaders() {
				throw new x9e("bad upgrade", null)
			}
			onUpgrade(t, r, n) {
				jne(t === 101)
				let { callback: i, opaque: s, context: o } = this
				zne(this), (this.callback = null)
				let a = this.responseHeaders === "raw" ? Jne.parseRawHeaders(r) : Jne.parseHeaders(r)
				this.runInAsyncScope(i, null, null, {
					headers: a,
					socket: n,
					opaque: s,
					context: o,
				})
			}
			onError(t) {
				let { callback: r, opaque: n } = this
				zne(this),
					r &&
						((this.callback = null),
						queueMicrotask(() => {
							this.runInAsyncScope(r, null, t, { opaque: n })
						}))
			}
		}
	function Zne(e, t) {
		if (t === void 0)
			return new Promise((r, n) => {
				Zne.call(this, e, (i, s) => (i ? n(i) : r(s)))
			})
		try {
			let r = new Kq(e, t)
			this.dispatch({ ...e, method: e.method || "GET", upgrade: e.protocol || "Websocket" }, r)
		} catch (r) {
			if (typeof t != "function") throw r
			let n = e?.opaque
			queueMicrotask(() => t(r, { opaque: n }))
		}
	}
	Xne.exports = Zne
})
var sie = x((NIt, iie) => {
	"use strict"
	var I9e = require("assert"),
		{ AsyncResource: S9e } = require("async_hooks"),
		{ InvalidArgumentError: Jq, SocketError: B9e } = Vr(),
		tie = Xt(),
		{ addSignal: D9e, removeSignal: rie } = rb(),
		zq = class extends S9e {
			constructor(t, r) {
				if (!t || typeof t != "object") throw new Jq("invalid opts")
				if (typeof r != "function") throw new Jq("invalid callback")
				let { signal: n, opaque: i, responseHeaders: s } = t
				if (n && typeof n.on != "function" && typeof n.addEventListener != "function")
					throw new Jq("signal must be an EventEmitter or EventTarget")
				super("UNDICI_CONNECT"),
					(this.opaque = i || null),
					(this.responseHeaders = s || null),
					(this.callback = r),
					(this.abort = null),
					D9e(this, n)
			}
			onConnect(t, r) {
				if (this.reason) {
					t(this.reason)
					return
				}
				I9e(this.callback), (this.abort = t), (this.context = r)
			}
			onHeaders() {
				throw new B9e("bad connect", null)
			}
			onUpgrade(t, r, n) {
				let { callback: i, opaque: s, context: o } = this
				rie(this), (this.callback = null)
				let a = r
				a != null && (a = this.responseHeaders === "raw" ? tie.parseRawHeaders(r) : tie.parseHeaders(r)),
					this.runInAsyncScope(i, null, null, {
						statusCode: t,
						headers: a,
						socket: n,
						opaque: s,
						context: o,
					})
			}
			onError(t) {
				let { callback: r, opaque: n } = this
				rie(this),
					r &&
						((this.callback = null),
						queueMicrotask(() => {
							this.runInAsyncScope(r, null, t, { opaque: n })
						}))
			}
		}
	function nie(e, t) {
		if (t === void 0)
			return new Promise((r, n) => {
				nie.call(this, e, (i, s) => (i ? n(i) : r(s)))
			})
		try {
			let r = new zq(e, t)
			this.dispatch({ ...e, method: "CONNECT" }, r)
		} catch (r) {
			if (typeof t != "function") throw r
			let n = e?.opaque
			queueMicrotask(() => t(r, { opaque: n }))
		}
	}
	iie.exports = nie
})
var oie = x((PIt, C0) => {
	"use strict"
	C0.exports.request = Pne()
	C0.exports.stream = Wne()
	C0.exports.pipeline = Kne()
	C0.exports.upgrade = eie()
	C0.exports.connect = sie()
})
var Zq = x((LIt, aie) => {
	"use strict"
	var { UndiciError: T9e } = Vr(),
		jq = class e extends T9e {
			constructor(t) {
				super(t),
					Error.captureStackTrace(this, e),
					(this.name = "MockNotMatchedError"),
					(this.message = t || "The request does not match any registered mock dispatches"),
					(this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED")
			}
		}
	aie.exports = { MockNotMatchedError: jq }
})
var v0 = x((UIt, lie) => {
	"use strict"
	lie.exports = {
		kAgent: Symbol("agent"),
		kOptions: Symbol("options"),
		kFactory: Symbol("factory"),
		kDispatches: Symbol("dispatches"),
		kDispatchKey: Symbol("dispatch key"),
		kDefaultHeaders: Symbol("default headers"),
		kDefaultTrailers: Symbol("default trailers"),
		kContentLength: Symbol("content length"),
		kMockAgent: Symbol("mock agent"),
		kMockAgentSet: Symbol("mock agent set"),
		kMockAgentGet: Symbol("mock agent get"),
		kMockDispatch: Symbol("mock dispatch"),
		kClose: Symbol("close"),
		kOriginalClose: Symbol("original agent close"),
		kOrigin: Symbol("origin"),
		kIsMockActive: Symbol("is mock active"),
		kNetConnect: Symbol("net connect"),
		kGetNetConnect: Symbol("get net connect"),
		kConnected: Symbol("connected"),
	}
})
var ib = x((OIt, Cie) => {
	"use strict"
	var { MockNotMatchedError: fp } = Zq(),
		{ kDispatches: nD, kMockAgent: R9e, kOriginalDispatch: k9e, kOrigin: M9e, kGetNetConnect: F9e } = v0(),
		{ buildURL: Q9e } = Xt(),
		{ STATUS_CODES: N9e } = require("http"),
		{
			types: { isPromise: P9e },
		} = require("util")
	function kd(e, t) {
		return typeof e == "string"
			? e === t
			: e instanceof RegExp
				? e.test(t)
				: typeof e == "function"
					? e(t) === !0
					: !1
	}
	function uie(e) {
		return Object.fromEntries(Object.entries(e).map(([t, r]) => [t.toLocaleLowerCase(), r]))
	}
	function die(e, t) {
		if (Array.isArray(e)) {
			for (let r = 0; r < e.length; r += 2)
				if (e[r].toLocaleLowerCase() === t.toLocaleLowerCase()) return e[r + 1]
			return
		} else return typeof e.get == "function" ? e.get(t) : uie(e)[t.toLocaleLowerCase()]
	}
	function tV(e) {
		let t = e.slice(),
			r = []
		for (let n = 0; n < t.length; n += 2) r.push([t[n], t[n + 1]])
		return Object.fromEntries(r)
	}
	function fie(e, t) {
		if (typeof e.headers == "function") return Array.isArray(t) && (t = tV(t)), e.headers(t ? uie(t) : {})
		if (typeof e.headers > "u") return !0
		if (typeof t != "object" || typeof e.headers != "object") return !1
		for (let [r, n] of Object.entries(e.headers)) {
			let i = die(t, r)
			if (!kd(n, i)) return !1
		}
		return !0
	}
	function cie(e) {
		if (typeof e != "string") return e
		let t = e.split("?")
		if (t.length !== 2) return e
		let r = new URLSearchParams(t.pop())
		return r.sort(), [...t, r.toString()].join("?")
	}
	function L9e(e, { path: t, method: r, body: n, headers: i }) {
		let s = kd(e.path, t),
			o = kd(e.method, r),
			a = typeof e.body < "u" ? kd(e.body, n) : !0,
			l = fie(e, i)
		return s && o && a && l
	}
	function hie(e) {
		return Buffer.isBuffer(e) || e instanceof Uint8Array || e instanceof ArrayBuffer
			? e
			: typeof e == "object"
				? JSON.stringify(e)
				: e.toString()
	}
	function gie(e, t) {
		let r = t.query ? Q9e(t.path, t.query) : t.path,
			n = typeof r == "string" ? cie(r) : r,
			i = e.filter(({ consumed: s }) => !s).filter(({ path: s }) => kd(cie(s), n))
		if (i.length === 0) throw new fp(`Mock dispatch not matched for path '${n}'`)
		if (((i = i.filter(({ method: s }) => kd(s, t.method))), i.length === 0))
			throw new fp(`Mock dispatch not matched for method '${t.method}' on path '${n}'`)
		if (((i = i.filter(({ body: s }) => (typeof s < "u" ? kd(s, t.body) : !0))), i.length === 0))
			throw new fp(`Mock dispatch not matched for body '${t.body}' on path '${n}'`)
		if (((i = i.filter((s) => fie(s, t.headers))), i.length === 0)) {
			let s = typeof t.headers == "object" ? JSON.stringify(t.headers) : t.headers
			throw new fp(`Mock dispatch not matched for headers '${s}' on path '${n}'`)
		}
		return i[0]
	}
	function U9e(e, t, r) {
		let n = { timesInvoked: 0, times: 1, persist: !1, consumed: !1 },
			i = typeof r == "function" ? { callback: r } : { ...r },
			s = { ...n, ...t, pending: !0, data: { error: null, ...i } }
		return e.push(s), s
	}
	function Xq(e, t) {
		let r = e.findIndex((n) => (n.consumed ? L9e(n, t) : !1))
		r !== -1 && e.splice(r, 1)
	}
	function pie(e) {
		let { path: t, method: r, body: n, headers: i, query: s } = e
		return { path: t, method: r, body: n, headers: i, query: s }
	}
	function eV(e) {
		let t = Object.keys(e),
			r = []
		for (let n = 0; n < t.length; ++n) {
			let i = t[n],
				s = e[i],
				o = Buffer.from(`${i}`)
			if (Array.isArray(s)) for (let a = 0; a < s.length; ++a) r.push(o, Buffer.from(`${s[a]}`))
			else r.push(o, Buffer.from(`${s}`))
		}
		return r
	}
	function Aie(e) {
		return N9e[e] || "unknown"
	}
	async function O9e(e) {
		let t = []
		for await (let r of e) t.push(r)
		return Buffer.concat(t).toString("utf8")
	}
	function mie(e, t) {
		let r = pie(e),
			n = gie(this[nD], r)
		n.timesInvoked++, n.data.callback && (n.data = { ...n.data, ...n.data.callback(e) })
		let {
				data: { statusCode: i, data: s, headers: o, trailers: a, error: l },
				delay: c,
				persist: u,
			} = n,
			{ timesInvoked: f, times: p } = n
		if (((n.consumed = !u && f >= p), (n.pending = f < p), l !== null)) return Xq(this[nD], r), t.onError(l), !0
		typeof c == "number" && c > 0
			? setTimeout(() => {
					g(this[nD])
				}, c)
			: g(this[nD])
		function g(y, C = s) {
			let v = Array.isArray(e.headers) ? tV(e.headers) : e.headers,
				b = typeof C == "function" ? C({ ...e, headers: v }) : C
			if (P9e(b)) {
				b.then((Q) => g(y, Q))
				return
			}
			let w = hie(b),
				B = eV(o),
				M = eV(a)
			t.onConnect?.((Q) => t.onError(Q), null),
				t.onHeaders?.(i, B, m, Aie(i)),
				t.onData?.(Buffer.from(w)),
				t.onComplete?.(M),
				Xq(y, r)
		}
		function m() {}
		return !0
	}
	function q9e() {
		let e = this[R9e],
			t = this[M9e],
			r = this[k9e]
		return function (i, s) {
			if (e.isMockActive)
				try {
					mie.call(this, i, s)
				} catch (o) {
					if (o instanceof fp) {
						let a = e[F9e]()
						if (a === !1)
							throw new fp(
								`${o.message}: subsequent request to origin ${t} was not allowed (net.connect disabled)`,
							)
						if (yie(a, t)) r.call(this, i, s)
						else
							throw new fp(
								`${o.message}: subsequent request to origin ${t} was not allowed (net.connect is not enabled for this origin)`,
							)
					} else throw o
				}
			else r.call(this, i, s)
		}
	}
	function yie(e, t) {
		let r = new URL(t)
		return e === !0 ? !0 : !!(Array.isArray(e) && e.some((n) => kd(n, r.host)))
	}
	function V9e(e) {
		if (e) {
			let { agent: t, ...r } = e
			return r
		}
	}
	Cie.exports = {
		getResponseData: hie,
		getMockDispatch: gie,
		addMockDispatch: U9e,
		deleteMockDispatch: Xq,
		buildKey: pie,
		generateKeyValues: eV,
		matchValue: kd,
		getResponse: O9e,
		getStatusText: Aie,
		mockDispatch: mie,
		buildMockDispatch: q9e,
		checkNetConnect: yie,
		buildMockOptions: V9e,
		getHeaderByName: die,
		buildHeadersFromArray: tV,
	}
})
var lV = x((qIt, aV) => {
	"use strict"
	var { getResponseData: H9e, buildKey: W9e, addMockDispatch: rV } = ib(),
		{
			kDispatches: iD,
			kDispatchKey: sD,
			kDefaultHeaders: nV,
			kDefaultTrailers: iV,
			kContentLength: sV,
			kMockDispatch: oD,
		} = v0(),
		{ InvalidArgumentError: cu } = Vr(),
		{ buildURL: G9e } = Xt(),
		E0 = class {
			constructor(t) {
				this[oD] = t
			}
			delay(t) {
				if (typeof t != "number" || !Number.isInteger(t) || t <= 0)
					throw new cu("waitInMs must be a valid integer > 0")
				return (this[oD].delay = t), this
			}
			persist() {
				return (this[oD].persist = !0), this
			}
			times(t) {
				if (typeof t != "number" || !Number.isInteger(t) || t <= 0)
					throw new cu("repeatTimes must be a valid integer > 0")
				return (this[oD].times = t), this
			}
		},
		oV = class {
			constructor(t, r) {
				if (typeof t != "object") throw new cu("opts must be an object")
				if (typeof t.path > "u") throw new cu("opts.path must be defined")
				if ((typeof t.method > "u" && (t.method = "GET"), typeof t.path == "string"))
					if (t.query) t.path = G9e(t.path, t.query)
					else {
						let n = new URL(t.path, "data://")
						t.path = n.pathname + n.search
					}
				typeof t.method == "string" && (t.method = t.method.toUpperCase()),
					(this[sD] = W9e(t)),
					(this[iD] = r),
					(this[nV] = {}),
					(this[iV] = {}),
					(this[sV] = !1)
			}
			createMockScopeDispatchData({ statusCode: t, data: r, responseOptions: n }) {
				let i = H9e(r),
					s = this[sV] ? { "content-length": i.length } : {},
					o = { ...this[nV], ...s, ...n.headers },
					a = { ...this[iV], ...n.trailers }
				return { statusCode: t, data: r, headers: o, trailers: a }
			}
			validateReplyParameters(t) {
				if (typeof t.statusCode > "u") throw new cu("statusCode must be defined")
				if (typeof t.responseOptions != "object" || t.responseOptions === null)
					throw new cu("responseOptions must be an object")
			}
			reply(t) {
				if (typeof t == "function") {
					let s = (a) => {
							let l = t(a)
							if (typeof l != "object" || l === null)
								throw new cu("reply options callback must return an object")
							let c = { data: "", responseOptions: {}, ...l }
							return this.validateReplyParameters(c), { ...this.createMockScopeDispatchData(c) }
						},
						o = rV(this[iD], this[sD], s)
					return new E0(o)
				}
				let r = {
					statusCode: t,
					data: arguments[1] === void 0 ? "" : arguments[1],
					responseOptions: arguments[2] === void 0 ? {} : arguments[2],
				}
				this.validateReplyParameters(r)
				let n = this.createMockScopeDispatchData(r),
					i = rV(this[iD], this[sD], n)
				return new E0(i)
			}
			replyWithError(t) {
				if (typeof t > "u") throw new cu("error must be defined")
				let r = rV(this[iD], this[sD], { error: t })
				return new E0(r)
			}
			defaultReplyHeaders(t) {
				if (typeof t > "u") throw new cu("headers must be defined")
				return (this[nV] = t), this
			}
			defaultReplyTrailers(t) {
				if (typeof t > "u") throw new cu("trailers must be defined")
				return (this[iV] = t), this
			}
			replyContentLength() {
				return (this[sV] = !0), this
			}
		}
	aV.exports.MockInterceptor = oV
	aV.exports.MockScope = E0
})
var dV = x((VIt, Iie) => {
	"use strict"
	var { promisify: $9e } = require("util"),
		Y9e = $E(),
		{ buildMockDispatch: K9e } = ib(),
		{
			kDispatches: vie,
			kMockAgent: Eie,
			kClose: bie,
			kOriginalClose: xie,
			kOrigin: _ie,
			kOriginalDispatch: J9e,
			kConnected: cV,
		} = v0(),
		{ MockInterceptor: z9e } = lV(),
		wie = Qn(),
		{ InvalidArgumentError: j9e } = Vr(),
		uV = class extends Y9e {
			constructor(t, r) {
				if ((super(t, r), !r || !r.agent || typeof r.agent.dispatch != "function"))
					throw new j9e("Argument opts.agent must implement Agent")
				;(this[Eie] = r.agent),
					(this[_ie] = t),
					(this[vie] = []),
					(this[cV] = 1),
					(this[J9e] = this.dispatch),
					(this[xie] = this.close.bind(this)),
					(this.dispatch = K9e.call(this)),
					(this.close = this[bie])
			}
			get [wie.kConnected]() {
				return this[cV]
			}
			intercept(t) {
				return new z9e(t, this[vie])
			}
			async [bie]() {
				await $9e(this[xie])(), (this[cV] = 0), this[Eie][wie.kClients].delete(this[_ie])
			}
		}
	Iie.exports = uV
})
var gV = x((HIt, Mie) => {
	"use strict"
	var { promisify: Z9e } = require("util"),
		X9e = f0(),
		{ buildMockDispatch: e$e } = ib(),
		{
			kDispatches: Sie,
			kMockAgent: Bie,
			kClose: Die,
			kOriginalClose: Tie,
			kOrigin: Rie,
			kOriginalDispatch: t$e,
			kConnected: fV,
		} = v0(),
		{ MockInterceptor: r$e } = lV(),
		kie = Qn(),
		{ InvalidArgumentError: n$e } = Vr(),
		hV = class extends X9e {
			constructor(t, r) {
				if ((super(t, r), !r || !r.agent || typeof r.agent.dispatch != "function"))
					throw new n$e("Argument opts.agent must implement Agent")
				;(this[Bie] = r.agent),
					(this[Rie] = t),
					(this[Sie] = []),
					(this[fV] = 1),
					(this[t$e] = this.dispatch),
					(this[Tie] = this.close.bind(this)),
					(this.dispatch = e$e.call(this)),
					(this.close = this[Die])
			}
			get [kie.kConnected]() {
				return this[fV]
			}
			intercept(t) {
				return new r$e(t, this[Sie])
			}
			async [Die]() {
				await Z9e(this[Tie])(), (this[fV] = 0), this[Bie][kie.kClients].delete(this[Rie])
			}
		}
	Mie.exports = hV
})
var Qie = x((GIt, Fie) => {
	"use strict"
	var i$e = { pronoun: "it", is: "is", was: "was", this: "this" },
		s$e = { pronoun: "they", is: "are", was: "were", this: "these" }
	Fie.exports = class {
		constructor(t, r) {
			;(this.singular = t), (this.plural = r)
		}
		pluralize(t) {
			let r = t === 1,
				n = r ? i$e : s$e,
				i = r ? this.singular : this.plural
			return { ...n, count: t, noun: i }
		}
	}
})
var Pie = x((YIt, Nie) => {
	"use strict"
	var { Transform: o$e } = require("stream"),
		{ Console: a$e } = require("console"),
		l$e = process.versions.icu ? "\u2705" : "Y ",
		c$e = process.versions.icu ? "\u274C" : "N "
	Nie.exports = class {
		constructor({ disableColors: t } = {}) {
			;(this.transform = new o$e({
				transform(r, n, i) {
					i(null, r)
				},
			})),
				(this.logger = new a$e({
					stdout: this.transform,
					inspectOptions: { colors: !t && !process.env.CI },
				}))
		}
		format(t) {
			let r = t.map(
				({
					method: n,
					path: i,
					data: { statusCode: s },
					persist: o,
					times: a,
					timesInvoked: l,
					origin: c,
				}) => ({
					Method: n,
					Origin: c,
					Path: i,
					"Status code": s,
					Persistent: o ? l$e : c$e,
					Invocations: l,
					Remaining: o ? 1 / 0 : a - l,
				}),
			)
			return this.logger.table(r), this.transform.read().toString()
		}
	}
})
var qie = x((KIt, Oie) => {
	"use strict"
	var { kClients: hp } = Qn(),
		u$e = h0(),
		{
			kAgent: pV,
			kMockAgentSet: aD,
			kMockAgentGet: Lie,
			kDispatches: AV,
			kIsMockActive: lD,
			kNetConnect: gp,
			kGetNetConnect: d$e,
			kOptions: cD,
			kFactory: uD,
		} = v0(),
		f$e = dV(),
		h$e = gV(),
		{ matchValue: g$e, buildMockOptions: p$e } = ib(),
		{ InvalidArgumentError: Uie, UndiciError: A$e } = Vr(),
		m$e = _E(),
		y$e = Qie(),
		C$e = Pie(),
		mV = class extends m$e {
			constructor(t) {
				if ((super(t), (this[gp] = !0), (this[lD] = !0), t?.agent && typeof t.agent.dispatch != "function"))
					throw new Uie("Argument opts.agent must implement Agent")
				let r = t?.agent ? t.agent : new u$e(t)
				;(this[pV] = r), (this[hp] = r[hp]), (this[cD] = p$e(t))
			}
			get(t) {
				let r = this[Lie](t)
				return r || ((r = this[uD](t)), this[aD](t, r)), r
			}
			dispatch(t, r) {
				return this.get(t.origin), this[pV].dispatch(t, r)
			}
			async close() {
				await this[pV].close(), this[hp].clear()
			}
			deactivate() {
				this[lD] = !1
			}
			activate() {
				this[lD] = !0
			}
			enableNetConnect(t) {
				if (typeof t == "string" || typeof t == "function" || t instanceof RegExp)
					Array.isArray(this[gp]) ? this[gp].push(t) : (this[gp] = [t])
				else if (typeof t > "u") this[gp] = !0
				else throw new Uie("Unsupported matcher. Must be one of String|Function|RegExp.")
			}
			disableNetConnect() {
				this[gp] = !1
			}
			get isMockActive() {
				return this[lD]
			}
			[aD](t, r) {
				this[hp].set(t, r)
			}
			[uD](t) {
				let r = Object.assign({ agent: this }, this[cD])
				return this[cD] && this[cD].connections === 1 ? new f$e(t, r) : new h$e(t, r)
			}
			[Lie](t) {
				let r = this[hp].get(t)
				if (r) return r
				if (typeof t != "string") {
					let n = this[uD]("http://localhost:9999")
					return this[aD](t, n), n
				}
				for (let [n, i] of Array.from(this[hp]))
					if (i && typeof n != "string" && g$e(n, t)) {
						let s = this[uD](t)
						return this[aD](t, s), (s[AV] = i[AV]), s
					}
			}
			[d$e]() {
				return this[gp]
			}
			pendingInterceptors() {
				let t = this[hp]
				return Array.from(t.entries())
					.flatMap(([r, n]) => n[AV].map((i) => ({ ...i, origin: r })))
					.filter(({ pending: r }) => r)
			}
			assertNoPendingInterceptors({ pendingInterceptorsFormatter: t = new C$e() } = {}) {
				let r = this.pendingInterceptors()
				if (r.length === 0) return
				let n = new y$e("interceptor", "interceptors").pluralize(r.length)
				throw new A$e(
					`
${n.count} ${n.noun} ${n.is} pending:

${t.format(r)}
`.trim(),
				)
			}
		}
	Oie.exports = mV
})
var dD = x((JIt, Gie) => {
	"use strict"
	var Vie = Symbol.for("undici.globalDispatcher.1"),
		{ InvalidArgumentError: v$e } = Vr(),
		E$e = h0()
	Wie() === void 0 && Hie(new E$e())
	function Hie(e) {
		if (!e || typeof e.dispatch != "function") throw new v$e("Argument agent must implement Agent")
		Object.defineProperty(globalThis, Vie, {
			value: e,
			writable: !0,
			enumerable: !1,
			configurable: !1,
		})
	}
	function Wie() {
		return globalThis[Vie]
	}
	Gie.exports = { setGlobalDispatcher: Hie, getGlobalDispatcher: Wie }
})
var fD = x((jIt, $ie) => {
	"use strict"
	$ie.exports = class {
		#e
		constructor(t) {
			if (typeof t != "object" || t === null) throw new TypeError("handler must be an object")
			this.#e = t
		}
		onConnect(...t) {
			return this.#e.onConnect?.(...t)
		}
		onError(...t) {
			return this.#e.onError?.(...t)
		}
		onUpgrade(...t) {
			return this.#e.onUpgrade?.(...t)
		}
		onResponseStarted(...t) {
			return this.#e.onResponseStarted?.(...t)
		}
		onHeaders(...t) {
			return this.#e.onHeaders?.(...t)
		}
		onData(...t) {
			return this.#e.onData?.(...t)
		}
		onComplete(...t) {
			return this.#e.onComplete?.(...t)
		}
		onBodySent(...t) {
			return this.#e.onBodySent?.(...t)
		}
	}
})
var Kie = x((ZIt, Yie) => {
	"use strict"
	var b$e = WB()
	Yie.exports = (e) => {
		let t = e?.maxRedirections
		return (r) =>
			function (i, s) {
				let { maxRedirections: o = t, ...a } = i
				if (!o) return r(i, s)
				let l = new b$e(r, o, i, s)
				return r(a, l)
			}
	}
})
var zie = x((XIt, Jie) => {
	"use strict"
	var x$e = tD()
	Jie.exports = (e) => (t) =>
		function (n, i) {
			return t(n, new x$e({ ...n, retryOptions: { ...e, ...n.retryOptions } }, { handler: i, dispatch: t }))
		}
})
var Zie = x((eSt, jie) => {
	"use strict"
	var _$e = Xt(),
		{ InvalidArgumentError: w$e, RequestAbortedError: I$e } = Vr(),
		S$e = fD(),
		yV = class extends S$e {
			#e = 1024 * 1024
			#t = null
			#i = !1
			#n = !1
			#r = 0
			#l = null
			#o = null
			constructor({ maxSize: t }, r) {
				if ((super(r), t != null && (!Number.isFinite(t) || t < 1)))
					throw new w$e("maxSize must be a number greater than 0")
				;(this.#e = t ?? this.#e), (this.#o = r)
			}
			onConnect(t) {
				;(this.#t = t), this.#o.onConnect(this.#u.bind(this))
			}
			#u(t) {
				;(this.#n = !0), (this.#l = t)
			}
			onHeaders(t, r, n, i) {
				let o = _$e.parseHeaders(r)["content-length"]
				if (o != null && o > this.#e) throw new I$e(`Response size (${o}) larger than maxSize (${this.#e})`)
				return this.#n ? !0 : this.#o.onHeaders(t, r, n, i)
			}
			onError(t) {
				this.#i || ((t = this.#l ?? t), this.#o.onError(t))
			}
			onData(t) {
				return (
					(this.#r = this.#r + t.length),
					this.#r >= this.#e && ((this.#i = !0), this.#n ? this.#o.onError(this.#l) : this.#o.onComplete([])),
					!0
				)
			}
			onComplete(t) {
				if (!this.#i) {
					if (this.#n) {
						this.#o.onError(this.reason)
						return
					}
					this.#o.onComplete(t)
				}
			}
		}
	function B$e({ maxSize: e } = { maxSize: 1024 * 1024 }) {
		return (t) =>
			function (n, i) {
				let { dumpMaxSize: s = e } = n,
					o = new yV({ maxSize: s }, i)
				return t(n, o)
			}
	}
	jie.exports = B$e
})
var tse = x((tSt, ese) => {
	"use strict"
	var { isIP: D$e } = require("net"),
		{ lookup: T$e } = require("dns"),
		R$e = fD(),
		{ InvalidArgumentError: b0, InformationalError: k$e } = Vr(),
		Xie = Math.pow(2, 31) - 1,
		CV = class {
			#e = 0
			#t = 0
			#i = new Map()
			dualStack = !0
			affinity = null
			lookup = null
			pick = null
			constructor(t) {
				;(this.#e = t.maxTTL),
					(this.#t = t.maxItems),
					(this.dualStack = t.dualStack),
					(this.affinity = t.affinity),
					(this.lookup = t.lookup ?? this.#n),
					(this.pick = t.pick ?? this.#r)
			}
			get full() {
				return this.#i.size === this.#t
			}
			runLookup(t, r, n) {
				let i = this.#i.get(t.hostname)
				if (i == null && this.full) {
					n(null, t.origin)
					return
				}
				let s = {
					affinity: this.affinity,
					dualStack: this.dualStack,
					lookup: this.lookup,
					pick: this.pick,
					...r.dns,
					maxTTL: this.#e,
					maxItems: this.#t,
				}
				if (i == null)
					this.lookup(t, s, (o, a) => {
						if (o || a == null || a.length === 0) {
							n(o ?? new k$e("No DNS entries found"))
							return
						}
						this.setRecords(t, a)
						let l = this.#i.get(t.hostname),
							c = this.pick(t, l, s.affinity),
							u
						typeof c.port == "number" ? (u = `:${c.port}`) : t.port !== "" ? (u = `:${t.port}`) : (u = ""),
							n(null, `${t.protocol}//${c.family === 6 ? `[${c.address}]` : c.address}${u}`)
					})
				else {
					let o = this.pick(t, i, s.affinity)
					if (o == null) {
						this.#i.delete(t.hostname), this.runLookup(t, r, n)
						return
					}
					let a
					typeof o.port == "number" ? (a = `:${o.port}`) : t.port !== "" ? (a = `:${t.port}`) : (a = ""),
						n(null, `${t.protocol}//${o.family === 6 ? `[${o.address}]` : o.address}${a}`)
				}
			}
			#n(t, r, n) {
				T$e(
					t.hostname,
					{
						all: !0,
						family: this.dualStack === !1 ? this.affinity : 0,
						order: "ipv4first",
					},
					(i, s) => {
						if (i) return n(i)
						let o = new Map()
						for (let a of s) o.set(`${a.address}:${a.family}`, a)
						n(null, o.values())
					},
				)
			}
			#r(t, r, n) {
				let i = null,
					{ records: s, offset: o } = r,
					a
				if (
					(this.dualStack
						? (n == null &&
								(o == null || o === Xie
									? ((r.offset = 0), (n = 4))
									: (r.offset++, (n = (r.offset & 1) === 1 ? 6 : 4))),
							s[n] != null && s[n].ips.length > 0 ? (a = s[n]) : (a = s[n === 4 ? 6 : 4]))
						: (a = s[n]),
					a == null || a.ips.length === 0)
				)
					return i
				a.offset == null || a.offset === Xie ? (a.offset = 0) : a.offset++
				let l = a.offset % a.ips.length
				return (
					(i = a.ips[l] ?? null),
					i == null ? i : Date.now() - i.timestamp > i.ttl ? (a.ips.splice(l, 1), this.pick(t, r, n)) : i
				)
			}
			setRecords(t, r) {
				let n = Date.now(),
					i = { records: { 4: null, 6: null } }
				for (let s of r) {
					;(s.timestamp = n),
						typeof s.ttl == "number" ? (s.ttl = Math.min(s.ttl, this.#e)) : (s.ttl = this.#e)
					let o = i.records[s.family] ?? { ips: [] }
					o.ips.push(s), (i.records[s.family] = o)
				}
				this.#i.set(t.hostname, i)
			}
			getHandler(t, r) {
				return new vV(this, t, r)
			}
		},
		vV = class extends R$e {
			#e = null
			#t = null
			#i = null
			#n = null
			#r = null
			constructor(t, { origin: r, handler: n, dispatch: i }, s) {
				super(n), (this.#r = r), (this.#n = n), (this.#t = { ...s }), (this.#e = t), (this.#i = i)
			}
			onError(t) {
				switch (t.code) {
					case "ETIMEDOUT":
					case "ECONNREFUSED": {
						if (this.#e.dualStack) {
							this.#e.runLookup(this.#r, this.#t, (r, n) => {
								if (r) return this.#n.onError(r)
								let i = { ...this.#t, origin: n }
								this.#i(i, this)
							})
							return
						}
						this.#n.onError(t)
						return
					}
					case "ENOTFOUND":
						this.#e.deleteRecord(this.#r)
					default:
						this.#n.onError(t)
						break
				}
			}
		}
	ese.exports = (e) => {
		if (e?.maxTTL != null && (typeof e?.maxTTL != "number" || e?.maxTTL < 0))
			throw new b0("Invalid maxTTL. Must be a positive number")
		if (e?.maxItems != null && (typeof e?.maxItems != "number" || e?.maxItems < 1))
			throw new b0("Invalid maxItems. Must be a positive number and greater than zero")
		if (e?.affinity != null && e?.affinity !== 4 && e?.affinity !== 6)
			throw new b0("Invalid affinity. Must be either 4 or 6")
		if (e?.dualStack != null && typeof e?.dualStack != "boolean")
			throw new b0("Invalid dualStack. Must be a boolean")
		if (e?.lookup != null && typeof e?.lookup != "function") throw new b0("Invalid lookup. Must be a function")
		if (e?.pick != null && typeof e?.pick != "function") throw new b0("Invalid pick. Must be a function")
		let t = e?.dualStack ?? !0,
			r
		t ? (r = e?.affinity ?? null) : (r = e?.affinity ?? 4)
		let n = {
				maxTTL: e?.maxTTL ?? 1e4,
				lookup: e?.lookup ?? null,
				pick: e?.pick ?? null,
				dualStack: t,
				affinity: r,
				maxItems: e?.maxItems ?? 1 / 0,
			},
			i = new CV(n)
		return (s) =>
			function (a, l) {
				let c = a.origin.constructor === URL ? a.origin : new URL(a.origin)
				return D$e(c.hostname) !== 0
					? s(a, l)
					: (i.runLookup(c, a, (u, f) => {
							if (u) return l.onError(u)
							let p = null
							;(p = {
								...a,
								servername: c.hostname,
								origin: f,
								headers: { host: c.hostname, ...a.headers },
							}),
								s(p, i.getHandler({ origin: c, dispatch: s, handler: l }, a))
						}),
						!0)
			}
	}
})
var pp = x((rSt, lse) => {
	"use strict"
	var { kConstruct: M$e } = Qn(),
		{ kEnumerableProperty: x0 } = Xt(),
		{ iteratorMixin: F$e, isValidHeaderName: sb, isValidHeaderValue: nse } = ga(),
		{ webidl: Er } = ys(),
		EV = require("assert"),
		hD = require("util"),
		wi = Symbol("headers map"),
		ma = Symbol("headers map sorted")
	function rse(e) {
		return e === 10 || e === 13 || e === 9 || e === 32
	}
	function ise(e) {
		let t = 0,
			r = e.length
		for (; r > t && rse(e.charCodeAt(r - 1)); ) --r
		for (; r > t && rse(e.charCodeAt(t)); ) ++t
		return t === 0 && r === e.length ? e : e.substring(t, r)
	}
	function sse(e, t) {
		if (Array.isArray(t))
			for (let r = 0; r < t.length; ++r) {
				let n = t[r]
				if (n.length !== 2)
					throw Er.errors.exception({
						header: "Headers constructor",
						message: `expected name/value pair to be length 2, found ${n.length}.`,
					})
				bV(e, n[0], n[1])
			}
		else if (typeof t == "object" && t !== null) {
			let r = Object.keys(t)
			for (let n = 0; n < r.length; ++n) bV(e, r[n], t[r[n]])
		} else
			throw Er.errors.conversionFailed({
				prefix: "Headers constructor",
				argument: "Argument 1",
				types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"],
			})
	}
	function bV(e, t, r) {
		if (((r = ise(r)), sb(t))) {
			if (!nse(r))
				throw Er.errors.invalidArgument({
					prefix: "Headers.append",
					value: r,
					type: "header value",
				})
		} else
			throw Er.errors.invalidArgument({
				prefix: "Headers.append",
				value: t,
				type: "header name",
			})
		if (ase(e) === "immutable") throw new TypeError("immutable")
		return xV(e).append(t, r, !1)
	}
	function ose(e, t) {
		return e[0] < t[0] ? -1 : 1
	}
	var gD = class e {
			cookies = null
			constructor(t) {
				t instanceof e
					? ((this[wi] = new Map(t[wi])),
						(this[ma] = t[ma]),
						(this.cookies = t.cookies === null ? null : [...t.cookies]))
					: ((this[wi] = new Map(t)), (this[ma] = null))
			}
			contains(t, r) {
				return this[wi].has(r ? t : t.toLowerCase())
			}
			clear() {
				this[wi].clear(), (this[ma] = null), (this.cookies = null)
			}
			append(t, r, n) {
				this[ma] = null
				let i = n ? t : t.toLowerCase(),
					s = this[wi].get(i)
				if (s) {
					let o = i === "cookie" ? "; " : ", "
					this[wi].set(i, { name: s.name, value: `${s.value}${o}${r}` })
				} else this[wi].set(i, { name: t, value: r })
				i === "set-cookie" && (this.cookies ??= []).push(r)
			}
			set(t, r, n) {
				this[ma] = null
				let i = n ? t : t.toLowerCase()
				i === "set-cookie" && (this.cookies = [r]), this[wi].set(i, { name: t, value: r })
			}
			delete(t, r) {
				;(this[ma] = null),
					r || (t = t.toLowerCase()),
					t === "set-cookie" && (this.cookies = null),
					this[wi].delete(t)
			}
			get(t, r) {
				return this[wi].get(r ? t : t.toLowerCase())?.value ?? null
			}
			*[Symbol.iterator]() {
				for (let {
					0: t,
					1: { value: r },
				} of this[wi])
					yield [t, r]
			}
			get entries() {
				let t = {}
				if (this[wi].size !== 0) for (let { name: r, value: n } of this[wi].values()) t[r] = n
				return t
			}
			rawValues() {
				return this[wi].values()
			}
			get entriesList() {
				let t = []
				if (this[wi].size !== 0)
					for (let {
						0: r,
						1: { name: n, value: i },
					} of this[wi])
						if (r === "set-cookie") for (let s of this.cookies) t.push([n, s])
						else t.push([n, i])
				return t
			}
			toSortedArray() {
				let t = this[wi].size,
					r = new Array(t)
				if (t <= 32) {
					if (t === 0) return r
					let n = this[wi][Symbol.iterator](),
						i = n.next().value
					;(r[0] = [i[0], i[1].value]), EV(i[1].value !== null)
					for (let s = 1, o = 0, a = 0, l = 0, c = 0, u, f; s < t; ++s) {
						for (
							f = n.next().value, u = r[s] = [f[0], f[1].value], EV(u[1] !== null), l = 0, a = s;
							l < a;

						)
							(c = l + ((a - l) >> 1)), r[c][0] <= u[0] ? (l = c + 1) : (a = c)
						if (s !== c) {
							for (o = s; o > l; ) r[o] = r[--o]
							r[l] = u
						}
					}
					if (!n.next().done) throw new TypeError("Unreachable")
					return r
				} else {
					let n = 0
					for (let {
						0: i,
						1: { value: s },
					} of this[wi])
						(r[n++] = [i, s]), EV(s !== null)
					return r.sort(ose)
				}
			}
		},
		uc = class e {
			#e
			#t
			constructor(t = void 0) {
				Er.util.markAsUncloneable(this),
					t !== M$e &&
						((this.#t = new gD()),
						(this.#e = "none"),
						t !== void 0 &&
							((t = Er.converters.HeadersInit(t, "Headers contructor", "init")), sse(this, t)))
			}
			append(t, r) {
				Er.brandCheck(this, e), Er.argumentLengthCheck(arguments, 2, "Headers.append")
				let n = "Headers.append"
				return (
					(t = Er.converters.ByteString(t, n, "name")),
					(r = Er.converters.ByteString(r, n, "value")),
					bV(this, t, r)
				)
			}
			delete(t) {
				Er.brandCheck(this, e), Er.argumentLengthCheck(arguments, 1, "Headers.delete")
				let r = "Headers.delete"
				if (((t = Er.converters.ByteString(t, r, "name")), !sb(t)))
					throw Er.errors.invalidArgument({
						prefix: "Headers.delete",
						value: t,
						type: "header name",
					})
				if (this.#e === "immutable") throw new TypeError("immutable")
				this.#t.contains(t, !1) && this.#t.delete(t, !1)
			}
			get(t) {
				Er.brandCheck(this, e), Er.argumentLengthCheck(arguments, 1, "Headers.get")
				let r = "Headers.get"
				if (((t = Er.converters.ByteString(t, r, "name")), !sb(t)))
					throw Er.errors.invalidArgument({
						prefix: r,
						value: t,
						type: "header name",
					})
				return this.#t.get(t, !1)
			}
			has(t) {
				Er.brandCheck(this, e), Er.argumentLengthCheck(arguments, 1, "Headers.has")
				let r = "Headers.has"
				if (((t = Er.converters.ByteString(t, r, "name")), !sb(t)))
					throw Er.errors.invalidArgument({
						prefix: r,
						value: t,
						type: "header name",
					})
				return this.#t.contains(t, !1)
			}
			set(t, r) {
				Er.brandCheck(this, e), Er.argumentLengthCheck(arguments, 2, "Headers.set")
				let n = "Headers.set"
				if (
					((t = Er.converters.ByteString(t, n, "name")),
					(r = Er.converters.ByteString(r, n, "value")),
					(r = ise(r)),
					sb(t))
				) {
					if (!nse(r))
						throw Er.errors.invalidArgument({
							prefix: n,
							value: r,
							type: "header value",
						})
				} else
					throw Er.errors.invalidArgument({
						prefix: n,
						value: t,
						type: "header name",
					})
				if (this.#e === "immutable") throw new TypeError("immutable")
				this.#t.set(t, r, !1)
			}
			getSetCookie() {
				Er.brandCheck(this, e)
				let t = this.#t.cookies
				return t ? [...t] : []
			}
			get [ma]() {
				if (this.#t[ma]) return this.#t[ma]
				let t = [],
					r = this.#t.toSortedArray(),
					n = this.#t.cookies
				if (n === null || n.length === 1) return (this.#t[ma] = r)
				for (let i = 0; i < r.length; ++i) {
					let { 0: s, 1: o } = r[i]
					if (s === "set-cookie") for (let a = 0; a < n.length; ++a) t.push([s, n[a]])
					else t.push([s, o])
				}
				return (this.#t[ma] = t)
			}
			[hD.inspect.custom](t, r) {
				return (r.depth ??= t), `Headers ${hD.formatWithOptions(r, this.#t.entries)}`
			}
			static getHeadersGuard(t) {
				return t.#e
			}
			static setHeadersGuard(t, r) {
				t.#e = r
			}
			static getHeadersList(t) {
				return t.#t
			}
			static setHeadersList(t, r) {
				t.#t = r
			}
		},
		{ getHeadersGuard: ase, setHeadersGuard: Q$e, getHeadersList: xV, setHeadersList: N$e } = uc
	Reflect.deleteProperty(uc, "getHeadersGuard")
	Reflect.deleteProperty(uc, "setHeadersGuard")
	Reflect.deleteProperty(uc, "getHeadersList")
	Reflect.deleteProperty(uc, "setHeadersList")
	F$e("Headers", uc, ma, 0, 1)
	Object.defineProperties(uc.prototype, {
		append: x0,
		delete: x0,
		get: x0,
		has: x0,
		set: x0,
		getSetCookie: x0,
		[Symbol.toStringTag]: { value: "Headers", configurable: !0 },
		[hD.inspect.custom]: { enumerable: !1 },
	})
	Er.converters.HeadersInit = function (e, t, r) {
		if (Er.util.Type(e) === "Object") {
			let n = Reflect.get(e, Symbol.iterator)
			if (!hD.types.isProxy(e) && n === uc.prototype.entries)
				try {
					return xV(e).entriesList
				} catch {}
			return typeof n == "function"
				? Er.converters["sequence<sequence<ByteString>>"](e, t, r, n.bind(e))
				: Er.converters["record<ByteString, ByteString>"](e, t, r)
		}
		throw Er.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"],
		})
	}
	lse.exports = {
		fill: sse,
		compareHeaderName: ose,
		Headers: uc,
		HeadersList: gD,
		getHeadersGuard: ase,
		setHeadersGuard: Q$e,
		setHeadersList: N$e,
		getHeadersList: xV,
	}
})
var ab = x((nSt, yse) => {
	"use strict"
	var {
			Headers: gse,
			HeadersList: cse,
			fill: P$e,
			getHeadersGuard: L$e,
			setHeadersGuard: pse,
			setHeadersList: Ase,
		} = pp(),
		{
			extractBody: use,
			cloneBody: U$e,
			mixinBody: O$e,
			hasFinalizationRegistry: q$e,
			streamRegistry: V$e,
			bodyUnusable: H$e,
		} = s0(),
		_V = Xt(),
		dse = require("util"),
		{ kEnumerableProperty: ya } = _V,
		{
			isValidReasonPhrase: W$e,
			isCancelled: G$e,
			isAborted: $$e,
			isBlobLike: Y$e,
			serializeJavascriptValueToJSONString: K$e,
			isErrorLike: J$e,
			isomorphicEncode: z$e,
			environmentSettingsObject: j$e,
		} = ga(),
		{ redirectStatusSet: Z$e, nullBodyStatus: X$e } = SE(),
		{ kState: ni, kHeaders: Md } = Gf(),
		{ webidl: Ht } = ys(),
		{ FormData: eYe } = ME(),
		{ URLSerializer: fse } = No(),
		{ kConstruct: AD } = Qn(),
		wV = require("assert"),
		{ types: tYe } = require("util"),
		rYe = new TextEncoder("utf-8"),
		Ap = class e {
			static error() {
				return ob(mD(), "immutable")
			}
			static json(t, r = {}) {
				Ht.argumentLengthCheck(arguments, 1, "Response.json"), r !== null && (r = Ht.converters.ResponseInit(r))
				let n = rYe.encode(K$e(t)),
					i = use(n),
					s = ob(_0({}), "response")
				return hse(s, r, { body: i[0], type: "application/json" }), s
			}
			static redirect(t, r = 302) {
				Ht.argumentLengthCheck(arguments, 1, "Response.redirect"),
					(t = Ht.converters.USVString(t)),
					(r = Ht.converters["unsigned short"](r))
				let n
				try {
					n = new URL(t, j$e.settingsObject.baseUrl)
				} catch (o) {
					throw new TypeError(`Failed to parse URL from ${t}`, { cause: o })
				}
				if (!Z$e.has(r)) throw new RangeError(`Invalid status code ${r}`)
				let i = ob(_0({}), "immutable")
				i[ni].status = r
				let s = z$e(fse(n))
				return i[ni].headersList.append("location", s, !0), i
			}
			constructor(t = null, r = {}) {
				if ((Ht.util.markAsUncloneable(this), t === AD)) return
				t !== null && (t = Ht.converters.BodyInit(t)),
					(r = Ht.converters.ResponseInit(r)),
					(this[ni] = _0({})),
					(this[Md] = new gse(AD)),
					pse(this[Md], "response"),
					Ase(this[Md], this[ni].headersList)
				let n = null
				if (t != null) {
					let [i, s] = use(t)
					n = { body: i, type: s }
				}
				hse(this, r, n)
			}
			get type() {
				return Ht.brandCheck(this, e), this[ni].type
			}
			get url() {
				Ht.brandCheck(this, e)
				let t = this[ni].urlList,
					r = t[t.length - 1] ?? null
				return r === null ? "" : fse(r, !0)
			}
			get redirected() {
				return Ht.brandCheck(this, e), this[ni].urlList.length > 1
			}
			get status() {
				return Ht.brandCheck(this, e), this[ni].status
			}
			get ok() {
				return Ht.brandCheck(this, e), this[ni].status >= 200 && this[ni].status <= 299
			}
			get statusText() {
				return Ht.brandCheck(this, e), this[ni].statusText
			}
			get headers() {
				return Ht.brandCheck(this, e), this[Md]
			}
			get body() {
				return Ht.brandCheck(this, e), this[ni].body ? this[ni].body.stream : null
			}
			get bodyUsed() {
				return Ht.brandCheck(this, e), !!this[ni].body && _V.isDisturbed(this[ni].body.stream)
			}
			clone() {
				if ((Ht.brandCheck(this, e), H$e(this)))
					throw Ht.errors.exception({
						header: "Response.clone",
						message: "Body has already been consumed.",
					})
				let t = IV(this[ni])
				return ob(t, L$e(this[Md]))
			}
			[dse.inspect.custom](t, r) {
				r.depth === null && (r.depth = 2), (r.colors ??= !0)
				let n = {
					status: this.status,
					statusText: this.statusText,
					headers: this.headers,
					body: this.body,
					bodyUsed: this.bodyUsed,
					ok: this.ok,
					redirected: this.redirected,
					type: this.type,
					url: this.url,
				}
				return `Response ${dse.formatWithOptions(r, n)}`
			}
		}
	O$e(Ap)
	Object.defineProperties(Ap.prototype, {
		type: ya,
		url: ya,
		status: ya,
		ok: ya,
		redirected: ya,
		statusText: ya,
		headers: ya,
		clone: ya,
		body: ya,
		bodyUsed: ya,
		[Symbol.toStringTag]: { value: "Response", configurable: !0 },
	})
	Object.defineProperties(Ap, { json: ya, redirect: ya, error: ya })
	function IV(e) {
		if (e.internalResponse) return mse(IV(e.internalResponse), e.type)
		let t = _0({ ...e, body: null })
		return e.body != null && (t.body = U$e(t, e.body)), t
	}
	function _0(e) {
		return {
			aborted: !1,
			rangeRequested: !1,
			timingAllowPassed: !1,
			requestIncludesCredentials: !1,
			type: "default",
			status: 200,
			timingInfo: null,
			cacheState: "",
			statusText: "",
			...e,
			headersList: e?.headersList ? new cse(e?.headersList) : new cse(),
			urlList: e?.urlList ? [...e.urlList] : [],
		}
	}
	function mD(e) {
		let t = J$e(e)
		return _0({
			type: "error",
			status: 0,
			error: t ? e : new Error(e && String(e)),
			aborted: e && e.name === "AbortError",
		})
	}
	function nYe(e) {
		return e.type === "error" && e.status === 0
	}
	function pD(e, t) {
		return (
			(t = { internalResponse: e, ...t }),
			new Proxy(e, {
				get(r, n) {
					return n in t ? t[n] : r[n]
				},
				set(r, n, i) {
					return wV(!(n in t)), (r[n] = i), !0
				},
			})
		)
	}
	function mse(e, t) {
		if (t === "basic") return pD(e, { type: "basic", headersList: e.headersList })
		if (t === "cors") return pD(e, { type: "cors", headersList: e.headersList })
		if (t === "opaque")
			return pD(e, {
				type: "opaque",
				urlList: Object.freeze([]),
				status: 0,
				statusText: "",
				body: null,
			})
		if (t === "opaqueredirect")
			return pD(e, {
				type: "opaqueredirect",
				status: 0,
				statusText: "",
				headersList: [],
				body: null,
			})
		wV(!1)
	}
	function iYe(e, t = null) {
		return (
			wV(G$e(e)),
			$$e(e)
				? mD(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: t }))
				: mD(
						Object.assign(new DOMException("Request was cancelled."), {
							cause: t,
						}),
					)
		)
	}
	function hse(e, t, r) {
		if (t.status !== null && (t.status < 200 || t.status > 599))
			throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.')
		if ("statusText" in t && t.statusText != null && !W$e(String(t.statusText)))
			throw new TypeError("Invalid statusText")
		if (
			("status" in t && t.status != null && (e[ni].status = t.status),
			"statusText" in t && t.statusText != null && (e[ni].statusText = t.statusText),
			"headers" in t && t.headers != null && P$e(e[Md], t.headers),
			r)
		) {
			if (X$e.includes(e.status))
				throw Ht.errors.exception({
					header: "Response constructor",
					message: `Invalid response status code ${e.status}`,
				})
			;(e[ni].body = r.body),
				r.type != null &&
					!e[ni].headersList.contains("content-type", !0) &&
					e[ni].headersList.append("content-type", r.type, !0)
		}
	}
	function ob(e, t) {
		let r = new Ap(AD)
		return (
			(r[ni] = e),
			(r[Md] = new gse(AD)),
			Ase(r[Md], e.headersList),
			pse(r[Md], t),
			q$e && e.body?.stream && V$e.register(r, new WeakRef(e.body.stream)),
			r
		)
	}
	Ht.converters.ReadableStream = Ht.interfaceConverter(ReadableStream)
	Ht.converters.FormData = Ht.interfaceConverter(eYe)
	Ht.converters.URLSearchParams = Ht.interfaceConverter(URLSearchParams)
	Ht.converters.XMLHttpRequestBodyInit = function (e, t, r) {
		return typeof e == "string"
			? Ht.converters.USVString(e, t, r)
			: Y$e(e)
				? Ht.converters.Blob(e, t, r, { strict: !1 })
				: ArrayBuffer.isView(e) || tYe.isArrayBuffer(e)
					? Ht.converters.BufferSource(e, t, r)
					: _V.isFormDataLike(e)
						? Ht.converters.FormData(e, t, r, { strict: !1 })
						: e instanceof URLSearchParams
							? Ht.converters.URLSearchParams(e, t, r)
							: Ht.converters.DOMString(e, t, r)
	}
	Ht.converters.BodyInit = function (e, t, r) {
		return e instanceof ReadableStream
			? Ht.converters.ReadableStream(e, t, r)
			: e?.[Symbol.asyncIterator]
				? e
				: Ht.converters.XMLHttpRequestBodyInit(e, t, r)
	}
	Ht.converters.ResponseInit = Ht.dictionaryConverter([
		{
			key: "status",
			converter: Ht.converters["unsigned short"],
			defaultValue: () => 200,
		},
		{
			key: "statusText",
			converter: Ht.converters.ByteString,
			defaultValue: () => "",
		},
		{ key: "headers", converter: Ht.converters.HeadersInit },
	])
	yse.exports = {
		isNetworkError: nYe,
		makeNetworkError: mD,
		makeResponse: _0,
		makeAppropriateNetworkError: iYe,
		filterResponse: mse,
		Response: Ap,
		cloneResponse: IV,
		fromInnerResponse: ob,
	}
})
var bse = x((iSt, Ese) => {
	"use strict"
	var { kConnected: Cse, kSize: vse } = Qn(),
		SV = class {
			constructor(t) {
				this.value = t
			}
			deref() {
				return this.value[Cse] === 0 && this.value[vse] === 0 ? void 0 : this.value
			}
		},
		BV = class {
			constructor(t) {
				this.finalizer = t
			}
			register(t, r) {
				t.on &&
					t.on("disconnect", () => {
						t[Cse] === 0 && t[vse] === 0 && this.finalizer(r)
					})
			}
			unregister(t) {}
		}
	Ese.exports = function () {
		return process.env.NODE_V8_COVERAGE && process.version.startsWith("v18")
			? (process._rawDebug("Using compatibility WeakRef and FinalizationRegistry"),
				{ WeakRef: SV, FinalizationRegistry: BV })
			: { WeakRef, FinalizationRegistry }
	}
})
var w0 = x((sSt, Pse) => {
	"use strict"
	var { extractBody: sYe, mixinBody: oYe, cloneBody: aYe, bodyUnusable: xse } = s0(),
		{
			Headers: kse,
			fill: lYe,
			HeadersList: ED,
			setHeadersGuard: TV,
			getHeadersGuard: cYe,
			setHeadersList: Mse,
			getHeadersList: _se,
		} = pp(),
		{ FinalizationRegistry: uYe } = bse()(),
		CD = Xt(),
		wse = require("util"),
		{ isValidHTTPToken: dYe, sameOrigin: Ise, environmentSettingsObject: yD } = ga(),
		{
			forbiddenMethodsSet: fYe,
			corsSafeListedMethodsSet: hYe,
			referrerPolicy: gYe,
			requestRedirect: pYe,
			requestMode: AYe,
			requestCredentials: mYe,
			requestCache: yYe,
			requestDuplex: CYe,
		} = SE(),
		{ kEnumerableProperty: Ii, normalizedMethodRecordsBase: vYe, normalizedMethodRecords: EYe } = CD,
		{ kHeaders: Ca, kSignal: vD, kState: xn, kDispatcher: DV } = Gf(),
		{ webidl: gt } = ys(),
		{ URLSerializer: bYe } = No(),
		{ kConstruct: bD } = Qn(),
		xYe = require("assert"),
		{
			getMaxListeners: Sse,
			setMaxListeners: Bse,
			getEventListeners: _Ye,
			defaultMaxListeners: Dse,
		} = require("events"),
		wYe = Symbol("abortController"),
		Fse = new uYe(({ signal: e, abort: t }) => {
			e.removeEventListener("abort", t)
		}),
		xD = new WeakMap()
	function Tse(e) {
		return t
		function t() {
			let r = e.deref()
			if (r !== void 0) {
				Fse.unregister(t), this.removeEventListener("abort", t), r.abort(this.reason)
				let n = xD.get(r.signal)
				if (n !== void 0) {
					if (n.size !== 0) {
						for (let i of n) {
							let s = i.deref()
							s !== void 0 && s.abort(this.reason)
						}
						n.clear()
					}
					xD.delete(r.signal)
				}
			}
		}
	}
	var Rse = !1,
		rh = class e {
			constructor(t, r = {}) {
				if ((gt.util.markAsUncloneable(this), t === bD)) return
				let n = "Request constructor"
				gt.argumentLengthCheck(arguments, 1, n),
					(t = gt.converters.RequestInfo(t, n, "input")),
					(r = gt.converters.RequestInit(r, n, "init"))
				let i = null,
					s = null,
					o = yD.settingsObject.baseUrl,
					a = null
				if (typeof t == "string") {
					this[DV] = r.dispatcher
					let v
					try {
						v = new URL(t, o)
					} catch (b) {
						throw new TypeError("Failed to parse URL from " + t, { cause: b })
					}
					if (v.username || v.password)
						throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + t)
					;(i = _D({ urlList: [v] })), (s = "cors")
				} else (this[DV] = r.dispatcher || t[DV]), xYe(t instanceof e), (i = t[xn]), (a = t[vD])
				let l = yD.settingsObject.origin,
					c = "client"
				if (
					(i.window?.constructor?.name === "EnvironmentSettingsObject" && Ise(i.window, l) && (c = i.window),
					r.window != null)
				)
					throw new TypeError(`'window' option '${c}' must be null`)
				"window" in r && (c = "no-window"),
					(i = _D({
						method: i.method,
						headersList: i.headersList,
						unsafeRequest: i.unsafeRequest,
						client: yD.settingsObject,
						window: c,
						priority: i.priority,
						origin: i.origin,
						referrer: i.referrer,
						referrerPolicy: i.referrerPolicy,
						mode: i.mode,
						credentials: i.credentials,
						cache: i.cache,
						redirect: i.redirect,
						integrity: i.integrity,
						keepalive: i.keepalive,
						reloadNavigation: i.reloadNavigation,
						historyNavigation: i.historyNavigation,
						urlList: [...i.urlList],
					}))
				let u = Object.keys(r).length !== 0
				if (
					(u &&
						(i.mode === "navigate" && (i.mode = "same-origin"),
						(i.reloadNavigation = !1),
						(i.historyNavigation = !1),
						(i.origin = "client"),
						(i.referrer = "client"),
						(i.referrerPolicy = ""),
						(i.url = i.urlList[i.urlList.length - 1]),
						(i.urlList = [i.url])),
					r.referrer !== void 0)
				) {
					let v = r.referrer
					if (v === "") i.referrer = "no-referrer"
					else {
						let b
						try {
							b = new URL(v, o)
						} catch (w) {
							throw new TypeError(`Referrer "${v}" is not a valid URL.`, {
								cause: w,
							})
						}
						;(b.protocol === "about:" && b.hostname === "client") ||
						(l && !Ise(b, yD.settingsObject.baseUrl))
							? (i.referrer = "client")
							: (i.referrer = b)
					}
				}
				r.referrerPolicy !== void 0 && (i.referrerPolicy = r.referrerPolicy)
				let f
				if ((r.mode !== void 0 ? (f = r.mode) : (f = s), f === "navigate"))
					throw gt.errors.exception({
						header: "Request constructor",
						message: "invalid request mode navigate.",
					})
				if (
					(f != null && (i.mode = f),
					r.credentials !== void 0 && (i.credentials = r.credentials),
					r.cache !== void 0 && (i.cache = r.cache),
					i.cache === "only-if-cached" && i.mode !== "same-origin")
				)
					throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode")
				if (
					(r.redirect !== void 0 && (i.redirect = r.redirect),
					r.integrity != null && (i.integrity = String(r.integrity)),
					r.keepalive !== void 0 && (i.keepalive = !!r.keepalive),
					r.method !== void 0)
				) {
					let v = r.method,
						b = EYe[v]
					if (b !== void 0) i.method = b
					else {
						if (!dYe(v)) throw new TypeError(`'${v}' is not a valid HTTP method.`)
						let w = v.toUpperCase()
						if (fYe.has(w)) throw new TypeError(`'${v}' HTTP method is unsupported.`)
						;(v = vYe[w] ?? v), (i.method = v)
					}
					!Rse &&
						i.method === "patch" &&
						(process.emitWarning(
							"Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.",
							{ code: "UNDICI-FETCH-patch" },
						),
						(Rse = !0))
				}
				r.signal !== void 0 && (a = r.signal), (this[xn] = i)
				let p = new AbortController()
				if (((this[vD] = p.signal), a != null)) {
					if (!a || typeof a.aborted != "boolean" || typeof a.addEventListener != "function")
						throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.")
					if (a.aborted) p.abort(a.reason)
					else {
						this[wYe] = p
						let v = new WeakRef(p),
							b = Tse(v)
						try {
							;((typeof Sse == "function" && Sse(a) === Dse) || _Ye(a, "abort").length >= Dse) &&
								Bse(1500, a)
						} catch {}
						CD.addAbortListener(a, b), Fse.register(p, { signal: a, abort: b }, b)
					}
				}
				if (
					((this[Ca] = new kse(bD)), Mse(this[Ca], i.headersList), TV(this[Ca], "request"), f === "no-cors")
				) {
					if (!hYe.has(i.method)) throw new TypeError(`'${i.method} is unsupported in no-cors mode.`)
					TV(this[Ca], "request-no-cors")
				}
				if (u) {
					let v = _se(this[Ca]),
						b = r.headers !== void 0 ? r.headers : new ED(v)
					if ((v.clear(), b instanceof ED)) {
						for (let { name: w, value: B } of b.rawValues()) v.append(w, B, !1)
						v.cookies = b.cookies
					} else lYe(this[Ca], b)
				}
				let g = t instanceof e ? t[xn].body : null
				if ((r.body != null || g != null) && (i.method === "GET" || i.method === "HEAD"))
					throw new TypeError("Request with GET/HEAD method cannot have body.")
				let m = null
				if (r.body != null) {
					let [v, b] = sYe(r.body, i.keepalive)
					;(m = v), b && !_se(this[Ca]).contains("content-type", !0) && this[Ca].append("content-type", b)
				}
				let y = m ?? g
				if (y != null && y.source == null) {
					if (m != null && r.duplex == null)
						throw new TypeError("RequestInit: duplex option is required when sending a body.")
					if (i.mode !== "same-origin" && i.mode !== "cors")
						throw new TypeError(
							'If request is made from ReadableStream, mode should be "same-origin" or "cors"',
						)
					i.useCORSPreflightFlag = !0
				}
				let C = y
				if (m == null && g != null) {
					if (xse(t))
						throw new TypeError(
							"Cannot construct a Request with a Request object that has already been used.",
						)
					let v = new TransformStream()
					g.stream.pipeThrough(v), (C = { source: g.source, length: g.length, stream: v.readable })
				}
				this[xn].body = C
			}
			get method() {
				return gt.brandCheck(this, e), this[xn].method
			}
			get url() {
				return gt.brandCheck(this, e), bYe(this[xn].url)
			}
			get headers() {
				return gt.brandCheck(this, e), this[Ca]
			}
			get destination() {
				return gt.brandCheck(this, e), this[xn].destination
			}
			get referrer() {
				return (
					gt.brandCheck(this, e),
					this[xn].referrer === "no-referrer"
						? ""
						: this[xn].referrer === "client"
							? "about:client"
							: this[xn].referrer.toString()
				)
			}
			get referrerPolicy() {
				return gt.brandCheck(this, e), this[xn].referrerPolicy
			}
			get mode() {
				return gt.brandCheck(this, e), this[xn].mode
			}
			get credentials() {
				return this[xn].credentials
			}
			get cache() {
				return gt.brandCheck(this, e), this[xn].cache
			}
			get redirect() {
				return gt.brandCheck(this, e), this[xn].redirect
			}
			get integrity() {
				return gt.brandCheck(this, e), this[xn].integrity
			}
			get keepalive() {
				return gt.brandCheck(this, e), this[xn].keepalive
			}
			get isReloadNavigation() {
				return gt.brandCheck(this, e), this[xn].reloadNavigation
			}
			get isHistoryNavigation() {
				return gt.brandCheck(this, e), this[xn].historyNavigation
			}
			get signal() {
				return gt.brandCheck(this, e), this[vD]
			}
			get body() {
				return gt.brandCheck(this, e), this[xn].body ? this[xn].body.stream : null
			}
			get bodyUsed() {
				return gt.brandCheck(this, e), !!this[xn].body && CD.isDisturbed(this[xn].body.stream)
			}
			get duplex() {
				return gt.brandCheck(this, e), "half"
			}
			clone() {
				if ((gt.brandCheck(this, e), xse(this))) throw new TypeError("unusable")
				let t = Qse(this[xn]),
					r = new AbortController()
				if (this.signal.aborted) r.abort(this.signal.reason)
				else {
					let n = xD.get(this.signal)
					n === void 0 && ((n = new Set()), xD.set(this.signal, n))
					let i = new WeakRef(r)
					n.add(i), CD.addAbortListener(r.signal, Tse(i))
				}
				return Nse(t, r.signal, cYe(this[Ca]))
			}
			[wse.inspect.custom](t, r) {
				r.depth === null && (r.depth = 2), (r.colors ??= !0)
				let n = {
					method: this.method,
					url: this.url,
					headers: this.headers,
					destination: this.destination,
					referrer: this.referrer,
					referrerPolicy: this.referrerPolicy,
					mode: this.mode,
					credentials: this.credentials,
					cache: this.cache,
					redirect: this.redirect,
					integrity: this.integrity,
					keepalive: this.keepalive,
					isReloadNavigation: this.isReloadNavigation,
					isHistoryNavigation: this.isHistoryNavigation,
					signal: this.signal,
				}
				return `Request ${wse.formatWithOptions(r, n)}`
			}
		}
	oYe(rh)
	function _D(e) {
		return {
			method: e.method ?? "GET",
			localURLsOnly: e.localURLsOnly ?? !1,
			unsafeRequest: e.unsafeRequest ?? !1,
			body: e.body ?? null,
			client: e.client ?? null,
			reservedClient: e.reservedClient ?? null,
			replacesClientId: e.replacesClientId ?? "",
			window: e.window ?? "client",
			keepalive: e.keepalive ?? !1,
			serviceWorkers: e.serviceWorkers ?? "all",
			initiator: e.initiator ?? "",
			destination: e.destination ?? "",
			priority: e.priority ?? null,
			origin: e.origin ?? "client",
			policyContainer: e.policyContainer ?? "client",
			referrer: e.referrer ?? "client",
			referrerPolicy: e.referrerPolicy ?? "",
			mode: e.mode ?? "no-cors",
			useCORSPreflightFlag: e.useCORSPreflightFlag ?? !1,
			credentials: e.credentials ?? "same-origin",
			useCredentials: e.useCredentials ?? !1,
			cache: e.cache ?? "default",
			redirect: e.redirect ?? "follow",
			integrity: e.integrity ?? "",
			cryptoGraphicsNonceMetadata: e.cryptoGraphicsNonceMetadata ?? "",
			parserMetadata: e.parserMetadata ?? "",
			reloadNavigation: e.reloadNavigation ?? !1,
			historyNavigation: e.historyNavigation ?? !1,
			userActivation: e.userActivation ?? !1,
			taintedOrigin: e.taintedOrigin ?? !1,
			redirectCount: e.redirectCount ?? 0,
			responseTainting: e.responseTainting ?? "basic",
			preventNoCacheCacheControlHeaderModification: e.preventNoCacheCacheControlHeaderModification ?? !1,
			done: e.done ?? !1,
			timingAllowFailed: e.timingAllowFailed ?? !1,
			urlList: e.urlList,
			url: e.urlList[0],
			headersList: e.headersList ? new ED(e.headersList) : new ED(),
		}
	}
	function Qse(e) {
		let t = _D({ ...e, body: null })
		return e.body != null && (t.body = aYe(t, e.body)), t
	}
	function Nse(e, t, r) {
		let n = new rh(bD)
		return (n[xn] = e), (n[vD] = t), (n[Ca] = new kse(bD)), Mse(n[Ca], e.headersList), TV(n[Ca], r), n
	}
	Object.defineProperties(rh.prototype, {
		method: Ii,
		url: Ii,
		headers: Ii,
		redirect: Ii,
		clone: Ii,
		signal: Ii,
		duplex: Ii,
		destination: Ii,
		body: Ii,
		bodyUsed: Ii,
		isHistoryNavigation: Ii,
		isReloadNavigation: Ii,
		keepalive: Ii,
		integrity: Ii,
		cache: Ii,
		credentials: Ii,
		attribute: Ii,
		referrerPolicy: Ii,
		referrer: Ii,
		mode: Ii,
		[Symbol.toStringTag]: { value: "Request", configurable: !0 },
	})
	gt.converters.Request = gt.interfaceConverter(rh)
	gt.converters.RequestInfo = function (e, t, r) {
		return typeof e == "string"
			? gt.converters.USVString(e, t, r)
			: e instanceof rh
				? gt.converters.Request(e, t, r)
				: gt.converters.USVString(e, t, r)
	}
	gt.converters.AbortSignal = gt.interfaceConverter(AbortSignal)
	gt.converters.RequestInit = gt.dictionaryConverter([
		{ key: "method", converter: gt.converters.ByteString },
		{ key: "headers", converter: gt.converters.HeadersInit },
		{ key: "body", converter: gt.nullableConverter(gt.converters.BodyInit) },
		{ key: "referrer", converter: gt.converters.USVString },
		{
			key: "referrerPolicy",
			converter: gt.converters.DOMString,
			allowedValues: gYe,
		},
		{ key: "mode", converter: gt.converters.DOMString, allowedValues: AYe },
		{
			key: "credentials",
			converter: gt.converters.DOMString,
			allowedValues: mYe,
		},
		{ key: "cache", converter: gt.converters.DOMString, allowedValues: yYe },
		{ key: "redirect", converter: gt.converters.DOMString, allowedValues: pYe },
		{ key: "integrity", converter: gt.converters.DOMString },
		{ key: "keepalive", converter: gt.converters.boolean },
		{
			key: "signal",
			converter: gt.nullableConverter((e) =>
				gt.converters.AbortSignal(e, "RequestInit", "signal", { strict: !1 }),
			),
		},
		{ key: "window", converter: gt.converters.any },
		{ key: "duplex", converter: gt.converters.DOMString, allowedValues: CYe },
		{ key: "dispatcher", converter: gt.converters.any },
	])
	Pse.exports = {
		Request: rh,
		makeRequest: _D,
		fromInnerRequest: Nse,
		cloneRequest: Qse,
	}
})
var cb = x((oSt, Zse) => {
	"use strict"
	var {
			makeNetworkError: nn,
			makeAppropriateNetworkError: wD,
			filterResponse: RV,
			makeResponse: ID,
			fromInnerResponse: IYe,
		} = ab(),
		{ HeadersList: Lse } = pp(),
		{ Request: SYe, cloneRequest: BYe } = w0(),
		nh = require("zlib"),
		{
			bytesMatch: DYe,
			makePolicyContainer: TYe,
			clonePolicyContainer: RYe,
			requestBadPort: kYe,
			TAOCheck: MYe,
			appendRequestOriginHeader: FYe,
			responseLocationURL: QYe,
			requestCurrentURL: uu,
			setRequestReferrerPolicyOnRedirect: NYe,
			tryUpgradeRequestToAPotentiallyTrustworthyURL: PYe,
			createOpaqueTimingInfo: NV,
			appendFetchMetadata: LYe,
			corsCheck: UYe,
			crossOriginResourcePolicyCheck: OYe,
			determineRequestsReferrer: qYe,
			coarsenedSharedCurrentTime: lb,
			createDeferredPromise: VYe,
			isBlobLike: HYe,
			sameOrigin: QV,
			isCancelled: mp,
			isAborted: Use,
			isErrorLike: WYe,
			fullyReadBody: GYe,
			readableStreamClose: $Ye,
			isomorphicEncode: SD,
			urlIsLocal: YYe,
			urlIsHttpHttpsScheme: PV,
			urlHasHttpsScheme: KYe,
			clampAndCoarsenConnectionTimingInfo: JYe,
			simpleRangeHeaderValue: zYe,
			buildContentRange: jYe,
			createInflate: ZYe,
			extractMimeType: XYe,
		} = ga(),
		{ kState: Hse, kDispatcher: eKe } = Gf(),
		yp = require("assert"),
		{ safelyExtractBody: LV, extractBody: Ose } = s0(),
		{
			redirectStatusSet: Wse,
			nullBodyStatus: Gse,
			safeMethodsSet: tKe,
			requestBodyHeader: rKe,
			subresourceSet: nKe,
		} = SE(),
		iKe = require("events"),
		{ Readable: sKe, pipeline: oKe, finished: aKe } = require("stream"),
		{ addAbortListener: lKe, isErrored: cKe, isReadable: BD, bufferToLowerCasedHeaderName: qse } = Xt(),
		{ dataURLProcessor: uKe, serializeAMimeType: dKe, minimizeSupportedMimeType: fKe } = No(),
		{ getGlobalDispatcher: hKe } = dD(),
		{ webidl: gKe } = ys(),
		{ STATUS_CODES: pKe } = require("http"),
		AKe = ["GET", "HEAD"],
		mKe = typeof __UNDICI_IS_NODE__ < "u" || typeof esbuildDetection < "u" ? "node" : "undici",
		kV,
		DD = class extends iKe {
			constructor(t) {
				super(), (this.dispatcher = t), (this.connection = null), (this.dump = !1), (this.state = "ongoing")
			}
			terminate(t) {
				this.state === "ongoing" &&
					((this.state = "terminated"), this.connection?.destroy(t), this.emit("terminated", t))
			}
			abort(t) {
				this.state === "ongoing" &&
					((this.state = "aborted"),
					t || (t = new DOMException("The operation was aborted.", "AbortError")),
					(this.serializedAbortReason = t),
					this.connection?.destroy(t),
					this.emit("terminated", t))
			}
		}
	function yKe(e) {
		$se(e, "fetch")
	}
	function CKe(e, t = void 0) {
		gKe.argumentLengthCheck(arguments, 1, "globalThis.fetch")
		let r = VYe(),
			n
		try {
			n = new SYe(e, t)
		} catch (u) {
			return r.reject(u), r.promise
		}
		let i = n[Hse]
		if (n.signal.aborted) return MV(r, i, null, n.signal.reason), r.promise
		i.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope" && (i.serviceWorkers = "none")
		let o = null,
			a = !1,
			l = null
		return (
			lKe(n.signal, () => {
				;(a = !0), yp(l != null), l.abort(n.signal.reason)
				let u = o?.deref()
				MV(r, i, u, n.signal.reason)
			}),
			(l = Kse({
				request: i,
				processResponseEndOfBody: yKe,
				processResponse: (u) => {
					if (!a) {
						if (u.aborted) {
							MV(r, i, o, l.serializedAbortReason)
							return
						}
						if (u.type === "error") {
							r.reject(new TypeError("fetch failed", { cause: u.error }))
							return
						}
						;(o = new WeakRef(IYe(u, "immutable"))), r.resolve(o.deref()), (r = null)
					}
				},
				dispatcher: n[eKe],
			})),
			r.promise
		)
	}
	function $se(e, t = "other") {
		if ((e.type === "error" && e.aborted) || !e.urlList?.length) return
		let r = e.urlList[0],
			n = e.timingInfo,
			i = e.cacheState
		PV(r) &&
			n !== null &&
			(e.timingAllowPassed || ((n = NV({ startTime: n.startTime })), (i = "")),
			(n.endTime = lb()),
			(e.timingInfo = n),
			Yse(n, r.href, t, globalThis, i))
	}
	var Yse = performance.markResourceTiming
	function MV(e, t, r, n) {
		if (
			(e && e.reject(n),
			t.body != null &&
				BD(t.body?.stream) &&
				t.body.stream.cancel(n).catch((s) => {
					if (s.code !== "ERR_INVALID_STATE") throw s
				}),
			r == null)
		)
			return
		let i = r[Hse]
		i.body != null &&
			BD(i.body?.stream) &&
			i.body.stream.cancel(n).catch((s) => {
				if (s.code !== "ERR_INVALID_STATE") throw s
			})
	}
	function Kse({
		request: e,
		processRequestBodyChunkLength: t,
		processRequestEndOfBody: r,
		processResponse: n,
		processResponseEndOfBody: i,
		processResponseConsumeBody: s,
		useParallelQueue: o = !1,
		dispatcher: a = hKe(),
	}) {
		yp(a)
		let l = null,
			c = !1
		e.client != null && ((l = e.client.globalObject), (c = e.client.crossOriginIsolatedCapability))
		let u = lb(c),
			f = NV({ startTime: u }),
			p = {
				controller: new DD(a),
				request: e,
				timingInfo: f,
				processRequestBodyChunkLength: t,
				processRequestEndOfBody: r,
				processResponse: n,
				processResponseConsumeBody: s,
				processResponseEndOfBody: i,
				taskDestination: l,
				crossOriginIsolatedCapability: c,
			}
		if (
			(yp(!e.body || e.body.stream),
			e.window === "client" &&
				(e.window = e.client?.globalObject?.constructor?.name === "Window" ? e.client : "no-window"),
			e.origin === "client" && (e.origin = e.client.origin),
			e.policyContainer === "client" &&
				(e.client != null ? (e.policyContainer = RYe(e.client.policyContainer)) : (e.policyContainer = TYe())),
			!e.headersList.contains("accept", !0))
		) {
			let g = "*/*"
			e.headersList.append("accept", g, !0)
		}
		return (
			e.headersList.contains("accept-language", !0) || e.headersList.append("accept-language", "*", !0),
			e.priority,
			nKe.has(e.destination),
			Jse(p).catch((g) => {
				p.controller.terminate(g)
			}),
			p.controller
		)
	}
	async function Jse(e, t = !1) {
		let r = e.request,
			n = null
		if (
			(r.localURLsOnly && !YYe(uu(r)) && (n = nn("local URLs only")),
			PYe(r),
			kYe(r) === "blocked" && (n = nn("bad port")),
			r.referrerPolicy === "" && (r.referrerPolicy = r.policyContainer.referrerPolicy),
			r.referrer !== "no-referrer" && (r.referrer = qYe(r)),
			n === null &&
				(n = await (async () => {
					let s = uu(r)
					return (QV(s, r.url) && r.responseTainting === "basic") ||
						s.protocol === "data:" ||
						r.mode === "navigate" ||
						r.mode === "websocket"
						? ((r.responseTainting = "basic"), await Vse(e))
						: r.mode === "same-origin"
							? nn('request mode cannot be "same-origin"')
							: r.mode === "no-cors"
								? r.redirect !== "follow"
									? nn('redirect mode cannot be "follow" for "no-cors" request')
									: ((r.responseTainting = "opaque"), await Vse(e))
								: PV(uu(r))
									? ((r.responseTainting = "cors"), await zse(e))
									: nn("URL scheme must be a HTTP(S) scheme")
				})()),
			t)
		)
			return n
		n.status !== 0 &&
			!n.internalResponse &&
			(r.responseTainting,
			r.responseTainting === "basic"
				? (n = RV(n, "basic"))
				: r.responseTainting === "cors"
					? (n = RV(n, "cors"))
					: r.responseTainting === "opaque"
						? (n = RV(n, "opaque"))
						: yp(!1))
		let i = n.status === 0 ? n : n.internalResponse
		if (
			(i.urlList.length === 0 && i.urlList.push(...r.urlList),
			r.timingAllowFailed || (n.timingAllowPassed = !0),
			n.type === "opaque" &&
				i.status === 206 &&
				i.rangeRequested &&
				!r.headers.contains("range", !0) &&
				(n = i = nn()),
			n.status !== 0 &&
				(r.method === "HEAD" || r.method === "CONNECT" || Gse.includes(i.status)) &&
				((i.body = null), (e.controller.dump = !0)),
			r.integrity)
		) {
			let s = (a) => FV(e, nn(a))
			if (r.responseTainting === "opaque" || n.body == null) {
				s(n.error)
				return
			}
			let o = (a) => {
				if (!DYe(a, r.integrity)) {
					s("integrity mismatch")
					return
				}
				;(n.body = LV(a)[0]), FV(e, n)
			}
			await GYe(n.body, o, s)
		} else FV(e, n)
	}
	function Vse(e) {
		if (mp(e) && e.request.redirectCount === 0) return Promise.resolve(wD(e))
		let { request: t } = e,
			{ protocol: r } = uu(t)
		switch (r) {
			case "about:":
				return Promise.resolve(nn("about scheme is not supported"))
			case "blob:": {
				kV || (kV = require("buffer").resolveObjectURL)
				let n = uu(t)
				if (n.search.length !== 0) return Promise.resolve(nn("NetworkError when attempting to fetch resource."))
				let i = kV(n.toString())
				if (t.method !== "GET" || !HYe(i)) return Promise.resolve(nn("invalid method"))
				let s = ID(),
					o = i.size,
					a = SD(`${o}`),
					l = i.type
				if (t.headersList.contains("range", !0)) {
					s.rangeRequested = !0
					let c = t.headersList.get("range", !0),
						u = zYe(c, !0)
					if (u === "failure") return Promise.resolve(nn("failed to fetch the data URL"))
					let { rangeStartValue: f, rangeEndValue: p } = u
					if (f === null) (f = o - p), (p = f + p - 1)
					else {
						if (f >= o) return Promise.resolve(nn("Range start is greater than the blob's size."))
						;(p === null || p >= o) && (p = o - 1)
					}
					let g = i.slice(f, p, l),
						m = Ose(g)
					s.body = m[0]
					let y = SD(`${g.size}`),
						C = jYe(f, p, o)
					;(s.status = 206),
						(s.statusText = "Partial Content"),
						s.headersList.set("content-length", y, !0),
						s.headersList.set("content-type", l, !0),
						s.headersList.set("content-range", C, !0)
				} else {
					let c = Ose(i)
					;(s.statusText = "OK"),
						(s.body = c[0]),
						s.headersList.set("content-length", a, !0),
						s.headersList.set("content-type", l, !0)
				}
				return Promise.resolve(s)
			}
			case "data:": {
				let n = uu(t),
					i = uKe(n)
				if (i === "failure") return Promise.resolve(nn("failed to fetch the data URL"))
				let s = dKe(i.mimeType)
				return Promise.resolve(
					ID({
						statusText: "OK",
						headersList: [["content-type", { name: "Content-Type", value: s }]],
						body: LV(i.body)[0],
					}),
				)
			}
			case "file:":
				return Promise.resolve(nn("not implemented... yet..."))
			case "http:":
			case "https:":
				return zse(e).catch((n) => nn(n))
			default:
				return Promise.resolve(nn("unknown scheme"))
		}
	}
	function vKe(e, t) {
		;(e.request.done = !0), e.processResponseDone != null && queueMicrotask(() => e.processResponseDone(t))
	}
	function FV(e, t) {
		let r = e.timingInfo,
			n = () => {
				let s = Date.now()
				e.request.destination === "document" && (e.controller.fullTimingInfo = r),
					(e.controller.reportTimingSteps = () => {
						if (e.request.url.protocol !== "https:") return
						r.endTime = s
						let a = t.cacheState,
							l = t.bodyInfo
						t.timingAllowPassed || ((r = NV(r)), (a = ""))
						let c = 0
						if (e.request.mode !== "navigator" || !t.hasCrossOriginRedirects) {
							c = t.status
							let u = XYe(t.headersList)
							u !== "failure" && (l.contentType = fKe(u))
						}
						e.request.initiatorType != null &&
							Yse(r, e.request.url.href, e.request.initiatorType, globalThis, a, l, c)
					})
				let o = () => {
					;(e.request.done = !0),
						e.processResponseEndOfBody != null && queueMicrotask(() => e.processResponseEndOfBody(t)),
						e.request.initiatorType != null && e.controller.reportTimingSteps()
				}
				queueMicrotask(() => o())
			}
		e.processResponse != null &&
			queueMicrotask(() => {
				e.processResponse(t), (e.processResponse = null)
			})
		let i = t.type === "error" ? t : (t.internalResponse ?? t)
		i.body == null
			? n()
			: aKe(i.body.stream, () => {
					n()
				})
	}
	async function zse(e) {
		let t = e.request,
			r = null,
			n = null,
			i = e.timingInfo
		if ((t.serviceWorkers, r === null)) {
			if (
				(t.redirect === "follow" && (t.serviceWorkers = "none"),
				(n = r = await jse(e)),
				t.responseTainting === "cors" && UYe(t, r) === "failure")
			)
				return nn("cors failure")
			MYe(t, r) === "failure" && (t.timingAllowFailed = !0)
		}
		return (t.responseTainting === "opaque" || r.type === "opaque") &&
			OYe(t.origin, t.client, t.destination, n) === "blocked"
			? nn("blocked")
			: (Wse.has(n.status) &&
					(t.redirect !== "manual" && e.controller.connection.destroy(void 0, !1),
					t.redirect === "error"
						? (r = nn("unexpected redirect"))
						: t.redirect === "manual"
							? (r = n)
							: t.redirect === "follow"
								? (r = await EKe(e, r))
								: yp(!1)),
				(r.timingInfo = i),
				r)
	}
	function EKe(e, t) {
		let r = e.request,
			n = t.internalResponse ? t.internalResponse : t,
			i
		try {
			if (((i = QYe(n, uu(r).hash)), i == null)) return t
		} catch (o) {
			return Promise.resolve(nn(o))
		}
		if (!PV(i)) return Promise.resolve(nn("URL scheme must be a HTTP(S) scheme"))
		if (r.redirectCount === 20) return Promise.resolve(nn("redirect count exceeded"))
		if (((r.redirectCount += 1), r.mode === "cors" && (i.username || i.password) && !QV(r, i)))
			return Promise.resolve(nn('cross origin not allowed for request mode "cors"'))
		if (r.responseTainting === "cors" && (i.username || i.password))
			return Promise.resolve(nn('URL cannot contain credentials for request mode "cors"'))
		if (n.status !== 303 && r.body != null && r.body.source == null) return Promise.resolve(nn())
		if (([301, 302].includes(n.status) && r.method === "POST") || (n.status === 303 && !AKe.includes(r.method))) {
			;(r.method = "GET"), (r.body = null)
			for (let o of rKe) r.headersList.delete(o)
		}
		QV(uu(r), i) ||
			(r.headersList.delete("authorization", !0),
			r.headersList.delete("proxy-authorization", !0),
			r.headersList.delete("cookie", !0),
			r.headersList.delete("host", !0)),
			r.body != null && (yp(r.body.source != null), (r.body = LV(r.body.source)[0]))
		let s = e.timingInfo
		return (
			(s.redirectEndTime = s.postRedirectStartTime = lb(e.crossOriginIsolatedCapability)),
			s.redirectStartTime === 0 && (s.redirectStartTime = s.startTime),
			r.urlList.push(i),
			NYe(r, n),
			Jse(e, !0)
		)
	}
	async function jse(e, t = !1, r = !1) {
		let n = e.request,
			i = null,
			s = null,
			o = null,
			a = null,
			l = !1
		n.window === "no-window" && n.redirect === "error"
			? ((i = e), (s = n))
			: ((s = BYe(n)), (i = { ...e }), (i.request = s))
		let c = n.credentials === "include" || (n.credentials === "same-origin" && n.responseTainting === "basic"),
			u = s.body ? s.body.length : null,
			f = null
		if (
			(s.body == null && ["POST", "PUT"].includes(s.method) && (f = "0"),
			u != null && (f = SD(`${u}`)),
			f != null && s.headersList.append("content-length", f, !0),
			u != null && s.keepalive,
			s.referrer instanceof URL && s.headersList.append("referer", SD(s.referrer.href), !0),
			FYe(s),
			LYe(s),
			s.headersList.contains("user-agent", !0) || s.headersList.append("user-agent", mKe),
			s.cache === "default" &&
				(s.headersList.contains("if-modified-since", !0) ||
					s.headersList.contains("if-none-match", !0) ||
					s.headersList.contains("if-unmodified-since", !0) ||
					s.headersList.contains("if-match", !0) ||
					s.headersList.contains("if-range", !0)) &&
				(s.cache = "no-store"),
			s.cache === "no-cache" &&
				!s.preventNoCacheCacheControlHeaderModification &&
				!s.headersList.contains("cache-control", !0) &&
				s.headersList.append("cache-control", "max-age=0", !0),
			(s.cache === "no-store" || s.cache === "reload") &&
				(s.headersList.contains("pragma", !0) || s.headersList.append("pragma", "no-cache", !0),
				s.headersList.contains("cache-control", !0) || s.headersList.append("cache-control", "no-cache", !0)),
			s.headersList.contains("range", !0) && s.headersList.append("accept-encoding", "identity", !0),
			s.headersList.contains("accept-encoding", !0) ||
				(KYe(uu(s))
					? s.headersList.append("accept-encoding", "br, gzip, deflate", !0)
					: s.headersList.append("accept-encoding", "gzip, deflate", !0)),
			s.headersList.delete("host", !0),
			a == null && (s.cache = "no-store"),
			s.cache !== "no-store" && s.cache,
			o == null)
		) {
			if (s.cache === "only-if-cached") return nn("only if cached")
			let p = await bKe(i, c, r)
			!tKe.has(s.method) && p.status >= 200 && p.status <= 399, l && p.status, o == null && (o = p)
		}
		if (
			((o.urlList = [...s.urlList]),
			s.headersList.contains("range", !0) && (o.rangeRequested = !0),
			(o.requestIncludesCredentials = c),
			o.status === 407)
		)
			return n.window === "no-window" ? nn() : mp(e) ? wD(e) : nn("proxy authentication required")
		if (o.status === 421 && !r && (n.body == null || n.body.source != null)) {
			if (mp(e)) return wD(e)
			e.controller.connection.destroy(), (o = await jse(e, t, !0))
		}
		return o
	}
	async function bKe(e, t = !1, r = !1) {
		yp(!e.controller.connection || e.controller.connection.destroyed),
			(e.controller.connection = {
				abort: null,
				destroyed: !1,
				destroy(m, y = !0) {
					this.destroyed ||
						((this.destroyed = !0),
						y && this.abort?.(m ?? new DOMException("The operation was aborted.", "AbortError")))
				},
			})
		let n = e.request,
			i = null,
			s = e.timingInfo
		null == null && (n.cache = "no-store")
		let a = r ? "yes" : "no"
		n.mode
		let l = null
		if (n.body == null && e.processRequestEndOfBody) queueMicrotask(() => e.processRequestEndOfBody())
		else if (n.body != null) {
			let m = async function* (v) {
					mp(e) || (yield v, e.processRequestBodyChunkLength?.(v.byteLength))
				},
				y = () => {
					mp(e) || (e.processRequestEndOfBody && e.processRequestEndOfBody())
				},
				C = (v) => {
					mp(e) || (v.name === "AbortError" ? e.controller.abort() : e.controller.terminate(v))
				}
			l = (async function* () {
				try {
					for await (let v of n.body.stream) yield* m(v)
					y()
				} catch (v) {
					C(v)
				}
			})()
		}
		try {
			let { body: m, status: y, statusText: C, headersList: v, socket: b } = await g({ body: l })
			if (b) i = ID({ status: y, statusText: C, headersList: v, socket: b })
			else {
				let w = m[Symbol.asyncIterator]()
				;(e.controller.next = () => w.next()), (i = ID({ status: y, statusText: C, headersList: v }))
			}
		} catch (m) {
			return m.name === "AbortError" ? (e.controller.connection.destroy(), wD(e, m)) : nn(m)
		}
		let c = async () => {
				await e.controller.resume()
			},
			u = (m) => {
				mp(e) || e.controller.abort(m)
			},
			f = new ReadableStream({
				async start(m) {
					e.controller.controller = m
				},
				async pull(m) {
					await c(m)
				},
				async cancel(m) {
					await u(m)
				},
				type: "bytes",
			})
		;(i.body = { stream: f, source: null, length: null }),
			(e.controller.onAborted = p),
			e.controller.on("terminated", p),
			(e.controller.resume = async () => {
				for (;;) {
					let m, y
					try {
						let { done: v, value: b } = await e.controller.next()
						if (Use(e)) break
						m = v ? void 0 : b
					} catch (v) {
						e.controller.ended && !s.encodedBodySize ? (m = void 0) : ((m = v), (y = !0))
					}
					if (m === void 0) {
						$Ye(e.controller.controller), vKe(e, i)
						return
					}
					if (((s.decodedBodySize += m?.byteLength ?? 0), y)) {
						e.controller.terminate(m)
						return
					}
					let C = new Uint8Array(m)
					if ((C.byteLength && e.controller.controller.enqueue(C), cKe(f))) {
						e.controller.terminate()
						return
					}
					if (e.controller.controller.desiredSize <= 0) return
				}
			})
		function p(m) {
			Use(e)
				? ((i.aborted = !0), BD(f) && e.controller.controller.error(e.controller.serializedAbortReason))
				: BD(f) && e.controller.controller.error(new TypeError("terminated", { cause: WYe(m) ? m : void 0 })),
				e.controller.connection.destroy()
		}
		return i
		function g({ body: m }) {
			let y = uu(n),
				C = e.controller.dispatcher
			return new Promise((v, b) =>
				C.dispatch(
					{
						path: y.pathname + y.search,
						origin: y.origin,
						method: n.method,
						body: C.isMockActive ? n.body && (n.body.source || n.body.stream) : m,
						headers: n.headersList.entries,
						maxRedirections: 0,
						upgrade: n.mode === "websocket" ? "websocket" : void 0,
					},
					{
						body: null,
						abort: null,
						onConnect(w) {
							let { connection: B } = e.controller
							;(s.finalConnectionTimingInfo = JYe(
								void 0,
								s.postRedirectStartTime,
								e.crossOriginIsolatedCapability,
							)),
								B.destroyed
									? w(new DOMException("The operation was aborted.", "AbortError"))
									: (e.controller.on("terminated", w), (this.abort = B.abort = w)),
								(s.finalNetworkRequestStartTime = lb(e.crossOriginIsolatedCapability))
						},
						onResponseStarted() {
							s.finalNetworkResponseStartTime = lb(e.crossOriginIsolatedCapability)
						},
						onHeaders(w, B, M, Q) {
							if (w < 200) return
							let O = [],
								Y = "",
								j = new Lse()
							for (let N = 0; N < B.length; N += 2) j.append(qse(B[N]), B[N + 1].toString("latin1"), !0)
							let ne = j.get("content-encoding", !0)
							ne &&
								(O = ne
									.toLowerCase()
									.split(",")
									.map((N) => N.trim())),
								(Y = j.get("location", !0)),
								(this.body = new sKe({ read: M }))
							let q = [],
								me = Y && n.redirect === "follow" && Wse.has(w)
							if (
								O.length !== 0 &&
								n.method !== "HEAD" &&
								n.method !== "CONNECT" &&
								!Gse.includes(w) &&
								!me
							)
								for (let N = O.length - 1; N >= 0; --N) {
									let re = O[N]
									if (re === "x-gzip" || re === "gzip")
										q.push(
											nh.createGunzip({
												flush: nh.constants.Z_SYNC_FLUSH,
												finishFlush: nh.constants.Z_SYNC_FLUSH,
											}),
										)
									else if (re === "deflate")
										q.push(
											ZYe({
												flush: nh.constants.Z_SYNC_FLUSH,
												finishFlush: nh.constants.Z_SYNC_FLUSH,
											}),
										)
									else if (re === "br")
										q.push(
											nh.createBrotliDecompress({
												flush: nh.constants.BROTLI_OPERATION_FLUSH,
												finishFlush: nh.constants.BROTLI_OPERATION_FLUSH,
											}),
										)
									else {
										q.length = 0
										break
									}
								}
							let Qe = this.onError.bind(this)
							return (
								v({
									status: w,
									statusText: Q,
									headersList: j,
									body: q.length
										? oKe(this.body, ...q, (N) => {
												N && this.onError(N)
											}).on("error", Qe)
										: this.body.on("error", Qe),
								}),
								!0
							)
						},
						onData(w) {
							if (e.controller.dump) return
							let B = w
							return (s.encodedBodySize += B.byteLength), this.body.push(B)
						},
						onComplete() {
							this.abort && e.controller.off("terminated", this.abort),
								e.controller.onAborted && e.controller.off("terminated", e.controller.onAborted),
								(e.controller.ended = !0),
								this.body.push(null)
						},
						onError(w) {
							this.abort && e.controller.off("terminated", this.abort),
								this.body?.destroy(w),
								e.controller.terminate(w),
								b(w)
						},
						onUpgrade(w, B, M) {
							if (w !== 101) return
							let Q = new Lse()
							for (let O = 0; O < B.length; O += 2) Q.append(qse(B[O]), B[O + 1].toString("latin1"), !0)
							return v({ status: w, statusText: pKe[w], headersList: Q, socket: M }), !0
						},
					},
				),
			)
		}
	}
	Zse.exports = {
		fetch: CKe,
		Fetch: DD,
		fetching: Kse,
		finalizeAndReportTiming: $se,
	}
})
var UV = x((aSt, Xse) => {
	"use strict"
	Xse.exports = {
		kState: Symbol("FileReader state"),
		kResult: Symbol("FileReader result"),
		kError: Symbol("FileReader error"),
		kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
		kEvents: Symbol("FileReader events"),
		kAborted: Symbol("FileReader aborted"),
	}
})
var toe = x((lSt, eoe) => {
	"use strict"
	var { webidl: va } = ys(),
		TD = Symbol("ProgressEvent state"),
		OV = class e extends Event {
			constructor(t, r = {}) {
				;(t = va.converters.DOMString(t, "ProgressEvent constructor", "type")),
					(r = va.converters.ProgressEventInit(r ?? {})),
					super(t, r),
					(this[TD] = {
						lengthComputable: r.lengthComputable,
						loaded: r.loaded,
						total: r.total,
					})
			}
			get lengthComputable() {
				return va.brandCheck(this, e), this[TD].lengthComputable
			}
			get loaded() {
				return va.brandCheck(this, e), this[TD].loaded
			}
			get total() {
				return va.brandCheck(this, e), this[TD].total
			}
		}
	va.converters.ProgressEventInit = va.dictionaryConverter([
		{
			key: "lengthComputable",
			converter: va.converters.boolean,
			defaultValue: () => !1,
		},
		{
			key: "loaded",
			converter: va.converters["unsigned long long"],
			defaultValue: () => 0,
		},
		{
			key: "total",
			converter: va.converters["unsigned long long"],
			defaultValue: () => 0,
		},
		{
			key: "bubbles",
			converter: va.converters.boolean,
			defaultValue: () => !1,
		},
		{
			key: "cancelable",
			converter: va.converters.boolean,
			defaultValue: () => !1,
		},
		{
			key: "composed",
			converter: va.converters.boolean,
			defaultValue: () => !1,
		},
	])
	eoe.exports = { ProgressEvent: OV }
})
var noe = x((cSt, roe) => {
	"use strict"
	function xKe(e) {
		if (!e) return "failure"
		switch (e.trim().toLowerCase()) {
			case "unicode-1-1-utf-8":
			case "unicode11utf8":
			case "unicode20utf8":
			case "utf-8":
			case "utf8":
			case "x-unicode20utf8":
				return "UTF-8"
			case "866":
			case "cp866":
			case "csibm866":
			case "ibm866":
				return "IBM866"
			case "csisolatin2":
			case "iso-8859-2":
			case "iso-ir-101":
			case "iso8859-2":
			case "iso88592":
			case "iso_8859-2":
			case "iso_8859-2:1987":
			case "l2":
			case "latin2":
				return "ISO-8859-2"
			case "csisolatin3":
			case "iso-8859-3":
			case "iso-ir-109":
			case "iso8859-3":
			case "iso88593":
			case "iso_8859-3":
			case "iso_8859-3:1988":
			case "l3":
			case "latin3":
				return "ISO-8859-3"
			case "csisolatin4":
			case "iso-8859-4":
			case "iso-ir-110":
			case "iso8859-4":
			case "iso88594":
			case "iso_8859-4":
			case "iso_8859-4:1988":
			case "l4":
			case "latin4":
				return "ISO-8859-4"
			case "csisolatincyrillic":
			case "cyrillic":
			case "iso-8859-5":
			case "iso-ir-144":
			case "iso8859-5":
			case "iso88595":
			case "iso_8859-5":
			case "iso_8859-5:1988":
				return "ISO-8859-5"
			case "arabic":
			case "asmo-708":
			case "csiso88596e":
			case "csiso88596i":
			case "csisolatinarabic":
			case "ecma-114":
			case "iso-8859-6":
			case "iso-8859-6-e":
			case "iso-8859-6-i":
			case "iso-ir-127":
			case "iso8859-6":
			case "iso88596":
			case "iso_8859-6":
			case "iso_8859-6:1987":
				return "ISO-8859-6"
			case "csisolatingreek":
			case "ecma-118":
			case "elot_928":
			case "greek":
			case "greek8":
			case "iso-8859-7":
			case "iso-ir-126":
			case "iso8859-7":
			case "iso88597":
			case "iso_8859-7":
			case "iso_8859-7:1987":
			case "sun_eu_greek":
				return "ISO-8859-7"
			case "csiso88598e":
			case "csisolatinhebrew":
			case "hebrew":
			case "iso-8859-8":
			case "iso-8859-8-e":
			case "iso-ir-138":
			case "iso8859-8":
			case "iso88598":
			case "iso_8859-8":
			case "iso_8859-8:1988":
			case "visual":
				return "ISO-8859-8"
			case "csiso88598i":
			case "iso-8859-8-i":
			case "logical":
				return "ISO-8859-8-I"
			case "csisolatin6":
			case "iso-8859-10":
			case "iso-ir-157":
			case "iso8859-10":
			case "iso885910":
			case "l6":
			case "latin6":
				return "ISO-8859-10"
			case "iso-8859-13":
			case "iso8859-13":
			case "iso885913":
				return "ISO-8859-13"
			case "iso-8859-14":
			case "iso8859-14":
			case "iso885914":
				return "ISO-8859-14"
			case "csisolatin9":
			case "iso-8859-15":
			case "iso8859-15":
			case "iso885915":
			case "iso_8859-15":
			case "l9":
				return "ISO-8859-15"
			case "iso-8859-16":
				return "ISO-8859-16"
			case "cskoi8r":
			case "koi":
			case "koi8":
			case "koi8-r":
			case "koi8_r":
				return "KOI8-R"
			case "koi8-ru":
			case "koi8-u":
				return "KOI8-U"
			case "csmacintosh":
			case "mac":
			case "macintosh":
			case "x-mac-roman":
				return "macintosh"
			case "iso-8859-11":
			case "iso8859-11":
			case "iso885911":
			case "tis-620":
			case "windows-874":
				return "windows-874"
			case "cp1250":
			case "windows-1250":
			case "x-cp1250":
				return "windows-1250"
			case "cp1251":
			case "windows-1251":
			case "x-cp1251":
				return "windows-1251"
			case "ansi_x3.4-1968":
			case "ascii":
			case "cp1252":
			case "cp819":
			case "csisolatin1":
			case "ibm819":
			case "iso-8859-1":
			case "iso-ir-100":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "iso_8859-1:1987":
			case "l1":
			case "latin1":
			case "us-ascii":
			case "windows-1252":
			case "x-cp1252":
				return "windows-1252"
			case "cp1253":
			case "windows-1253":
			case "x-cp1253":
				return "windows-1253"
			case "cp1254":
			case "csisolatin5":
			case "iso-8859-9":
			case "iso-ir-148":
			case "iso8859-9":
			case "iso88599":
			case "iso_8859-9":
			case "iso_8859-9:1989":
			case "l5":
			case "latin5":
			case "windows-1254":
			case "x-cp1254":
				return "windows-1254"
			case "cp1255":
			case "windows-1255":
			case "x-cp1255":
				return "windows-1255"
			case "cp1256":
			case "windows-1256":
			case "x-cp1256":
				return "windows-1256"
			case "cp1257":
			case "windows-1257":
			case "x-cp1257":
				return "windows-1257"
			case "cp1258":
			case "windows-1258":
			case "x-cp1258":
				return "windows-1258"
			case "x-mac-cyrillic":
			case "x-mac-ukrainian":
				return "x-mac-cyrillic"
			case "chinese":
			case "csgb2312":
			case "csiso58gb231280":
			case "gb2312":
			case "gb_2312":
			case "gb_2312-80":
			case "gbk":
			case "iso-ir-58":
			case "x-gbk":
				return "GBK"
			case "gb18030":
				return "gb18030"
			case "big5":
			case "big5-hkscs":
			case "cn-big5":
			case "csbig5":
			case "x-x-big5":
				return "Big5"
			case "cseucpkdfmtjapanese":
			case "euc-jp":
			case "x-euc-jp":
				return "EUC-JP"
			case "csiso2022jp":
			case "iso-2022-jp":
				return "ISO-2022-JP"
			case "csshiftjis":
			case "ms932":
			case "ms_kanji":
			case "shift-jis":
			case "shift_jis":
			case "sjis":
			case "windows-31j":
			case "x-sjis":
				return "Shift_JIS"
			case "cseuckr":
			case "csksc56011987":
			case "euc-kr":
			case "iso-ir-149":
			case "korean":
			case "ks_c_5601-1987":
			case "ks_c_5601-1989":
			case "ksc5601":
			case "ksc_5601":
			case "windows-949":
				return "EUC-KR"
			case "csiso2022kr":
			case "hz-gb-2312":
			case "iso-2022-cn":
			case "iso-2022-cn-ext":
			case "iso-2022-kr":
			case "replacement":
				return "replacement"
			case "unicodefffe":
			case "utf-16be":
				return "UTF-16BE"
			case "csunicode":
			case "iso-10646-ucs-2":
			case "ucs-2":
			case "unicode":
			case "unicodefeff":
			case "utf-16":
			case "utf-16le":
				return "UTF-16LE"
			case "x-user-defined":
				return "x-user-defined"
			default:
				return "failure"
		}
	}
	roe.exports = { getEncoding: xKe }
})
var doe = x((uSt, uoe) => {
	"use strict"
	var { kState: I0, kError: qV, kResult: ioe, kAborted: ub, kLastProgressEventFired: VV } = UV(),
		{ ProgressEvent: _Ke } = toe(),
		{ getEncoding: soe } = noe(),
		{ serializeAMimeType: wKe, parseMIMEType: ooe } = No(),
		{ types: IKe } = require("util"),
		{ StringDecoder: aoe } = require("string_decoder"),
		{ btoa: loe } = require("buffer"),
		SKe = { enumerable: !0, writable: !1, configurable: !1 }
	function BKe(e, t, r, n) {
		if (e[I0] === "loading") throw new DOMException("Invalid state", "InvalidStateError")
		;(e[I0] = "loading"), (e[ioe] = null), (e[qV] = null)
		let s = t.stream().getReader(),
			o = [],
			a = s.read(),
			l = !0
		;(async () => {
			for (; !e[ub]; )
				try {
					let { done: c, value: u } = await a
					if (
						(l &&
							!e[ub] &&
							queueMicrotask(() => {
								ih("loadstart", e)
							}),
						(l = !1),
						!c && IKe.isUint8Array(u))
					)
						o.push(u),
							(e[VV] === void 0 || Date.now() - e[VV] >= 50) &&
								!e[ub] &&
								((e[VV] = Date.now()),
								queueMicrotask(() => {
									ih("progress", e)
								})),
							(a = s.read())
					else if (c) {
						queueMicrotask(() => {
							e[I0] = "done"
							try {
								let f = DKe(o, r, t.type, n)
								if (e[ub]) return
								;(e[ioe] = f), ih("load", e)
							} catch (f) {
								;(e[qV] = f), ih("error", e)
							}
							e[I0] !== "loading" && ih("loadend", e)
						})
						break
					}
				} catch (c) {
					if (e[ub]) return
					queueMicrotask(() => {
						;(e[I0] = "done"), (e[qV] = c), ih("error", e), e[I0] !== "loading" && ih("loadend", e)
					})
					break
				}
		})()
	}
	function ih(e, t) {
		let r = new _Ke(e, { bubbles: !1, cancelable: !1 })
		t.dispatchEvent(r)
	}
	function DKe(e, t, r, n) {
		switch (t) {
			case "DataURL": {
				let i = "data:",
					s = ooe(r || "application/octet-stream")
				s !== "failure" && (i += wKe(s)), (i += ";base64,")
				let o = new aoe("latin1")
				for (let a of e) i += loe(o.write(a))
				return (i += loe(o.end())), i
			}
			case "Text": {
				let i = "failure"
				if ((n && (i = soe(n)), i === "failure" && r)) {
					let s = ooe(r)
					s !== "failure" && (i = soe(s.parameters.get("charset")))
				}
				return i === "failure" && (i = "UTF-8"), TKe(e, i)
			}
			case "ArrayBuffer":
				return coe(e).buffer
			case "BinaryString": {
				let i = "",
					s = new aoe("latin1")
				for (let o of e) i += s.write(o)
				return (i += s.end()), i
			}
		}
	}
	function TKe(e, t) {
		let r = coe(e),
			n = RKe(r),
			i = 0
		n !== null && ((t = n), (i = n === "UTF-8" ? 3 : 2))
		let s = r.slice(i)
		return new TextDecoder(t).decode(s)
	}
	function RKe(e) {
		let [t, r, n] = e
		return t === 239 && r === 187 && n === 191
			? "UTF-8"
			: t === 254 && r === 255
				? "UTF-16BE"
				: t === 255 && r === 254
					? "UTF-16LE"
					: null
	}
	function coe(e) {
		let t = e.reduce((n, i) => n + i.byteLength, 0),
			r = 0
		return e.reduce((n, i) => (n.set(i, r), (r += i.byteLength), n), new Uint8Array(t))
	}
	uoe.exports = {
		staticPropertyDescriptors: SKe,
		readOperation: BKe,
		fireAProgressEvent: ih,
	}
})
var poe = x((dSt, goe) => {
	"use strict"
	var { staticPropertyDescriptors: S0, readOperation: RD, fireAProgressEvent: foe } = doe(),
		{ kState: Cp, kError: hoe, kResult: kD, kEvents: Hr, kAborted: kKe } = UV(),
		{ webidl: on } = ys(),
		{ kEnumerableProperty: Uo } = Xt(),
		dc = class e extends EventTarget {
			constructor() {
				super(),
					(this[Cp] = "empty"),
					(this[kD] = null),
					(this[hoe] = null),
					(this[Hr] = {
						loadend: null,
						error: null,
						abort: null,
						load: null,
						progress: null,
						loadstart: null,
					})
			}
			readAsArrayBuffer(t) {
				on.brandCheck(this, e),
					on.argumentLengthCheck(arguments, 1, "FileReader.readAsArrayBuffer"),
					(t = on.converters.Blob(t, { strict: !1 })),
					RD(this, t, "ArrayBuffer")
			}
			readAsBinaryString(t) {
				on.brandCheck(this, e),
					on.argumentLengthCheck(arguments, 1, "FileReader.readAsBinaryString"),
					(t = on.converters.Blob(t, { strict: !1 })),
					RD(this, t, "BinaryString")
			}
			readAsText(t, r = void 0) {
				on.brandCheck(this, e),
					on.argumentLengthCheck(arguments, 1, "FileReader.readAsText"),
					(t = on.converters.Blob(t, { strict: !1 })),
					r !== void 0 && (r = on.converters.DOMString(r, "FileReader.readAsText", "encoding")),
					RD(this, t, "Text", r)
			}
			readAsDataURL(t) {
				on.brandCheck(this, e),
					on.argumentLengthCheck(arguments, 1, "FileReader.readAsDataURL"),
					(t = on.converters.Blob(t, { strict: !1 })),
					RD(this, t, "DataURL")
			}
			abort() {
				if (this[Cp] === "empty" || this[Cp] === "done") {
					this[kD] = null
					return
				}
				this[Cp] === "loading" && ((this[Cp] = "done"), (this[kD] = null)),
					(this[kKe] = !0),
					foe("abort", this),
					this[Cp] !== "loading" && foe("loadend", this)
			}
			get readyState() {
				switch ((on.brandCheck(this, e), this[Cp])) {
					case "empty":
						return this.EMPTY
					case "loading":
						return this.LOADING
					case "done":
						return this.DONE
				}
			}
			get result() {
				return on.brandCheck(this, e), this[kD]
			}
			get error() {
				return on.brandCheck(this, e), this[hoe]
			}
			get onloadend() {
				return on.brandCheck(this, e), this[Hr].loadend
			}
			set onloadend(t) {
				on.brandCheck(this, e),
					this[Hr].loadend && this.removeEventListener("loadend", this[Hr].loadend),
					typeof t == "function"
						? ((this[Hr].loadend = t), this.addEventListener("loadend", t))
						: (this[Hr].loadend = null)
			}
			get onerror() {
				return on.brandCheck(this, e), this[Hr].error
			}
			set onerror(t) {
				on.brandCheck(this, e),
					this[Hr].error && this.removeEventListener("error", this[Hr].error),
					typeof t == "function"
						? ((this[Hr].error = t), this.addEventListener("error", t))
						: (this[Hr].error = null)
			}
			get onloadstart() {
				return on.brandCheck(this, e), this[Hr].loadstart
			}
			set onloadstart(t) {
				on.brandCheck(this, e),
					this[Hr].loadstart && this.removeEventListener("loadstart", this[Hr].loadstart),
					typeof t == "function"
						? ((this[Hr].loadstart = t), this.addEventListener("loadstart", t))
						: (this[Hr].loadstart = null)
			}
			get onprogress() {
				return on.brandCheck(this, e), this[Hr].progress
			}
			set onprogress(t) {
				on.brandCheck(this, e),
					this[Hr].progress && this.removeEventListener("progress", this[Hr].progress),
					typeof t == "function"
						? ((this[Hr].progress = t), this.addEventListener("progress", t))
						: (this[Hr].progress = null)
			}
			get onload() {
				return on.brandCheck(this, e), this[Hr].load
			}
			set onload(t) {
				on.brandCheck(this, e),
					this[Hr].load && this.removeEventListener("load", this[Hr].load),
					typeof t == "function"
						? ((this[Hr].load = t), this.addEventListener("load", t))
						: (this[Hr].load = null)
			}
			get onabort() {
				return on.brandCheck(this, e), this[Hr].abort
			}
			set onabort(t) {
				on.brandCheck(this, e),
					this[Hr].abort && this.removeEventListener("abort", this[Hr].abort),
					typeof t == "function"
						? ((this[Hr].abort = t), this.addEventListener("abort", t))
						: (this[Hr].abort = null)
			}
		}
	dc.EMPTY = dc.prototype.EMPTY = 0
	dc.LOADING = dc.prototype.LOADING = 1
	dc.DONE = dc.prototype.DONE = 2
	Object.defineProperties(dc.prototype, {
		EMPTY: S0,
		LOADING: S0,
		DONE: S0,
		readAsArrayBuffer: Uo,
		readAsBinaryString: Uo,
		readAsText: Uo,
		readAsDataURL: Uo,
		abort: Uo,
		readyState: Uo,
		result: Uo,
		error: Uo,
		onloadstart: Uo,
		onprogress: Uo,
		onload: Uo,
		onabort: Uo,
		onerror: Uo,
		onloadend: Uo,
		[Symbol.toStringTag]: {
			value: "FileReader",
			writable: !1,
			enumerable: !1,
			configurable: !0,
		},
	})
	Object.defineProperties(dc, { EMPTY: S0, LOADING: S0, DONE: S0 })
	goe.exports = { FileReader: dc }
})
var MD = x((fSt, Aoe) => {
	"use strict"
	Aoe.exports = { kConstruct: Qn().kConstruct }
})
var Coe = x((hSt, yoe) => {
	"use strict"
	var MKe = require("assert"),
		{ URLSerializer: moe } = No(),
		{ isValidHeaderName: FKe } = ga()
	function QKe(e, t, r = !1) {
		let n = moe(e, r),
			i = moe(t, r)
		return n === i
	}
	function NKe(e) {
		MKe(e !== null)
		let t = []
		for (let r of e.split(",")) (r = r.trim()), FKe(r) && t.push(r)
		return t
	}
	yoe.exports = { urlEquals: QKe, getFieldValues: NKe }
})
var boe = x((gSt, Eoe) => {
	"use strict"
	var { kConstruct: PKe } = MD(),
		{ urlEquals: LKe, getFieldValues: HV } = Coe(),
		{ kEnumerableProperty: vp, isDisturbed: UKe } = Xt(),
		{ webidl: tt } = ys(),
		{ Response: OKe, cloneResponse: qKe, fromInnerResponse: VKe } = ab(),
		{ Request: Fd, fromInnerRequest: HKe } = w0(),
		{ kState: fc } = Gf(),
		{ fetching: WKe } = cb(),
		{ urlIsHttpHttpsScheme: FD, createDeferredPromise: B0, readAllBytes: GKe } = ga(),
		WV = require("assert"),
		QD = class e {
			#e
			constructor() {
				arguments[0] !== PKe && tt.illegalConstructor(),
					tt.util.markAsUncloneable(this),
					(this.#e = arguments[1])
			}
			async match(t, r = {}) {
				tt.brandCheck(this, e)
				let n = "Cache.match"
				tt.argumentLengthCheck(arguments, 1, n),
					(t = tt.converters.RequestInfo(t, n, "request")),
					(r = tt.converters.CacheQueryOptions(r, n, "options"))
				let i = this.#r(t, r, 1)
				if (i.length !== 0) return i[0]
			}
			async matchAll(t = void 0, r = {}) {
				tt.brandCheck(this, e)
				let n = "Cache.matchAll"
				return (
					t !== void 0 && (t = tt.converters.RequestInfo(t, n, "request")),
					(r = tt.converters.CacheQueryOptions(r, n, "options")),
					this.#r(t, r)
				)
			}
			async add(t) {
				tt.brandCheck(this, e)
				let r = "Cache.add"
				tt.argumentLengthCheck(arguments, 1, r), (t = tt.converters.RequestInfo(t, r, "request"))
				let n = [t]
				return await this.addAll(n)
			}
			async addAll(t) {
				tt.brandCheck(this, e)
				let r = "Cache.addAll"
				tt.argumentLengthCheck(arguments, 1, r)
				let n = [],
					i = []
				for (let p of t) {
					if (p === void 0)
						throw tt.errors.conversionFailed({
							prefix: r,
							argument: "Argument 1",
							types: ["undefined is not allowed"],
						})
					if (((p = tt.converters.RequestInfo(p)), typeof p == "string")) continue
					let g = p[fc]
					if (!FD(g.url) || g.method !== "GET")
						throw tt.errors.exception({
							header: r,
							message: "Expected http/s scheme when method is not GET.",
						})
				}
				let s = []
				for (let p of t) {
					let g = new Fd(p)[fc]
					if (!FD(g.url))
						throw tt.errors.exception({
							header: r,
							message: "Expected http/s scheme.",
						})
					;(g.initiator = "fetch"), (g.destination = "subresource"), i.push(g)
					let m = B0()
					s.push(
						WKe({
							request: g,
							processResponse(y) {
								if (y.type === "error" || y.status === 206 || y.status < 200 || y.status > 299)
									m.reject(
										tt.errors.exception({
											header: "Cache.addAll",
											message: "Received an invalid status code or the request failed.",
										}),
									)
								else if (y.headersList.contains("vary")) {
									let C = HV(y.headersList.get("vary"))
									for (let v of C)
										if (v === "*") {
											m.reject(
												tt.errors.exception({
													header: "Cache.addAll",
													message: "invalid vary field value",
												}),
											)
											for (let b of s) b.abort()
											return
										}
								}
							},
							processResponseEndOfBody(y) {
								if (y.aborted) {
									m.reject(new DOMException("aborted", "AbortError"))
									return
								}
								m.resolve(y)
							},
						}),
					),
						n.push(m.promise)
				}
				let a = await Promise.all(n),
					l = [],
					c = 0
				for (let p of a) {
					let g = { type: "put", request: i[c], response: p }
					l.push(g), c++
				}
				let u = B0(),
					f = null
				try {
					this.#t(l)
				} catch (p) {
					f = p
				}
				return (
					queueMicrotask(() => {
						f === null ? u.resolve(void 0) : u.reject(f)
					}),
					u.promise
				)
			}
			async put(t, r) {
				tt.brandCheck(this, e)
				let n = "Cache.put"
				tt.argumentLengthCheck(arguments, 2, n),
					(t = tt.converters.RequestInfo(t, n, "request")),
					(r = tt.converters.Response(r, n, "response"))
				let i = null
				if ((t instanceof Fd ? (i = t[fc]) : (i = new Fd(t)[fc]), !FD(i.url) || i.method !== "GET"))
					throw tt.errors.exception({
						header: n,
						message: "Expected an http/s scheme when method is not GET",
					})
				let s = r[fc]
				if (s.status === 206) throw tt.errors.exception({ header: n, message: "Got 206 status" })
				if (s.headersList.contains("vary")) {
					let g = HV(s.headersList.get("vary"))
					for (let m of g)
						if (m === "*")
							throw tt.errors.exception({
								header: n,
								message: "Got * vary field value",
							})
				}
				if (s.body && (UKe(s.body.stream) || s.body.stream.locked))
					throw tt.errors.exception({
						header: n,
						message: "Response body is locked or disturbed",
					})
				let o = qKe(s),
					a = B0()
				if (s.body != null) {
					let m = s.body.stream.getReader()
					GKe(m).then(a.resolve, a.reject)
				} else a.resolve(void 0)
				let l = [],
					c = { type: "put", request: i, response: o }
				l.push(c)
				let u = await a.promise
				o.body != null && (o.body.source = u)
				let f = B0(),
					p = null
				try {
					this.#t(l)
				} catch (g) {
					p = g
				}
				return (
					queueMicrotask(() => {
						p === null ? f.resolve() : f.reject(p)
					}),
					f.promise
				)
			}
			async delete(t, r = {}) {
				tt.brandCheck(this, e)
				let n = "Cache.delete"
				tt.argumentLengthCheck(arguments, 1, n),
					(t = tt.converters.RequestInfo(t, n, "request")),
					(r = tt.converters.CacheQueryOptions(r, n, "options"))
				let i = null
				if (t instanceof Fd) {
					if (((i = t[fc]), i.method !== "GET" && !r.ignoreMethod)) return !1
				} else WV(typeof t == "string"), (i = new Fd(t)[fc])
				let s = [],
					o = { type: "delete", request: i, options: r }
				s.push(o)
				let a = B0(),
					l = null,
					c
				try {
					c = this.#t(s)
				} catch (u) {
					l = u
				}
				return (
					queueMicrotask(() => {
						l === null ? a.resolve(!!c?.length) : a.reject(l)
					}),
					a.promise
				)
			}
			async keys(t = void 0, r = {}) {
				tt.brandCheck(this, e)
				let n = "Cache.keys"
				t !== void 0 && (t = tt.converters.RequestInfo(t, n, "request")),
					(r = tt.converters.CacheQueryOptions(r, n, "options"))
				let i = null
				if (t !== void 0)
					if (t instanceof Fd) {
						if (((i = t[fc]), i.method !== "GET" && !r.ignoreMethod)) return []
					} else typeof t == "string" && (i = new Fd(t)[fc])
				let s = B0(),
					o = []
				if (t === void 0) for (let a of this.#e) o.push(a[0])
				else {
					let a = this.#i(i, r)
					for (let l of a) o.push(l[0])
				}
				return (
					queueMicrotask(() => {
						let a = []
						for (let l of o) {
							let c = HKe(l, new AbortController().signal, "immutable")
							a.push(c)
						}
						s.resolve(Object.freeze(a))
					}),
					s.promise
				)
			}
			#t(t) {
				let r = this.#e,
					n = [...r],
					i = [],
					s = []
				try {
					for (let o of t) {
						if (o.type !== "delete" && o.type !== "put")
							throw tt.errors.exception({
								header: "Cache.#batchCacheOperations",
								message: 'operation type does not match "delete" or "put"',
							})
						if (o.type === "delete" && o.response != null)
							throw tt.errors.exception({
								header: "Cache.#batchCacheOperations",
								message: "delete operation should not have an associated response",
							})
						if (this.#i(o.request, o.options, i).length) throw new DOMException("???", "InvalidStateError")
						let a
						if (o.type === "delete") {
							if (((a = this.#i(o.request, o.options)), a.length === 0)) return []
							for (let l of a) {
								let c = r.indexOf(l)
								WV(c !== -1), r.splice(c, 1)
							}
						} else if (o.type === "put") {
							if (o.response == null)
								throw tt.errors.exception({
									header: "Cache.#batchCacheOperations",
									message: "put operation should have an associated response",
								})
							let l = o.request
							if (!FD(l.url))
								throw tt.errors.exception({
									header: "Cache.#batchCacheOperations",
									message: "expected http or https scheme",
								})
							if (l.method !== "GET")
								throw tt.errors.exception({
									header: "Cache.#batchCacheOperations",
									message: "not get method",
								})
							if (o.options != null)
								throw tt.errors.exception({
									header: "Cache.#batchCacheOperations",
									message: "options must not be defined",
								})
							a = this.#i(o.request)
							for (let c of a) {
								let u = r.indexOf(c)
								WV(u !== -1), r.splice(u, 1)
							}
							r.push([o.request, o.response]), i.push([o.request, o.response])
						}
						s.push([o.request, o.response])
					}
					return s
				} catch (o) {
					throw ((this.#e.length = 0), (this.#e = n), o)
				}
			}
			#i(t, r, n) {
				let i = [],
					s = n ?? this.#e
				for (let o of s) {
					let [a, l] = o
					this.#n(t, a, l, r) && i.push(o)
				}
				return i
			}
			#n(t, r, n = null, i) {
				let s = new URL(t.url),
					o = new URL(r.url)
				if ((i?.ignoreSearch && ((o.search = ""), (s.search = "")), !LKe(s, o, !0))) return !1
				if (n == null || i?.ignoreVary || !n.headersList.contains("vary")) return !0
				let a = HV(n.headersList.get("vary"))
				for (let l of a) {
					if (l === "*") return !1
					let c = r.headersList.get(l),
						u = t.headersList.get(l)
					if (c !== u) return !1
				}
				return !0
			}
			#r(t, r, n = 1 / 0) {
				let i = null
				if (t !== void 0)
					if (t instanceof Fd) {
						if (((i = t[fc]), i.method !== "GET" && !r.ignoreMethod)) return []
					} else typeof t == "string" && (i = new Fd(t)[fc])
				let s = []
				if (t === void 0) for (let a of this.#e) s.push(a[1])
				else {
					let a = this.#i(i, r)
					for (let l of a) s.push(l[1])
				}
				let o = []
				for (let a of s) {
					let l = VKe(a, "immutable")
					if ((o.push(l.clone()), o.length >= n)) break
				}
				return Object.freeze(o)
			}
		}
	Object.defineProperties(QD.prototype, {
		[Symbol.toStringTag]: { value: "Cache", configurable: !0 },
		match: vp,
		matchAll: vp,
		add: vp,
		addAll: vp,
		put: vp,
		delete: vp,
		keys: vp,
	})
	var voe = [
		{
			key: "ignoreSearch",
			converter: tt.converters.boolean,
			defaultValue: () => !1,
		},
		{
			key: "ignoreMethod",
			converter: tt.converters.boolean,
			defaultValue: () => !1,
		},
		{
			key: "ignoreVary",
			converter: tt.converters.boolean,
			defaultValue: () => !1,
		},
	]
	tt.converters.CacheQueryOptions = tt.dictionaryConverter(voe)
	tt.converters.MultiCacheQueryOptions = tt.dictionaryConverter([
		...voe,
		{ key: "cacheName", converter: tt.converters.DOMString },
	])
	tt.converters.Response = tt.interfaceConverter(OKe)
	tt.converters["sequence<RequestInfo>"] = tt.sequenceConverter(tt.converters.RequestInfo)
	Eoe.exports = { Cache: QD }
})
var _oe = x((pSt, xoe) => {
	"use strict"
	var { kConstruct: db } = MD(),
		{ Cache: ND } = boe(),
		{ webidl: Vs } = ys(),
		{ kEnumerableProperty: fb } = Xt(),
		PD = class e {
			#e = new Map()
			constructor() {
				arguments[0] !== db && Vs.illegalConstructor(), Vs.util.markAsUncloneable(this)
			}
			async match(t, r = {}) {
				if (
					(Vs.brandCheck(this, e),
					Vs.argumentLengthCheck(arguments, 1, "CacheStorage.match"),
					(t = Vs.converters.RequestInfo(t)),
					(r = Vs.converters.MultiCacheQueryOptions(r)),
					r.cacheName != null)
				) {
					if (this.#e.has(r.cacheName)) {
						let n = this.#e.get(r.cacheName)
						return await new ND(db, n).match(t, r)
					}
				} else
					for (let n of this.#e.values()) {
						let s = await new ND(db, n).match(t, r)
						if (s !== void 0) return s
					}
			}
			async has(t) {
				Vs.brandCheck(this, e)
				let r = "CacheStorage.has"
				return (
					Vs.argumentLengthCheck(arguments, 1, r),
					(t = Vs.converters.DOMString(t, r, "cacheName")),
					this.#e.has(t)
				)
			}
			async open(t) {
				Vs.brandCheck(this, e)
				let r = "CacheStorage.open"
				if (
					(Vs.argumentLengthCheck(arguments, 1, r),
					(t = Vs.converters.DOMString(t, r, "cacheName")),
					this.#e.has(t))
				) {
					let i = this.#e.get(t)
					return new ND(db, i)
				}
				let n = []
				return this.#e.set(t, n), new ND(db, n)
			}
			async delete(t) {
				Vs.brandCheck(this, e)
				let r = "CacheStorage.delete"
				return (
					Vs.argumentLengthCheck(arguments, 1, r),
					(t = Vs.converters.DOMString(t, r, "cacheName")),
					this.#e.delete(t)
				)
			}
			async keys() {
				return Vs.brandCheck(this, e), [...this.#e.keys()]
			}
		}
	Object.defineProperties(PD.prototype, {
		[Symbol.toStringTag]: { value: "CacheStorage", configurable: !0 },
		match: fb,
		has: fb,
		open: fb,
		delete: fb,
		keys: fb,
	})
	xoe.exports = { CacheStorage: PD }
})
var Ioe = x((ASt, woe) => {
	"use strict"
	woe.exports = { maxAttributeValueSize: 1024, maxNameValuePairSize: 4096 }
})
var GV = x((mSt, Roe) => {
	"use strict"
	function $Ke(e) {
		for (let t = 0; t < e.length; ++t) {
			let r = e.charCodeAt(t)
			if ((r >= 0 && r <= 8) || (r >= 10 && r <= 31) || r === 127) return !0
		}
		return !1
	}
	function Soe(e) {
		for (let t = 0; t < e.length; ++t) {
			let r = e.charCodeAt(t)
			if (
				r < 33 ||
				r > 126 ||
				r === 34 ||
				r === 40 ||
				r === 41 ||
				r === 60 ||
				r === 62 ||
				r === 64 ||
				r === 44 ||
				r === 59 ||
				r === 58 ||
				r === 92 ||
				r === 47 ||
				r === 91 ||
				r === 93 ||
				r === 63 ||
				r === 61 ||
				r === 123 ||
				r === 125
			)
				throw new Error("Invalid cookie name")
		}
	}
	function Boe(e) {
		let t = e.length,
			r = 0
		if (e[0] === '"') {
			if (t === 1 || e[t - 1] !== '"') throw new Error("Invalid cookie value")
			--t, ++r
		}
		for (; r < t; ) {
			let n = e.charCodeAt(r++)
			if (n < 33 || n > 126 || n === 34 || n === 44 || n === 59 || n === 92)
				throw new Error("Invalid cookie value")
		}
	}
	function Doe(e) {
		for (let t = 0; t < e.length; ++t) {
			let r = e.charCodeAt(t)
			if (r < 32 || r === 127 || r === 59) throw new Error("Invalid cookie path")
		}
	}
	function YKe(e) {
		if (e.startsWith("-") || e.endsWith(".") || e.endsWith("-")) throw new Error("Invalid cookie domain")
	}
	var KKe = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
		JKe = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
		LD = Array(61)
			.fill(0)
			.map((e, t) => t.toString().padStart(2, "0"))
	function Toe(e) {
		return (
			typeof e == "number" && (e = new Date(e)),
			`${KKe[e.getUTCDay()]}, ${LD[e.getUTCDate()]} ${
				JKe[e.getUTCMonth()]
			} ${e.getUTCFullYear()} ${LD[e.getUTCHours()]}:${LD[e.getUTCMinutes()]}:${LD[e.getUTCSeconds()]} GMT`
		)
	}
	function zKe(e) {
		if (e < 0) throw new Error("Invalid cookie max-age")
	}
	function jKe(e) {
		if (e.name.length === 0) return null
		Soe(e.name), Boe(e.value)
		let t = [`${e.name}=${e.value}`]
		e.name.startsWith("__Secure-") && (e.secure = !0),
			e.name.startsWith("__Host-") && ((e.secure = !0), (e.domain = null), (e.path = "/")),
			e.secure && t.push("Secure"),
			e.httpOnly && t.push("HttpOnly"),
			typeof e.maxAge == "number" && (zKe(e.maxAge), t.push(`Max-Age=${e.maxAge}`)),
			e.domain && (YKe(e.domain), t.push(`Domain=${e.domain}`)),
			e.path && (Doe(e.path), t.push(`Path=${e.path}`)),
			e.expires && e.expires.toString() !== "Invalid Date" && t.push(`Expires=${Toe(e.expires)}`),
			e.sameSite && t.push(`SameSite=${e.sameSite}`)
		for (let r of e.unparsed) {
			if (!r.includes("=")) throw new Error("Invalid unparsed")
			let [n, ...i] = r.split("=")
			t.push(`${n.trim()}=${i.join("=")}`)
		}
		return t.join("; ")
	}
	Roe.exports = {
		isCTLExcludingHtab: $Ke,
		validateCookieName: Soe,
		validateCookiePath: Doe,
		validateCookieValue: Boe,
		toIMFDate: Toe,
		stringify: jKe,
	}
})
var Moe = x((ySt, koe) => {
	"use strict"
	var { maxNameValuePairSize: ZKe, maxAttributeValueSize: XKe } = Ioe(),
		{ isCTLExcludingHtab: eJe } = GV(),
		{ collectASequenceOfCodePointsFast: UD } = No(),
		tJe = require("assert")
	function rJe(e) {
		if (eJe(e)) return null
		let t = "",
			r = "",
			n = "",
			i = ""
		if (e.includes(";")) {
			let s = { position: 0 }
			;(t = UD(";", e, s)), (r = e.slice(s.position))
		} else t = e
		if (!t.includes("=")) i = t
		else {
			let s = { position: 0 }
			;(n = UD("=", t, s)), (i = t.slice(s.position + 1))
		}
		return (n = n.trim()), (i = i.trim()), n.length + i.length > ZKe ? null : { name: n, value: i, ...D0(r) }
	}
	function D0(e, t = {}) {
		if (e.length === 0) return t
		tJe(e[0] === ";"), (e = e.slice(1))
		let r = ""
		e.includes(";") ? ((r = UD(";", e, { position: 0 })), (e = e.slice(r.length))) : ((r = e), (e = ""))
		let n = "",
			i = ""
		if (r.includes("=")) {
			let o = { position: 0 }
			;(n = UD("=", r, o)), (i = r.slice(o.position + 1))
		} else n = r
		if (((n = n.trim()), (i = i.trim()), i.length > XKe)) return D0(e, t)
		let s = n.toLowerCase()
		if (s === "expires") {
			let o = new Date(i)
			t.expires = o
		} else if (s === "max-age") {
			let o = i.charCodeAt(0)
			if (((o < 48 || o > 57) && i[0] !== "-") || !/^\d+$/.test(i)) return D0(e, t)
			let a = Number(i)
			t.maxAge = a
		} else if (s === "domain") {
			let o = i
			o[0] === "." && (o = o.slice(1)), (o = o.toLowerCase()), (t.domain = o)
		} else if (s === "path") {
			let o = ""
			i.length === 0 || i[0] !== "/" ? (o = "/") : (o = i), (t.path = o)
		} else if (s === "secure") t.secure = !0
		else if (s === "httponly") t.httpOnly = !0
		else if (s === "samesite") {
			let o = "Default",
				a = i.toLowerCase()
			a.includes("none") && (o = "None"),
				a.includes("strict") && (o = "Strict"),
				a.includes("lax") && (o = "Lax"),
				(t.sameSite = o)
		} else (t.unparsed ??= []), t.unparsed.push(`${n}=${i}`)
		return D0(e, t)
	}
	koe.exports = { parseSetCookie: rJe, parseUnparsedAttributes: D0 }
})
var Noe = x((CSt, Qoe) => {
	"use strict"
	var { parseSetCookie: nJe } = Moe(),
		{ stringify: iJe } = GV(),
		{ webidl: fr } = ys(),
		{ Headers: OD } = pp()
	function sJe(e) {
		fr.argumentLengthCheck(arguments, 1, "getCookies"), fr.brandCheck(e, OD, { strict: !1 })
		let t = e.get("cookie"),
			r = {}
		if (!t) return r
		for (let n of t.split(";")) {
			let [i, ...s] = n.split("=")
			r[i.trim()] = s.join("=")
		}
		return r
	}
	function oJe(e, t, r) {
		fr.brandCheck(e, OD, { strict: !1 })
		let n = "deleteCookie"
		fr.argumentLengthCheck(arguments, 2, n),
			(t = fr.converters.DOMString(t, n, "name")),
			(r = fr.converters.DeleteCookieAttributes(r)),
			Foe(e, { name: t, value: "", expires: new Date(0), ...r })
	}
	function aJe(e) {
		fr.argumentLengthCheck(arguments, 1, "getSetCookies"), fr.brandCheck(e, OD, { strict: !1 })
		let t = e.getSetCookie()
		return t ? t.map((r) => nJe(r)) : []
	}
	function Foe(e, t) {
		fr.argumentLengthCheck(arguments, 2, "setCookie"),
			fr.brandCheck(e, OD, { strict: !1 }),
			(t = fr.converters.Cookie(t))
		let r = iJe(t)
		r && e.append("Set-Cookie", r)
	}
	fr.converters.DeleteCookieAttributes = fr.dictionaryConverter([
		{
			converter: fr.nullableConverter(fr.converters.DOMString),
			key: "path",
			defaultValue: () => null,
		},
		{
			converter: fr.nullableConverter(fr.converters.DOMString),
			key: "domain",
			defaultValue: () => null,
		},
	])
	fr.converters.Cookie = fr.dictionaryConverter([
		{ converter: fr.converters.DOMString, key: "name" },
		{ converter: fr.converters.DOMString, key: "value" },
		{
			converter: fr.nullableConverter((e) =>
				typeof e == "number" ? fr.converters["unsigned long long"](e) : new Date(e),
			),
			key: "expires",
			defaultValue: () => null,
		},
		{
			converter: fr.nullableConverter(fr.converters["long long"]),
			key: "maxAge",
			defaultValue: () => null,
		},
		{
			converter: fr.nullableConverter(fr.converters.DOMString),
			key: "domain",
			defaultValue: () => null,
		},
		{
			converter: fr.nullableConverter(fr.converters.DOMString),
			key: "path",
			defaultValue: () => null,
		},
		{
			converter: fr.nullableConverter(fr.converters.boolean),
			key: "secure",
			defaultValue: () => null,
		},
		{
			converter: fr.nullableConverter(fr.converters.boolean),
			key: "httpOnly",
			defaultValue: () => null,
		},
		{
			converter: fr.converters.USVString,
			key: "sameSite",
			allowedValues: ["Strict", "Lax", "None"],
		},
		{
			converter: fr.sequenceConverter(fr.converters.DOMString),
			key: "unparsed",
			defaultValue: () => new Array(0),
		},
	])
	Qoe.exports = {
		getCookies: sJe,
		deleteCookie: oJe,
		getSetCookies: aJe,
		setCookie: Foe,
	}
})
var R0 = x((vSt, Loe) => {
	"use strict"
	var { webidl: et } = ys(),
		{ kEnumerableProperty: Oo } = Xt(),
		{ kConstruct: Poe } = Qn(),
		{ MessagePort: lJe } = require("worker_threads"),
		T0 = class e extends Event {
			#e
			constructor(t, r = {}) {
				if (t === Poe) {
					super(arguments[1], arguments[2]), et.util.markAsUncloneable(this)
					return
				}
				let n = "MessageEvent constructor"
				et.argumentLengthCheck(arguments, 1, n),
					(t = et.converters.DOMString(t, n, "type")),
					(r = et.converters.MessageEventInit(r, n, "eventInitDict")),
					super(t, r),
					(this.#e = r),
					et.util.markAsUncloneable(this)
			}
			get data() {
				return et.brandCheck(this, e), this.#e.data
			}
			get origin() {
				return et.brandCheck(this, e), this.#e.origin
			}
			get lastEventId() {
				return et.brandCheck(this, e), this.#e.lastEventId
			}
			get source() {
				return et.brandCheck(this, e), this.#e.source
			}
			get ports() {
				return (
					et.brandCheck(this, e),
					Object.isFrozen(this.#e.ports) || Object.freeze(this.#e.ports),
					this.#e.ports
				)
			}
			initMessageEvent(t, r = !1, n = !1, i = null, s = "", o = "", a = null, l = []) {
				return (
					et.brandCheck(this, e),
					et.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent"),
					new e(t, {
						bubbles: r,
						cancelable: n,
						data: i,
						origin: s,
						lastEventId: o,
						source: a,
						ports: l,
					})
				)
			}
			static createFastMessageEvent(t, r) {
				let n = new e(Poe, t, r)
				return (
					(n.#e = r),
					(n.#e.data ??= null),
					(n.#e.origin ??= ""),
					(n.#e.lastEventId ??= ""),
					(n.#e.source ??= null),
					(n.#e.ports ??= []),
					n
				)
			}
		},
		{ createFastMessageEvent: cJe } = T0
	delete T0.createFastMessageEvent
	var qD = class e extends Event {
			#e
			constructor(t, r = {}) {
				let n = "CloseEvent constructor"
				et.argumentLengthCheck(arguments, 1, n),
					(t = et.converters.DOMString(t, n, "type")),
					(r = et.converters.CloseEventInit(r)),
					super(t, r),
					(this.#e = r),
					et.util.markAsUncloneable(this)
			}
			get wasClean() {
				return et.brandCheck(this, e), this.#e.wasClean
			}
			get code() {
				return et.brandCheck(this, e), this.#e.code
			}
			get reason() {
				return et.brandCheck(this, e), this.#e.reason
			}
		},
		VD = class e extends Event {
			#e
			constructor(t, r) {
				let n = "ErrorEvent constructor"
				et.argumentLengthCheck(arguments, 1, n),
					super(t, r),
					et.util.markAsUncloneable(this),
					(t = et.converters.DOMString(t, n, "type")),
					(r = et.converters.ErrorEventInit(r ?? {})),
					(this.#e = r)
			}
			get message() {
				return et.brandCheck(this, e), this.#e.message
			}
			get filename() {
				return et.brandCheck(this, e), this.#e.filename
			}
			get lineno() {
				return et.brandCheck(this, e), this.#e.lineno
			}
			get colno() {
				return et.brandCheck(this, e), this.#e.colno
			}
			get error() {
				return et.brandCheck(this, e), this.#e.error
			}
		}
	Object.defineProperties(T0.prototype, {
		[Symbol.toStringTag]: { value: "MessageEvent", configurable: !0 },
		data: Oo,
		origin: Oo,
		lastEventId: Oo,
		source: Oo,
		ports: Oo,
		initMessageEvent: Oo,
	})
	Object.defineProperties(qD.prototype, {
		[Symbol.toStringTag]: { value: "CloseEvent", configurable: !0 },
		reason: Oo,
		code: Oo,
		wasClean: Oo,
	})
	Object.defineProperties(VD.prototype, {
		[Symbol.toStringTag]: { value: "ErrorEvent", configurable: !0 },
		message: Oo,
		filename: Oo,
		lineno: Oo,
		colno: Oo,
		error: Oo,
	})
	et.converters.MessagePort = et.interfaceConverter(lJe)
	et.converters["sequence<MessagePort>"] = et.sequenceConverter(et.converters.MessagePort)
	var $V = [
		{
			key: "bubbles",
			converter: et.converters.boolean,
			defaultValue: () => !1,
		},
		{
			key: "cancelable",
			converter: et.converters.boolean,
			defaultValue: () => !1,
		},
		{
			key: "composed",
			converter: et.converters.boolean,
			defaultValue: () => !1,
		},
	]
	et.converters.MessageEventInit = et.dictionaryConverter([
		...$V,
		{ key: "data", converter: et.converters.any, defaultValue: () => null },
		{
			key: "origin",
			converter: et.converters.USVString,
			defaultValue: () => "",
		},
		{
			key: "lastEventId",
			converter: et.converters.DOMString,
			defaultValue: () => "",
		},
		{
			key: "source",
			converter: et.nullableConverter(et.converters.MessagePort),
			defaultValue: () => null,
		},
		{
			key: "ports",
			converter: et.converters["sequence<MessagePort>"],
			defaultValue: () => new Array(0),
		},
	])
	et.converters.CloseEventInit = et.dictionaryConverter([
		...$V,
		{
			key: "wasClean",
			converter: et.converters.boolean,
			defaultValue: () => !1,
		},
		{
			key: "code",
			converter: et.converters["unsigned short"],
			defaultValue: () => 0,
		},
		{
			key: "reason",
			converter: et.converters.USVString,
			defaultValue: () => "",
		},
	])
	et.converters.ErrorEventInit = et.dictionaryConverter([
		...$V,
		{
			key: "message",
			converter: et.converters.DOMString,
			defaultValue: () => "",
		},
		{
			key: "filename",
			converter: et.converters.USVString,
			defaultValue: () => "",
		},
		{
			key: "lineno",
			converter: et.converters["unsigned long"],
			defaultValue: () => 0,
		},
		{
			key: "colno",
			converter: et.converters["unsigned long"],
			defaultValue: () => 0,
		},
		{ key: "error", converter: et.converters.any },
	])
	Loe.exports = {
		MessageEvent: T0,
		CloseEvent: qD,
		ErrorEvent: VD,
		createFastMessageEvent: cJe,
	}
})
var Ep = x((ESt, Uoe) => {
	"use strict"
	var uJe = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
		dJe = { enumerable: !0, writable: !1, configurable: !1 },
		fJe = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 },
		hJe = { NOT_SENT: 0, PROCESSING: 1, SENT: 2 },
		gJe = { CONTINUATION: 0, TEXT: 1, BINARY: 2, CLOSE: 8, PING: 9, PONG: 10 },
		pJe = 2 ** 16 - 1,
		AJe = { INFO: 0, PAYLOADLENGTH_16: 2, PAYLOADLENGTH_64: 3, READ_DATA: 4 },
		mJe = Buffer.allocUnsafe(0),
		yJe = { string: 1, typedArray: 2, arrayBuffer: 3, blob: 4 }
	Uoe.exports = {
		uid: uJe,
		sentCloseFrameState: hJe,
		staticPropertyDescriptors: dJe,
		states: fJe,
		opcodes: gJe,
		maxUnsigned16Bit: pJe,
		parserStates: AJe,
		emptyBuffer: mJe,
		sendHints: yJe,
	}
})
var hb = x((bSt, Ooe) => {
	"use strict"
	Ooe.exports = {
		kWebSocketURL: Symbol("url"),
		kReadyState: Symbol("ready state"),
		kController: Symbol("controller"),
		kResponse: Symbol("response"),
		kBinaryType: Symbol("binary type"),
		kSentClose: Symbol("sent close"),
		kReceivedClose: Symbol("received close"),
		kByteParser: Symbol("byte parser"),
	}
})
var Ab = x((xSt, Joe) => {
	"use strict"
	var { kReadyState: gb, kController: CJe, kResponse: vJe, kBinaryType: EJe, kWebSocketURL: bJe } = hb(),
		{ states: pb, opcodes: sh } = Ep(),
		{ ErrorEvent: xJe, createFastMessageEvent: _Je } = R0(),
		{ isUtf8: wJe } = require("buffer"),
		{ collectASequenceOfCodePointsFast: IJe, removeHTTPWhitespace: qoe } = No()
	function SJe(e) {
		return e[gb] === pb.CONNECTING
	}
	function BJe(e) {
		return e[gb] === pb.OPEN
	}
	function DJe(e) {
		return e[gb] === pb.CLOSING
	}
	function TJe(e) {
		return e[gb] === pb.CLOSED
	}
	function YV(e, t, r = (i, s) => new Event(i, s), n = {}) {
		let i = r(e, n)
		t.dispatchEvent(i)
	}
	function RJe(e, t, r) {
		if (e[gb] !== pb.OPEN) return
		let n
		if (t === sh.TEXT)
			try {
				n = Koe(r)
			} catch {
				Hoe(e, "Received invalid UTF-8 in text frame.")
				return
			}
		else t === sh.BINARY && (e[EJe] === "blob" ? (n = new Blob([r])) : (n = kJe(r)))
		YV("message", e, _Je, { origin: e[bJe].origin, data: n })
	}
	function kJe(e) {
		return e.byteLength === e.buffer.byteLength
			? e.buffer
			: e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength)
	}
	function MJe(e) {
		if (e.length === 0) return !1
		for (let t = 0; t < e.length; ++t) {
			let r = e.charCodeAt(t)
			if (
				r < 33 ||
				r > 126 ||
				r === 34 ||
				r === 40 ||
				r === 41 ||
				r === 44 ||
				r === 47 ||
				r === 58 ||
				r === 59 ||
				r === 60 ||
				r === 61 ||
				r === 62 ||
				r === 63 ||
				r === 64 ||
				r === 91 ||
				r === 92 ||
				r === 93 ||
				r === 123 ||
				r === 125
			)
				return !1
		}
		return !0
	}
	function FJe(e) {
		return e >= 1e3 && e < 1015 ? e !== 1004 && e !== 1005 && e !== 1006 : e >= 3e3 && e <= 4999
	}
	function Hoe(e, t) {
		let { [CJe]: r, [vJe]: n } = e
		r.abort(),
			n?.socket && !n.socket.destroyed && n.socket.destroy(),
			t &&
				YV("error", e, (i, s) => new xJe(i, s), {
					error: new Error(t),
					message: t,
				})
	}
	function Woe(e) {
		return e === sh.CLOSE || e === sh.PING || e === sh.PONG
	}
	function Goe(e) {
		return e === sh.CONTINUATION
	}
	function $oe(e) {
		return e === sh.TEXT || e === sh.BINARY
	}
	function QJe(e) {
		return $oe(e) || Goe(e) || Woe(e)
	}
	function NJe(e) {
		let t = { position: 0 },
			r = new Map()
		for (; t.position < e.length; ) {
			let n = IJe(";", e, t),
				[i, s = ""] = n.split("=")
			r.set(qoe(i, !0, !1), qoe(s, !1, !0)), t.position++
		}
		return r
	}
	function PJe(e) {
		for (let t = 0; t < e.length; t++) {
			let r = e.charCodeAt(t)
			if (r < 48 || r > 57) return !1
		}
		return !0
	}
	var Yoe = typeof process.versions.icu == "string",
		Voe = Yoe ? new TextDecoder("utf-8", { fatal: !0 }) : void 0,
		Koe = Yoe
			? Voe.decode.bind(Voe)
			: function (e) {
					if (wJe(e)) return e.toString("utf-8")
					throw new TypeError("Invalid utf-8 received.")
				}
	Joe.exports = {
		isConnecting: SJe,
		isEstablished: BJe,
		isClosing: DJe,
		isClosed: TJe,
		fireEvent: YV,
		isValidSubprotocol: MJe,
		isValidStatusCode: FJe,
		failWebsocketConnection: Hoe,
		websocketMessageReceived: RJe,
		utf8Decode: Koe,
		isControlFrame: Woe,
		isContinuationFrame: Goe,
		isTextBinaryFrame: $oe,
		isValidOpcode: QJe,
		parseExtensions: NJe,
		isValidClientWindowBits: PJe,
	}
})
var WD = x((_St, zoe) => {
	"use strict"
	var { maxUnsigned16Bit: LJe } = Ep(),
		HD = 16386,
		KV,
		mb = null,
		k0 = HD
	try {
		KV = require("crypto")
	} catch {
		KV = {
			randomFillSync: function (t, r, n) {
				for (let i = 0; i < t.length; ++i) t[i] = (Math.random() * 255) | 0
				return t
			},
		}
	}
	function UJe() {
		return (
			k0 === HD && ((k0 = 0), KV.randomFillSync((mb ??= Buffer.allocUnsafe(HD)), 0, HD)),
			[mb[k0++], mb[k0++], mb[k0++], mb[k0++]]
		)
	}
	var JV = class {
		constructor(t) {
			this.frameData = t
		}
		createFrame(t) {
			let r = this.frameData,
				n = UJe(),
				i = r?.byteLength ?? 0,
				s = i,
				o = 6
			i > LJe ? ((o += 8), (s = 127)) : i > 125 && ((o += 2), (s = 126))
			let a = Buffer.allocUnsafe(i + o)
			;(a[0] = a[1] = 0), (a[0] |= 128), (a[0] = (a[0] & 240) + t)
			;(a[o - 4] = n[0]),
				(a[o - 3] = n[1]),
				(a[o - 2] = n[2]),
				(a[o - 1] = n[3]),
				(a[1] = s),
				s === 126 ? a.writeUInt16BE(i, 2) : s === 127 && ((a[2] = a[3] = 0), a.writeUIntBE(i, 4, 6)),
				(a[1] |= 128)
			for (let l = 0; l < i; ++l) a[o + l] = r[l] ^ n[l & 3]
			return a
		}
	}
	zoe.exports = { WebsocketFrameSend: JV }
})
var jV = x((wSt, nae) => {
	"use strict"
	var { uid: OJe, states: yb, sentCloseFrameState: GD, emptyBuffer: qJe, opcodes: VJe } = Ep(),
		{ kReadyState: Cb, kSentClose: $D, kByteParser: Zoe, kReceivedClose: joe, kResponse: Xoe } = hb(),
		{
			fireEvent: HJe,
			failWebsocketConnection: oh,
			isClosing: WJe,
			isClosed: GJe,
			isEstablished: $Je,
			parseExtensions: YJe,
		} = Ab(),
		{ channels: M0 } = $m(),
		{ CloseEvent: KJe } = R0(),
		{ makeRequest: JJe } = w0(),
		{ fetching: zJe } = cb(),
		{ Headers: jJe, getHeadersList: ZJe } = pp(),
		{ getDecodeSplit: XJe } = ga(),
		{ WebsocketFrameSend: eze } = WD(),
		zV
	try {
		zV = require("crypto")
	} catch {}
	function tze(e, t, r, n, i, s) {
		let o = e
		o.protocol = e.protocol === "ws:" ? "http:" : "https:"
		let a = JJe({
			urlList: [o],
			client: r,
			serviceWorkers: "none",
			referrer: "no-referrer",
			mode: "websocket",
			credentials: "include",
			cache: "no-store",
			redirect: "error",
		})
		if (s.headers) {
			let f = ZJe(new jJe(s.headers))
			a.headersList = f
		}
		let l = zV.randomBytes(16).toString("base64")
		a.headersList.append("sec-websocket-key", l), a.headersList.append("sec-websocket-version", "13")
		for (let f of t) a.headersList.append("sec-websocket-protocol", f)
		let c = "permessage-deflate; client_max_window_bits"
		return (
			a.headersList.append("sec-websocket-extensions", c),
			zJe({
				request: a,
				useParallelQueue: !0,
				dispatcher: s.dispatcher,
				processResponse(f) {
					if (f.type === "error" || f.status !== 101) {
						oh(n, "Received network error or non-101 status code.")
						return
					}
					if (t.length !== 0 && !f.headersList.get("Sec-WebSocket-Protocol")) {
						oh(n, "Server did not respond with sent protocols.")
						return
					}
					if (f.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
						oh(n, 'Server did not set Upgrade header to "websocket".')
						return
					}
					if (f.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
						oh(n, 'Server did not set Connection header to "upgrade".')
						return
					}
					let p = f.headersList.get("Sec-WebSocket-Accept"),
						g = zV
							.createHash("sha1")
							.update(l + OJe)
							.digest("base64")
					if (p !== g) {
						oh(n, "Incorrect hash received in Sec-WebSocket-Accept header.")
						return
					}
					let m = f.headersList.get("Sec-WebSocket-Extensions"),
						y
					if (m !== null && ((y = YJe(m)), !y.has("permessage-deflate"))) {
						oh(n, "Sec-WebSocket-Extensions header does not match.")
						return
					}
					let C = f.headersList.get("Sec-WebSocket-Protocol")
					if (C !== null && !XJe("sec-websocket-protocol", a.headersList).includes(C)) {
						oh(n, "Protocol was not set in the opening handshake.")
						return
					}
					f.socket.on("data", eae),
						f.socket.on("close", tae),
						f.socket.on("error", rae),
						M0.open.hasSubscribers &&
							M0.open.publish({
								address: f.socket.address(),
								protocol: C,
								extensions: m,
							}),
						i(f, y)
				},
			})
		)
	}
	function rze(e, t, r, n) {
		if (!(WJe(e) || GJe(e)))
			if (!$Je(e)) oh(e, "Connection was closed before it was established."), (e[Cb] = yb.CLOSING)
			else if (e[$D] === GD.NOT_SENT) {
				e[$D] = GD.PROCESSING
				let i = new eze()
				t !== void 0 && r === void 0
					? ((i.frameData = Buffer.allocUnsafe(2)), i.frameData.writeUInt16BE(t, 0))
					: t !== void 0 && r !== void 0
						? ((i.frameData = Buffer.allocUnsafe(2 + n)),
							i.frameData.writeUInt16BE(t, 0),
							i.frameData.write(r, 2, "utf-8"))
						: (i.frameData = qJe),
					e[Xoe].socket.write(i.createFrame(VJe.CLOSE)),
					(e[$D] = GD.SENT),
					(e[Cb] = yb.CLOSING)
			} else e[Cb] = yb.CLOSING
	}
	function eae(e) {
		this.ws[Zoe].write(e) || this.pause()
	}
	function tae() {
		let { ws: e } = this,
			{ [Xoe]: t } = e
		t.socket.off("data", eae), t.socket.off("close", tae), t.socket.off("error", rae)
		let r = e[$D] === GD.SENT && e[joe],
			n = 1005,
			i = "",
			s = e[Zoe].closingInfo
		s && !s.error ? ((n = s.code ?? 1005), (i = s.reason)) : e[joe] || (n = 1006),
			(e[Cb] = yb.CLOSED),
			HJe("close", e, (o, a) => new KJe(o, a), {
				wasClean: r,
				code: n,
				reason: i,
			}),
			M0.close.hasSubscribers && M0.close.publish({ websocket: e, code: n, reason: i })
	}
	function rae(e) {
		let { ws: t } = this
		;(t[Cb] = yb.CLOSING), M0.socketError.hasSubscribers && M0.socketError.publish(e), this.destroy()
	}
	nae.exports = {
		establishWebSocketConnection: tze,
		closeWebSocketConnection: rze,
	}
})
var sae = x((ISt, iae) => {
	"use strict"
	var { createInflateRaw: nze, Z_DEFAULT_WINDOWBITS: ize } = require("zlib"),
		{ isValidClientWindowBits: sze } = Ab(),
		oze = Buffer.from([0, 0, 255, 255]),
		YD = Symbol("kBuffer"),
		KD = Symbol("kLength"),
		ZV = class {
			#e
			#t = {}
			constructor(t) {
				;(this.#t.serverNoContextTakeover = t.has("server_no_context_takeover")),
					(this.#t.serverMaxWindowBits = t.get("server_max_window_bits"))
			}
			decompress(t, r, n) {
				if (!this.#e) {
					let i = ize
					if (this.#t.serverMaxWindowBits) {
						if (!sze(this.#t.serverMaxWindowBits)) {
							n(new Error("Invalid server_max_window_bits"))
							return
						}
						i = Number.parseInt(this.#t.serverMaxWindowBits)
					}
					;(this.#e = nze({ windowBits: i })),
						(this.#e[YD] = []),
						(this.#e[KD] = 0),
						this.#e.on("data", (s) => {
							this.#e[YD].push(s), (this.#e[KD] += s.length)
						}),
						this.#e.on("error", (s) => {
							;(this.#e = null), n(s)
						})
				}
				this.#e.write(t),
					r && this.#e.write(oze),
					this.#e.flush(() => {
						let i = Buffer.concat(this.#e[YD], this.#e[KD])
						;(this.#e[YD].length = 0), (this.#e[KD] = 0), n(null, i)
					})
			}
		}
	iae.exports = { PerMessageDeflate: ZV }
})
var Aae = x((SSt, pae) => {
	"use strict"
	var { Writable: aze } = require("stream"),
		lze = require("assert"),
		{ parserStates: qo, opcodes: F0, states: cze, emptyBuffer: oae, sentCloseFrameState: aae } = Ep(),
		{ kReadyState: uze, kSentClose: lae, kResponse: cae, kReceivedClose: uae } = hb(),
		{ channels: JD } = $m(),
		{
			isValidStatusCode: dze,
			isValidOpcode: fze,
			failWebsocketConnection: al,
			websocketMessageReceived: dae,
			utf8Decode: hze,
			isControlFrame: fae,
			isTextBinaryFrame: XV,
			isContinuationFrame: gze,
		} = Ab(),
		{ WebsocketFrameSend: hae } = WD(),
		{ closeWebSocketConnection: gae } = jV(),
		{ PerMessageDeflate: pze } = sae(),
		e5 = class extends aze {
			#e = []
			#t = 0
			#i = !1
			#n = qo.INFO
			#r = {}
			#l = []
			#o
			constructor(t, r) {
				super(),
					(this.ws = t),
					(this.#o = r ?? new Map()),
					this.#o.has("permessage-deflate") && this.#o.set("permessage-deflate", new pze(r))
			}
			_write(t, r, n) {
				this.#e.push(t), (this.#t += t.length), (this.#i = !0), this.run(n)
			}
			run(t) {
				for (; this.#i; )
					if (this.#n === qo.INFO) {
						if (this.#t < 2) return t()
						let r = this.consume(2),
							n = (r[0] & 128) !== 0,
							i = r[0] & 15,
							s = (r[1] & 128) === 128,
							o = !n && i !== F0.CONTINUATION,
							a = r[1] & 127,
							l = r[0] & 64,
							c = r[0] & 32,
							u = r[0] & 16
						if (!fze(i)) return al(this.ws, "Invalid opcode received"), t()
						if (s) return al(this.ws, "Frame cannot be masked"), t()
						if (l !== 0 && !this.#o.has("permessage-deflate")) {
							al(this.ws, "Expected RSV1 to be clear.")
							return
						}
						if (c !== 0 || u !== 0) {
							al(this.ws, "RSV1, RSV2, RSV3 must be clear")
							return
						}
						if (o && !XV(i)) {
							al(this.ws, "Invalid frame type was fragmented.")
							return
						}
						if (XV(i) && this.#l.length > 0) {
							al(this.ws, "Expected continuation frame")
							return
						}
						if (this.#r.fragmented && o) {
							al(this.ws, "Fragmented frame exceeded 125 bytes.")
							return
						}
						if ((a > 125 || o) && fae(i)) {
							al(this.ws, "Control frame either too large or fragmented")
							return
						}
						if (gze(i) && this.#l.length === 0 && !this.#r.compressed) {
							al(this.ws, "Unexpected continuation frame")
							return
						}
						a <= 125
							? ((this.#r.payloadLength = a), (this.#n = qo.READ_DATA))
							: a === 126
								? (this.#n = qo.PAYLOADLENGTH_16)
								: a === 127 && (this.#n = qo.PAYLOADLENGTH_64),
							XV(i) && ((this.#r.binaryType = i), (this.#r.compressed = l !== 0)),
							(this.#r.opcode = i),
							(this.#r.masked = s),
							(this.#r.fin = n),
							(this.#r.fragmented = o)
					} else if (this.#n === qo.PAYLOADLENGTH_16) {
						if (this.#t < 2) return t()
						let r = this.consume(2)
						;(this.#r.payloadLength = r.readUInt16BE(0)), (this.#n = qo.READ_DATA)
					} else if (this.#n === qo.PAYLOADLENGTH_64) {
						if (this.#t < 8) return t()
						let r = this.consume(8),
							n = r.readUInt32BE(0)
						if (n > 2 ** 31 - 1) {
							al(this.ws, "Received payload length > 2^31 bytes.")
							return
						}
						let i = r.readUInt32BE(4)
						;(this.#r.payloadLength = (n << 8) + i), (this.#n = qo.READ_DATA)
					} else if (this.#n === qo.READ_DATA) {
						if (this.#t < this.#r.payloadLength) return t()
						let r = this.consume(this.#r.payloadLength)
						if (fae(this.#r.opcode)) (this.#i = this.parseControlFrame(r)), (this.#n = qo.INFO)
						else if (this.#r.compressed) {
							this.#o.get("permessage-deflate").decompress(r, this.#r.fin, (n, i) => {
								if (n) {
									gae(this.ws, 1007, n.message, n.message.length)
									return
								}
								if ((this.#l.push(i), !this.#r.fin)) {
									;(this.#n = qo.INFO), (this.#i = !0), this.run(t)
									return
								}
								dae(this.ws, this.#r.binaryType, Buffer.concat(this.#l)),
									(this.#i = !0),
									(this.#n = qo.INFO),
									(this.#l.length = 0),
									this.run(t)
							}),
								(this.#i = !1)
							break
						} else {
							if ((this.#l.push(r), !this.#r.fragmented && this.#r.fin)) {
								let n = Buffer.concat(this.#l)
								dae(this.ws, this.#r.binaryType, n), (this.#l.length = 0)
							}
							this.#n = qo.INFO
						}
					}
			}
			consume(t) {
				if (t > this.#t) throw new Error("Called consume() before buffers satiated.")
				if (t === 0) return oae
				if (this.#e[0].length === t) return (this.#t -= this.#e[0].length), this.#e.shift()
				let r = Buffer.allocUnsafe(t),
					n = 0
				for (; n !== t; ) {
					let i = this.#e[0],
						{ length: s } = i
					if (s + n === t) {
						r.set(this.#e.shift(), n)
						break
					} else if (s + n > t) {
						r.set(i.subarray(0, t - n), n), (this.#e[0] = i.subarray(t - n))
						break
					} else r.set(this.#e.shift(), n), (n += i.length)
				}
				return (this.#t -= t), r
			}
			parseCloseBody(t) {
				lze(t.length !== 1)
				let r
				if ((t.length >= 2 && (r = t.readUInt16BE(0)), r !== void 0 && !dze(r)))
					return { code: 1002, reason: "Invalid status code", error: !0 }
				let n = t.subarray(2)
				n[0] === 239 && n[1] === 187 && n[2] === 191 && (n = n.subarray(3))
				try {
					n = hze(n)
				} catch {
					return { code: 1007, reason: "Invalid UTF-8", error: !0 }
				}
				return { code: r, reason: n, error: !1 }
			}
			parseControlFrame(t) {
				let { opcode: r, payloadLength: n } = this.#r
				if (r === F0.CLOSE) {
					if (n === 1) return al(this.ws, "Received close frame with a 1-byte body."), !1
					if (((this.#r.closeInfo = this.parseCloseBody(t)), this.#r.closeInfo.error)) {
						let { code: i, reason: s } = this.#r.closeInfo
						return gae(this.ws, i, s, s.length), al(this.ws, s), !1
					}
					if (this.ws[lae] !== aae.SENT) {
						let i = oae
						this.#r.closeInfo.code &&
							((i = Buffer.allocUnsafe(2)), i.writeUInt16BE(this.#r.closeInfo.code, 0))
						let s = new hae(i)
						this.ws[cae].socket.write(s.createFrame(F0.CLOSE), (o) => {
							o || (this.ws[lae] = aae.SENT)
						})
					}
					return (this.ws[uze] = cze.CLOSING), (this.ws[uae] = !0), !1
				} else if (r === F0.PING) {
					if (!this.ws[uae]) {
						let i = new hae(t)
						this.ws[cae].socket.write(i.createFrame(F0.PONG)),
							JD.ping.hasSubscribers && JD.ping.publish({ payload: t })
					}
				} else r === F0.PONG && JD.pong.hasSubscribers && JD.pong.publish({ payload: t })
				return !0
			}
			get closingInfo() {
				return this.#r.closeInfo
			}
		}
	pae.exports = { ByteParser: e5 }
})
var Eae = x((BSt, vae) => {
	"use strict"
	var { WebsocketFrameSend: Aze } = WD(),
		{ opcodes: mae, sendHints: Q0 } = Ep(),
		mze = fq(),
		yae = Buffer[Symbol.species],
		t5 = class {
			#e = new mze()
			#t = !1
			#i
			constructor(t) {
				this.#i = t
			}
			add(t, r, n) {
				if (n !== Q0.blob) {
					let s = Cae(t, n)
					if (!this.#t) this.#i.write(s, r)
					else {
						let o = { promise: null, callback: r, frame: s }
						this.#e.push(o)
					}
					return
				}
				let i = {
					promise: t.arrayBuffer().then((s) => {
						;(i.promise = null), (i.frame = Cae(s, n))
					}),
					callback: r,
					frame: null,
				}
				this.#e.push(i), this.#t || this.#n()
			}
			async #n() {
				this.#t = !0
				let t = this.#e
				for (; !t.isEmpty(); ) {
					let r = t.shift()
					r.promise !== null && (await r.promise),
						this.#i.write(r.frame, r.callback),
						(r.callback = r.frame = null)
				}
				this.#t = !1
			}
		}
	function Cae(e, t) {
		return new Aze(yze(e, t)).createFrame(t === Q0.string ? mae.TEXT : mae.BINARY)
	}
	function yze(e, t) {
		switch (t) {
			case Q0.string:
				return Buffer.from(e)
			case Q0.arrayBuffer:
			case Q0.blob:
				return new yae(e)
			case Q0.typedArray:
				return new yae(e.buffer, e.byteOffset, e.byteLength)
		}
	}
	vae.exports = { SendQueue: t5 }
})
var Tae = x((DSt, Dae) => {
	"use strict"
	var { webidl: _t } = ys(),
		{ URLSerializer: Cze } = No(),
		{ environmentSettingsObject: bae } = ga(),
		{ staticPropertyDescriptors: ah, states: vb, sentCloseFrameState: vze, sendHints: zD } = Ep(),
		{
			kWebSocketURL: xae,
			kReadyState: r5,
			kController: Eze,
			kBinaryType: jD,
			kResponse: _ae,
			kSentClose: bze,
			kByteParser: xze,
		} = hb(),
		{ isConnecting: _ze, isEstablished: wze, isClosing: Ize, isValidSubprotocol: Sze, fireEvent: wae } = Ab(),
		{ establishWebSocketConnection: Bze, closeWebSocketConnection: Iae } = jV(),
		{ ByteParser: Dze } = Aae(),
		{ kEnumerableProperty: ll, isBlobLike: Sae } = Xt(),
		{ getGlobalDispatcher: Tze } = dD(),
		{ types: Bae } = require("util"),
		{ ErrorEvent: Rze, CloseEvent: kze } = R0(),
		{ SendQueue: Mze } = Eae(),
		Ea = class e extends EventTarget {
			#e = { open: null, error: null, close: null, message: null }
			#t = 0
			#i = ""
			#n = ""
			#r
			constructor(t, r = []) {
				super(), _t.util.markAsUncloneable(this)
				let n = "WebSocket constructor"
				_t.argumentLengthCheck(arguments, 1, n)
				let i = _t.converters["DOMString or sequence<DOMString> or WebSocketInit"](r, n, "options")
				;(t = _t.converters.USVString(t, n, "url")), (r = i.protocols)
				let s = bae.settingsObject.baseUrl,
					o
				try {
					o = new URL(t, s)
				} catch (l) {
					throw new DOMException(l, "SyntaxError")
				}
				if (
					(o.protocol === "http:" ? (o.protocol = "ws:") : o.protocol === "https:" && (o.protocol = "wss:"),
					o.protocol !== "ws:" && o.protocol !== "wss:")
				)
					throw new DOMException(`Expected a ws: or wss: protocol, got ${o.protocol}`, "SyntaxError")
				if (o.hash || o.href.endsWith("#")) throw new DOMException("Got fragment", "SyntaxError")
				if ((typeof r == "string" && (r = [r]), r.length !== new Set(r.map((l) => l.toLowerCase())).size))
					throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError")
				if (r.length > 0 && !r.every((l) => Sze(l)))
					throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError")
				this[xae] = new URL(o.href)
				let a = bae.settingsObject
				;(this[Eze] = Bze(o, r, a, this, (l, c) => this.#l(l, c), i)),
					(this[r5] = e.CONNECTING),
					(this[bze] = vze.NOT_SENT),
					(this[jD] = "blob")
			}
			close(t = void 0, r = void 0) {
				_t.brandCheck(this, e)
				let n = "WebSocket.close"
				if (
					(t !== void 0 && (t = _t.converters["unsigned short"](t, n, "code", { clamp: !0 })),
					r !== void 0 && (r = _t.converters.USVString(r, n, "reason")),
					t !== void 0 && t !== 1e3 && (t < 3e3 || t > 4999))
				)
					throw new DOMException("invalid code", "InvalidAccessError")
				let i = 0
				if (r !== void 0 && ((i = Buffer.byteLength(r)), i > 123))
					throw new DOMException(`Reason must be less than 123 bytes; received ${i}`, "SyntaxError")
				Iae(this, t, r, i)
			}
			send(t) {
				_t.brandCheck(this, e)
				let r = "WebSocket.send"
				if (
					(_t.argumentLengthCheck(arguments, 1, r),
					(t = _t.converters.WebSocketSendData(t, r, "data")),
					_ze(this))
				)
					throw new DOMException("Sent before connected.", "InvalidStateError")
				if (!(!wze(this) || Ize(this)))
					if (typeof t == "string") {
						let n = Buffer.byteLength(t)
						;(this.#t += n),
							this.#r.add(
								t,
								() => {
									this.#t -= n
								},
								zD.string,
							)
					} else
						Bae.isArrayBuffer(t)
							? ((this.#t += t.byteLength),
								this.#r.add(
									t,
									() => {
										this.#t -= t.byteLength
									},
									zD.arrayBuffer,
								))
							: ArrayBuffer.isView(t)
								? ((this.#t += t.byteLength),
									this.#r.add(
										t,
										() => {
											this.#t -= t.byteLength
										},
										zD.typedArray,
									))
								: Sae(t) &&
									((this.#t += t.size),
									this.#r.add(
										t,
										() => {
											this.#t -= t.size
										},
										zD.blob,
									))
			}
			get readyState() {
				return _t.brandCheck(this, e), this[r5]
			}
			get bufferedAmount() {
				return _t.brandCheck(this, e), this.#t
			}
			get url() {
				return _t.brandCheck(this, e), Cze(this[xae])
			}
			get extensions() {
				return _t.brandCheck(this, e), this.#n
			}
			get protocol() {
				return _t.brandCheck(this, e), this.#i
			}
			get onopen() {
				return _t.brandCheck(this, e), this.#e.open
			}
			set onopen(t) {
				_t.brandCheck(this, e),
					this.#e.open && this.removeEventListener("open", this.#e.open),
					typeof t == "function"
						? ((this.#e.open = t), this.addEventListener("open", t))
						: (this.#e.open = null)
			}
			get onerror() {
				return _t.brandCheck(this, e), this.#e.error
			}
			set onerror(t) {
				_t.brandCheck(this, e),
					this.#e.error && this.removeEventListener("error", this.#e.error),
					typeof t == "function"
						? ((this.#e.error = t), this.addEventListener("error", t))
						: (this.#e.error = null)
			}
			get onclose() {
				return _t.brandCheck(this, e), this.#e.close
			}
			set onclose(t) {
				_t.brandCheck(this, e),
					this.#e.close && this.removeEventListener("close", this.#e.close),
					typeof t == "function"
						? ((this.#e.close = t), this.addEventListener("close", t))
						: (this.#e.close = null)
			}
			get onmessage() {
				return _t.brandCheck(this, e), this.#e.message
			}
			set onmessage(t) {
				_t.brandCheck(this, e),
					this.#e.message && this.removeEventListener("message", this.#e.message),
					typeof t == "function"
						? ((this.#e.message = t), this.addEventListener("message", t))
						: (this.#e.message = null)
			}
			get binaryType() {
				return _t.brandCheck(this, e), this[jD]
			}
			set binaryType(t) {
				_t.brandCheck(this, e), t !== "blob" && t !== "arraybuffer" ? (this[jD] = "blob") : (this[jD] = t)
			}
			#l(t, r) {
				this[_ae] = t
				let n = new Dze(this, r)
				n.on("drain", Fze),
					n.on("error", Qze.bind(this)),
					(t.socket.ws = this),
					(this[xze] = n),
					(this.#r = new Mze(t.socket)),
					(this[r5] = vb.OPEN)
				let i = t.headersList.get("sec-websocket-extensions")
				i !== null && (this.#n = i)
				let s = t.headersList.get("sec-websocket-protocol")
				s !== null && (this.#i = s), wae("open", this)
			}
		}
	Ea.CONNECTING = Ea.prototype.CONNECTING = vb.CONNECTING
	Ea.OPEN = Ea.prototype.OPEN = vb.OPEN
	Ea.CLOSING = Ea.prototype.CLOSING = vb.CLOSING
	Ea.CLOSED = Ea.prototype.CLOSED = vb.CLOSED
	Object.defineProperties(Ea.prototype, {
		CONNECTING: ah,
		OPEN: ah,
		CLOSING: ah,
		CLOSED: ah,
		url: ll,
		readyState: ll,
		bufferedAmount: ll,
		onopen: ll,
		onerror: ll,
		onclose: ll,
		close: ll,
		onmessage: ll,
		binaryType: ll,
		send: ll,
		extensions: ll,
		protocol: ll,
		[Symbol.toStringTag]: {
			value: "WebSocket",
			writable: !1,
			enumerable: !1,
			configurable: !0,
		},
	})
	Object.defineProperties(Ea, {
		CONNECTING: ah,
		OPEN: ah,
		CLOSING: ah,
		CLOSED: ah,
	})
	_t.converters["sequence<DOMString>"] = _t.sequenceConverter(_t.converters.DOMString)
	_t.converters["DOMString or sequence<DOMString>"] = function (e, t, r) {
		return _t.util.Type(e) === "Object" && Symbol.iterator in e
			? _t.converters["sequence<DOMString>"](e)
			: _t.converters.DOMString(e, t, r)
	}
	_t.converters.WebSocketInit = _t.dictionaryConverter([
		{
			key: "protocols",
			converter: _t.converters["DOMString or sequence<DOMString>"],
			defaultValue: () => new Array(0),
		},
		{
			key: "dispatcher",
			converter: _t.converters.any,
			defaultValue: () => Tze(),
		},
		{
			key: "headers",
			converter: _t.nullableConverter(_t.converters.HeadersInit),
		},
	])
	_t.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function (e) {
		return _t.util.Type(e) === "Object" && !(Symbol.iterator in e)
			? _t.converters.WebSocketInit(e)
			: { protocols: _t.converters["DOMString or sequence<DOMString>"](e) }
	}
	_t.converters.WebSocketSendData = function (e) {
		if (_t.util.Type(e) === "Object") {
			if (Sae(e)) return _t.converters.Blob(e, { strict: !1 })
			if (ArrayBuffer.isView(e) || Bae.isArrayBuffer(e)) return _t.converters.BufferSource(e)
		}
		return _t.converters.USVString(e)
	}
	function Fze() {
		this.ws[_ae].socket.resume()
	}
	function Qze(e) {
		let t, r
		e instanceof kze ? ((t = e.reason), (r = e.code)) : (t = e.message),
			wae("error", this, () => new Rze("error", { error: e, message: t })),
			Iae(this, r)
	}
	Dae.exports = { WebSocket: Ea }
})
var n5 = x((TSt, Rae) => {
	"use strict"
	function Nze(e) {
		return e.indexOf("\0") === -1
	}
	function Pze(e) {
		if (e.length === 0) return !1
		for (let t = 0; t < e.length; t++) if (e.charCodeAt(t) < 48 || e.charCodeAt(t) > 57) return !1
		return !0
	}
	function Lze(e) {
		return new Promise((t) => {
			setTimeout(t, e).unref()
		})
	}
	Rae.exports = { isValidLastEventId: Nze, isASCIINumber: Pze, delay: Lze }
})
var Qae = x((RSt, Fae) => {
	"use strict"
	var { Transform: Uze } = require("stream"),
		{ isASCIINumber: kae, isValidLastEventId: Mae } = n5(),
		Qd = [239, 187, 191],
		i5 = 10,
		ZD = 13,
		Oze = 58,
		qze = 32,
		s5 = class extends Uze {
			state = null
			checkBOM = !0
			crlfCheck = !1
			eventEndCheck = !1
			buffer = null
			pos = 0
			event = { data: void 0, event: void 0, id: void 0, retry: void 0 }
			constructor(t = {}) {
				;(t.readableObjectMode = !0),
					super(t),
					(this.state = t.eventSourceSettings || {}),
					t.push && (this.push = t.push)
			}
			_transform(t, r, n) {
				if (t.length === 0) {
					n()
					return
				}
				if ((this.buffer ? (this.buffer = Buffer.concat([this.buffer, t])) : (this.buffer = t), this.checkBOM))
					switch (this.buffer.length) {
						case 1:
							if (this.buffer[0] === Qd[0]) {
								n()
								return
							}
							;(this.checkBOM = !1), n()
							return
						case 2:
							if (this.buffer[0] === Qd[0] && this.buffer[1] === Qd[1]) {
								n()
								return
							}
							this.checkBOM = !1
							break
						case 3:
							if (this.buffer[0] === Qd[0] && this.buffer[1] === Qd[1] && this.buffer[2] === Qd[2]) {
								;(this.buffer = Buffer.alloc(0)), (this.checkBOM = !1), n()
								return
							}
							this.checkBOM = !1
							break
						default:
							this.buffer[0] === Qd[0] &&
								this.buffer[1] === Qd[1] &&
								this.buffer[2] === Qd[2] &&
								(this.buffer = this.buffer.subarray(3)),
								(this.checkBOM = !1)
							break
					}
				for (; this.pos < this.buffer.length; ) {
					if (this.eventEndCheck) {
						if (this.crlfCheck) {
							if (this.buffer[this.pos] === i5) {
								;(this.buffer = this.buffer.subarray(this.pos + 1)),
									(this.pos = 0),
									(this.crlfCheck = !1)
								continue
							}
							this.crlfCheck = !1
						}
						if (this.buffer[this.pos] === i5 || this.buffer[this.pos] === ZD) {
							this.buffer[this.pos] === ZD && (this.crlfCheck = !0),
								(this.buffer = this.buffer.subarray(this.pos + 1)),
								(this.pos = 0),
								(this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) &&
									this.processEvent(this.event),
								this.clearEvent()
							continue
						}
						this.eventEndCheck = !1
						continue
					}
					if (this.buffer[this.pos] === i5 || this.buffer[this.pos] === ZD) {
						this.buffer[this.pos] === ZD && (this.crlfCheck = !0),
							this.parseLine(this.buffer.subarray(0, this.pos), this.event),
							(this.buffer = this.buffer.subarray(this.pos + 1)),
							(this.pos = 0),
							(this.eventEndCheck = !0)
						continue
					}
					this.pos++
				}
				n()
			}
			parseLine(t, r) {
				if (t.length === 0) return
				let n = t.indexOf(Oze)
				if (n === 0) return
				let i = "",
					s = ""
				if (n !== -1) {
					i = t.subarray(0, n).toString("utf8")
					let o = n + 1
					t[o] === qze && ++o, (s = t.subarray(o).toString("utf8"))
				} else (i = t.toString("utf8")), (s = "")
				switch (i) {
					case "data":
						r[i] === void 0
							? (r[i] = s)
							: (r[i] += `
${s}`)
						break
					case "retry":
						kae(s) && (r[i] = s)
						break
					case "id":
						Mae(s) && (r[i] = s)
						break
					case "event":
						s.length > 0 && (r[i] = s)
						break
				}
			}
			processEvent(t) {
				t.retry && kae(t.retry) && (this.state.reconnectionTime = parseInt(t.retry, 10)),
					t.id && Mae(t.id) && (this.state.lastEventId = t.id),
					t.data !== void 0 &&
						this.push({
							type: t.event || "message",
							options: {
								data: t.data,
								lastEventId: this.state.lastEventId,
								origin: this.state.origin,
							},
						})
			}
			clearEvent() {
				this.event = { data: void 0, event: void 0, id: void 0, retry: void 0 }
			}
		}
	Fae.exports = { EventSourceStream: s5 }
})
var Hae = x((kSt, Vae) => {
	"use strict"
	var { pipeline: Vze } = require("stream"),
		{ fetching: Hze } = cb(),
		{ makeRequest: Wze } = w0(),
		{ webidl: Nd } = ys(),
		{ EventSourceStream: Gze } = Qae(),
		{ parseMIMEType: $ze } = No(),
		{ createFastMessageEvent: Yze } = R0(),
		{ isNetworkError: Nae } = ab(),
		{ delay: Kze } = n5(),
		{ kEnumerableProperty: bp } = Xt(),
		{ environmentSettingsObject: Pae } = ga(),
		Lae = !1,
		Uae = 3e3,
		Eb = 0,
		Oae = 1,
		bb = 2,
		Jze = "anonymous",
		zze = "use-credentials",
		N0 = class e extends EventTarget {
			#e = { open: null, error: null, message: null }
			#t = null
			#i = !1
			#n = Eb
			#r = null
			#l = null
			#o
			#u
			constructor(t, r = {}) {
				super(), Nd.util.markAsUncloneable(this)
				let n = "EventSource constructor"
				Nd.argumentLengthCheck(arguments, 1, n),
					Lae ||
						((Lae = !0),
						process.emitWarning("EventSource is experimental, expect them to change at any time.", {
							code: "UNDICI-ES",
						})),
					(t = Nd.converters.USVString(t, n, "url")),
					(r = Nd.converters.EventSourceInitDict(r, n, "eventSourceInitDict")),
					(this.#o = r.dispatcher),
					(this.#u = { lastEventId: "", reconnectionTime: Uae })
				let i = Pae,
					s
				try {
					;(s = new URL(t, i.settingsObject.baseUrl)), (this.#u.origin = s.origin)
				} catch (l) {
					throw new DOMException(l, "SyntaxError")
				}
				this.#t = s.href
				let o = Jze
				r.withCredentials && ((o = zze), (this.#i = !0))
				let a = {
					redirect: "follow",
					keepalive: !0,
					mode: "cors",
					credentials: o === "anonymous" ? "same-origin" : "omit",
					referrer: "no-referrer",
				}
				;(a.client = Pae.settingsObject),
					(a.headersList = [["accept", { name: "accept", value: "text/event-stream" }]]),
					(a.cache = "no-store"),
					(a.initiator = "other"),
					(a.urlList = [new URL(this.#t)]),
					(this.#r = Wze(a)),
					this.#d()
			}
			get readyState() {
				return this.#n
			}
			get url() {
				return this.#t
			}
			get withCredentials() {
				return this.#i
			}
			#d() {
				if (this.#n === bb) return
				this.#n = Eb
				let t = { request: this.#r, dispatcher: this.#o },
					r = (n) => {
						Nae(n) && (this.dispatchEvent(new Event("error")), this.close()), this.#a()
					}
				;(t.processResponseEndOfBody = r),
					(t.processResponse = (n) => {
						if (Nae(n))
							if (n.aborted) {
								this.close(), this.dispatchEvent(new Event("error"))
								return
							} else {
								this.#a()
								return
							}
						let i = n.headersList.get("content-type", !0),
							s = i !== null ? $ze(i) : "failure",
							o = s !== "failure" && s.essence === "text/event-stream"
						if (n.status !== 200 || o === !1) {
							this.close(), this.dispatchEvent(new Event("error"))
							return
						}
						;(this.#n = Oae),
							this.dispatchEvent(new Event("open")),
							(this.#u.origin = n.urlList[n.urlList.length - 1].origin)
						let a = new Gze({
							eventSourceSettings: this.#u,
							push: (l) => {
								this.dispatchEvent(Yze(l.type, l.options))
							},
						})
						Vze(n.body.stream, a, (l) => {
							l?.aborted === !1 && (this.close(), this.dispatchEvent(new Event("error")))
						})
					}),
					(this.#l = Hze(t))
			}
			async #a() {
				this.#n !== bb &&
					((this.#n = Eb),
					this.dispatchEvent(new Event("error")),
					await Kze(this.#u.reconnectionTime),
					this.#n === Eb &&
						(this.#u.lastEventId.length &&
							this.#r.headersList.set("last-event-id", this.#u.lastEventId, !0),
						this.#d()))
			}
			close() {
				Nd.brandCheck(this, e), this.#n !== bb && ((this.#n = bb), this.#l.abort(), (this.#r = null))
			}
			get onopen() {
				return this.#e.open
			}
			set onopen(t) {
				this.#e.open && this.removeEventListener("open", this.#e.open),
					typeof t == "function"
						? ((this.#e.open = t), this.addEventListener("open", t))
						: (this.#e.open = null)
			}
			get onmessage() {
				return this.#e.message
			}
			set onmessage(t) {
				this.#e.message && this.removeEventListener("message", this.#e.message),
					typeof t == "function"
						? ((this.#e.message = t), this.addEventListener("message", t))
						: (this.#e.message = null)
			}
			get onerror() {
				return this.#e.error
			}
			set onerror(t) {
				this.#e.error && this.removeEventListener("error", this.#e.error),
					typeof t == "function"
						? ((this.#e.error = t), this.addEventListener("error", t))
						: (this.#e.error = null)
			}
		},
		qae = {
			CONNECTING: {
				__proto__: null,
				configurable: !1,
				enumerable: !0,
				value: Eb,
				writable: !1,
			},
			OPEN: {
				__proto__: null,
				configurable: !1,
				enumerable: !0,
				value: Oae,
				writable: !1,
			},
			CLOSED: {
				__proto__: null,
				configurable: !1,
				enumerable: !0,
				value: bb,
				writable: !1,
			},
		}
	Object.defineProperties(N0, qae)
	Object.defineProperties(N0.prototype, qae)
	Object.defineProperties(N0.prototype, {
		close: bp,
		onerror: bp,
		onmessage: bp,
		onopen: bp,
		readyState: bp,
		url: bp,
		withCredentials: bp,
	})
	Nd.converters.EventSourceInitDict = Nd.dictionaryConverter([
		{
			key: "withCredentials",
			converter: Nd.converters.boolean,
			defaultValue: () => !1,
		},
		{ key: "dispatcher", converter: Nd.converters.any },
	])
	Vae.exports = { EventSource: N0, defaultReconnectionTime: Uae }
})
var Yae = x((MSt, yt) => {
	"use strict"
	var jze = $E(),
		Wae = _E(),
		Zze = f0(),
		Xze = jre(),
		eje = h0(),
		tje = Tq(),
		rje = gne(),
		nje = vne(),
		Gae = Vr(),
		eT = Xt(),
		{ InvalidArgumentError: XD } = Gae,
		P0 = oie(),
		ije = IE(),
		sje = dV(),
		oje = qie(),
		aje = gV(),
		lje = Zq(),
		cje = tD(),
		{ getGlobalDispatcher: $ae, setGlobalDispatcher: uje } = dD(),
		dje = fD(),
		fje = WB(),
		hje = GB()
	Object.assign(Wae.prototype, P0)
	yt.exports.Dispatcher = Wae
	yt.exports.Client = jze
	yt.exports.Pool = Zze
	yt.exports.BalancedPool = Xze
	yt.exports.Agent = eje
	yt.exports.ProxyAgent = tje
	yt.exports.EnvHttpProxyAgent = rje
	yt.exports.RetryAgent = nje
	yt.exports.RetryHandler = cje
	yt.exports.DecoratorHandler = dje
	yt.exports.RedirectHandler = fje
	yt.exports.createRedirectInterceptor = hje
	yt.exports.interceptors = {
		redirect: Kie(),
		retry: zie(),
		dump: Zie(),
		dns: tse(),
	}
	yt.exports.buildConnector = ije
	yt.exports.errors = Gae
	yt.exports.util = {
		parseHeaders: eT.parseHeaders,
		headerNameToString: eT.headerNameToString,
	}
	function xb(e) {
		return (t, r, n) => {
			if (
				(typeof r == "function" && ((n = r), (r = null)),
				!t || (typeof t != "string" && typeof t != "object" && !(t instanceof URL)))
			)
				throw new XD("invalid url")
			if (r != null && typeof r != "object") throw new XD("invalid opts")
			if (r && r.path != null) {
				if (typeof r.path != "string") throw new XD("invalid opts.path")
				let o = r.path
				r.path.startsWith("/") || (o = `/${o}`), (t = new URL(eT.parseOrigin(t).origin + o))
			} else r || (r = typeof t == "object" ? t : {}), (t = eT.parseURL(t))
			let { agent: i, dispatcher: s = $ae() } = r
			if (i) throw new XD("unsupported opts.agent. Did you mean opts.client?")
			return e.call(
				s,
				{
					...r,
					origin: t.origin,
					path: t.search ? `${t.pathname}${t.search}` : t.pathname,
					method: r.method || (r.body ? "PUT" : "GET"),
				},
				n,
			)
		}
	}
	yt.exports.setGlobalDispatcher = uje
	yt.exports.getGlobalDispatcher = $ae
	var gje = cb().fetch
	yt.exports.fetch = async function (t, r = void 0) {
		try {
			return await gje(t, r)
		} catch (n) {
			throw (n && typeof n == "object" && Error.captureStackTrace(n), n)
		}
	}
	yt.exports.Headers = pp().Headers
	yt.exports.Response = ab().Response
	yt.exports.Request = w0().Request
	yt.exports.FormData = ME().FormData
	yt.exports.File = globalThis.File ?? require("buffer").File
	yt.exports.FileReader = poe().FileReader
	var { setGlobalOrigin: pje, getGlobalOrigin: Aje } = RO()
	yt.exports.setGlobalOrigin = pje
	yt.exports.getGlobalOrigin = Aje
	var { CacheStorage: mje } = _oe(),
		{ kConstruct: yje } = MD()
	yt.exports.caches = new mje(yje)
	var { deleteCookie: Cje, getCookies: vje, getSetCookies: Eje, setCookie: bje } = Noe()
	yt.exports.deleteCookie = Cje
	yt.exports.getCookies = vje
	yt.exports.getSetCookies = Eje
	yt.exports.setCookie = bje
	var { parseMIMEType: xje, serializeAMimeType: _je } = No()
	yt.exports.parseMIMEType = xje
	yt.exports.serializeAMimeType = _je
	var { CloseEvent: wje, ErrorEvent: Ije, MessageEvent: Sje } = R0()
	yt.exports.WebSocket = Tae().WebSocket
	yt.exports.CloseEvent = wje
	yt.exports.ErrorEvent = Ije
	yt.exports.MessageEvent = Sje
	yt.exports.request = xb(P0.request)
	yt.exports.stream = xb(P0.stream)
	yt.exports.pipeline = xb(P0.pipeline)
	yt.exports.connect = xb(P0.connect)
	yt.exports.upgrade = xb(P0.upgrade)
	yt.exports.MockClient = sje
	yt.exports.MockPool = aje
	yt.exports.MockAgent = oje
	yt.exports.mockErrors = lje
	var { EventSource: Bje } = Hae()
	yt.exports.EventSource = Bje
})
var Yt = x((FSt, Kae) => {
	"use strict"
	Kae.exports = { options: { usePureJavaScript: !1 } }
})
var jae = x((QSt, zae) => {
	"use strict"
	var o5 = {}
	zae.exports = o5
	var Jae = {}
	o5.encode = function (e, t, r) {
		if (typeof t != "string") throw new TypeError('"alphabet" must be a string.')
		if (r !== void 0 && typeof r != "number") throw new TypeError('"maxline" must be a number.')
		var n = ""
		if (!(e instanceof Uint8Array)) n = Dje(e, t)
		else {
			var i = 0,
				s = t.length,
				o = t.charAt(0),
				a = [0]
			for (i = 0; i < e.length; ++i) {
				for (var l = 0, c = e[i]; l < a.length; ++l) (c += a[l] << 8), (a[l] = c % s), (c = (c / s) | 0)
				for (; c > 0; ) a.push(c % s), (c = (c / s) | 0)
			}
			for (i = 0; e[i] === 0 && i < e.length - 1; ++i) n += o
			for (i = a.length - 1; i >= 0; --i) n += t[a[i]]
		}
		if (r) {
			var u = new RegExp(".{1," + r + "}", "g")
			n = n.match(u).join(`\r
`)
		}
		return n
	}
	o5.decode = function (e, t) {
		if (typeof e != "string") throw new TypeError('"input" must be a string.')
		if (typeof t != "string") throw new TypeError('"alphabet" must be a string.')
		var r = Jae[t]
		if (!r) {
			r = Jae[t] = []
			for (var n = 0; n < t.length; ++n) r[t.charCodeAt(n)] = n
		}
		e = e.replace(/\s/g, "")
		for (var i = t.length, s = t.charAt(0), o = [0], n = 0; n < e.length; n++) {
			var a = r[e.charCodeAt(n)]
			if (a === void 0) return
			for (var l = 0, c = a; l < o.length; ++l) (c += o[l] * i), (o[l] = c & 255), (c >>= 8)
			for (; c > 0; ) o.push(c & 255), (c >>= 8)
		}
		for (var u = 0; e[u] === s && u < e.length - 1; ++u) o.push(0)
		return typeof Buffer < "u" ? Buffer.from(o.reverse()) : new Uint8Array(o.reverse())
	}
	function Dje(e, t) {
		var r = 0,
			n = t.length,
			i = t.charAt(0),
			s = [0]
		for (r = 0; r < e.length(); ++r) {
			for (var o = 0, a = e.at(r); o < s.length; ++o) (a += s[o] << 8), (s[o] = a % n), (a = (a / n) | 0)
			for (; a > 0; ) s.push(a % n), (a = (a / n) | 0)
		}
		var l = ""
		for (r = 0; e.at(r) === 0 && r < e.length() - 1; ++r) l += i
		for (r = s.length - 1; r >= 0; --r) l += t[s[r]]
		return l
	}
})
var Sr = x((NSt, tle) => {
	"use strict"
	var Zae = Yt(),
		Xae = jae(),
		$ = (tle.exports = Zae.util = Zae.util || {})
	;(function () {
		if (typeof process < "u" && process.nextTick && !process.browser) {
			;($.nextTick = process.nextTick),
				typeof setImmediate == "function" ? ($.setImmediate = setImmediate) : ($.setImmediate = $.nextTick)
			return
		}
		if (typeof setImmediate == "function") {
			;($.setImmediate = function () {
				return setImmediate.apply(void 0, arguments)
			}),
				($.nextTick = function (a) {
					return setImmediate(a)
				})
			return
		}
		if (
			(($.setImmediate = function (a) {
				setTimeout(a, 0)
			}),
			typeof window < "u" && typeof window.postMessage == "function")
		) {
			let a = function (l) {
				if (l.source === window && l.data === e) {
					l.stopPropagation()
					var c = t.slice()
					;(t.length = 0),
						c.forEach(function (u) {
							u()
						})
				}
			}
			var o = a,
				e = "forge.setImmediate",
				t = []
			;($.setImmediate = function (l) {
				t.push(l), t.length === 1 && window.postMessage(e, "*")
			}),
				window.addEventListener("message", a, !0)
		}
		if (typeof MutationObserver < "u") {
			var r = Date.now(),
				n = !0,
				i = document.createElement("div"),
				t = []
			new MutationObserver(function () {
				var l = t.slice()
				;(t.length = 0),
					l.forEach(function (c) {
						c()
					})
			}).observe(i, { attributes: !0 })
			var s = $.setImmediate
			$.setImmediate = function (l) {
				Date.now() - r > 15
					? ((r = Date.now()), s(l))
					: (t.push(l), t.length === 1 && i.setAttribute("a", (n = !n)))
			}
		}
		$.nextTick = $.setImmediate
	})()
	$.isNodejs = typeof process < "u" && process.versions && process.versions.node
	$.globalScope = (function () {
		return $.isNodejs ? global : typeof self > "u" ? window : self
	})()
	$.isArray =
		Array.isArray ||
		function (e) {
			return Object.prototype.toString.call(e) === "[object Array]"
		}
	$.isArrayBuffer = function (e) {
		return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer
	}
	$.isArrayBufferView = function (e) {
		return e && $.isArrayBuffer(e.buffer) && e.byteLength !== void 0
	}
	function _b(e) {
		if (!(e === 8 || e === 16 || e === 24 || e === 32))
			throw new Error("Only 8, 16, 24, or 32 bits supported: " + e)
	}
	$.ByteBuffer = a5
	function a5(e) {
		if (((this.data = ""), (this.read = 0), typeof e == "string")) this.data = e
		else if ($.isArrayBuffer(e) || $.isArrayBufferView(e))
			if (typeof Buffer < "u" && e instanceof Buffer) this.data = e.toString("binary")
			else {
				var t = new Uint8Array(e)
				try {
					this.data = String.fromCharCode.apply(null, t)
				} catch {
					for (var r = 0; r < t.length; ++r) this.putByte(t[r])
				}
			}
		else
			(e instanceof a5 || (typeof e == "object" && typeof e.data == "string" && typeof e.read == "number")) &&
				((this.data = e.data), (this.read = e.read))
		this._constructedStringLength = 0
	}
	$.ByteStringBuffer = a5
	var Tje = 4096
	$.ByteStringBuffer.prototype._optimizeConstructedString = function (e) {
		;(this._constructedStringLength += e),
			this._constructedStringLength > Tje && (this.data.substr(0, 1), (this._constructedStringLength = 0))
	}
	$.ByteStringBuffer.prototype.length = function () {
		return this.data.length - this.read
	}
	$.ByteStringBuffer.prototype.isEmpty = function () {
		return this.length() <= 0
	}
	$.ByteStringBuffer.prototype.putByte = function (e) {
		return this.putBytes(String.fromCharCode(e))
	}
	$.ByteStringBuffer.prototype.fillWithByte = function (e, t) {
		e = String.fromCharCode(e)
		for (var r = this.data; t > 0; ) t & 1 && (r += e), (t >>>= 1), t > 0 && (e += e)
		return (this.data = r), this._optimizeConstructedString(t), this
	}
	$.ByteStringBuffer.prototype.putBytes = function (e) {
		return (this.data += e), this._optimizeConstructedString(e.length), this
	}
	$.ByteStringBuffer.prototype.putString = function (e) {
		return this.putBytes($.encodeUtf8(e))
	}
	$.ByteStringBuffer.prototype.putInt16 = function (e) {
		return this.putBytes(String.fromCharCode((e >> 8) & 255) + String.fromCharCode(e & 255))
	}
	$.ByteStringBuffer.prototype.putInt24 = function (e) {
		return this.putBytes(
			String.fromCharCode((e >> 16) & 255) + String.fromCharCode((e >> 8) & 255) + String.fromCharCode(e & 255),
		)
	}
	$.ByteStringBuffer.prototype.putInt32 = function (e) {
		return this.putBytes(
			String.fromCharCode((e >> 24) & 255) +
				String.fromCharCode((e >> 16) & 255) +
				String.fromCharCode((e >> 8) & 255) +
				String.fromCharCode(e & 255),
		)
	}
	$.ByteStringBuffer.prototype.putInt16Le = function (e) {
		return this.putBytes(String.fromCharCode(e & 255) + String.fromCharCode((e >> 8) & 255))
	}
	$.ByteStringBuffer.prototype.putInt24Le = function (e) {
		return this.putBytes(
			String.fromCharCode(e & 255) + String.fromCharCode((e >> 8) & 255) + String.fromCharCode((e >> 16) & 255),
		)
	}
	$.ByteStringBuffer.prototype.putInt32Le = function (e) {
		return this.putBytes(
			String.fromCharCode(e & 255) +
				String.fromCharCode((e >> 8) & 255) +
				String.fromCharCode((e >> 16) & 255) +
				String.fromCharCode((e >> 24) & 255),
		)
	}
	$.ByteStringBuffer.prototype.putInt = function (e, t) {
		_b(t)
		var r = ""
		do (t -= 8), (r += String.fromCharCode((e >> t) & 255))
		while (t > 0)
		return this.putBytes(r)
	}
	$.ByteStringBuffer.prototype.putSignedInt = function (e, t) {
		return e < 0 && (e += 2 << (t - 1)), this.putInt(e, t)
	}
	$.ByteStringBuffer.prototype.putBuffer = function (e) {
		return this.putBytes(e.getBytes())
	}
	$.ByteStringBuffer.prototype.getByte = function () {
		return this.data.charCodeAt(this.read++)
	}
	$.ByteStringBuffer.prototype.getInt16 = function () {
		var e = (this.data.charCodeAt(this.read) << 8) ^ this.data.charCodeAt(this.read + 1)
		return (this.read += 2), e
	}
	$.ByteStringBuffer.prototype.getInt24 = function () {
		var e =
			(this.data.charCodeAt(this.read) << 16) ^
			(this.data.charCodeAt(this.read + 1) << 8) ^
			this.data.charCodeAt(this.read + 2)
		return (this.read += 3), e
	}
	$.ByteStringBuffer.prototype.getInt32 = function () {
		var e =
			(this.data.charCodeAt(this.read) << 24) ^
			(this.data.charCodeAt(this.read + 1) << 16) ^
			(this.data.charCodeAt(this.read + 2) << 8) ^
			this.data.charCodeAt(this.read + 3)
		return (this.read += 4), e
	}
	$.ByteStringBuffer.prototype.getInt16Le = function () {
		var e = this.data.charCodeAt(this.read) ^ (this.data.charCodeAt(this.read + 1) << 8)
		return (this.read += 2), e
	}
	$.ByteStringBuffer.prototype.getInt24Le = function () {
		var e =
			this.data.charCodeAt(this.read) ^
			(this.data.charCodeAt(this.read + 1) << 8) ^
			(this.data.charCodeAt(this.read + 2) << 16)
		return (this.read += 3), e
	}
	$.ByteStringBuffer.prototype.getInt32Le = function () {
		var e =
			this.data.charCodeAt(this.read) ^
			(this.data.charCodeAt(this.read + 1) << 8) ^
			(this.data.charCodeAt(this.read + 2) << 16) ^
			(this.data.charCodeAt(this.read + 3) << 24)
		return (this.read += 4), e
	}
	$.ByteStringBuffer.prototype.getInt = function (e) {
		_b(e)
		var t = 0
		do (t = (t << 8) + this.data.charCodeAt(this.read++)), (e -= 8)
		while (e > 0)
		return t
	}
	$.ByteStringBuffer.prototype.getSignedInt = function (e) {
		var t = this.getInt(e),
			r = 2 << (e - 2)
		return t >= r && (t -= r << 1), t
	}
	$.ByteStringBuffer.prototype.getBytes = function (e) {
		var t
		return (
			e
				? ((e = Math.min(this.length(), e)), (t = this.data.slice(this.read, this.read + e)), (this.read += e))
				: e === 0
					? (t = "")
					: ((t = this.read === 0 ? this.data : this.data.slice(this.read)), this.clear()),
			t
		)
	}
	$.ByteStringBuffer.prototype.bytes = function (e) {
		return typeof e > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e)
	}
	$.ByteStringBuffer.prototype.at = function (e) {
		return this.data.charCodeAt(this.read + e)
	}
	$.ByteStringBuffer.prototype.setAt = function (e, t) {
		return (
			(this.data =
				this.data.substr(0, this.read + e) + String.fromCharCode(t) + this.data.substr(this.read + e + 1)),
			this
		)
	}
	$.ByteStringBuffer.prototype.last = function () {
		return this.data.charCodeAt(this.data.length - 1)
	}
	$.ByteStringBuffer.prototype.copy = function () {
		var e = $.createBuffer(this.data)
		return (e.read = this.read), e
	}
	$.ByteStringBuffer.prototype.compact = function () {
		return this.read > 0 && ((this.data = this.data.slice(this.read)), (this.read = 0)), this
	}
	$.ByteStringBuffer.prototype.clear = function () {
		return (this.data = ""), (this.read = 0), this
	}
	$.ByteStringBuffer.prototype.truncate = function (e) {
		var t = Math.max(0, this.length() - e)
		return (this.data = this.data.substr(this.read, t)), (this.read = 0), this
	}
	$.ByteStringBuffer.prototype.toHex = function () {
		for (var e = "", t = this.read; t < this.data.length; ++t) {
			var r = this.data.charCodeAt(t)
			r < 16 && (e += "0"), (e += r.toString(16))
		}
		return e
	}
	$.ByteStringBuffer.prototype.toString = function () {
		return $.decodeUtf8(this.bytes())
	}
	function Rje(e, t) {
		;(t = t || {}), (this.read = t.readOffset || 0), (this.growSize = t.growSize || 1024)
		var r = $.isArrayBuffer(e),
			n = $.isArrayBufferView(e)
		if (r || n) {
			r ? (this.data = new DataView(e)) : (this.data = new DataView(e.buffer, e.byteOffset, e.byteLength)),
				(this.write = "writeOffset" in t ? t.writeOffset : this.data.byteLength)
			return
		}
		;(this.data = new DataView(new ArrayBuffer(0))),
			(this.write = 0),
			e != null && this.putBytes(e),
			"writeOffset" in t && (this.write = t.writeOffset)
	}
	$.DataBuffer = Rje
	$.DataBuffer.prototype.length = function () {
		return this.write - this.read
	}
	$.DataBuffer.prototype.isEmpty = function () {
		return this.length() <= 0
	}
	$.DataBuffer.prototype.accommodate = function (e, t) {
		if (this.length() >= e) return this
		t = Math.max(t || this.growSize, e)
		var r = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength),
			n = new Uint8Array(this.length() + t)
		return n.set(r), (this.data = new DataView(n.buffer)), this
	}
	$.DataBuffer.prototype.putByte = function (e) {
		return this.accommodate(1), this.data.setUint8(this.write++, e), this
	}
	$.DataBuffer.prototype.fillWithByte = function (e, t) {
		this.accommodate(t)
		for (var r = 0; r < t; ++r) this.data.setUint8(e)
		return this
	}
	$.DataBuffer.prototype.putBytes = function (e, t) {
		if ($.isArrayBufferView(e)) {
			var r = new Uint8Array(e.buffer, e.byteOffset, e.byteLength),
				n = r.byteLength - r.byteOffset
			this.accommodate(n)
			var i = new Uint8Array(this.data.buffer, this.write)
			return i.set(r), (this.write += n), this
		}
		if ($.isArrayBuffer(e)) {
			var r = new Uint8Array(e)
			this.accommodate(r.byteLength)
			var i = new Uint8Array(this.data.buffer)
			return i.set(r, this.write), (this.write += r.byteLength), this
		}
		if (
			e instanceof $.DataBuffer ||
			(typeof e == "object" &&
				typeof e.read == "number" &&
				typeof e.write == "number" &&
				$.isArrayBufferView(e.data))
		) {
			var r = new Uint8Array(e.data.byteLength, e.read, e.length())
			this.accommodate(r.byteLength)
			var i = new Uint8Array(e.data.byteLength, this.write)
			return i.set(r), (this.write += r.byteLength), this
		}
		if (
			(e instanceof $.ByteStringBuffer && ((e = e.data), (t = "binary")),
			(t = t || "binary"),
			typeof e == "string")
		) {
			var s
			if (t === "hex")
				return (
					this.accommodate(Math.ceil(e.length / 2)),
					(s = new Uint8Array(this.data.buffer, this.write)),
					(this.write += $.binary.hex.decode(e, s, this.write)),
					this
				)
			if (t === "base64")
				return (
					this.accommodate(Math.ceil(e.length / 4) * 3),
					(s = new Uint8Array(this.data.buffer, this.write)),
					(this.write += $.binary.base64.decode(e, s, this.write)),
					this
				)
			if ((t === "utf8" && ((e = $.encodeUtf8(e)), (t = "binary")), t === "binary" || t === "raw"))
				return (
					this.accommodate(e.length),
					(s = new Uint8Array(this.data.buffer, this.write)),
					(this.write += $.binary.raw.decode(s)),
					this
				)
			if (t === "utf16")
				return (
					this.accommodate(e.length * 2),
					(s = new Uint16Array(this.data.buffer, this.write)),
					(this.write += $.text.utf16.encode(s)),
					this
				)
			throw new Error("Invalid encoding: " + t)
		}
		throw Error("Invalid parameter: " + e)
	}
	$.DataBuffer.prototype.putBuffer = function (e) {
		return this.putBytes(e), e.clear(), this
	}
	$.DataBuffer.prototype.putString = function (e) {
		return this.putBytes(e, "utf16")
	}
	$.DataBuffer.prototype.putInt16 = function (e) {
		return this.accommodate(2), this.data.setInt16(this.write, e), (this.write += 2), this
	}
	$.DataBuffer.prototype.putInt24 = function (e) {
		return (
			this.accommodate(3),
			this.data.setInt16(this.write, (e >> 8) & 65535),
			this.data.setInt8(this.write, (e >> 16) & 255),
			(this.write += 3),
			this
		)
	}
	$.DataBuffer.prototype.putInt32 = function (e) {
		return this.accommodate(4), this.data.setInt32(this.write, e), (this.write += 4), this
	}
	$.DataBuffer.prototype.putInt16Le = function (e) {
		return this.accommodate(2), this.data.setInt16(this.write, e, !0), (this.write += 2), this
	}
	$.DataBuffer.prototype.putInt24Le = function (e) {
		return (
			this.accommodate(3),
			this.data.setInt8(this.write, (e >> 16) & 255),
			this.data.setInt16(this.write, (e >> 8) & 65535, !0),
			(this.write += 3),
			this
		)
	}
	$.DataBuffer.prototype.putInt32Le = function (e) {
		return this.accommodate(4), this.data.setInt32(this.write, e, !0), (this.write += 4), this
	}
	$.DataBuffer.prototype.putInt = function (e, t) {
		_b(t), this.accommodate(t / 8)
		do (t -= 8), this.data.setInt8(this.write++, (e >> t) & 255)
		while (t > 0)
		return this
	}
	$.DataBuffer.prototype.putSignedInt = function (e, t) {
		return _b(t), this.accommodate(t / 8), e < 0 && (e += 2 << (t - 1)), this.putInt(e, t)
	}
	$.DataBuffer.prototype.getByte = function () {
		return this.data.getInt8(this.read++)
	}
	$.DataBuffer.prototype.getInt16 = function () {
		var e = this.data.getInt16(this.read)
		return (this.read += 2), e
	}
	$.DataBuffer.prototype.getInt24 = function () {
		var e = (this.data.getInt16(this.read) << 8) ^ this.data.getInt8(this.read + 2)
		return (this.read += 3), e
	}
	$.DataBuffer.prototype.getInt32 = function () {
		var e = this.data.getInt32(this.read)
		return (this.read += 4), e
	}
	$.DataBuffer.prototype.getInt16Le = function () {
		var e = this.data.getInt16(this.read, !0)
		return (this.read += 2), e
	}
	$.DataBuffer.prototype.getInt24Le = function () {
		var e = this.data.getInt8(this.read) ^ (this.data.getInt16(this.read + 1, !0) << 8)
		return (this.read += 3), e
	}
	$.DataBuffer.prototype.getInt32Le = function () {
		var e = this.data.getInt32(this.read, !0)
		return (this.read += 4), e
	}
	$.DataBuffer.prototype.getInt = function (e) {
		_b(e)
		var t = 0
		do (t = (t << 8) + this.data.getInt8(this.read++)), (e -= 8)
		while (e > 0)
		return t
	}
	$.DataBuffer.prototype.getSignedInt = function (e) {
		var t = this.getInt(e),
			r = 2 << (e - 2)
		return t >= r && (t -= r << 1), t
	}
	$.DataBuffer.prototype.getBytes = function (e) {
		var t
		return (
			e
				? ((e = Math.min(this.length(), e)), (t = this.data.slice(this.read, this.read + e)), (this.read += e))
				: e === 0
					? (t = "")
					: ((t = this.read === 0 ? this.data : this.data.slice(this.read)), this.clear()),
			t
		)
	}
	$.DataBuffer.prototype.bytes = function (e) {
		return typeof e > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e)
	}
	$.DataBuffer.prototype.at = function (e) {
		return this.data.getUint8(this.read + e)
	}
	$.DataBuffer.prototype.setAt = function (e, t) {
		return this.data.setUint8(e, t), this
	}
	$.DataBuffer.prototype.last = function () {
		return this.data.getUint8(this.write - 1)
	}
	$.DataBuffer.prototype.copy = function () {
		return new $.DataBuffer(this)
	}
	$.DataBuffer.prototype.compact = function () {
		if (this.read > 0) {
			var e = new Uint8Array(this.data.buffer, this.read),
				t = new Uint8Array(e.byteLength)
			t.set(e), (this.data = new DataView(t)), (this.write -= this.read), (this.read = 0)
		}
		return this
	}
	$.DataBuffer.prototype.clear = function () {
		return (this.data = new DataView(new ArrayBuffer(0))), (this.read = this.write = 0), this
	}
	$.DataBuffer.prototype.truncate = function (e) {
		return (this.write = Math.max(0, this.length() - e)), (this.read = Math.min(this.read, this.write)), this
	}
	$.DataBuffer.prototype.toHex = function () {
		for (var e = "", t = this.read; t < this.data.byteLength; ++t) {
			var r = this.data.getUint8(t)
			r < 16 && (e += "0"), (e += r.toString(16))
		}
		return e
	}
	$.DataBuffer.prototype.toString = function (e) {
		var t = new Uint8Array(this.data, this.read, this.length())
		if (((e = e || "utf8"), e === "binary" || e === "raw")) return $.binary.raw.encode(t)
		if (e === "hex") return $.binary.hex.encode(t)
		if (e === "base64") return $.binary.base64.encode(t)
		if (e === "utf8") return $.text.utf8.decode(t)
		if (e === "utf16") return $.text.utf16.decode(t)
		throw new Error("Invalid encoding: " + e)
	}
	$.createBuffer = function (e, t) {
		return (t = t || "raw"), e !== void 0 && t === "utf8" && (e = $.encodeUtf8(e)), new $.ByteBuffer(e)
	}
	$.fillString = function (e, t) {
		for (var r = ""; t > 0; ) t & 1 && (r += e), (t >>>= 1), t > 0 && (e += e)
		return r
	}
	$.xorBytes = function (e, t, r) {
		for (var n = "", i = "", s = "", o = 0, a = 0; r > 0; --r, ++o)
			(i = e.charCodeAt(o) ^ t.charCodeAt(o)),
				a >= 10 && ((n += s), (s = ""), (a = 0)),
				(s += String.fromCharCode(i)),
				++a
		return (n += s), n
	}
	$.hexToBytes = function (e) {
		var t = "",
			r = 0
		for (e.length & !0 && ((r = 1), (t += String.fromCharCode(parseInt(e[0], 16)))); r < e.length; r += 2)
			t += String.fromCharCode(parseInt(e.substr(r, 2), 16))
		return t
	}
	$.bytesToHex = function (e) {
		return $.createBuffer(e).toHex()
	}
	$.int32ToBytes = function (e) {
		return (
			String.fromCharCode((e >> 24) & 255) +
			String.fromCharCode((e >> 16) & 255) +
			String.fromCharCode((e >> 8) & 255) +
			String.fromCharCode(e & 255)
		)
	}
	var lh = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
		ch = [
			62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6,
			7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28,
			29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
		],
		ele = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
	$.encode64 = function (e, t) {
		for (var r = "", n = "", i, s, o, a = 0; a < e.length; )
			(i = e.charCodeAt(a++)),
				(s = e.charCodeAt(a++)),
				(o = e.charCodeAt(a++)),
				(r += lh.charAt(i >> 2)),
				(r += lh.charAt(((i & 3) << 4) | (s >> 4))),
				isNaN(s)
					? (r += "==")
					: ((r += lh.charAt(((s & 15) << 2) | (o >> 6))), (r += isNaN(o) ? "=" : lh.charAt(o & 63))),
				t &&
					r.length > t &&
					((n +=
						r.substr(0, t) +
						`\r
`),
					(r = r.substr(t)))
		return (n += r), n
	}
	$.decode64 = function (e) {
		e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "")
		for (var t = "", r, n, i, s, o = 0; o < e.length; )
			(r = ch[e.charCodeAt(o++) - 43]),
				(n = ch[e.charCodeAt(o++) - 43]),
				(i = ch[e.charCodeAt(o++) - 43]),
				(s = ch[e.charCodeAt(o++) - 43]),
				(t += String.fromCharCode((r << 2) | (n >> 4))),
				i !== 64 &&
					((t += String.fromCharCode(((n & 15) << 4) | (i >> 2))),
					s !== 64 && (t += String.fromCharCode(((i & 3) << 6) | s)))
		return t
	}
	$.encodeUtf8 = function (e) {
		return unescape(encodeURIComponent(e))
	}
	$.decodeUtf8 = function (e) {
		return decodeURIComponent(escape(e))
	}
	$.binary = {
		raw: {},
		hex: {},
		base64: {},
		base58: {},
		baseN: { encode: Xae.encode, decode: Xae.decode },
	}
	$.binary.raw.encode = function (e) {
		return String.fromCharCode.apply(null, e)
	}
	$.binary.raw.decode = function (e, t, r) {
		var n = t
		n || (n = new Uint8Array(e.length)), (r = r || 0)
		for (var i = r, s = 0; s < e.length; ++s) n[i++] = e.charCodeAt(s)
		return t ? i - r : n
	}
	$.binary.hex.encode = $.bytesToHex
	$.binary.hex.decode = function (e, t, r) {
		var n = t
		n || (n = new Uint8Array(Math.ceil(e.length / 2))), (r = r || 0)
		var i = 0,
			s = r
		for (e.length & 1 && ((i = 1), (n[s++] = parseInt(e[0], 16))); i < e.length; i += 2)
			n[s++] = parseInt(e.substr(i, 2), 16)
		return t ? s - r : n
	}
	$.binary.base64.encode = function (e, t) {
		for (var r = "", n = "", i, s, o, a = 0; a < e.byteLength; )
			(i = e[a++]),
				(s = e[a++]),
				(o = e[a++]),
				(r += lh.charAt(i >> 2)),
				(r += lh.charAt(((i & 3) << 4) | (s >> 4))),
				isNaN(s)
					? (r += "==")
					: ((r += lh.charAt(((s & 15) << 2) | (o >> 6))), (r += isNaN(o) ? "=" : lh.charAt(o & 63))),
				t &&
					r.length > t &&
					((n +=
						r.substr(0, t) +
						`\r
`),
					(r = r.substr(t)))
		return (n += r), n
	}
	$.binary.base64.decode = function (e, t, r) {
		var n = t
		n || (n = new Uint8Array(Math.ceil(e.length / 4) * 3)), (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "")), (r = r || 0)
		for (var i, s, o, a, l = 0, c = r; l < e.length; )
			(i = ch[e.charCodeAt(l++) - 43]),
				(s = ch[e.charCodeAt(l++) - 43]),
				(o = ch[e.charCodeAt(l++) - 43]),
				(a = ch[e.charCodeAt(l++) - 43]),
				(n[c++] = (i << 2) | (s >> 4)),
				o !== 64 && ((n[c++] = ((s & 15) << 4) | (o >> 2)), a !== 64 && (n[c++] = ((o & 3) << 6) | a))
		return t ? c - r : n.subarray(0, c)
	}
	$.binary.base58.encode = function (e, t) {
		return $.binary.baseN.encode(e, ele, t)
	}
	$.binary.base58.decode = function (e, t) {
		return $.binary.baseN.decode(e, ele, t)
	}
	$.text = { utf8: {}, utf16: {} }
	$.text.utf8.encode = function (e, t, r) {
		e = $.encodeUtf8(e)
		var n = t
		n || (n = new Uint8Array(e.length)), (r = r || 0)
		for (var i = r, s = 0; s < e.length; ++s) n[i++] = e.charCodeAt(s)
		return t ? i - r : n
	}
	$.text.utf8.decode = function (e) {
		return $.decodeUtf8(String.fromCharCode.apply(null, e))
	}
	$.text.utf16.encode = function (e, t, r) {
		var n = t
		n || (n = new Uint8Array(e.length * 2))
		var i = new Uint16Array(n.buffer)
		r = r || 0
		for (var s = r, o = r, a = 0; a < e.length; ++a) (i[o++] = e.charCodeAt(a)), (s += 2)
		return t ? s - r : n
	}
	$.text.utf16.decode = function (e) {
		return String.fromCharCode.apply(null, new Uint16Array(e.buffer))
	}
	$.deflate = function (e, t, r) {
		if (((t = $.decode64(e.deflate($.encode64(t)).rval)), r)) {
			var n = 2,
				i = t.charCodeAt(1)
			i & 32 && (n = 6), (t = t.substring(n, t.length - 4))
		}
		return t
	}
	$.inflate = function (e, t, r) {
		var n = e.inflate($.encode64(t)).rval
		return n === null ? null : $.decode64(n)
	}
	var l5 = function (e, t, r) {
			if (!e) throw new Error("WebStorage not available.")
			var n
			if (
				(r === null ? (n = e.removeItem(t)) : ((r = $.encode64(JSON.stringify(r))), (n = e.setItem(t, r))),
				typeof n < "u" && n.rval !== !0)
			) {
				var i = new Error(n.error.message)
				throw ((i.id = n.error.id), (i.name = n.error.name), i)
			}
		},
		c5 = function (e, t) {
			if (!e) throw new Error("WebStorage not available.")
			var r = e.getItem(t)
			if (e.init)
				if (r.rval === null) {
					if (r.error) {
						var n = new Error(r.error.message)
						throw ((n.id = r.error.id), (n.name = r.error.name), n)
					}
					r = null
				} else r = r.rval
			return r !== null && (r = JSON.parse($.decode64(r))), r
		},
		kje = function (e, t, r, n) {
			var i = c5(e, t)
			i === null && (i = {}), (i[r] = n), l5(e, t, i)
		},
		Mje = function (e, t, r) {
			var n = c5(e, t)
			return n !== null && (n = r in n ? n[r] : null), n
		},
		Fje = function (e, t, r) {
			var n = c5(e, t)
			if (n !== null && r in n) {
				delete n[r]
				var i = !0
				for (var s in n) {
					i = !1
					break
				}
				i && (n = null), l5(e, t, n)
			}
		},
		Qje = function (e, t) {
			l5(e, t, null)
		},
		tT = function (e, t, r) {
			var n = null
			typeof r > "u" && (r = ["web", "flash"])
			var i,
				s = !1,
				o = null
			for (var a in r) {
				i = r[a]
				try {
					if (i === "flash" || i === "both") {
						if (t[0] === null) throw new Error("Flash local storage not available.")
						;(n = e.apply(this, t)), (s = i === "flash")
					}
					;(i === "web" || i === "both") && ((t[0] = localStorage), (n = e.apply(this, t)), (s = !0))
				} catch (l) {
					o = l
				}
				if (s) break
			}
			if (!s) throw o
			return n
		}
	$.setItem = function (e, t, r, n, i) {
		tT(kje, arguments, i)
	}
	$.getItem = function (e, t, r, n) {
		return tT(Mje, arguments, n)
	}
	$.removeItem = function (e, t, r, n) {
		tT(Fje, arguments, n)
	}
	$.clearItems = function (e, t, r) {
		tT(Qje, arguments, r)
	}
	$.isEmpty = function (e) {
		for (var t in e) if (e.hasOwnProperty(t)) return !1
		return !0
	}
	$.format = function (e) {
		for (var t = /%./g, r, n, i = 0, s = [], o = 0; (r = t.exec(e)); ) {
			;(n = e.substring(o, t.lastIndex - 2)), n.length > 0 && s.push(n), (o = t.lastIndex)
			var a = r[0][1]
			switch (a) {
				case "s":
				case "o":
					i < arguments.length ? s.push(arguments[i++ + 1]) : s.push("<?>")
					break
				case "%":
					s.push("%")
					break
				default:
					s.push("<%" + a + "?>")
			}
		}
		return s.push(e.substring(o)), s.join("")
	}
	$.formatNumber = function (e, t, r, n) {
		var i = e,
			s = isNaN((t = Math.abs(t))) ? 2 : t,
			o = r === void 0 ? "," : r,
			a = n === void 0 ? "." : n,
			l = i < 0 ? "-" : "",
			c = parseInt((i = Math.abs(+i || 0).toFixed(s)), 10) + "",
			u = c.length > 3 ? c.length % 3 : 0
		return (
			l +
			(u ? c.substr(0, u) + a : "") +
			c.substr(u).replace(/(\d{3})(?=\d)/g, "$1" + a) +
			(s
				? o +
					Math.abs(i - c)
						.toFixed(s)
						.slice(2)
				: "")
		)
	}
	$.formatSize = function (e) {
		return (
			e >= 1073741824
				? (e = $.formatNumber(e / 1073741824, 2, ".", "") + " GiB")
				: e >= 1048576
					? (e = $.formatNumber(e / 1048576, 2, ".", "") + " MiB")
					: e >= 1024
						? (e = $.formatNumber(e / 1024, 0) + " KiB")
						: (e = $.formatNumber(e, 0) + " bytes"),
			e
		)
	}
	$.bytesFromIP = function (e) {
		return e.indexOf(".") !== -1 ? $.bytesFromIPv4(e) : e.indexOf(":") !== -1 ? $.bytesFromIPv6(e) : null
	}
	$.bytesFromIPv4 = function (e) {
		if (((e = e.split(".")), e.length !== 4)) return null
		for (var t = $.createBuffer(), r = 0; r < e.length; ++r) {
			var n = parseInt(e[r], 10)
			if (isNaN(n)) return null
			t.putByte(n)
		}
		return t.getBytes()
	}
	$.bytesFromIPv6 = function (e) {
		var t = 0
		e = e.split(":").filter(function (o) {
			return o.length === 0 && ++t, !0
		})
		for (var r = (8 - e.length + t) * 2, n = $.createBuffer(), i = 0; i < 8; ++i) {
			if (!e[i] || e[i].length === 0) {
				n.fillWithByte(0, r), (r = 0)
				continue
			}
			var s = $.hexToBytes(e[i])
			s.length < 2 && n.putByte(0), n.putBytes(s)
		}
		return n.getBytes()
	}
	$.bytesToIP = function (e) {
		return e.length === 4 ? $.bytesToIPv4(e) : e.length === 16 ? $.bytesToIPv6(e) : null
	}
	$.bytesToIPv4 = function (e) {
		if (e.length !== 4) return null
		for (var t = [], r = 0; r < e.length; ++r) t.push(e.charCodeAt(r))
		return t.join(".")
	}
	$.bytesToIPv6 = function (e) {
		if (e.length !== 16) return null
		for (var t = [], r = [], n = 0, i = 0; i < e.length; i += 2) {
			for (var s = $.bytesToHex(e[i] + e[i + 1]); s[0] === "0" && s !== "0"; ) s = s.substr(1)
			if (s === "0") {
				var o = r[r.length - 1],
					a = t.length
				!o || a !== o.end + 1
					? r.push({ start: a, end: a })
					: ((o.end = a), o.end - o.start > r[n].end - r[n].start && (n = r.length - 1))
			}
			t.push(s)
		}
		if (r.length > 0) {
			var l = r[n]
			l.end - l.start > 0 &&
				(t.splice(l.start, l.end - l.start + 1, ""), l.start === 0 && t.unshift(""), l.end === 7 && t.push(""))
		}
		return t.join(":")
	}
	$.estimateCores = function (e, t) {
		if ((typeof e == "function" && ((t = e), (e = {})), (e = e || {}), "cores" in $ && !e.update))
			return t(null, $.cores)
		if (typeof navigator < "u" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0)
			return ($.cores = navigator.hardwareConcurrency), t(null, $.cores)
		if (typeof Worker > "u") return ($.cores = 1), t(null, $.cores)
		if (typeof Blob > "u") return ($.cores = 2), t(null, $.cores)
		var r = URL.createObjectURL(
			new Blob(
				[
					"(",
					function () {
						self.addEventListener("message", function (o) {
							for (var a = Date.now(), l = a + 4; Date.now() < l; );
							self.postMessage({ st: a, et: l })
						})
					}.toString(),
					")()",
				],
				{ type: "application/javascript" },
			),
		)
		n([], 5, 16)
		function n(o, a, l) {
			if (a === 0) {
				var c = Math.floor(
					o.reduce(function (u, f) {
						return u + f
					}, 0) / o.length,
				)
				return ($.cores = Math.max(1, c)), URL.revokeObjectURL(r), t(null, $.cores)
			}
			i(l, function (u, f) {
				o.push(s(l, f)), n(o, a - 1, l)
			})
		}
		function i(o, a) {
			for (var l = [], c = [], u = 0; u < o; ++u) {
				var f = new Worker(r)
				f.addEventListener("message", function (p) {
					if ((c.push(p.data), c.length === o)) {
						for (var g = 0; g < o; ++g) l[g].terminate()
						a(null, c)
					}
				}),
					l.push(f)
			}
			for (var u = 0; u < o; ++u) l[u].postMessage(u)
		}
		function s(o, a) {
			for (var l = [], c = 0; c < o; ++c)
				for (var u = a[c], f = (l[c] = []), p = 0; p < o; ++p)
					if (c !== p) {
						var g = a[p]
						;((u.st > g.st && u.st < g.et) || (g.st > u.st && g.st < u.et)) && f.push(p)
					}
			return l.reduce(function (m, y) {
				return Math.max(m, y.length)
			}, 0)
		}
	}
})
var rT = x((PSt, rle) => {
	"use strict"
	var ji = Yt()
	Sr()
	rle.exports = ji.cipher = ji.cipher || {}
	ji.cipher.algorithms = ji.cipher.algorithms || {}
	ji.cipher.createCipher = function (e, t) {
		var r = e
		if ((typeof r == "string" && ((r = ji.cipher.getAlgorithm(r)), r && (r = r())), !r))
			throw new Error("Unsupported algorithm: " + e)
		return new ji.cipher.BlockCipher({ algorithm: r, key: t, decrypt: !1 })
	}
	ji.cipher.createDecipher = function (e, t) {
		var r = e
		if ((typeof r == "string" && ((r = ji.cipher.getAlgorithm(r)), r && (r = r())), !r))
			throw new Error("Unsupported algorithm: " + e)
		return new ji.cipher.BlockCipher({ algorithm: r, key: t, decrypt: !0 })
	}
	ji.cipher.registerAlgorithm = function (e, t) {
		;(e = e.toUpperCase()), (ji.cipher.algorithms[e] = t)
	}
	ji.cipher.getAlgorithm = function (e) {
		return (e = e.toUpperCase()), e in ji.cipher.algorithms ? ji.cipher.algorithms[e] : null
	}
	var u5 = (ji.cipher.BlockCipher = function (e) {
		;(this.algorithm = e.algorithm),
			(this.mode = this.algorithm.mode),
			(this.blockSize = this.mode.blockSize),
			(this._finish = !1),
			(this._input = null),
			(this.output = null),
			(this._op = e.decrypt ? this.mode.decrypt : this.mode.encrypt),
			(this._decrypt = e.decrypt),
			this.algorithm.initialize(e)
	})
	u5.prototype.start = function (e) {
		e = e || {}
		var t = {}
		for (var r in e) t[r] = e[r]
		;(t.decrypt = this._decrypt),
			(this._finish = !1),
			(this._input = ji.util.createBuffer()),
			(this.output = e.output || ji.util.createBuffer()),
			this.mode.start(t)
	}
	u5.prototype.update = function (e) {
		for (
			e && this._input.putBuffer(e);
			!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish;

		);
		this._input.compact()
	}
	u5.prototype.finish = function (e) {
		e &&
			(this.mode.name === "ECB" || this.mode.name === "CBC") &&
			((this.mode.pad = function (r) {
				return e(this.blockSize, r, !1)
			}),
			(this.mode.unpad = function (r) {
				return e(this.blockSize, r, !0)
			}))
		var t = {}
		return (
			(t.decrypt = this._decrypt),
			(t.overflow = this._input.length() % this.blockSize),
			!(
				(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, t)) ||
				((this._finish = !0),
				this.update(),
				this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, t)) ||
				(this.mode.afterFinish && !this.mode.afterFinish(this.output, t))
			)
		)
	}
})
var f5 = x((LSt, nle) => {
	"use strict"
	var Zi = Yt()
	Sr()
	Zi.cipher = Zi.cipher || {}
	var sr = (nle.exports = Zi.cipher.modes = Zi.cipher.modes || {})
	sr.ecb = function (e) {
		;(e = e || {}),
			(this.name = "ECB"),
			(this.cipher = e.cipher),
			(this.blockSize = e.blockSize || 16),
			(this._ints = this.blockSize / 4),
			(this._inBlock = new Array(this._ints)),
			(this._outBlock = new Array(this._ints))
	}
	sr.ecb.prototype.start = function (e) {}
	sr.ecb.prototype.encrypt = function (e, t, r) {
		if (e.length() < this.blockSize && !(r && e.length() > 0)) return !0
		for (var n = 0; n < this._ints; ++n) this._inBlock[n] = e.getInt32()
		this.cipher.encrypt(this._inBlock, this._outBlock)
		for (var n = 0; n < this._ints; ++n) t.putInt32(this._outBlock[n])
	}
	sr.ecb.prototype.decrypt = function (e, t, r) {
		if (e.length() < this.blockSize && !(r && e.length() > 0)) return !0
		for (var n = 0; n < this._ints; ++n) this._inBlock[n] = e.getInt32()
		this.cipher.decrypt(this._inBlock, this._outBlock)
		for (var n = 0; n < this._ints; ++n) t.putInt32(this._outBlock[n])
	}
	sr.ecb.prototype.pad = function (e, t) {
		var r = e.length() === this.blockSize ? this.blockSize : this.blockSize - e.length()
		return e.fillWithByte(r, r), !0
	}
	sr.ecb.prototype.unpad = function (e, t) {
		if (t.overflow > 0) return !1
		var r = e.length(),
			n = e.at(r - 1)
		return n > this.blockSize << 2 ? !1 : (e.truncate(n), !0)
	}
	sr.cbc = function (e) {
		;(e = e || {}),
			(this.name = "CBC"),
			(this.cipher = e.cipher),
			(this.blockSize = e.blockSize || 16),
			(this._ints = this.blockSize / 4),
			(this._inBlock = new Array(this._ints)),
			(this._outBlock = new Array(this._ints))
	}
	sr.cbc.prototype.start = function (e) {
		if (e.iv === null) {
			if (!this._prev) throw new Error("Invalid IV parameter.")
			this._iv = this._prev.slice(0)
		} else if ("iv" in e) (this._iv = nT(e.iv, this.blockSize)), (this._prev = this._iv.slice(0))
		else throw new Error("Invalid IV parameter.")
	}
	sr.cbc.prototype.encrypt = function (e, t, r) {
		if (e.length() < this.blockSize && !(r && e.length() > 0)) return !0
		for (var n = 0; n < this._ints; ++n) this._inBlock[n] = this._prev[n] ^ e.getInt32()
		this.cipher.encrypt(this._inBlock, this._outBlock)
		for (var n = 0; n < this._ints; ++n) t.putInt32(this._outBlock[n])
		this._prev = this._outBlock
	}
	sr.cbc.prototype.decrypt = function (e, t, r) {
		if (e.length() < this.blockSize && !(r && e.length() > 0)) return !0
		for (var n = 0; n < this._ints; ++n) this._inBlock[n] = e.getInt32()
		this.cipher.decrypt(this._inBlock, this._outBlock)
		for (var n = 0; n < this._ints; ++n) t.putInt32(this._prev[n] ^ this._outBlock[n])
		this._prev = this._inBlock.slice(0)
	}
	sr.cbc.prototype.pad = function (e, t) {
		var r = e.length() === this.blockSize ? this.blockSize : this.blockSize - e.length()
		return e.fillWithByte(r, r), !0
	}
	sr.cbc.prototype.unpad = function (e, t) {
		if (t.overflow > 0) return !1
		var r = e.length(),
			n = e.at(r - 1)
		return n > this.blockSize << 2 ? !1 : (e.truncate(n), !0)
	}
	sr.cfb = function (e) {
		;(e = e || {}),
			(this.name = "CFB"),
			(this.cipher = e.cipher),
			(this.blockSize = e.blockSize || 16),
			(this._ints = this.blockSize / 4),
			(this._inBlock = null),
			(this._outBlock = new Array(this._ints)),
			(this._partialBlock = new Array(this._ints)),
			(this._partialOutput = Zi.util.createBuffer()),
			(this._partialBytes = 0)
	}
	sr.cfb.prototype.start = function (e) {
		if (!("iv" in e)) throw new Error("Invalid IV parameter.")
		;(this._iv = nT(e.iv, this.blockSize)), (this._inBlock = this._iv.slice(0)), (this._partialBytes = 0)
	}
	sr.cfb.prototype.encrypt = function (e, t, r) {
		var n = e.length()
		if (n === 0) return !0
		if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize)) {
			for (var i = 0; i < this._ints; ++i)
				(this._inBlock[i] = e.getInt32() ^ this._outBlock[i]), t.putInt32(this._inBlock[i])
			return
		}
		var s = (this.blockSize - n) % this.blockSize
		s > 0 && (s = this.blockSize - s), this._partialOutput.clear()
		for (var i = 0; i < this._ints; ++i)
			(this._partialBlock[i] = e.getInt32() ^ this._outBlock[i]),
				this._partialOutput.putInt32(this._partialBlock[i])
		if (s > 0) e.read -= this.blockSize
		else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i]
		if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !r))
			return t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), (this._partialBytes = s), !0
		t.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), (this._partialBytes = 0)
	}
	sr.cfb.prototype.decrypt = function (e, t, r) {
		var n = e.length()
		if (n === 0) return !0
		if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize)) {
			for (var i = 0; i < this._ints; ++i)
				(this._inBlock[i] = e.getInt32()), t.putInt32(this._inBlock[i] ^ this._outBlock[i])
			return
		}
		var s = (this.blockSize - n) % this.blockSize
		s > 0 && (s = this.blockSize - s), this._partialOutput.clear()
		for (var i = 0; i < this._ints; ++i)
			(this._partialBlock[i] = e.getInt32()),
				this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i])
		if (s > 0) e.read -= this.blockSize
		else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i]
		if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !r))
			return t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), (this._partialBytes = s), !0
		t.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), (this._partialBytes = 0)
	}
	sr.ofb = function (e) {
		;(e = e || {}),
			(this.name = "OFB"),
			(this.cipher = e.cipher),
			(this.blockSize = e.blockSize || 16),
			(this._ints = this.blockSize / 4),
			(this._inBlock = null),
			(this._outBlock = new Array(this._ints)),
			(this._partialOutput = Zi.util.createBuffer()),
			(this._partialBytes = 0)
	}
	sr.ofb.prototype.start = function (e) {
		if (!("iv" in e)) throw new Error("Invalid IV parameter.")
		;(this._iv = nT(e.iv, this.blockSize)), (this._inBlock = this._iv.slice(0)), (this._partialBytes = 0)
	}
	sr.ofb.prototype.encrypt = function (e, t, r) {
		var n = e.length()
		if (e.length() === 0) return !0
		if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize)) {
			for (var i = 0; i < this._ints; ++i)
				t.putInt32(e.getInt32() ^ this._outBlock[i]), (this._inBlock[i] = this._outBlock[i])
			return
		}
		var s = (this.blockSize - n) % this.blockSize
		s > 0 && (s = this.blockSize - s), this._partialOutput.clear()
		for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[i])
		if (s > 0) e.read -= this.blockSize
		else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._outBlock[i]
		if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !r))
			return t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), (this._partialBytes = s), !0
		t.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), (this._partialBytes = 0)
	}
	sr.ofb.prototype.decrypt = sr.ofb.prototype.encrypt
	sr.ctr = function (e) {
		;(e = e || {}),
			(this.name = "CTR"),
			(this.cipher = e.cipher),
			(this.blockSize = e.blockSize || 16),
			(this._ints = this.blockSize / 4),
			(this._inBlock = null),
			(this._outBlock = new Array(this._ints)),
			(this._partialOutput = Zi.util.createBuffer()),
			(this._partialBytes = 0)
	}
	sr.ctr.prototype.start = function (e) {
		if (!("iv" in e)) throw new Error("Invalid IV parameter.")
		;(this._iv = nT(e.iv, this.blockSize)), (this._inBlock = this._iv.slice(0)), (this._partialBytes = 0)
	}
	sr.ctr.prototype.encrypt = function (e, t, r) {
		var n = e.length()
		if (n === 0) return !0
		if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize))
			for (var i = 0; i < this._ints; ++i) t.putInt32(e.getInt32() ^ this._outBlock[i])
		else {
			var s = (this.blockSize - n) % this.blockSize
			s > 0 && (s = this.blockSize - s), this._partialOutput.clear()
			for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[i])
			if (
				(s > 0 && (e.read -= this.blockSize),
				this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes),
				s > 0 && !r)
			)
				return t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), (this._partialBytes = s), !0
			t.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), (this._partialBytes = 0)
		}
		iT(this._inBlock)
	}
	sr.ctr.prototype.decrypt = sr.ctr.prototype.encrypt
	sr.gcm = function (e) {
		;(e = e || {}),
			(this.name = "GCM"),
			(this.cipher = e.cipher),
			(this.blockSize = e.blockSize || 16),
			(this._ints = this.blockSize / 4),
			(this._inBlock = new Array(this._ints)),
			(this._outBlock = new Array(this._ints)),
			(this._partialOutput = Zi.util.createBuffer()),
			(this._partialBytes = 0),
			(this._R = 3774873600)
	}
	sr.gcm.prototype.start = function (e) {
		if (!("iv" in e)) throw new Error("Invalid IV parameter.")
		var t = Zi.util.createBuffer(e.iv)
		this._cipherLength = 0
		var r
		if (
			("additionalData" in e ? (r = Zi.util.createBuffer(e.additionalData)) : (r = Zi.util.createBuffer()),
			"tagLength" in e ? (this._tagLength = e.tagLength) : (this._tagLength = 128),
			(this._tag = null),
			e.decrypt &&
				((this._tag = Zi.util.createBuffer(e.tag).getBytes()), this._tag.length !== this._tagLength / 8))
		)
			throw new Error("Authentication tag does not match tag length.")
		;(this._hashBlock = new Array(this._ints)),
			(this.tag = null),
			(this._hashSubkey = new Array(this._ints)),
			this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey),
			(this.componentBits = 4),
			(this._m = this.generateHashTable(this._hashSubkey, this.componentBits))
		var n = t.length()
		if (n === 12) this._j0 = [t.getInt32(), t.getInt32(), t.getInt32(), 1]
		else {
			for (this._j0 = [0, 0, 0, 0]; t.length() > 0; )
				this._j0 = this.ghash(this._hashSubkey, this._j0, [
					t.getInt32(),
					t.getInt32(),
					t.getInt32(),
					t.getInt32(),
				])
			this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(d5(n * 8)))
		}
		;(this._inBlock = this._j0.slice(0)),
			iT(this._inBlock),
			(this._partialBytes = 0),
			(r = Zi.util.createBuffer(r)),
			(this._aDataLength = d5(r.length() * 8))
		var i = r.length() % this.blockSize
		for (i && r.fillWithByte(0, this.blockSize - i), this._s = [0, 0, 0, 0]; r.length() > 0; )
			this._s = this.ghash(this._hashSubkey, this._s, [r.getInt32(), r.getInt32(), r.getInt32(), r.getInt32()])
	}
	sr.gcm.prototype.encrypt = function (e, t, r) {
		var n = e.length()
		if (n === 0) return !0
		if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize)) {
			for (var i = 0; i < this._ints; ++i) t.putInt32((this._outBlock[i] ^= e.getInt32()))
			this._cipherLength += this.blockSize
		} else {
			var s = (this.blockSize - n) % this.blockSize
			s > 0 && (s = this.blockSize - s), this._partialOutput.clear()
			for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[i])
			if (s <= 0 || r) {
				if (r) {
					var o = n % this.blockSize
					;(this._cipherLength += o), this._partialOutput.truncate(this.blockSize - o)
				} else this._cipherLength += this.blockSize
				for (var i = 0; i < this._ints; ++i) this._outBlock[i] = this._partialOutput.getInt32()
				this._partialOutput.read -= this.blockSize
			}
			if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !r))
				return (
					(e.read -= this.blockSize),
					t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)),
					(this._partialBytes = s),
					!0
				)
			t.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), (this._partialBytes = 0)
		}
		;(this._s = this.ghash(this._hashSubkey, this._s, this._outBlock)), iT(this._inBlock)
	}
	sr.gcm.prototype.decrypt = function (e, t, r) {
		var n = e.length()
		if (n < this.blockSize && !(r && n > 0)) return !0
		this.cipher.encrypt(this._inBlock, this._outBlock),
			iT(this._inBlock),
			(this._hashBlock[0] = e.getInt32()),
			(this._hashBlock[1] = e.getInt32()),
			(this._hashBlock[2] = e.getInt32()),
			(this._hashBlock[3] = e.getInt32()),
			(this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock))
		for (var i = 0; i < this._ints; ++i) t.putInt32(this._outBlock[i] ^ this._hashBlock[i])
		n < this.blockSize ? (this._cipherLength += n % this.blockSize) : (this._cipherLength += this.blockSize)
	}
	sr.gcm.prototype.afterFinish = function (e, t) {
		var r = !0
		t.decrypt && t.overflow && e.truncate(this.blockSize - t.overflow), (this.tag = Zi.util.createBuffer())
		var n = this._aDataLength.concat(d5(this._cipherLength * 8))
		this._s = this.ghash(this._hashSubkey, this._s, n)
		var i = []
		this.cipher.encrypt(this._j0, i)
		for (var s = 0; s < this._ints; ++s) this.tag.putInt32(this._s[s] ^ i[s])
		return (
			this.tag.truncate(this.tag.length() % (this._tagLength / 8)),
			t.decrypt && this.tag.bytes() !== this._tag && (r = !1),
			r
		)
	}
	sr.gcm.prototype.multiply = function (e, t) {
		for (var r = [0, 0, 0, 0], n = t.slice(0), i = 0; i < 128; ++i) {
			var s = e[(i / 32) | 0] & (1 << (31 - (i % 32)))
			s && ((r[0] ^= n[0]), (r[1] ^= n[1]), (r[2] ^= n[2]), (r[3] ^= n[3])), this.pow(n, n)
		}
		return r
	}
	sr.gcm.prototype.pow = function (e, t) {
		for (var r = e[3] & 1, n = 3; n > 0; --n) t[n] = (e[n] >>> 1) | ((e[n - 1] & 1) << 31)
		;(t[0] = e[0] >>> 1), r && (t[0] ^= this._R)
	}
	sr.gcm.prototype.tableMultiply = function (e) {
		for (var t = [0, 0, 0, 0], r = 0; r < 32; ++r) {
			var n = (r / 8) | 0,
				i = (e[n] >>> ((7 - (r % 8)) * 4)) & 15,
				s = this._m[r][i]
			;(t[0] ^= s[0]), (t[1] ^= s[1]), (t[2] ^= s[2]), (t[3] ^= s[3])
		}
		return t
	}
	sr.gcm.prototype.ghash = function (e, t, r) {
		return (t[0] ^= r[0]), (t[1] ^= r[1]), (t[2] ^= r[2]), (t[3] ^= r[3]), this.tableMultiply(t)
	}
	sr.gcm.prototype.generateHashTable = function (e, t) {
		for (var r = 8 / t, n = 4 * r, i = 16 * r, s = new Array(i), o = 0; o < i; ++o) {
			var a = [0, 0, 0, 0],
				l = (o / n) | 0,
				c = (n - 1 - (o % n)) * t
			;(a[l] = (1 << (t - 1)) << c), (s[o] = this.generateSubHashTable(this.multiply(a, e), t))
		}
		return s
	}
	sr.gcm.prototype.generateSubHashTable = function (e, t) {
		var r = 1 << t,
			n = r >>> 1,
			i = new Array(r)
		i[n] = e.slice(0)
		for (var s = n >>> 1; s > 0; ) this.pow(i[2 * s], (i[s] = [])), (s >>= 1)
		for (s = 2; s < n; ) {
			for (var o = 1; o < s; ++o) {
				var a = i[s],
					l = i[o]
				i[s + o] = [a[0] ^ l[0], a[1] ^ l[1], a[2] ^ l[2], a[3] ^ l[3]]
			}
			s *= 2
		}
		for (i[0] = [0, 0, 0, 0], s = n + 1; s < r; ++s) {
			var c = i[s ^ n]
			i[s] = [e[0] ^ c[0], e[1] ^ c[1], e[2] ^ c[2], e[3] ^ c[3]]
		}
		return i
	}
	function nT(e, t) {
		if ((typeof e == "string" && (e = Zi.util.createBuffer(e)), Zi.util.isArray(e) && e.length > 4)) {
			var r = e
			e = Zi.util.createBuffer()
			for (var n = 0; n < r.length; ++n) e.putByte(r[n])
		}
		if (e.length() < t)
			throw new Error("Invalid IV length; got " + e.length() + " bytes and expected " + t + " bytes.")
		if (!Zi.util.isArray(e)) {
			for (var i = [], s = t / 4, n = 0; n < s; ++n) i.push(e.getInt32())
			e = i
		}
		return e
	}
	function iT(e) {
		e[e.length - 1] = (e[e.length - 1] + 1) & 4294967295
	}
	function d5(e) {
		return [(e / 4294967296) | 0, e & 4294967295]
	}
})
var uh = x((USt, ale) => {
	"use strict"
	var hn = Yt()
	rT()
	f5()
	Sr()
	ale.exports = hn.aes = hn.aes || {}
	hn.aes.startEncrypting = function (e, t, r, n) {
		var i = sT({ key: e, output: r, decrypt: !1, mode: n })
		return i.start(t), i
	}
	hn.aes.createEncryptionCipher = function (e, t) {
		return sT({ key: e, output: null, decrypt: !1, mode: t })
	}
	hn.aes.startDecrypting = function (e, t, r, n) {
		var i = sT({ key: e, output: r, decrypt: !0, mode: n })
		return i.start(t), i
	}
	hn.aes.createDecryptionCipher = function (e, t) {
		return sT({ key: e, output: null, decrypt: !0, mode: t })
	}
	hn.aes.Algorithm = function (e, t) {
		p5 || sle()
		var r = this
		;(r.name = e),
			(r.mode = new t({
				blockSize: 16,
				cipher: {
					encrypt: function (n, i) {
						return g5(r._w, n, i, !1)
					},
					decrypt: function (n, i) {
						return g5(r._w, n, i, !0)
					},
				},
			})),
			(r._init = !1)
	}
	hn.aes.Algorithm.prototype.initialize = function (e) {
		if (!this._init) {
			var t = e.key,
				r
			if (typeof t == "string" && (t.length === 16 || t.length === 24 || t.length === 32))
				t = hn.util.createBuffer(t)
			else if (hn.util.isArray(t) && (t.length === 16 || t.length === 24 || t.length === 32)) {
				;(r = t), (t = hn.util.createBuffer())
				for (var n = 0; n < r.length; ++n) t.putByte(r[n])
			}
			if (!hn.util.isArray(t)) {
				;(r = t), (t = [])
				var i = r.length()
				if (i === 16 || i === 24 || i === 32) {
					i = i >>> 2
					for (var n = 0; n < i; ++n) t.push(r.getInt32())
				}
			}
			if (!hn.util.isArray(t) || !(t.length === 4 || t.length === 6 || t.length === 8))
				throw new Error("Invalid key parameter.")
			var s = this.mode.name,
				o = ["CFB", "OFB", "CTR", "GCM"].indexOf(s) !== -1
			;(this._w = ole(t, e.decrypt && !o)), (this._init = !0)
		}
	}
	hn.aes._expandKey = function (e, t) {
		return p5 || sle(), ole(e, t)
	}
	hn.aes._updateBlock = g5
	U0("AES-ECB", hn.cipher.modes.ecb)
	U0("AES-CBC", hn.cipher.modes.cbc)
	U0("AES-CFB", hn.cipher.modes.cfb)
	U0("AES-OFB", hn.cipher.modes.ofb)
	U0("AES-CTR", hn.cipher.modes.ctr)
	U0("AES-GCM", hn.cipher.modes.gcm)
	function U0(e, t) {
		var r = function () {
			return new hn.aes.Algorithm(e, t)
		}
		hn.cipher.registerAlgorithm(e, r)
	}
	var p5 = !1,
		L0 = 4,
		so,
		h5,
		ile,
		xp,
		hc
	function sle() {
		;(p5 = !0), (ile = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54])
		for (var e = new Array(256), t = 0; t < 128; ++t) (e[t] = t << 1), (e[t + 128] = ((t + 128) << 1) ^ 283)
		;(so = new Array(256)), (h5 = new Array(256)), (xp = new Array(4)), (hc = new Array(4))
		for (var t = 0; t < 4; ++t) (xp[t] = new Array(256)), (hc[t] = new Array(256))
		for (var r = 0, n = 0, i, s, o, a, l, c, u, t = 0; t < 256; ++t) {
			;(a = n ^ (n << 1) ^ (n << 2) ^ (n << 3) ^ (n << 4)),
				(a = (a >> 8) ^ (a & 255) ^ 99),
				(so[r] = a),
				(h5[a] = r),
				(l = e[a]),
				(i = e[r]),
				(s = e[i]),
				(o = e[s]),
				(c = (l << 24) ^ (a << 16) ^ (a << 8) ^ (a ^ l)),
				(u = ((i ^ s ^ o) << 24) ^ ((r ^ o) << 16) ^ ((r ^ s ^ o) << 8) ^ (r ^ i ^ o))
			for (var f = 0; f < 4; ++f)
				(xp[f][r] = c), (hc[f][a] = u), (c = (c << 24) | (c >>> 8)), (u = (u << 24) | (u >>> 8))
			r === 0 ? (r = n = 1) : ((r = i ^ e[e[e[i ^ o]]]), (n ^= e[e[n]]))
		}
	}
	function ole(e, t) {
		for (var r = e.slice(0), n, i = 1, s = r.length, o = s + 6 + 1, a = L0 * o, l = s; l < a; ++l)
			(n = r[l - 1]),
				l % s === 0
					? ((n =
							(so[(n >>> 16) & 255] << 24) ^
							(so[(n >>> 8) & 255] << 16) ^
							(so[n & 255] << 8) ^
							so[n >>> 24] ^
							(ile[i] << 24)),
						i++)
					: s > 6 &&
						l % s === 4 &&
						(n =
							(so[n >>> 24] << 24) ^
							(so[(n >>> 16) & 255] << 16) ^
							(so[(n >>> 8) & 255] << 8) ^
							so[n & 255]),
				(r[l] = r[l - s] ^ n)
		if (t) {
			var c,
				u = hc[0],
				f = hc[1],
				p = hc[2],
				g = hc[3],
				m = r.slice(0)
			a = r.length
			for (var l = 0, y = a - L0; l < a; l += L0, y -= L0)
				if (l === 0 || l === a - L0)
					(m[l] = r[y]), (m[l + 1] = r[y + 3]), (m[l + 2] = r[y + 2]), (m[l + 3] = r[y + 1])
				else
					for (var C = 0; C < L0; ++C)
						(c = r[y + C]),
							(m[l + (3 & -C)] =
								u[so[c >>> 24]] ^ f[so[(c >>> 16) & 255]] ^ p[so[(c >>> 8) & 255]] ^ g[so[c & 255]])
			r = m
		}
		return r
	}
	function g5(e, t, r, n) {
		var i = e.length / 4 - 1,
			s,
			o,
			a,
			l,
			c
		n
			? ((s = hc[0]), (o = hc[1]), (a = hc[2]), (l = hc[3]), (c = h5))
			: ((s = xp[0]), (o = xp[1]), (a = xp[2]), (l = xp[3]), (c = so))
		var u, f, p, g, m, y, C
		;(u = t[0] ^ e[0]), (f = t[n ? 3 : 1] ^ e[1]), (p = t[2] ^ e[2]), (g = t[n ? 1 : 3] ^ e[3])
		for (var v = 3, b = 1; b < i; ++b)
			(m = s[u >>> 24] ^ o[(f >>> 16) & 255] ^ a[(p >>> 8) & 255] ^ l[g & 255] ^ e[++v]),
				(y = s[f >>> 24] ^ o[(p >>> 16) & 255] ^ a[(g >>> 8) & 255] ^ l[u & 255] ^ e[++v]),
				(C = s[p >>> 24] ^ o[(g >>> 16) & 255] ^ a[(u >>> 8) & 255] ^ l[f & 255] ^ e[++v]),
				(g = s[g >>> 24] ^ o[(u >>> 16) & 255] ^ a[(f >>> 8) & 255] ^ l[p & 255] ^ e[++v]),
				(u = m),
				(f = y),
				(p = C)
		;(r[0] = (c[u >>> 24] << 24) ^ (c[(f >>> 16) & 255] << 16) ^ (c[(p >>> 8) & 255] << 8) ^ c[g & 255] ^ e[++v]),
			(r[n ? 3 : 1] =
				(c[f >>> 24] << 24) ^ (c[(p >>> 16) & 255] << 16) ^ (c[(g >>> 8) & 255] << 8) ^ c[u & 255] ^ e[++v]),
			(r[2] =
				(c[p >>> 24] << 24) ^ (c[(g >>> 16) & 255] << 16) ^ (c[(u >>> 8) & 255] << 8) ^ c[f & 255] ^ e[++v]),
			(r[n ? 1 : 3] =
				(c[g >>> 24] << 24) ^ (c[(u >>> 16) & 255] << 16) ^ (c[(f >>> 8) & 255] << 8) ^ c[p & 255] ^ e[++v])
	}
	function sT(e) {
		e = e || {}
		var t = (e.mode || "CBC").toUpperCase(),
			r = "AES-" + t,
			n
		e.decrypt ? (n = hn.cipher.createDecipher(r, e.key)) : (n = hn.cipher.createCipher(r, e.key))
		var i = n.start
		return (
			(n.start = function (s, o) {
				var a = null
				o instanceof hn.util.ByteBuffer && ((a = o), (o = {})),
					(o = o || {}),
					(o.output = a),
					(o.iv = s),
					i.call(n, o)
			}),
			n
		)
	}
})
var dh = x((OSt, lle) => {
	"use strict"
	var wb = Yt()
	wb.pki = wb.pki || {}
	var A5 = (lle.exports = wb.pki.oids = wb.oids = wb.oids || {})
	function ye(e, t) {
		;(A5[e] = t), (A5[t] = e)
	}
	function Zr(e, t) {
		A5[e] = t
	}
	ye("1.2.840.113549.1.1.1", "rsaEncryption")
	ye("1.2.840.113549.1.1.4", "md5WithRSAEncryption")
	ye("1.2.840.113549.1.1.5", "sha1WithRSAEncryption")
	ye("1.2.840.113549.1.1.7", "RSAES-OAEP")
	ye("1.2.840.113549.1.1.8", "mgf1")
	ye("1.2.840.113549.1.1.9", "pSpecified")
	ye("1.2.840.113549.1.1.10", "RSASSA-PSS")
	ye("1.2.840.113549.1.1.11", "sha256WithRSAEncryption")
	ye("1.2.840.113549.1.1.12", "sha384WithRSAEncryption")
	ye("1.2.840.113549.1.1.13", "sha512WithRSAEncryption")
	ye("1.3.101.112", "EdDSA25519")
	ye("1.2.840.10040.4.3", "dsa-with-sha1")
	ye("1.3.14.3.2.7", "desCBC")
	ye("1.3.14.3.2.26", "sha1")
	ye("1.3.14.3.2.29", "sha1WithRSASignature")
	ye("2.16.840.1.101.3.4.2.1", "sha256")
	ye("2.16.840.1.101.3.4.2.2", "sha384")
	ye("2.16.840.1.101.3.4.2.3", "sha512")
	ye("2.16.840.1.101.3.4.2.4", "sha224")
	ye("2.16.840.1.101.3.4.2.5", "sha512-224")
	ye("2.16.840.1.101.3.4.2.6", "sha512-256")
	ye("1.2.840.113549.2.2", "md2")
	ye("1.2.840.113549.2.5", "md5")
	ye("1.2.840.113549.1.7.1", "data")
	ye("1.2.840.113549.1.7.2", "signedData")
	ye("1.2.840.113549.1.7.3", "envelopedData")
	ye("1.2.840.113549.1.7.4", "signedAndEnvelopedData")
	ye("1.2.840.113549.1.7.5", "digestedData")
	ye("1.2.840.113549.1.7.6", "encryptedData")
	ye("1.2.840.113549.1.9.1", "emailAddress")
	ye("1.2.840.113549.1.9.2", "unstructuredName")
	ye("1.2.840.113549.1.9.3", "contentType")
	ye("1.2.840.113549.1.9.4", "messageDigest")
	ye("1.2.840.113549.1.9.5", "signingTime")
	ye("1.2.840.113549.1.9.6", "counterSignature")
	ye("1.2.840.113549.1.9.7", "challengePassword")
	ye("1.2.840.113549.1.9.8", "unstructuredAddress")
	ye("1.2.840.113549.1.9.14", "extensionRequest")
	ye("1.2.840.113549.1.9.20", "friendlyName")
	ye("1.2.840.113549.1.9.21", "localKeyId")
	ye("1.2.840.113549.1.9.22.1", "x509Certificate")
	ye("1.2.840.113549.1.12.10.1.1", "keyBag")
	ye("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag")
	ye("1.2.840.113549.1.12.10.1.3", "certBag")
	ye("1.2.840.113549.1.12.10.1.4", "crlBag")
	ye("1.2.840.113549.1.12.10.1.5", "secretBag")
	ye("1.2.840.113549.1.12.10.1.6", "safeContentsBag")
	ye("1.2.840.113549.1.5.13", "pkcs5PBES2")
	ye("1.2.840.113549.1.5.12", "pkcs5PBKDF2")
	ye("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4")
	ye("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4")
	ye("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC")
	ye("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC")
	ye("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC")
	ye("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC")
	ye("1.2.840.113549.2.7", "hmacWithSHA1")
	ye("1.2.840.113549.2.8", "hmacWithSHA224")
	ye("1.2.840.113549.2.9", "hmacWithSHA256")
	ye("1.2.840.113549.2.10", "hmacWithSHA384")
	ye("1.2.840.113549.2.11", "hmacWithSHA512")
	ye("1.2.840.113549.3.7", "des-EDE3-CBC")
	ye("2.16.840.1.101.3.4.1.2", "aes128-CBC")
	ye("2.16.840.1.101.3.4.1.22", "aes192-CBC")
	ye("2.16.840.1.101.3.4.1.42", "aes256-CBC")
	ye("2.5.4.3", "commonName")
	ye("2.5.4.4", "surname")
	ye("2.5.4.5", "serialNumber")
	ye("2.5.4.6", "countryName")
	ye("2.5.4.7", "localityName")
	ye("2.5.4.8", "stateOrProvinceName")
	ye("2.5.4.9", "streetAddress")
	ye("2.5.4.10", "organizationName")
	ye("2.5.4.11", "organizationalUnitName")
	ye("2.5.4.12", "title")
	ye("2.5.4.13", "description")
	ye("2.5.4.15", "businessCategory")
	ye("2.5.4.17", "postalCode")
	ye("2.5.4.42", "givenName")
	ye("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName")
	ye("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName")
	ye("2.16.840.1.113730.1.1", "nsCertType")
	ye("2.16.840.1.113730.1.13", "nsComment")
	Zr("2.5.29.1", "authorityKeyIdentifier")
	Zr("2.5.29.2", "keyAttributes")
	Zr("2.5.29.3", "certificatePolicies")
	Zr("2.5.29.4", "keyUsageRestriction")
	Zr("2.5.29.5", "policyMapping")
	Zr("2.5.29.6", "subtreesConstraint")
	Zr("2.5.29.7", "subjectAltName")
	Zr("2.5.29.8", "issuerAltName")
	Zr("2.5.29.9", "subjectDirectoryAttributes")
	Zr("2.5.29.10", "basicConstraints")
	Zr("2.5.29.11", "nameConstraints")
	Zr("2.5.29.12", "policyConstraints")
	Zr("2.5.29.13", "basicConstraints")
	ye("2.5.29.14", "subjectKeyIdentifier")
	ye("2.5.29.15", "keyUsage")
	Zr("2.5.29.16", "privateKeyUsagePeriod")
	ye("2.5.29.17", "subjectAltName")
	ye("2.5.29.18", "issuerAltName")
	ye("2.5.29.19", "basicConstraints")
	Zr("2.5.29.20", "cRLNumber")
	Zr("2.5.29.21", "cRLReason")
	Zr("2.5.29.22", "expirationDate")
	Zr("2.5.29.23", "instructionCode")
	Zr("2.5.29.24", "invalidityDate")
	Zr("2.5.29.25", "cRLDistributionPoints")
	Zr("2.5.29.26", "issuingDistributionPoint")
	Zr("2.5.29.27", "deltaCRLIndicator")
	Zr("2.5.29.28", "issuingDistributionPoint")
	Zr("2.5.29.29", "certificateIssuer")
	Zr("2.5.29.30", "nameConstraints")
	ye("2.5.29.31", "cRLDistributionPoints")
	ye("2.5.29.32", "certificatePolicies")
	Zr("2.5.29.33", "policyMappings")
	Zr("2.5.29.34", "policyConstraints")
	ye("2.5.29.35", "authorityKeyIdentifier")
	Zr("2.5.29.36", "policyConstraints")
	ye("2.5.29.37", "extKeyUsage")
	Zr("2.5.29.46", "freshestCRL")
	Zr("2.5.29.54", "inhibitAnyPolicy")
	ye("1.3.6.1.4.1.11129.2.4.2", "timestampList")
	ye("1.3.6.1.5.5.7.1.1", "authorityInfoAccess")
	ye("1.3.6.1.5.5.7.3.1", "serverAuth")
	ye("1.3.6.1.5.5.7.3.2", "clientAuth")
	ye("1.3.6.1.5.5.7.3.3", "codeSigning")
	ye("1.3.6.1.5.5.7.3.4", "emailProtection")
	ye("1.3.6.1.5.5.7.3.8", "timeStamping")
})
var gc = x((qSt, ule) => {
	"use strict"
	var _n = Yt()
	Sr()
	dh()
	var ke = (ule.exports = _n.asn1 = _n.asn1 || {})
	ke.Class = {
		UNIVERSAL: 0,
		APPLICATION: 64,
		CONTEXT_SPECIFIC: 128,
		PRIVATE: 192,
	}
	ke.Type = {
		NONE: 0,
		BOOLEAN: 1,
		INTEGER: 2,
		BITSTRING: 3,
		OCTETSTRING: 4,
		NULL: 5,
		OID: 6,
		ODESC: 7,
		EXTERNAL: 8,
		REAL: 9,
		ENUMERATED: 10,
		EMBEDDED: 11,
		UTF8: 12,
		ROID: 13,
		SEQUENCE: 16,
		SET: 17,
		PRINTABLESTRING: 19,
		IA5STRING: 22,
		UTCTIME: 23,
		GENERALIZEDTIME: 24,
		BMPSTRING: 30,
	}
	ke.create = function (e, t, r, n, i) {
		if (_n.util.isArray(n)) {
			for (var s = [], o = 0; o < n.length; ++o) n[o] !== void 0 && s.push(n[o])
			n = s
		}
		var a = {
			tagClass: e,
			type: t,
			constructed: r,
			composed: r || _n.util.isArray(n),
			value: n,
		}
		return (
			i && "bitStringContents" in i && ((a.bitStringContents = i.bitStringContents), (a.original = ke.copy(a))), a
		)
	}
	ke.copy = function (e, t) {
		var r
		if (_n.util.isArray(e)) {
			r = []
			for (var n = 0; n < e.length; ++n) r.push(ke.copy(e[n], t))
			return r
		}
		return typeof e == "string"
			? e
			: ((r = {
					tagClass: e.tagClass,
					type: e.type,
					constructed: e.constructed,
					composed: e.composed,
					value: ke.copy(e.value, t),
				}),
				t && !t.excludeBitStringContents && (r.bitStringContents = e.bitStringContents),
				r)
	}
	ke.equals = function (e, t, r) {
		if (_n.util.isArray(e)) {
			if (!_n.util.isArray(t) || e.length !== t.length) return !1
			for (var n = 0; n < e.length; ++n) if (!ke.equals(e[n], t[n])) return !1
			return !0
		}
		if (typeof e != typeof t) return !1
		if (typeof e == "string") return e === t
		var i =
			e.tagClass === t.tagClass &&
			e.type === t.type &&
			e.constructed === t.constructed &&
			e.composed === t.composed &&
			ke.equals(e.value, t.value)
		return r && r.includeBitStringContents && (i = i && e.bitStringContents === t.bitStringContents), i
	}
	ke.getBerValueLength = function (e) {
		var t = e.getByte()
		if (t !== 128) {
			var r,
				n = t & 128
			return n ? (r = e.getInt((t & 127) << 3)) : (r = t), r
		}
	}
	function Ib(e, t, r) {
		if (r > t) {
			var n = new Error("Too few bytes to parse DER.")
			throw ((n.available = e.length()), (n.remaining = t), (n.requested = r), n)
		}
	}
	var Nje = function (e, t) {
		var r = e.getByte()
		if ((t--, r !== 128)) {
			var n,
				i = r & 128
			if (!i) n = r
			else {
				var s = r & 127
				Ib(e, t, s), (n = e.getInt(s << 3))
			}
			if (n < 0) throw new Error("Negative length: " + n)
			return n
		}
	}
	ke.fromDer = function (e, t) {
		t === void 0 && (t = { strict: !0, parseAllBytes: !0, decodeBitStrings: !0 }),
			typeof t == "boolean" && (t = { strict: t, parseAllBytes: !0, decodeBitStrings: !0 }),
			"strict" in t || (t.strict = !0),
			"parseAllBytes" in t || (t.parseAllBytes = !0),
			"decodeBitStrings" in t || (t.decodeBitStrings = !0),
			typeof e == "string" && (e = _n.util.createBuffer(e))
		var r = e.length(),
			n = oT(e, e.length(), 0, t)
		if (t.parseAllBytes && e.length() !== 0) {
			var i = new Error("Unparsed DER bytes remain after ASN.1 parsing.")
			throw ((i.byteCount = r), (i.remaining = e.length()), i)
		}
		return n
	}
	function oT(e, t, r, n) {
		var i
		Ib(e, t, 2)
		var s = e.getByte()
		t--
		var o = s & 192,
			a = s & 31
		i = e.length()
		var l = Nje(e, t)
		if (((t -= i - e.length()), l !== void 0 && l > t)) {
			if (n.strict) {
				var c = new Error("Too few bytes to read ASN.1 value.")
				throw ((c.available = e.length()), (c.remaining = t), (c.requested = l), c)
			}
			l = t
		}
		var u,
			f,
			p = (s & 32) === 32
		if (p)
			if (((u = []), l === void 0))
				for (;;) {
					if ((Ib(e, t, 2), e.bytes(2) === "\0\0")) {
						e.getBytes(2), (t -= 2)
						break
					}
					;(i = e.length()), u.push(oT(e, t, r + 1, n)), (t -= i - e.length())
				}
			else
				for (; l > 0; )
					(i = e.length()), u.push(oT(e, l, r + 1, n)), (t -= i - e.length()), (l -= i - e.length())
		if (
			(u === void 0 && o === ke.Class.UNIVERSAL && a === ke.Type.BITSTRING && (f = e.bytes(l)),
			u === void 0 && n.decodeBitStrings && o === ke.Class.UNIVERSAL && a === ke.Type.BITSTRING && l > 1)
		) {
			var g = e.read,
				m = t,
				y = 0
			if ((a === ke.Type.BITSTRING && (Ib(e, t, 1), (y = e.getByte()), t--), y === 0))
				try {
					i = e.length()
					var C = { strict: !0, decodeBitStrings: !0 },
						v = oT(e, t, r + 1, C),
						b = i - e.length()
					;(t -= b), a == ke.Type.BITSTRING && b++
					var w = v.tagClass
					b === l && (w === ke.Class.UNIVERSAL || w === ke.Class.CONTEXT_SPECIFIC) && (u = [v])
				} catch {}
			u === void 0 && ((e.read = g), (t = m))
		}
		if (u === void 0) {
			if (l === void 0) {
				if (n.strict) throw new Error("Non-constructed ASN.1 object of indefinite length.")
				l = t
			}
			if (a === ke.Type.BMPSTRING)
				for (u = ""; l > 0; l -= 2) Ib(e, t, 2), (u += String.fromCharCode(e.getInt16())), (t -= 2)
			else (u = e.getBytes(l)), (t -= l)
		}
		var B = f === void 0 ? null : { bitStringContents: f }
		return ke.create(o, a, p, u, B)
	}
	ke.toDer = function (e) {
		var t = _n.util.createBuffer(),
			r = e.tagClass | e.type,
			n = _n.util.createBuffer(),
			i = !1
		if (("bitStringContents" in e && ((i = !0), e.original && (i = ke.equals(e, e.original))), i))
			n.putBytes(e.bitStringContents)
		else if (e.composed) {
			e.constructed ? (r |= 32) : n.putByte(0)
			for (var s = 0; s < e.value.length; ++s) e.value[s] !== void 0 && n.putBuffer(ke.toDer(e.value[s]))
		} else if (e.type === ke.Type.BMPSTRING)
			for (var s = 0; s < e.value.length; ++s) n.putInt16(e.value.charCodeAt(s))
		else
			e.type === ke.Type.INTEGER &&
			e.value.length > 1 &&
			((e.value.charCodeAt(0) === 0 && !(e.value.charCodeAt(1) & 128)) ||
				(e.value.charCodeAt(0) === 255 && (e.value.charCodeAt(1) & 128) === 128))
				? n.putBytes(e.value.substr(1))
				: n.putBytes(e.value)
		if ((t.putByte(r), n.length() <= 127)) t.putByte(n.length() & 127)
		else {
			var o = n.length(),
				a = ""
			do (a += String.fromCharCode(o & 255)), (o = o >>> 8)
			while (o > 0)
			t.putByte(a.length | 128)
			for (var s = a.length - 1; s >= 0; --s) t.putByte(a.charCodeAt(s))
		}
		return t.putBuffer(n), t
	}
	ke.oidToDer = function (e) {
		var t = e.split("."),
			r = _n.util.createBuffer()
		r.putByte(40 * parseInt(t[0], 10) + parseInt(t[1], 10))
		for (var n, i, s, o, a = 2; a < t.length; ++a) {
			;(n = !0), (i = []), (s = parseInt(t[a], 10))
			do (o = s & 127), (s = s >>> 7), n || (o |= 128), i.push(o), (n = !1)
			while (s > 0)
			for (var l = i.length - 1; l >= 0; --l) r.putByte(i[l])
		}
		return r
	}
	ke.derToOid = function (e) {
		var t
		typeof e == "string" && (e = _n.util.createBuffer(e))
		var r = e.getByte()
		t = Math.floor(r / 40) + "." + (r % 40)
		for (var n = 0; e.length() > 0; )
			(r = e.getByte()), (n = n << 7), r & 128 ? (n += r & 127) : ((t += "." + (n + r)), (n = 0))
		return t
	}
	ke.utcTimeToDate = function (e) {
		var t = new Date(),
			r = parseInt(e.substr(0, 2), 10)
		r = r >= 50 ? 1900 + r : 2e3 + r
		var n = parseInt(e.substr(2, 2), 10) - 1,
			i = parseInt(e.substr(4, 2), 10),
			s = parseInt(e.substr(6, 2), 10),
			o = parseInt(e.substr(8, 2), 10),
			a = 0
		if (e.length > 11) {
			var l = e.charAt(10),
				c = 10
			l !== "+" && l !== "-" && ((a = parseInt(e.substr(10, 2), 10)), (c += 2))
		}
		if ((t.setUTCFullYear(r, n, i), t.setUTCHours(s, o, a, 0), c && ((l = e.charAt(c)), l === "+" || l === "-"))) {
			var u = parseInt(e.substr(c + 1, 2), 10),
				f = parseInt(e.substr(c + 4, 2), 10),
				p = u * 60 + f
			;(p *= 6e4), l === "+" ? t.setTime(+t - p) : t.setTime(+t + p)
		}
		return t
	}
	ke.generalizedTimeToDate = function (e) {
		var t = new Date(),
			r = parseInt(e.substr(0, 4), 10),
			n = parseInt(e.substr(4, 2), 10) - 1,
			i = parseInt(e.substr(6, 2), 10),
			s = parseInt(e.substr(8, 2), 10),
			o = parseInt(e.substr(10, 2), 10),
			a = parseInt(e.substr(12, 2), 10),
			l = 0,
			c = 0,
			u = !1
		e.charAt(e.length - 1) === "Z" && (u = !0)
		var f = e.length - 5,
			p = e.charAt(f)
		if (p === "+" || p === "-") {
			var g = parseInt(e.substr(f + 1, 2), 10),
				m = parseInt(e.substr(f + 4, 2), 10)
			;(c = g * 60 + m), (c *= 6e4), p === "+" && (c *= -1), (u = !0)
		}
		return (
			e.charAt(14) === "." && (l = parseFloat(e.substr(14), 10) * 1e3),
			u
				? (t.setUTCFullYear(r, n, i), t.setUTCHours(s, o, a, l), t.setTime(+t + c))
				: (t.setFullYear(r, n, i), t.setHours(s, o, a, l)),
			t
		)
	}
	ke.dateToUtcTime = function (e) {
		if (typeof e == "string") return e
		var t = "",
			r = []
		r.push(("" + e.getUTCFullYear()).substr(2)),
			r.push("" + (e.getUTCMonth() + 1)),
			r.push("" + e.getUTCDate()),
			r.push("" + e.getUTCHours()),
			r.push("" + e.getUTCMinutes()),
			r.push("" + e.getUTCSeconds())
		for (var n = 0; n < r.length; ++n) r[n].length < 2 && (t += "0"), (t += r[n])
		return (t += "Z"), t
	}
	ke.dateToGeneralizedTime = function (e) {
		if (typeof e == "string") return e
		var t = "",
			r = []
		r.push("" + e.getUTCFullYear()),
			r.push("" + (e.getUTCMonth() + 1)),
			r.push("" + e.getUTCDate()),
			r.push("" + e.getUTCHours()),
			r.push("" + e.getUTCMinutes()),
			r.push("" + e.getUTCSeconds())
		for (var n = 0; n < r.length; ++n) r[n].length < 2 && (t += "0"), (t += r[n])
		return (t += "Z"), t
	}
	ke.integerToDer = function (e) {
		var t = _n.util.createBuffer()
		if (e >= -128 && e < 128) return t.putSignedInt(e, 8)
		if (e >= -32768 && e < 32768) return t.putSignedInt(e, 16)
		if (e >= -8388608 && e < 8388608) return t.putSignedInt(e, 24)
		if (e >= -2147483648 && e < 2147483648) return t.putSignedInt(e, 32)
		var r = new Error("Integer too large; max is 32-bits.")
		throw ((r.integer = e), r)
	}
	ke.derToInteger = function (e) {
		typeof e == "string" && (e = _n.util.createBuffer(e))
		var t = e.length() * 8
		if (t > 32) throw new Error("Integer too large; max is 32-bits.")
		return e.getSignedInt(t)
	}
	ke.validate = function (e, t, r, n) {
		var i = !1
		if ((e.tagClass === t.tagClass || typeof t.tagClass > "u") && (e.type === t.type || typeof t.type > "u"))
			if (e.constructed === t.constructed || typeof t.constructed > "u") {
				if (((i = !0), t.value && _n.util.isArray(t.value)))
					for (var s = 0, o = 0; i && o < t.value.length; ++o)
						(i = t.value[o].optional || !1),
							e.value[s] &&
								((i = ke.validate(e.value[s], t.value[o], r, n)),
								i ? ++s : t.value[o].optional && (i = !0)),
							!i &&
								n &&
								n.push(
									"[" +
										t.name +
										'] Tag class "' +
										t.tagClass +
										'", type "' +
										t.type +
										'" expected value length "' +
										t.value.length +
										'", got "' +
										e.value.length +
										'"',
								)
				if (
					i &&
					r &&
					(t.capture && (r[t.capture] = e.value),
					t.captureAsn1 && (r[t.captureAsn1] = e),
					t.captureBitStringContents &&
						"bitStringContents" in e &&
						(r[t.captureBitStringContents] = e.bitStringContents),
					t.captureBitStringValue && "bitStringContents" in e)
				) {
					var a
					if (e.bitStringContents.length < 2) r[t.captureBitStringValue] = ""
					else {
						var l = e.bitStringContents.charCodeAt(0)
						if (l !== 0) throw new Error("captureBitStringValue only supported for zero unused bits")
						r[t.captureBitStringValue] = e.bitStringContents.slice(1)
					}
				}
			} else
				n &&
					n.push("[" + t.name + '] Expected constructed "' + t.constructed + '", got "' + e.constructed + '"')
		else
			n &&
				(e.tagClass !== t.tagClass &&
					n.push("[" + t.name + '] Expected tag class "' + t.tagClass + '", got "' + e.tagClass + '"'),
				e.type !== t.type && n.push("[" + t.name + '] Expected type "' + t.type + '", got "' + e.type + '"'))
		return i
	}
	var cle = /[^\\u0000-\\u00ff]/
	ke.prettyPrint = function (e, t, r) {
		var n = ""
		;(t = t || 0),
			(r = r || 2),
			t > 0 &&
				(n += `
`)
		for (var i = "", s = 0; s < t * r; ++s) i += " "
		switch (((n += i + "Tag: "), e.tagClass)) {
			case ke.Class.UNIVERSAL:
				n += "Universal:"
				break
			case ke.Class.APPLICATION:
				n += "Application:"
				break
			case ke.Class.CONTEXT_SPECIFIC:
				n += "Context-Specific:"
				break
			case ke.Class.PRIVATE:
				n += "Private:"
				break
		}
		if (e.tagClass === ke.Class.UNIVERSAL)
			switch (((n += e.type), e.type)) {
				case ke.Type.NONE:
					n += " (None)"
					break
				case ke.Type.BOOLEAN:
					n += " (Boolean)"
					break
				case ke.Type.INTEGER:
					n += " (Integer)"
					break
				case ke.Type.BITSTRING:
					n += " (Bit string)"
					break
				case ke.Type.OCTETSTRING:
					n += " (Octet string)"
					break
				case ke.Type.NULL:
					n += " (Null)"
					break
				case ke.Type.OID:
					n += " (Object Identifier)"
					break
				case ke.Type.ODESC:
					n += " (Object Descriptor)"
					break
				case ke.Type.EXTERNAL:
					n += " (External or Instance of)"
					break
				case ke.Type.REAL:
					n += " (Real)"
					break
				case ke.Type.ENUMERATED:
					n += " (Enumerated)"
					break
				case ke.Type.EMBEDDED:
					n += " (Embedded PDV)"
					break
				case ke.Type.UTF8:
					n += " (UTF8)"
					break
				case ke.Type.ROID:
					n += " (Relative Object Identifier)"
					break
				case ke.Type.SEQUENCE:
					n += " (Sequence)"
					break
				case ke.Type.SET:
					n += " (Set)"
					break
				case ke.Type.PRINTABLESTRING:
					n += " (Printable String)"
					break
				case ke.Type.IA5String:
					n += " (IA5String (ASCII))"
					break
				case ke.Type.UTCTIME:
					n += " (UTC time)"
					break
				case ke.Type.GENERALIZEDTIME:
					n += " (Generalized time)"
					break
				case ke.Type.BMPSTRING:
					n += " (BMP String)"
					break
			}
		else n += e.type
		if (
			((n += `
`),
			(n +=
				i +
				"Constructed: " +
				e.constructed +
				`
`),
			e.composed)
		) {
			for (var o = 0, a = "", s = 0; s < e.value.length; ++s)
				e.value[s] !== void 0 &&
					((o += 1), (a += ke.prettyPrint(e.value[s], t + 1, r)), s + 1 < e.value.length && (a += ","))
			n += i + "Sub values: " + o + a
		} else {
			if (((n += i + "Value: "), e.type === ke.Type.OID)) {
				var l = ke.derToOid(e.value)
				;(n += l), _n.pki && _n.pki.oids && l in _n.pki.oids && (n += " (" + _n.pki.oids[l] + ") ")
			}
			if (e.type === ke.Type.INTEGER)
				try {
					n += ke.derToInteger(e.value)
				} catch {
					n += "0x" + _n.util.bytesToHex(e.value)
				}
			else if (e.type === ke.Type.BITSTRING) {
				if (
					(e.value.length > 1 ? (n += "0x" + _n.util.bytesToHex(e.value.slice(1))) : (n += "(none)"),
					e.value.length > 0)
				) {
					var c = e.value.charCodeAt(0)
					c == 1 ? (n += " (1 unused bit shown)") : c > 1 && (n += " (" + c + " unused bits shown)")
				}
			} else if (e.type === ke.Type.OCTETSTRING)
				cle.test(e.value) || (n += "(" + e.value + ") "), (n += "0x" + _n.util.bytesToHex(e.value))
			else if (e.type === ke.Type.UTF8)
				try {
					n += _n.util.decodeUtf8(e.value)
				} catch (u) {
					if (u.message === "URI malformed") n += "0x" + _n.util.bytesToHex(e.value) + " (malformed UTF8)"
					else throw u
				}
			else
				e.type === ke.Type.PRINTABLESTRING || e.type === ke.Type.IA5String
					? (n += e.value)
					: cle.test(e.value)
						? (n += "0x" + _n.util.bytesToHex(e.value))
						: e.value.length === 0
							? (n += "[null]")
							: (n += e.value)
		}
		return n
	}
})
var du = x((VSt, dle) => {
	"use strict"
	var aT = Yt()
	dle.exports = aT.md = aT.md || {}
	aT.md.algorithms = aT.md.algorithms || {}
})
var O0 = x((HSt, fle) => {
	"use strict"
	var Pd = Yt()
	du()
	Sr()
	var Pje = (fle.exports = Pd.hmac = Pd.hmac || {})
	Pje.create = function () {
		var e = null,
			t = null,
			r = null,
			n = null,
			i = {}
		return (
			(i.start = function (s, o) {
				if (s !== null)
					if (typeof s == "string")
						if (((s = s.toLowerCase()), s in Pd.md.algorithms)) t = Pd.md.algorithms[s].create()
						else throw new Error('Unknown hash algorithm "' + s + '"')
					else t = s
				if (o === null) o = e
				else {
					if (typeof o == "string") o = Pd.util.createBuffer(o)
					else if (Pd.util.isArray(o)) {
						var a = o
						o = Pd.util.createBuffer()
						for (var l = 0; l < a.length; ++l) o.putByte(a[l])
					}
					var c = o.length()
					c > t.blockLength && (t.start(), t.update(o.bytes()), (o = t.digest())),
						(r = Pd.util.createBuffer()),
						(n = Pd.util.createBuffer()),
						(c = o.length())
					for (var l = 0; l < c; ++l) {
						var a = o.at(l)
						r.putByte(54 ^ a), n.putByte(92 ^ a)
					}
					if (c < t.blockLength)
						for (var a = t.blockLength - c, l = 0; l < a; ++l) r.putByte(54), n.putByte(92)
					;(e = o), (r = r.bytes()), (n = n.bytes())
				}
				t.start(), t.update(r)
			}),
			(i.update = function (s) {
				t.update(s)
			}),
			(i.getMac = function () {
				var s = t.digest().bytes()
				return t.start(), t.update(n), t.update(s), t.digest()
			}),
			(i.digest = i.getMac),
			i
		)
	}
})
var cT = x((WSt, Ale) => {
	"use strict"
	var fu = Yt()
	du()
	Sr()
	var gle = (Ale.exports = fu.md5 = fu.md5 || {})
	fu.md.md5 = fu.md.algorithms.md5 = gle
	gle.create = function () {
		ple || Lje()
		var e = null,
			t = fu.util.createBuffer(),
			r = new Array(16),
			n = {
				algorithm: "md5",
				blockLength: 64,
				digestLength: 16,
				messageLength: 0,
				fullMessageLength: null,
				messageLengthSize: 8,
			}
		return (
			(n.start = function () {
				;(n.messageLength = 0), (n.fullMessageLength = n.messageLength64 = [])
				for (var i = n.messageLengthSize / 4, s = 0; s < i; ++s) n.fullMessageLength.push(0)
				return (
					(t = fu.util.createBuffer()),
					(e = {
						h0: 1732584193,
						h1: 4023233417,
						h2: 2562383102,
						h3: 271733878,
					}),
					n
				)
			}),
			n.start(),
			(n.update = function (i, s) {
				s === "utf8" && (i = fu.util.encodeUtf8(i))
				var o = i.length
				;(n.messageLength += o), (o = [(o / 4294967296) >>> 0, o >>> 0])
				for (var a = n.fullMessageLength.length - 1; a >= 0; --a)
					(n.fullMessageLength[a] += o[1]),
						(o[1] = o[0] + ((n.fullMessageLength[a] / 4294967296) >>> 0)),
						(n.fullMessageLength[a] = n.fullMessageLength[a] >>> 0),
						(o[0] = (o[1] / 4294967296) >>> 0)
				return t.putBytes(i), hle(e, r, t), (t.read > 2048 || t.length() === 0) && t.compact(), n
			}),
			(n.digest = function () {
				var i = fu.util.createBuffer()
				i.putBytes(t.bytes())
				var s = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize,
					o = s & (n.blockLength - 1)
				i.putBytes(m5.substr(0, n.blockLength - o))
				for (var a, l = 0, c = n.fullMessageLength.length - 1; c >= 0; --c)
					(a = n.fullMessageLength[c] * 8 + l), (l = (a / 4294967296) >>> 0), i.putInt32Le(a >>> 0)
				var u = { h0: e.h0, h1: e.h1, h2: e.h2, h3: e.h3 }
				hle(u, r, i)
				var f = fu.util.createBuffer()
				return f.putInt32Le(u.h0), f.putInt32Le(u.h1), f.putInt32Le(u.h2), f.putInt32Le(u.h3), f
			}),
			n
		)
	}
	var m5 = null,
		lT = null,
		Sb = null,
		q0 = null,
		ple = !1
	function Lje() {
		;(m5 = "\x80"),
			(m5 += fu.util.fillString("\0", 64)),
			(lT = [
				0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7,
				12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4,
				11, 2, 9,
			]),
			(Sb = [
				7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5,
				9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6,
				10, 15, 21, 6, 10, 15, 21,
			]),
			(q0 = new Array(64))
		for (var e = 0; e < 64; ++e) q0[e] = Math.floor(Math.abs(Math.sin(e + 1)) * 4294967296)
		ple = !0
	}
	function hle(e, t, r) {
		for (var n, i, s, o, a, l, c, u, f = r.length(); f >= 64; ) {
			for (i = e.h0, s = e.h1, o = e.h2, a = e.h3, u = 0; u < 16; ++u)
				(t[u] = r.getInt32Le()),
					(l = a ^ (s & (o ^ a))),
					(n = i + l + q0[u] + t[u]),
					(c = Sb[u]),
					(i = a),
					(a = o),
					(o = s),
					(s += (n << c) | (n >>> (32 - c)))
			for (; u < 32; ++u)
				(l = o ^ (a & (s ^ o))),
					(n = i + l + q0[u] + t[lT[u]]),
					(c = Sb[u]),
					(i = a),
					(a = o),
					(o = s),
					(s += (n << c) | (n >>> (32 - c)))
			for (; u < 48; ++u)
				(l = s ^ o ^ a),
					(n = i + l + q0[u] + t[lT[u]]),
					(c = Sb[u]),
					(i = a),
					(a = o),
					(o = s),
					(s += (n << c) | (n >>> (32 - c)))
			for (; u < 64; ++u)
				(l = o ^ (s | ~a)),
					(n = i + l + q0[u] + t[lT[u]]),
					(c = Sb[u]),
					(i = a),
					(a = o),
					(o = s),
					(s += (n << c) | (n >>> (32 - c)))
			;(e.h0 = (e.h0 + i) | 0),
				(e.h1 = (e.h1 + s) | 0),
				(e.h2 = (e.h2 + o) | 0),
				(e.h3 = (e.h3 + a) | 0),
				(f -= 64)
		}
	}
})
var _p = x((GSt, yle) => {
	"use strict"
	var dT = Yt()
	Sr()
	var mle = (yle.exports = dT.pem = dT.pem || {})
	mle.encode = function (e, t) {
		t = t || {}
		var r =
				"-----BEGIN " +
				e.type +
				`-----\r
`,
			n
		if (
			(e.procType &&
				((n = {
					name: "Proc-Type",
					values: [String(e.procType.version), e.procType.type],
				}),
				(r += uT(n))),
			e.contentDomain && ((n = { name: "Content-Domain", values: [e.contentDomain] }), (r += uT(n))),
			e.dekInfo &&
				((n = { name: "DEK-Info", values: [e.dekInfo.algorithm] }),
				e.dekInfo.parameters && n.values.push(e.dekInfo.parameters),
				(r += uT(n))),
			e.headers)
		)
			for (var i = 0; i < e.headers.length; ++i) r += uT(e.headers[i])
		return (
			e.procType &&
				(r += `\r
`),
			(r +=
				dT.util.encode64(e.body, t.maxline || 64) +
				`\r
`),
			(r +=
				"-----END " +
				e.type +
				`-----\r
`),
			r
		)
	}
	mle.decode = function (e) {
		for (
			var t = [],
				r =
					/\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,
				n = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,
				i = /\r?\n/,
				s;
			(s = r.exec(e)), !!s;

		) {
			var o = s[1]
			o === "NEW CERTIFICATE REQUEST" && (o = "CERTIFICATE REQUEST")
			var a = {
				type: o,
				procType: null,
				contentDomain: null,
				dekInfo: null,
				headers: [],
				body: dT.util.decode64(s[3]),
			}
			if ((t.push(a), !!s[2])) {
				for (var l = s[2].split(i), c = 0; s && c < l.length; ) {
					for (var u = l[c].replace(/\s+$/, ""), f = c + 1; f < l.length; ++f) {
						var p = l[f]
						if (!/\s/.test(p[0])) break
						;(u += p), (c = f)
					}
					if (((s = u.match(n)), s)) {
						for (var g = { name: s[1], values: [] }, m = s[2].split(","), y = 0; y < m.length; ++y)
							g.values.push(Uje(m[y]))
						if (a.procType)
							if (!a.contentDomain && g.name === "Content-Domain") a.contentDomain = m[0] || ""
							else if (!a.dekInfo && g.name === "DEK-Info") {
								if (g.values.length === 0)
									throw new Error(
										'Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.',
									)
								a.dekInfo = { algorithm: m[0], parameters: m[1] || null }
							} else a.headers.push(g)
						else {
							if (g.name !== "Proc-Type")
								throw new Error(
									'Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".',
								)
							if (g.values.length !== 2)
								throw new Error(
									'Invalid PEM formatted message. The "Proc-Type" header must have two subfields.',
								)
							a.procType = { version: m[0], type: m[1] }
						}
					}
					++c
				}
				if (a.procType === "ENCRYPTED" && !a.dekInfo)
					throw new Error(
						'Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".',
					)
			}
		}
		if (t.length === 0) throw new Error("Invalid PEM formatted message.")
		return t
	}
	function uT(e) {
		for (
			var t = e.name + ": ",
				r = [],
				n = function (l, c) {
					return " " + c
				},
				i = 0;
			i < e.values.length;
			++i
		)
			r.push(e.values[i].replace(/^(\S+\r\n)/, n))
		t +=
			r.join(",") +
			`\r
`
		for (var s = 0, o = -1, i = 0; i < t.length; ++i, ++s)
			if (s > 65 && o !== -1) {
				var a = t[o]
				a === ","
					? (++o,
						(t =
							t.substr(0, o) +
							`\r
 ` +
							t.substr(o)))
					: (t =
							t.substr(0, o) +
							`\r
` +
							a +
							t.substr(o + 1)),
					(s = i - o - 1),
					(o = -1),
					++i
			} else (t[i] === " " || t[i] === "	" || t[i] === ",") && (o = i)
		return t
	}
	function Uje(e) {
		return e.replace(/^\s+/, "")
	}
})
var Bb = x(($St, vle) => {
	"use strict"
	var Nn = Yt()
	rT()
	f5()
	Sr()
	vle.exports = Nn.des = Nn.des || {}
	Nn.des.startEncrypting = function (e, t, r, n) {
		var i = fT({
			key: e,
			output: r,
			decrypt: !1,
			mode: n || (t === null ? "ECB" : "CBC"),
		})
		return i.start(t), i
	}
	Nn.des.createEncryptionCipher = function (e, t) {
		return fT({ key: e, output: null, decrypt: !1, mode: t })
	}
	Nn.des.startDecrypting = function (e, t, r, n) {
		var i = fT({
			key: e,
			output: r,
			decrypt: !0,
			mode: n || (t === null ? "ECB" : "CBC"),
		})
		return i.start(t), i
	}
	Nn.des.createDecryptionCipher = function (e, t) {
		return fT({ key: e, output: null, decrypt: !0, mode: t })
	}
	Nn.des.Algorithm = function (e, t) {
		var r = this
		;(r.name = e),
			(r.mode = new t({
				blockSize: 8,
				cipher: {
					encrypt: function (n, i) {
						return Cle(r._keys, n, i, !1)
					},
					decrypt: function (n, i) {
						return Cle(r._keys, n, i, !0)
					},
				},
			})),
			(r._init = !1)
	}
	Nn.des.Algorithm.prototype.initialize = function (e) {
		if (!this._init) {
			var t = Nn.util.createBuffer(e.key)
			if (this.name.indexOf("3DES") === 0 && t.length() !== 24)
				throw new Error("Invalid Triple-DES key size: " + t.length() * 8)
			;(this._keys = Kje(t)), (this._init = !0)
		}
	}
	hu("DES-ECB", Nn.cipher.modes.ecb)
	hu("DES-CBC", Nn.cipher.modes.cbc)
	hu("DES-CFB", Nn.cipher.modes.cfb)
	hu("DES-OFB", Nn.cipher.modes.ofb)
	hu("DES-CTR", Nn.cipher.modes.ctr)
	hu("3DES-ECB", Nn.cipher.modes.ecb)
	hu("3DES-CBC", Nn.cipher.modes.cbc)
	hu("3DES-CFB", Nn.cipher.modes.cfb)
	hu("3DES-OFB", Nn.cipher.modes.ofb)
	hu("3DES-CTR", Nn.cipher.modes.ctr)
	function hu(e, t) {
		var r = function () {
			return new Nn.des.Algorithm(e, t)
		}
		Nn.cipher.registerAlgorithm(e, r)
	}
	var Oje = [
			16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756,
			16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220,
			16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024,
			16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220,
			1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756,
		],
		qje = [
			-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272,
			-2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0,
			-2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072,
			32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072,
			-2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616,
			1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040,
			-2146402272, 1081344,
		],
		Vje = [
			520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072,
			134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592,
			134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520,
			131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248,
			131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8,
			134348808, 131584,
		],
		Hje = [
			8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736,
			8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928,
			8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801,
			8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128,
			8388608, 8192, 8396928,
		],
		Wje = [
			256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688,
			1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080,
			1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256,
			524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688,
			1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256,
			1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112,
			34078976, 1073742080,
		],
		Gje = [
			536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304,
			536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16,
			541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232,
			4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616,
			4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320,
			536887312, 0, 541081600, 536870912, 4194320, 536887312,
		],
		$je = [
			2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2,
			67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154,
			69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914,
			67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064,
			2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912,
			2048, 2097154,
		],
		Yje = [
			268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760,
			266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664,
			268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64,
			268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0,
			268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160,
			262208, 268435456, 268701696,
		]
	function Kje(e) {
		for (
			var t = [
					0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428,
					66048, 66052, 536936960, 536936964,
				],
				r = [
					0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833,
					67109120, 67109121, 68157696, 68157697,
				],
				n = [
					0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224,
					16779264, 16779272,
				],
				i = [
					0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800,
					136445952, 139264, 2236416, 134356992, 136454144,
				],
				s = [
					0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112,
					266256,
				],
				o = [
					0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456,
					33554464, 33555488,
				],
				a = [
					0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744,
					2, 268435458, 524290, 268959746,
				],
				l = [
					0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656,
					537001984, 537067520, 537004032, 537069568,
				],
				c = [
					0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434,
					33816578, 33554434, 33816578,
				],
				u = [
					0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024,
					268436480, 1032, 268436488,
				],
				f = [
					0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768,
					1056800,
				],
				p = [
					0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376,
					83886592, 69206016, 85983232, 69206528, 85983744,
				],
				g = [
					0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840,
					524304, 528400, 134742032, 134746128,
				],
				m = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261],
				y = e.length() > 8 ? 3 : 1,
				C = [],
				v = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
				b = 0,
				w,
				B = 0;
			B < y;
			B++
		) {
			var M = e.getInt32(),
				Q = e.getInt32()
			;(w = ((M >>> 4) ^ Q) & 252645135),
				(Q ^= w),
				(M ^= w << 4),
				(w = ((Q >>> -16) ^ M) & 65535),
				(M ^= w),
				(Q ^= w << -16),
				(w = ((M >>> 2) ^ Q) & 858993459),
				(Q ^= w),
				(M ^= w << 2),
				(w = ((Q >>> -16) ^ M) & 65535),
				(M ^= w),
				(Q ^= w << -16),
				(w = ((M >>> 1) ^ Q) & 1431655765),
				(Q ^= w),
				(M ^= w << 1),
				(w = ((Q >>> 8) ^ M) & 16711935),
				(M ^= w),
				(Q ^= w << 8),
				(w = ((M >>> 1) ^ Q) & 1431655765),
				(Q ^= w),
				(M ^= w << 1),
				(w = (M << 8) | ((Q >>> 20) & 240)),
				(M = (Q << 24) | ((Q << 8) & 16711680) | ((Q >>> 8) & 65280) | ((Q >>> 24) & 240)),
				(Q = w)
			for (var O = 0; O < v.length; ++O) {
				v[O]
					? ((M = (M << 2) | (M >>> 26)), (Q = (Q << 2) | (Q >>> 26)))
					: ((M = (M << 1) | (M >>> 27)), (Q = (Q << 1) | (Q >>> 27))),
					(M &= -15),
					(Q &= -15)
				var Y =
						t[M >>> 28] |
						r[(M >>> 24) & 15] |
						n[(M >>> 20) & 15] |
						i[(M >>> 16) & 15] |
						s[(M >>> 12) & 15] |
						o[(M >>> 8) & 15] |
						a[(M >>> 4) & 15],
					j =
						l[Q >>> 28] |
						c[(Q >>> 24) & 15] |
						u[(Q >>> 20) & 15] |
						f[(Q >>> 16) & 15] |
						p[(Q >>> 12) & 15] |
						g[(Q >>> 8) & 15] |
						m[(Q >>> 4) & 15]
				;(w = ((j >>> 16) ^ Y) & 65535), (C[b++] = Y ^ w), (C[b++] = j ^ (w << 16))
			}
		}
		return C
	}
	function Cle(e, t, r, n) {
		var i = e.length === 32 ? 3 : 9,
			s
		i === 3
			? (s = n ? [30, -2, -2] : [0, 32, 2])
			: (s = n ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2])
		var o,
			a = t[0],
			l = t[1]
		;(o = ((a >>> 4) ^ l) & 252645135),
			(l ^= o),
			(a ^= o << 4),
			(o = ((a >>> 16) ^ l) & 65535),
			(l ^= o),
			(a ^= o << 16),
			(o = ((l >>> 2) ^ a) & 858993459),
			(a ^= o),
			(l ^= o << 2),
			(o = ((l >>> 8) ^ a) & 16711935),
			(a ^= o),
			(l ^= o << 8),
			(o = ((a >>> 1) ^ l) & 1431655765),
			(l ^= o),
			(a ^= o << 1),
			(a = (a << 1) | (a >>> 31)),
			(l = (l << 1) | (l >>> 31))
		for (var c = 0; c < i; c += 3) {
			for (var u = s[c + 1], f = s[c + 2], p = s[c]; p != u; p += f) {
				var g = l ^ e[p],
					m = ((l >>> 4) | (l << 28)) ^ e[p + 1]
				;(o = a),
					(a = l),
					(l =
						o ^
						(qje[(g >>> 24) & 63] |
							Hje[(g >>> 16) & 63] |
							Gje[(g >>> 8) & 63] |
							Yje[g & 63] |
							Oje[(m >>> 24) & 63] |
							Vje[(m >>> 16) & 63] |
							Wje[(m >>> 8) & 63] |
							$je[m & 63]))
			}
			;(o = a), (a = l), (l = o)
		}
		;(a = (a >>> 1) | (a << 31)),
			(l = (l >>> 1) | (l << 31)),
			(o = ((a >>> 1) ^ l) & 1431655765),
			(l ^= o),
			(a ^= o << 1),
			(o = ((l >>> 8) ^ a) & 16711935),
			(a ^= o),
			(l ^= o << 8),
			(o = ((l >>> 2) ^ a) & 858993459),
			(a ^= o),
			(l ^= o << 2),
			(o = ((a >>> 16) ^ l) & 65535),
			(l ^= o),
			(a ^= o << 16),
			(o = ((a >>> 4) ^ l) & 252645135),
			(l ^= o),
			(a ^= o << 4),
			(r[0] = a),
			(r[1] = l)
	}
	function fT(e) {
		e = e || {}
		var t = (e.mode || "CBC").toUpperCase(),
			r = "DES-" + t,
			n
		e.decrypt ? (n = Nn.cipher.createDecipher(r, e.key)) : (n = Nn.cipher.createCipher(r, e.key))
		var i = n.start
		return (
			(n.start = function (s, o) {
				var a = null
				o instanceof Nn.util.ByteBuffer && ((a = o), (o = {})),
					(o = o || {}),
					(o.output = a),
					(o.iv = s),
					i.call(n, o)
			}),
			n
		)
	}
})
var hT = x((YSt, Ele) => {
	"use strict"
	var oo = Yt()
	O0()
	du()
	Sr()
	var Jje = (oo.pkcs5 = oo.pkcs5 || {}),
		Ld
	oo.util.isNodejs && !oo.options.usePureJavaScript && (Ld = require("crypto"))
	Ele.exports =
		oo.pbkdf2 =
		Jje.pbkdf2 =
			function (e, t, r, n, i, s) {
				if (
					(typeof i == "function" && ((s = i), (i = null)),
					oo.util.isNodejs &&
						!oo.options.usePureJavaScript &&
						Ld.pbkdf2 &&
						(i === null || typeof i != "object") &&
						(Ld.pbkdf2Sync.length > 4 || !i || i === "sha1"))
				)
					return (
						typeof i != "string" && (i = "sha1"),
						(e = Buffer.from(e, "binary")),
						(t = Buffer.from(t, "binary")),
						s
							? Ld.pbkdf2Sync.length === 4
								? Ld.pbkdf2(e, t, r, n, function (w, B) {
										if (w) return s(w)
										s(null, B.toString("binary"))
									})
								: Ld.pbkdf2(e, t, r, n, i, function (w, B) {
										if (w) return s(w)
										s(null, B.toString("binary"))
									})
							: Ld.pbkdf2Sync.length === 4
								? Ld.pbkdf2Sync(e, t, r, n).toString("binary")
								: Ld.pbkdf2Sync(e, t, r, n, i).toString("binary")
					)
				if (((typeof i > "u" || i === null) && (i = "sha1"), typeof i == "string")) {
					if (!(i in oo.md.algorithms)) throw new Error("Unknown hash algorithm: " + i)
					i = oo.md[i].create()
				}
				var o = i.digestLength
				if (n > 4294967295 * o) {
					var a = new Error("Derived key is too long.")
					if (s) return s(a)
					throw a
				}
				var l = Math.ceil(n / o),
					c = n - (l - 1) * o,
					u = oo.hmac.create()
				u.start(i, e)
				var f = "",
					p,
					g,
					m
				if (!s) {
					for (var y = 1; y <= l; ++y) {
						u.start(null, null),
							u.update(t),
							u.update(oo.util.int32ToBytes(y)),
							(p = m = u.digest().getBytes())
						for (var C = 2; C <= r; ++C)
							u.start(null, null),
								u.update(m),
								(g = u.digest().getBytes()),
								(p = oo.util.xorBytes(p, g, o)),
								(m = g)
						f += y < l ? p : p.substr(0, c)
					}
					return f
				}
				var y = 1,
					C
				function v() {
					if (y > l) return s(null, f)
					u.start(null, null),
						u.update(t),
						u.update(oo.util.int32ToBytes(y)),
						(p = m = u.digest().getBytes()),
						(C = 2),
						b()
				}
				function b() {
					if (C <= r)
						return (
							u.start(null, null),
							u.update(m),
							(g = u.digest().getBytes()),
							(p = oo.util.xorBytes(p, g, o)),
							(m = g),
							++C,
							oo.util.setImmediate(b)
						)
					;(f += y < l ? p : p.substr(0, c)), ++y, v()
				}
				v()
			}
})
var C5 = x((KSt, Ile) => {
	"use strict"
	var gu = Yt()
	du()
	Sr()
	var xle = (Ile.exports = gu.sha256 = gu.sha256 || {})
	gu.md.sha256 = gu.md.algorithms.sha256 = xle
	xle.create = function () {
		_le || zje()
		var e = null,
			t = gu.util.createBuffer(),
			r = new Array(64),
			n = {
				algorithm: "sha256",
				blockLength: 64,
				digestLength: 32,
				messageLength: 0,
				fullMessageLength: null,
				messageLengthSize: 8,
			}
		return (
			(n.start = function () {
				;(n.messageLength = 0), (n.fullMessageLength = n.messageLength64 = [])
				for (var i = n.messageLengthSize / 4, s = 0; s < i; ++s) n.fullMessageLength.push(0)
				return (
					(t = gu.util.createBuffer()),
					(e = {
						h0: 1779033703,
						h1: 3144134277,
						h2: 1013904242,
						h3: 2773480762,
						h4: 1359893119,
						h5: 2600822924,
						h6: 528734635,
						h7: 1541459225,
					}),
					n
				)
			}),
			n.start(),
			(n.update = function (i, s) {
				s === "utf8" && (i = gu.util.encodeUtf8(i))
				var o = i.length
				;(n.messageLength += o), (o = [(o / 4294967296) >>> 0, o >>> 0])
				for (var a = n.fullMessageLength.length - 1; a >= 0; --a)
					(n.fullMessageLength[a] += o[1]),
						(o[1] = o[0] + ((n.fullMessageLength[a] / 4294967296) >>> 0)),
						(n.fullMessageLength[a] = n.fullMessageLength[a] >>> 0),
						(o[0] = (o[1] / 4294967296) >>> 0)
				return t.putBytes(i), ble(e, r, t), (t.read > 2048 || t.length() === 0) && t.compact(), n
			}),
			(n.digest = function () {
				var i = gu.util.createBuffer()
				i.putBytes(t.bytes())
				var s = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize,
					o = s & (n.blockLength - 1)
				i.putBytes(y5.substr(0, n.blockLength - o))
				for (var a, l, c = n.fullMessageLength[0] * 8, u = 0; u < n.fullMessageLength.length - 1; ++u)
					(a = n.fullMessageLength[u + 1] * 8),
						(l = (a / 4294967296) >>> 0),
						(c += l),
						i.putInt32(c >>> 0),
						(c = a >>> 0)
				i.putInt32(c)
				var f = {
					h0: e.h0,
					h1: e.h1,
					h2: e.h2,
					h3: e.h3,
					h4: e.h4,
					h5: e.h5,
					h6: e.h6,
					h7: e.h7,
				}
				ble(f, r, i)
				var p = gu.util.createBuffer()
				return (
					p.putInt32(f.h0),
					p.putInt32(f.h1),
					p.putInt32(f.h2),
					p.putInt32(f.h3),
					p.putInt32(f.h4),
					p.putInt32(f.h5),
					p.putInt32(f.h6),
					p.putInt32(f.h7),
					p
				)
			}),
			n
		)
	}
	var y5 = null,
		_le = !1,
		wle = null
	function zje() {
		;(y5 = "\x80"),
			(y5 += gu.util.fillString("\0", 64)),
			(wle = [
				1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221,
				3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
				3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882,
				2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912,
				1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
				3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556,
				883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452,
				2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
			]),
			(_le = !0)
	}
	function ble(e, t, r) {
		for (var n, i, s, o, a, l, c, u, f, p, g, m, y, C, v, b = r.length(); b >= 64; ) {
			for (c = 0; c < 16; ++c) t[c] = r.getInt32()
			for (; c < 64; ++c)
				(n = t[c - 2]),
					(n = ((n >>> 17) | (n << 15)) ^ ((n >>> 19) | (n << 13)) ^ (n >>> 10)),
					(i = t[c - 15]),
					(i = ((i >>> 7) | (i << 25)) ^ ((i >>> 18) | (i << 14)) ^ (i >>> 3)),
					(t[c] = (n + t[c - 7] + i + t[c - 16]) | 0)
			for (u = e.h0, f = e.h1, p = e.h2, g = e.h3, m = e.h4, y = e.h5, C = e.h6, v = e.h7, c = 0; c < 64; ++c)
				(o = ((m >>> 6) | (m << 26)) ^ ((m >>> 11) | (m << 21)) ^ ((m >>> 25) | (m << 7))),
					(a = C ^ (m & (y ^ C))),
					(s = ((u >>> 2) | (u << 30)) ^ ((u >>> 13) | (u << 19)) ^ ((u >>> 22) | (u << 10))),
					(l = (u & f) | (p & (u ^ f))),
					(n = v + o + a + wle[c] + t[c]),
					(i = s + l),
					(v = C),
					(C = y),
					(y = m),
					(m = (g + n) >>> 0),
					(g = p),
					(p = f),
					(f = u),
					(u = (n + i) >>> 0)
			;(e.h0 = (e.h0 + u) | 0),
				(e.h1 = (e.h1 + f) | 0),
				(e.h2 = (e.h2 + p) | 0),
				(e.h3 = (e.h3 + g) | 0),
				(e.h4 = (e.h4 + m) | 0),
				(e.h5 = (e.h5 + y) | 0),
				(e.h6 = (e.h6 + C) | 0),
				(e.h7 = (e.h7 + v) | 0),
				(b -= 64)
		}
	}
})
var v5 = x((JSt, Sle) => {
	"use strict"
	var pu = Yt()
	Sr()
	var gT = null
	pu.util.isNodejs && !pu.options.usePureJavaScript && !process.versions["node-webkit"] && (gT = require("crypto"))
	var jje = (Sle.exports = pu.prng = pu.prng || {})
	jje.create = function (e) {
		for (
			var t = {
					plugin: e,
					key: null,
					seed: null,
					time: null,
					reseeds: 0,
					generated: 0,
					keyBytes: "",
				},
				r = e.md,
				n = new Array(32),
				i = 0;
			i < 32;
			++i
		)
			n[i] = r.create()
		;(t.pools = n),
			(t.pool = 0),
			(t.generate = function (c, u) {
				if (!u) return t.generateSync(c)
				var f = t.plugin.cipher,
					p = t.plugin.increment,
					g = t.plugin.formatKey,
					m = t.plugin.formatSeed,
					y = pu.util.createBuffer()
				;(t.key = null), C()
				function C(v) {
					if (v) return u(v)
					if (y.length() >= c) return u(null, y.getBytes(c))
					if ((t.generated > 1048575 && (t.key = null), t.key === null))
						return pu.util.nextTick(function () {
							s(C)
						})
					var b = f(t.key, t.seed)
					;(t.generated += b.length),
						y.putBytes(b),
						(t.key = g(f(t.key, p(t.seed)))),
						(t.seed = m(f(t.key, t.seed))),
						pu.util.setImmediate(C)
				}
			}),
			(t.generateSync = function (c) {
				var u = t.plugin.cipher,
					f = t.plugin.increment,
					p = t.plugin.formatKey,
					g = t.plugin.formatSeed
				t.key = null
				for (var m = pu.util.createBuffer(); m.length() < c; ) {
					t.generated > 1048575 && (t.key = null), t.key === null && o()
					var y = u(t.key, t.seed)
					;(t.generated += y.length),
						m.putBytes(y),
						(t.key = p(u(t.key, f(t.seed)))),
						(t.seed = g(u(t.key, t.seed)))
				}
				return m.getBytes(c)
			})
		function s(c) {
			if (t.pools[0].messageLength >= 32) return a(), c()
			var u = (32 - t.pools[0].messageLength) << 5
			t.seedFile(u, function (f, p) {
				if (f) return c(f)
				t.collect(p), a(), c()
			})
		}
		function o() {
			if (t.pools[0].messageLength >= 32) return a()
			var c = (32 - t.pools[0].messageLength) << 5
			t.collect(t.seedFileSync(c)), a()
		}
		function a() {
			t.reseeds = t.reseeds === 4294967295 ? 0 : t.reseeds + 1
			var c = t.plugin.md.create()
			c.update(t.keyBytes)
			for (var u = 1, f = 0; f < 32; ++f)
				t.reseeds % u === 0 && (c.update(t.pools[f].digest().getBytes()), t.pools[f].start()), (u = u << 1)
			;(t.keyBytes = c.digest().getBytes()), c.start(), c.update(t.keyBytes)
			var p = c.digest().getBytes()
			;(t.key = t.plugin.formatKey(t.keyBytes)), (t.seed = t.plugin.formatSeed(p)), (t.generated = 0)
		}
		function l(c) {
			var u = null,
				f = pu.util.globalScope,
				p = f.crypto || f.msCrypto
			p &&
				p.getRandomValues &&
				(u = function (M) {
					return p.getRandomValues(M)
				})
			var g = pu.util.createBuffer()
			if (u)
				for (; g.length() < c; ) {
					var m = Math.max(1, Math.min(c - g.length(), 65536) / 4),
						y = new Uint32Array(Math.floor(m))
					try {
						u(y)
						for (var C = 0; C < y.length; ++C) g.putInt32(y[C])
					} catch (M) {
						if (!(typeof QuotaExceededError < "u" && M instanceof QuotaExceededError)) throw M
					}
				}
			if (g.length() < c)
				for (var v, b, w, B = Math.floor(Math.random() * 65536); g.length() < c; ) {
					;(b = 16807 * (B & 65535)),
						(v = 16807 * (B >> 16)),
						(b += (v & 32767) << 16),
						(b += v >> 15),
						(b = (b & 2147483647) + (b >> 31)),
						(B = b & 4294967295)
					for (var C = 0; C < 3; ++C)
						(w = B >>> (C << 3)), (w ^= Math.floor(Math.random() * 256)), g.putByte(w & 255)
				}
			return g.getBytes(c)
		}
		return (
			gT
				? ((t.seedFile = function (c, u) {
						gT.randomBytes(c, function (f, p) {
							if (f) return u(f)
							u(null, p.toString())
						})
					}),
					(t.seedFileSync = function (c) {
						return gT.randomBytes(c).toString()
					}))
				: ((t.seedFile = function (c, u) {
						try {
							u(null, l(c))
						} catch (f) {
							u(f)
						}
					}),
					(t.seedFileSync = l)),
			(t.collect = function (c) {
				for (var u = c.length, f = 0; f < u; ++f)
					t.pools[t.pool].update(c.substr(f, 1)), (t.pool = t.pool === 31 ? 0 : t.pool + 1)
			}),
			(t.collectInt = function (c, u) {
				for (var f = "", p = 0; p < u; p += 8) f += String.fromCharCode((c >> p) & 255)
				t.collect(f)
			}),
			(t.registerWorker = function (c) {
				if (c === self)
					t.seedFile = function (f, p) {
						function g(m) {
							var y = m.data
							y.forge &&
								y.forge.prng &&
								(self.removeEventListener("message", g), p(y.forge.prng.err, y.forge.prng.bytes))
						}
						self.addEventListener("message", g), self.postMessage({ forge: { prng: { needed: f } } })
					}
				else {
					var u = function (f) {
						var p = f.data
						p.forge &&
							p.forge.prng &&
							t.seedFile(p.forge.prng.needed, function (g, m) {
								c.postMessage({ forge: { prng: { err: g, bytes: m } } })
							})
					}
					c.addEventListener("message", u)
				}
			}),
			t
		)
	}
})
var cl = x((zSt, E5) => {
	"use strict"
	var Xi = Yt()
	uh()
	C5()
	v5()
	Sr()
	;(function () {
		if (Xi.random && Xi.random.getBytes) {
			E5.exports = Xi.random
			return
		}
		;(function (e) {
			var t = {},
				r = new Array(4),
				n = Xi.util.createBuffer()
			;(t.formatKey = function (f) {
				var p = Xi.util.createBuffer(f)
				return (
					(f = new Array(4)),
					(f[0] = p.getInt32()),
					(f[1] = p.getInt32()),
					(f[2] = p.getInt32()),
					(f[3] = p.getInt32()),
					Xi.aes._expandKey(f, !1)
				)
			}),
				(t.formatSeed = function (f) {
					var p = Xi.util.createBuffer(f)
					return (
						(f = new Array(4)),
						(f[0] = p.getInt32()),
						(f[1] = p.getInt32()),
						(f[2] = p.getInt32()),
						(f[3] = p.getInt32()),
						f
					)
				}),
				(t.cipher = function (f, p) {
					return (
						Xi.aes._updateBlock(f, p, r, !1),
						n.putInt32(r[0]),
						n.putInt32(r[1]),
						n.putInt32(r[2]),
						n.putInt32(r[3]),
						n.getBytes()
					)
				}),
				(t.increment = function (f) {
					return ++f[3], f
				}),
				(t.md = Xi.md.sha256)
			function i() {
				var f = Xi.prng.create(t)
				return (
					(f.getBytes = function (p, g) {
						return f.generate(p, g)
					}),
					(f.getBytesSync = function (p) {
						return f.generate(p)
					}),
					f
				)
			}
			var s = i(),
				o = null,
				a = Xi.util.globalScope,
				l = a.crypto || a.msCrypto
			if (
				(l &&
					l.getRandomValues &&
					(o = function (f) {
						return l.getRandomValues(f)
					}),
				Xi.options.usePureJavaScript || (!Xi.util.isNodejs && !o))
			) {
				if ((typeof window > "u" || window.document, s.collectInt(+new Date(), 32), typeof navigator < "u")) {
					var c = ""
					for (var u in navigator)
						try {
							typeof navigator[u] == "string" && (c += navigator[u])
						} catch {}
					s.collect(c), (c = null)
				}
				e &&
					(e().mousemove(function (f) {
						s.collectInt(f.clientX, 16), s.collectInt(f.clientY, 16)
					}),
					e().keypress(function (f) {
						s.collectInt(f.charCode, 8)
					}))
			}
			if (!Xi.random) Xi.random = s
			else for (var u in s) Xi.random[u] = s[u]
			;(Xi.random.createInstance = i), (E5.exports = Xi.random)
		})(typeof jQuery < "u" ? jQuery : null)
	})()
})
var x5 = x((jSt, Tle) => {
	"use strict"
	var Vo = Yt()
	Sr()
	var b5 = [
			217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83,
			142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125,
			50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96,
			178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163,
			60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144,
			239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172,
			53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110,
			15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91,
			37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207,
			225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95,
			185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173,
		],
		Ble = [1, 2, 3, 5],
		Zje = function (e, t) {
			return ((e << t) & 65535) | ((e & 65535) >> (16 - t))
		},
		Xje = function (e, t) {
			return ((e & 65535) >> t) | ((e << (16 - t)) & 65535)
		}
	Tle.exports = Vo.rc2 = Vo.rc2 || {}
	Vo.rc2.expandKey = function (e, t) {
		typeof e == "string" && (e = Vo.util.createBuffer(e)), (t = t || 128)
		var r = e,
			n = e.length(),
			i = t,
			s = Math.ceil(i / 8),
			o = 255 >> (i & 7),
			a
		for (a = n; a < 128; a++) r.putByte(b5[(r.at(a - 1) + r.at(a - n)) & 255])
		for (r.setAt(128 - s, b5[r.at(128 - s) & o]), a = 127 - s; a >= 0; a--)
			r.setAt(a, b5[r.at(a + 1) ^ r.at(a + s)])
		return r
	}
	var Dle = function (e, t, r) {
		var n = !1,
			i = null,
			s = null,
			o = null,
			a,
			l,
			c,
			u,
			f = []
		for (e = Vo.rc2.expandKey(e, t), c = 0; c < 64; c++) f.push(e.getInt16Le())
		r
			? ((a = function (m) {
					for (c = 0; c < 4; c++)
						(m[c] += f[u] + (m[(c + 3) % 4] & m[(c + 2) % 4]) + (~m[(c + 3) % 4] & m[(c + 1) % 4])),
							(m[c] = Zje(m[c], Ble[c])),
							u++
				}),
				(l = function (m) {
					for (c = 0; c < 4; c++) m[c] += f[m[(c + 3) % 4] & 63]
				}))
			: ((a = function (m) {
					for (c = 3; c >= 0; c--)
						(m[c] = Xje(m[c], Ble[c])),
							(m[c] -= f[u] + (m[(c + 3) % 4] & m[(c + 2) % 4]) + (~m[(c + 3) % 4] & m[(c + 1) % 4])),
							u--
				}),
				(l = function (m) {
					for (c = 3; c >= 0; c--) m[c] -= f[m[(c + 3) % 4] & 63]
				}))
		var p = function (m) {
				var y = []
				for (c = 0; c < 4; c++) {
					var C = i.getInt16Le()
					o !== null && (r ? (C ^= o.getInt16Le()) : o.putInt16Le(C)), y.push(C & 65535)
				}
				u = r ? 0 : 63
				for (var v = 0; v < m.length; v++) for (var b = 0; b < m[v][0]; b++) m[v][1](y)
				for (c = 0; c < 4; c++)
					o !== null && (r ? o.putInt16Le(y[c]) : (y[c] ^= o.getInt16Le())), s.putInt16Le(y[c])
			},
			g = null
		return (
			(g = {
				start: function (m, y) {
					m && typeof m == "string" && (m = Vo.util.createBuffer(m)),
						(n = !1),
						(i = Vo.util.createBuffer()),
						(s = y || new Vo.util.createBuffer()),
						(o = m),
						(g.output = s)
				},
				update: function (m) {
					for (n || i.putBuffer(m); i.length() >= 8; )
						p([
							[5, a],
							[1, l],
							[6, a],
							[1, l],
							[5, a],
						])
				},
				finish: function (m) {
					var y = !0
					if (r)
						if (m) y = m(8, i, !r)
						else {
							var C = i.length() === 8 ? 8 : 8 - i.length()
							i.fillWithByte(C, C)
						}
					if ((y && ((n = !0), g.update()), !r && ((y = i.length() === 0), y)))
						if (m) y = m(8, s, !r)
						else {
							var v = s.length(),
								b = s.at(v - 1)
							b > v ? (y = !1) : s.truncate(b)
						}
					return y
				},
			}),
			g
		)
	}
	Vo.rc2.startEncrypting = function (e, t, r) {
		var n = Vo.rc2.createEncryptionCipher(e, 128)
		return n.start(t, r), n
	}
	Vo.rc2.createEncryptionCipher = function (e, t) {
		return Dle(e, t, !0)
	}
	Vo.rc2.startDecrypting = function (e, t, r) {
		var n = Vo.rc2.createDecryptionCipher(e, 128)
		return n.start(t, r), n
	}
	Vo.rc2.createDecryptionCipher = function (e, t) {
		return Dle(e, t, !1)
	}
})
var Tb = x((ZSt, Lle) => {
	"use strict"
	var _5 = Yt()
	Lle.exports = _5.jsbn = _5.jsbn || {}
	var Ud,
		e7e = 0xdeadbeefcafe,
		Rle = (e7e & 16777215) == 15715070
	function ge(e, t, r) {
		;(this.data = []),
			e != null &&
				(typeof e == "number"
					? this.fromNumber(e, t, r)
					: t == null && typeof e != "string"
						? this.fromString(e, 256)
						: this.fromString(e, t))
	}
	_5.jsbn.BigInteger = ge
	function Br() {
		return new ge(null)
	}
	function t7e(e, t, r, n, i, s) {
		for (; --s >= 0; ) {
			var o = t * this.data[e++] + r.data[n] + i
			;(i = Math.floor(o / 67108864)), (r.data[n++] = o & 67108863)
		}
		return i
	}
	function r7e(e, t, r, n, i, s) {
		for (var o = t & 32767, a = t >> 15; --s >= 0; ) {
			var l = this.data[e] & 32767,
				c = this.data[e++] >> 15,
				u = a * l + c * o
			;(l = o * l + ((u & 32767) << 15) + r.data[n] + (i & 1073741823)),
				(i = (l >>> 30) + (u >>> 15) + a * c + (i >>> 30)),
				(r.data[n++] = l & 1073741823)
		}
		return i
	}
	function kle(e, t, r, n, i, s) {
		for (var o = t & 16383, a = t >> 14; --s >= 0; ) {
			var l = this.data[e] & 16383,
				c = this.data[e++] >> 14,
				u = a * l + c * o
			;(l = o * l + ((u & 16383) << 14) + r.data[n] + i),
				(i = (l >> 28) + (u >> 14) + a * c),
				(r.data[n++] = l & 268435455)
		}
		return i
	}
	typeof navigator > "u"
		? ((ge.prototype.am = kle), (Ud = 28))
		: Rle && navigator.appName == "Microsoft Internet Explorer"
			? ((ge.prototype.am = r7e), (Ud = 30))
			: Rle && navigator.appName != "Netscape"
				? ((ge.prototype.am = t7e), (Ud = 26))
				: ((ge.prototype.am = kle), (Ud = 28))
	ge.prototype.DB = Ud
	ge.prototype.DM = (1 << Ud) - 1
	ge.prototype.DV = 1 << Ud
	var w5 = 52
	ge.prototype.FV = Math.pow(2, w5)
	ge.prototype.F1 = w5 - Ud
	ge.prototype.F2 = 2 * Ud - w5
	var n7e = "0123456789abcdefghijklmnopqrstuvwxyz",
		pT = new Array(),
		V0,
		ul
	V0 = 48
	for (ul = 0; ul <= 9; ++ul) pT[V0++] = ul
	V0 = 97
	for (ul = 10; ul < 36; ++ul) pT[V0++] = ul
	V0 = 65
	for (ul = 10; ul < 36; ++ul) pT[V0++] = ul
	function Mle(e) {
		return n7e.charAt(e)
	}
	function Fle(e, t) {
		var r = pT[e.charCodeAt(t)]
		return r ?? -1
	}
	function i7e(e) {
		for (var t = this.t - 1; t >= 0; --t) e.data[t] = this.data[t]
		;(e.t = this.t), (e.s = this.s)
	}
	function s7e(e) {
		;(this.t = 1),
			(this.s = e < 0 ? -1 : 0),
			e > 0 ? (this.data[0] = e) : e < -1 ? (this.data[0] = e + this.DV) : (this.t = 0)
	}
	function fh(e) {
		var t = Br()
		return t.fromInt(e), t
	}
	function o7e(e, t) {
		var r
		if (t == 16) r = 4
		else if (t == 8) r = 3
		else if (t == 256) r = 8
		else if (t == 2) r = 1
		else if (t == 32) r = 5
		else if (t == 4) r = 2
		else {
			this.fromRadix(e, t)
			return
		}
		;(this.t = 0), (this.s = 0)
		for (var n = e.length, i = !1, s = 0; --n >= 0; ) {
			var o = r == 8 ? e[n] & 255 : Fle(e, n)
			if (o < 0) {
				e.charAt(n) == "-" && (i = !0)
				continue
			}
			;(i = !1),
				s == 0
					? (this.data[this.t++] = o)
					: s + r > this.DB
						? ((this.data[this.t - 1] |= (o & ((1 << (this.DB - s)) - 1)) << s),
							(this.data[this.t++] = o >> (this.DB - s)))
						: (this.data[this.t - 1] |= o << s),
				(s += r),
				s >= this.DB && (s -= this.DB)
		}
		r == 8 && e[0] & 128 && ((this.s = -1), s > 0 && (this.data[this.t - 1] |= ((1 << (this.DB - s)) - 1) << s)),
			this.clamp(),
			i && ge.ZERO.subTo(this, this)
	}
	function a7e() {
		for (var e = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == e; ) --this.t
	}
	function l7e(e) {
		if (this.s < 0) return "-" + this.negate().toString(e)
		var t
		if (e == 16) t = 4
		else if (e == 8) t = 3
		else if (e == 2) t = 1
		else if (e == 32) t = 5
		else if (e == 4) t = 2
		else return this.toRadix(e)
		var r = (1 << t) - 1,
			n,
			i = !1,
			s = "",
			o = this.t,
			a = this.DB - ((o * this.DB) % t)
		if (o-- > 0)
			for (a < this.DB && (n = this.data[o] >> a) > 0 && ((i = !0), (s = Mle(n))); o >= 0; )
				a < t
					? ((n = (this.data[o] & ((1 << a) - 1)) << (t - a)), (n |= this.data[--o] >> (a += this.DB - t)))
					: ((n = (this.data[o] >> (a -= t)) & r), a <= 0 && ((a += this.DB), --o)),
					n > 0 && (i = !0),
					i && (s += Mle(n))
		return i ? s : "0"
	}
	function c7e() {
		var e = Br()
		return ge.ZERO.subTo(this, e), e
	}
	function u7e() {
		return this.s < 0 ? this.negate() : this
	}
	function d7e(e) {
		var t = this.s - e.s
		if (t != 0) return t
		var r = this.t
		if (((t = r - e.t), t != 0)) return this.s < 0 ? -t : t
		for (; --r >= 0; ) if ((t = this.data[r] - e.data[r]) != 0) return t
		return 0
	}
	function AT(e) {
		var t = 1,
			r
		return (
			(r = e >>> 16) != 0 && ((e = r), (t += 16)),
			(r = e >> 8) != 0 && ((e = r), (t += 8)),
			(r = e >> 4) != 0 && ((e = r), (t += 4)),
			(r = e >> 2) != 0 && ((e = r), (t += 2)),
			(r = e >> 1) != 0 && ((e = r), (t += 1)),
			t
		)
	}
	function f7e() {
		return this.t <= 0 ? 0 : this.DB * (this.t - 1) + AT(this.data[this.t - 1] ^ (this.s & this.DM))
	}
	function h7e(e, t) {
		var r
		for (r = this.t - 1; r >= 0; --r) t.data[r + e] = this.data[r]
		for (r = e - 1; r >= 0; --r) t.data[r] = 0
		;(t.t = this.t + e), (t.s = this.s)
	}
	function g7e(e, t) {
		for (var r = e; r < this.t; ++r) t.data[r - e] = this.data[r]
		;(t.t = Math.max(this.t - e, 0)), (t.s = this.s)
	}
	function p7e(e, t) {
		var r = e % this.DB,
			n = this.DB - r,
			i = (1 << n) - 1,
			s = Math.floor(e / this.DB),
			o = (this.s << r) & this.DM,
			a
		for (a = this.t - 1; a >= 0; --a) (t.data[a + s + 1] = (this.data[a] >> n) | o), (o = (this.data[a] & i) << r)
		for (a = s - 1; a >= 0; --a) t.data[a] = 0
		;(t.data[s] = o), (t.t = this.t + s + 1), (t.s = this.s), t.clamp()
	}
	function A7e(e, t) {
		t.s = this.s
		var r = Math.floor(e / this.DB)
		if (r >= this.t) {
			t.t = 0
			return
		}
		var n = e % this.DB,
			i = this.DB - n,
			s = (1 << n) - 1
		t.data[0] = this.data[r] >> n
		for (var o = r + 1; o < this.t; ++o)
			(t.data[o - r - 1] |= (this.data[o] & s) << i), (t.data[o - r] = this.data[o] >> n)
		n > 0 && (t.data[this.t - r - 1] |= (this.s & s) << i), (t.t = this.t - r), t.clamp()
	}
	function m7e(e, t) {
		for (var r = 0, n = 0, i = Math.min(e.t, this.t); r < i; )
			(n += this.data[r] - e.data[r]), (t.data[r++] = n & this.DM), (n >>= this.DB)
		if (e.t < this.t) {
			for (n -= e.s; r < this.t; ) (n += this.data[r]), (t.data[r++] = n & this.DM), (n >>= this.DB)
			n += this.s
		} else {
			for (n += this.s; r < e.t; ) (n -= e.data[r]), (t.data[r++] = n & this.DM), (n >>= this.DB)
			n -= e.s
		}
		;(t.s = n < 0 ? -1 : 0), n < -1 ? (t.data[r++] = this.DV + n) : n > 0 && (t.data[r++] = n), (t.t = r), t.clamp()
	}
	function y7e(e, t) {
		var r = this.abs(),
			n = e.abs(),
			i = r.t
		for (t.t = i + n.t; --i >= 0; ) t.data[i] = 0
		for (i = 0; i < n.t; ++i) t.data[i + r.t] = r.am(0, n.data[i], t, i, 0, r.t)
		;(t.s = 0), t.clamp(), this.s != e.s && ge.ZERO.subTo(t, t)
	}
	function C7e(e) {
		for (var t = this.abs(), r = (e.t = 2 * t.t); --r >= 0; ) e.data[r] = 0
		for (r = 0; r < t.t - 1; ++r) {
			var n = t.am(r, t.data[r], e, 2 * r, 0, 1)
			;(e.data[r + t.t] += t.am(r + 1, 2 * t.data[r], e, 2 * r + 1, n, t.t - r - 1)) >= t.DV &&
				((e.data[r + t.t] -= t.DV), (e.data[r + t.t + 1] = 1))
		}
		e.t > 0 && (e.data[e.t - 1] += t.am(r, t.data[r], e, 2 * r, 0, 1)), (e.s = 0), e.clamp()
	}
	function v7e(e, t, r) {
		var n = e.abs()
		if (!(n.t <= 0)) {
			var i = this.abs()
			if (i.t < n.t) {
				t?.fromInt(0), r != null && this.copyTo(r)
				return
			}
			r == null && (r = Br())
			var s = Br(),
				o = this.s,
				a = e.s,
				l = this.DB - AT(n.data[n.t - 1])
			l > 0 ? (n.lShiftTo(l, s), i.lShiftTo(l, r)) : (n.copyTo(s), i.copyTo(r))
			var c = s.t,
				u = s.data[c - 1]
			if (u != 0) {
				var f = u * (1 << this.F1) + (c > 1 ? s.data[c - 2] >> this.F2 : 0),
					p = this.FV / f,
					g = (1 << this.F1) / f,
					m = 1 << this.F2,
					y = r.t,
					C = y - c,
					v = t ?? Br()
				for (
					s.dlShiftTo(C, v),
						r.compareTo(v) >= 0 && ((r.data[r.t++] = 1), r.subTo(v, r)),
						ge.ONE.dlShiftTo(c, v),
						v.subTo(s, s);
					s.t < c;

				)
					s.data[s.t++] = 0
				for (; --C >= 0; ) {
					var b = r.data[--y] == u ? this.DM : Math.floor(r.data[y] * p + (r.data[y - 1] + m) * g)
					if ((r.data[y] += s.am(0, b, r, C, 0, c)) < b)
						for (s.dlShiftTo(C, v), r.subTo(v, r); r.data[y] < --b; ) r.subTo(v, r)
				}
				t != null && (r.drShiftTo(c, t), o != a && ge.ZERO.subTo(t, t)),
					(r.t = c),
					r.clamp(),
					l > 0 && r.rShiftTo(l, r),
					o < 0 && ge.ZERO.subTo(r, r)
			}
		}
	}
	function E7e(e) {
		var t = Br()
		return this.abs().divRemTo(e, null, t), this.s < 0 && t.compareTo(ge.ZERO) > 0 && e.subTo(t, t), t
	}
	function wp(e) {
		this.m = e
	}
	function b7e(e) {
		return e.s < 0 || e.compareTo(this.m) >= 0 ? e.mod(this.m) : e
	}
	function x7e(e) {
		return e
	}
	function _7e(e) {
		e.divRemTo(this.m, null, e)
	}
	function w7e(e, t, r) {
		e.multiplyTo(t, r), this.reduce(r)
	}
	function I7e(e, t) {
		e.squareTo(t), this.reduce(t)
	}
	wp.prototype.convert = b7e
	wp.prototype.revert = x7e
	wp.prototype.reduce = _7e
	wp.prototype.mulTo = w7e
	wp.prototype.sqrTo = I7e
	function S7e() {
		if (this.t < 1) return 0
		var e = this.data[0]
		if (!(e & 1)) return 0
		var t = e & 3
		return (
			(t = (t * (2 - (e & 15) * t)) & 15),
			(t = (t * (2 - (e & 255) * t)) & 255),
			(t = (t * (2 - (((e & 65535) * t) & 65535))) & 65535),
			(t = (t * (2 - ((e * t) % this.DV))) % this.DV),
			t > 0 ? this.DV - t : -t
		)
	}
	function Ip(e) {
		;(this.m = e),
			(this.mp = e.invDigit()),
			(this.mpl = this.mp & 32767),
			(this.mph = this.mp >> 15),
			(this.um = (1 << (e.DB - 15)) - 1),
			(this.mt2 = 2 * e.t)
	}
	function B7e(e) {
		var t = Br()
		return (
			e.abs().dlShiftTo(this.m.t, t),
			t.divRemTo(this.m, null, t),
			e.s < 0 && t.compareTo(ge.ZERO) > 0 && this.m.subTo(t, t),
			t
		)
	}
	function D7e(e) {
		var t = Br()
		return e.copyTo(t), this.reduce(t), t
	}
	function T7e(e) {
		for (; e.t <= this.mt2; ) e.data[e.t++] = 0
		for (var t = 0; t < this.m.t; ++t) {
			var r = e.data[t] & 32767,
				n = (r * this.mpl + (((r * this.mph + (e.data[t] >> 15) * this.mpl) & this.um) << 15)) & e.DM
			for (r = t + this.m.t, e.data[r] += this.m.am(0, n, e, t, 0, this.m.t); e.data[r] >= e.DV; )
				(e.data[r] -= e.DV), e.data[++r]++
		}
		e.clamp(), e.drShiftTo(this.m.t, e), e.compareTo(this.m) >= 0 && e.subTo(this.m, e)
	}
	function R7e(e, t) {
		e.squareTo(t), this.reduce(t)
	}
	function k7e(e, t, r) {
		e.multiplyTo(t, r), this.reduce(r)
	}
	Ip.prototype.convert = B7e
	Ip.prototype.revert = D7e
	Ip.prototype.reduce = T7e
	Ip.prototype.mulTo = k7e
	Ip.prototype.sqrTo = R7e
	function M7e() {
		return (this.t > 0 ? this.data[0] & 1 : this.s) == 0
	}
	function F7e(e, t) {
		if (e > 4294967295 || e < 1) return ge.ONE
		var r = Br(),
			n = Br(),
			i = t.convert(this),
			s = AT(e) - 1
		for (i.copyTo(r); --s >= 0; )
			if ((t.sqrTo(r, n), (e & (1 << s)) > 0)) t.mulTo(n, i, r)
			else {
				var o = r
				;(r = n), (n = o)
			}
		return t.revert(r)
	}
	function Q7e(e, t) {
		var r
		return e < 256 || t.isEven() ? (r = new wp(t)) : (r = new Ip(t)), this.exp(e, r)
	}
	ge.prototype.copyTo = i7e
	ge.prototype.fromInt = s7e
	ge.prototype.fromString = o7e
	ge.prototype.clamp = a7e
	ge.prototype.dlShiftTo = h7e
	ge.prototype.drShiftTo = g7e
	ge.prototype.lShiftTo = p7e
	ge.prototype.rShiftTo = A7e
	ge.prototype.subTo = m7e
	ge.prototype.multiplyTo = y7e
	ge.prototype.squareTo = C7e
	ge.prototype.divRemTo = v7e
	ge.prototype.invDigit = S7e
	ge.prototype.isEven = M7e
	ge.prototype.exp = F7e
	ge.prototype.toString = l7e
	ge.prototype.negate = c7e
	ge.prototype.abs = u7e
	ge.prototype.compareTo = d7e
	ge.prototype.bitLength = f7e
	ge.prototype.mod = E7e
	ge.prototype.modPowInt = Q7e
	ge.ZERO = fh(0)
	ge.ONE = fh(1)
	function N7e() {
		var e = Br()
		return this.copyTo(e), e
	}
	function P7e() {
		if (this.s < 0) {
			if (this.t == 1) return this.data[0] - this.DV
			if (this.t == 0) return -1
		} else {
			if (this.t == 1) return this.data[0]
			if (this.t == 0) return 0
		}
		return ((this.data[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this.data[0]
	}
	function L7e() {
		return this.t == 0 ? this.s : (this.data[0] << 24) >> 24
	}
	function U7e() {
		return this.t == 0 ? this.s : (this.data[0] << 16) >> 16
	}
	function O7e(e) {
		return Math.floor((Math.LN2 * this.DB) / Math.log(e))
	}
	function q7e() {
		return this.s < 0 ? -1 : this.t <= 0 || (this.t == 1 && this.data[0] <= 0) ? 0 : 1
	}
	function V7e(e) {
		if ((e == null && (e = 10), this.signum() == 0 || e < 2 || e > 36)) return "0"
		var t = this.chunkSize(e),
			r = Math.pow(e, t),
			n = fh(r),
			i = Br(),
			s = Br(),
			o = ""
		for (this.divRemTo(n, i, s); i.signum() > 0; )
			(o = (r + s.intValue()).toString(e).substr(1) + o), i.divRemTo(n, i, s)
		return s.intValue().toString(e) + o
	}
	function H7e(e, t) {
		this.fromInt(0), t == null && (t = 10)
		for (var r = this.chunkSize(t), n = Math.pow(t, r), i = !1, s = 0, o = 0, a = 0; a < e.length; ++a) {
			var l = Fle(e, a)
			if (l < 0) {
				e.charAt(a) == "-" && this.signum() == 0 && (i = !0)
				continue
			}
			;(o = t * o + l), ++s >= r && (this.dMultiply(n), this.dAddOffset(o, 0), (s = 0), (o = 0))
		}
		s > 0 && (this.dMultiply(Math.pow(t, s)), this.dAddOffset(o, 0)), i && ge.ZERO.subTo(this, this)
	}
	function W7e(e, t, r) {
		if (typeof t == "number")
			if (e < 2) this.fromInt(1)
			else
				for (
					this.fromNumber(e, r),
						this.testBit(e - 1) || this.bitwiseTo(ge.ONE.shiftLeft(e - 1), I5, this),
						this.isEven() && this.dAddOffset(1, 0);
					!this.isProbablePrime(t);

				)
					this.dAddOffset(2, 0), this.bitLength() > e && this.subTo(ge.ONE.shiftLeft(e - 1), this)
		else {
			var n = new Array(),
				i = e & 7
			;(n.length = (e >> 3) + 1),
				t.nextBytes(n),
				i > 0 ? (n[0] &= (1 << i) - 1) : (n[0] = 0),
				this.fromString(n, 256)
		}
	}
	function G7e() {
		var e = this.t,
			t = new Array()
		t[0] = this.s
		var r = this.DB - ((e * this.DB) % 8),
			n,
			i = 0
		if (e-- > 0)
			for (
				r < this.DB &&
				(n = this.data[e] >> r) != (this.s & this.DM) >> r &&
				(t[i++] = n | (this.s << (this.DB - r)));
				e >= 0;

			)
				r < 8
					? ((n = (this.data[e] & ((1 << r) - 1)) << (8 - r)), (n |= this.data[--e] >> (r += this.DB - 8)))
					: ((n = (this.data[e] >> (r -= 8)) & 255), r <= 0 && ((r += this.DB), --e)),
					n & 128 && (n |= -256),
					i == 0 && (this.s & 128) != (n & 128) && ++i,
					(i > 0 || n != this.s) && (t[i++] = n)
		return t
	}
	function $7e(e) {
		return this.compareTo(e) == 0
	}
	function Y7e(e) {
		return this.compareTo(e) < 0 ? this : e
	}
	function K7e(e) {
		return this.compareTo(e) > 0 ? this : e
	}
	function J7e(e, t, r) {
		var n,
			i,
			s = Math.min(e.t, this.t)
		for (n = 0; n < s; ++n) r.data[n] = t(this.data[n], e.data[n])
		if (e.t < this.t) {
			for (i = e.s & this.DM, n = s; n < this.t; ++n) r.data[n] = t(this.data[n], i)
			r.t = this.t
		} else {
			for (i = this.s & this.DM, n = s; n < e.t; ++n) r.data[n] = t(i, e.data[n])
			r.t = e.t
		}
		;(r.s = t(this.s, e.s)), r.clamp()
	}
	function z7e(e, t) {
		return e & t
	}
	function j7e(e) {
		var t = Br()
		return this.bitwiseTo(e, z7e, t), t
	}
	function I5(e, t) {
		return e | t
	}
	function Z7e(e) {
		var t = Br()
		return this.bitwiseTo(e, I5, t), t
	}
	function Qle(e, t) {
		return e ^ t
	}
	function X7e(e) {
		var t = Br()
		return this.bitwiseTo(e, Qle, t), t
	}
	function Nle(e, t) {
		return e & ~t
	}
	function eZe(e) {
		var t = Br()
		return this.bitwiseTo(e, Nle, t), t
	}
	function tZe() {
		for (var e = Br(), t = 0; t < this.t; ++t) e.data[t] = this.DM & ~this.data[t]
		return (e.t = this.t), (e.s = ~this.s), e
	}
	function rZe(e) {
		var t = Br()
		return e < 0 ? this.rShiftTo(-e, t) : this.lShiftTo(e, t), t
	}
	function nZe(e) {
		var t = Br()
		return e < 0 ? this.lShiftTo(-e, t) : this.rShiftTo(e, t), t
	}
	function iZe(e) {
		if (e == 0) return -1
		var t = 0
		return (
			e & 65535 || ((e >>= 16), (t += 16)),
			e & 255 || ((e >>= 8), (t += 8)),
			e & 15 || ((e >>= 4), (t += 4)),
			e & 3 || ((e >>= 2), (t += 2)),
			e & 1 || ++t,
			t
		)
	}
	function sZe() {
		for (var e = 0; e < this.t; ++e) if (this.data[e] != 0) return e * this.DB + iZe(this.data[e])
		return this.s < 0 ? this.t * this.DB : -1
	}
	function oZe(e) {
		for (var t = 0; e != 0; ) (e &= e - 1), ++t
		return t
	}
	function aZe() {
		for (var e = 0, t = this.s & this.DM, r = 0; r < this.t; ++r) e += oZe(this.data[r] ^ t)
		return e
	}
	function lZe(e) {
		var t = Math.floor(e / this.DB)
		return t >= this.t ? this.s != 0 : (this.data[t] & (1 << e % this.DB)) != 0
	}
	function cZe(e, t) {
		var r = ge.ONE.shiftLeft(e)
		return this.bitwiseTo(r, t, r), r
	}
	function uZe(e) {
		return this.changeBit(e, I5)
	}
	function dZe(e) {
		return this.changeBit(e, Nle)
	}
	function fZe(e) {
		return this.changeBit(e, Qle)
	}
	function hZe(e, t) {
		for (var r = 0, n = 0, i = Math.min(e.t, this.t); r < i; )
			(n += this.data[r] + e.data[r]), (t.data[r++] = n & this.DM), (n >>= this.DB)
		if (e.t < this.t) {
			for (n += e.s; r < this.t; ) (n += this.data[r]), (t.data[r++] = n & this.DM), (n >>= this.DB)
			n += this.s
		} else {
			for (n += this.s; r < e.t; ) (n += e.data[r]), (t.data[r++] = n & this.DM), (n >>= this.DB)
			n += e.s
		}
		;(t.s = n < 0 ? -1 : 0), n > 0 ? (t.data[r++] = n) : n < -1 && (t.data[r++] = this.DV + n), (t.t = r), t.clamp()
	}
	function gZe(e) {
		var t = Br()
		return this.addTo(e, t), t
	}
	function pZe(e) {
		var t = Br()
		return this.subTo(e, t), t
	}
	function AZe(e) {
		var t = Br()
		return this.multiplyTo(e, t), t
	}
	function mZe(e) {
		var t = Br()
		return this.divRemTo(e, t, null), t
	}
	function yZe(e) {
		var t = Br()
		return this.divRemTo(e, null, t), t
	}
	function CZe(e) {
		var t = Br(),
			r = Br()
		return this.divRemTo(e, t, r), new Array(t, r)
	}
	function vZe(e) {
		;(this.data[this.t] = this.am(0, e - 1, this, 0, 0, this.t)), ++this.t, this.clamp()
	}
	function EZe(e, t) {
		if (e != 0) {
			for (; this.t <= t; ) this.data[this.t++] = 0
			for (this.data[t] += e; this.data[t] >= this.DV; )
				(this.data[t] -= this.DV), ++t >= this.t && (this.data[this.t++] = 0), ++this.data[t]
		}
	}
	function Db() {}
	function Ple(e) {
		return e
	}
	function bZe(e, t, r) {
		e.multiplyTo(t, r)
	}
	function xZe(e, t) {
		e.squareTo(t)
	}
	Db.prototype.convert = Ple
	Db.prototype.revert = Ple
	Db.prototype.mulTo = bZe
	Db.prototype.sqrTo = xZe
	function _Ze(e) {
		return this.exp(e, new Db())
	}
	function wZe(e, t, r) {
		var n = Math.min(this.t + e.t, t)
		for (r.s = 0, r.t = n; n > 0; ) r.data[--n] = 0
		var i
		for (i = r.t - this.t; n < i; ++n) r.data[n + this.t] = this.am(0, e.data[n], r, n, 0, this.t)
		for (i = Math.min(e.t, t); n < i; ++n) this.am(0, e.data[n], r, n, 0, t - n)
		r.clamp()
	}
	function IZe(e, t, r) {
		--t
		var n = (r.t = this.t + e.t - t)
		for (r.s = 0; --n >= 0; ) r.data[n] = 0
		for (n = Math.max(t - this.t, 0); n < e.t; ++n)
			r.data[this.t + n - t] = this.am(t - n, e.data[n], r, 0, 0, this.t + n - t)
		r.clamp(), r.drShiftTo(1, r)
	}
	function H0(e) {
		;(this.r2 = Br()),
			(this.q3 = Br()),
			ge.ONE.dlShiftTo(2 * e.t, this.r2),
			(this.mu = this.r2.divide(e)),
			(this.m = e)
	}
	function SZe(e) {
		if (e.s < 0 || e.t > 2 * this.m.t) return e.mod(this.m)
		if (e.compareTo(this.m) < 0) return e
		var t = Br()
		return e.copyTo(t), this.reduce(t), t
	}
	function BZe(e) {
		return e
	}
	function DZe(e) {
		for (
			e.drShiftTo(this.m.t - 1, this.r2),
				e.t > this.m.t + 1 && ((e.t = this.m.t + 1), e.clamp()),
				this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3),
				this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
			e.compareTo(this.r2) < 0;

		)
			e.dAddOffset(1, this.m.t + 1)
		for (e.subTo(this.r2, e); e.compareTo(this.m) >= 0; ) e.subTo(this.m, e)
	}
	function TZe(e, t) {
		e.squareTo(t), this.reduce(t)
	}
	function RZe(e, t, r) {
		e.multiplyTo(t, r), this.reduce(r)
	}
	H0.prototype.convert = SZe
	H0.prototype.revert = BZe
	H0.prototype.reduce = DZe
	H0.prototype.mulTo = RZe
	H0.prototype.sqrTo = TZe
	function kZe(e, t) {
		var r = e.bitLength(),
			n,
			i = fh(1),
			s
		if (r <= 0) return i
		r < 18 ? (n = 1) : r < 48 ? (n = 3) : r < 144 ? (n = 4) : r < 768 ? (n = 5) : (n = 6),
			r < 8 ? (s = new wp(t)) : t.isEven() ? (s = new H0(t)) : (s = new Ip(t))
		var o = new Array(),
			a = 3,
			l = n - 1,
			c = (1 << n) - 1
		if (((o[1] = s.convert(this)), n > 1)) {
			var u = Br()
			for (s.sqrTo(o[1], u); a <= c; ) (o[a] = Br()), s.mulTo(u, o[a - 2], o[a]), (a += 2)
		}
		var f = e.t - 1,
			p,
			g = !0,
			m = Br(),
			y
		for (r = AT(e.data[f]) - 1; f >= 0; ) {
			for (
				r >= l
					? (p = (e.data[f] >> (r - l)) & c)
					: ((p = (e.data[f] & ((1 << (r + 1)) - 1)) << (l - r)),
						f > 0 && (p |= e.data[f - 1] >> (this.DB + r - l))),
					a = n;
				!(p & 1);

			)
				(p >>= 1), --a
			if (((r -= a) < 0 && ((r += this.DB), --f), g)) o[p].copyTo(i), (g = !1)
			else {
				for (; a > 1; ) s.sqrTo(i, m), s.sqrTo(m, i), (a -= 2)
				a > 0 ? s.sqrTo(i, m) : ((y = i), (i = m), (m = y)), s.mulTo(m, o[p], i)
			}
			for (; f >= 0 && !(e.data[f] & (1 << r)); )
				s.sqrTo(i, m), (y = i), (i = m), (m = y), --r < 0 && ((r = this.DB - 1), --f)
		}
		return s.revert(i)
	}
	function MZe(e) {
		var t = this.s < 0 ? this.negate() : this.clone(),
			r = e.s < 0 ? e.negate() : e.clone()
		if (t.compareTo(r) < 0) {
			var n = t
			;(t = r), (r = n)
		}
		var i = t.getLowestSetBit(),
			s = r.getLowestSetBit()
		if (s < 0) return t
		for (i < s && (s = i), s > 0 && (t.rShiftTo(s, t), r.rShiftTo(s, r)); t.signum() > 0; )
			(i = t.getLowestSetBit()) > 0 && t.rShiftTo(i, t),
				(i = r.getLowestSetBit()) > 0 && r.rShiftTo(i, r),
				t.compareTo(r) >= 0 ? (t.subTo(r, t), t.rShiftTo(1, t)) : (r.subTo(t, r), r.rShiftTo(1, r))
		return s > 0 && r.lShiftTo(s, r), r
	}
	function FZe(e) {
		if (e <= 0) return 0
		var t = this.DV % e,
			r = this.s < 0 ? e - 1 : 0
		if (this.t > 0)
			if (t == 0) r = this.data[0] % e
			else for (var n = this.t - 1; n >= 0; --n) r = (t * r + this.data[n]) % e
		return r
	}
	function QZe(e) {
		var t = e.isEven()
		if ((this.isEven() && t) || e.signum() == 0) return ge.ZERO
		for (var r = e.clone(), n = this.clone(), i = fh(1), s = fh(0), o = fh(0), a = fh(1); r.signum() != 0; ) {
			for (; r.isEven(); )
				r.rShiftTo(1, r),
					t
						? ((!i.isEven() || !s.isEven()) && (i.addTo(this, i), s.subTo(e, s)), i.rShiftTo(1, i))
						: s.isEven() || s.subTo(e, s),
					s.rShiftTo(1, s)
			for (; n.isEven(); )
				n.rShiftTo(1, n),
					t
						? ((!o.isEven() || !a.isEven()) && (o.addTo(this, o), a.subTo(e, a)), o.rShiftTo(1, o))
						: a.isEven() || a.subTo(e, a),
					a.rShiftTo(1, a)
			r.compareTo(n) >= 0
				? (r.subTo(n, r), t && i.subTo(o, i), s.subTo(a, s))
				: (n.subTo(r, n), t && o.subTo(i, o), a.subTo(s, a))
		}
		if (n.compareTo(ge.ONE) != 0) return ge.ZERO
		if (a.compareTo(e) >= 0) return a.subtract(e)
		if (a.signum() < 0) a.addTo(e, a)
		else return a
		return a.signum() < 0 ? a.add(e) : a
	}
	var pc = [
			2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103,
			107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223,
			227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,
			349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463,
			467, 479, 487, 491, 499, 503, 509,
		],
		NZe = (1 << 26) / pc[pc.length - 1]
	function PZe(e) {
		var t,
			r = this.abs()
		if (r.t == 1 && r.data[0] <= pc[pc.length - 1]) {
			for (t = 0; t < pc.length; ++t) if (r.data[0] == pc[t]) return !0
			return !1
		}
		if (r.isEven()) return !1
		for (t = 1; t < pc.length; ) {
			for (var n = pc[t], i = t + 1; i < pc.length && n < NZe; ) n *= pc[i++]
			for (n = r.modInt(n); t < i; ) if (n % pc[t++] == 0) return !1
		}
		return r.millerRabin(e)
	}
	function LZe(e) {
		var t = this.subtract(ge.ONE),
			r = t.getLowestSetBit()
		if (r <= 0) return !1
		for (var n = t.shiftRight(r), i = UZe(), s, o = 0; o < e; ++o) {
			do s = new ge(this.bitLength(), i)
			while (s.compareTo(ge.ONE) <= 0 || s.compareTo(t) >= 0)
			var a = s.modPow(n, this)
			if (a.compareTo(ge.ONE) != 0 && a.compareTo(t) != 0) {
				for (var l = 1; l++ < r && a.compareTo(t) != 0; )
					if (((a = a.modPowInt(2, this)), a.compareTo(ge.ONE) == 0)) return !1
				if (a.compareTo(t) != 0) return !1
			}
		}
		return !0
	}
	function UZe() {
		return {
			nextBytes: function (e) {
				for (var t = 0; t < e.length; ++t) e[t] = Math.floor(Math.random() * 256)
			},
		}
	}
	ge.prototype.chunkSize = O7e
	ge.prototype.toRadix = V7e
	ge.prototype.fromRadix = H7e
	ge.prototype.fromNumber = W7e
	ge.prototype.bitwiseTo = J7e
	ge.prototype.changeBit = cZe
	ge.prototype.addTo = hZe
	ge.prototype.dMultiply = vZe
	ge.prototype.dAddOffset = EZe
	ge.prototype.multiplyLowerTo = wZe
	ge.prototype.multiplyUpperTo = IZe
	ge.prototype.modInt = FZe
	ge.prototype.millerRabin = LZe
	ge.prototype.clone = N7e
	ge.prototype.intValue = P7e
	ge.prototype.byteValue = L7e
	ge.prototype.shortValue = U7e
	ge.prototype.signum = q7e
	ge.prototype.toByteArray = G7e
	ge.prototype.equals = $7e
	ge.prototype.min = Y7e
	ge.prototype.max = K7e
	ge.prototype.and = j7e
	ge.prototype.or = Z7e
	ge.prototype.xor = X7e
	ge.prototype.andNot = eZe
	ge.prototype.not = tZe
	ge.prototype.shiftLeft = rZe
	ge.prototype.shiftRight = nZe
	ge.prototype.getLowestSetBit = sZe
	ge.prototype.bitCount = aZe
	ge.prototype.testBit = lZe
	ge.prototype.setBit = uZe
	ge.prototype.clearBit = dZe
	ge.prototype.flipBit = fZe
	ge.prototype.add = gZe
	ge.prototype.subtract = pZe
	ge.prototype.multiply = AZe
	ge.prototype.divide = mZe
	ge.prototype.remainder = yZe
	ge.prototype.divideAndRemainder = CZe
	ge.prototype.modPow = kZe
	ge.prototype.modInverse = QZe
	ge.prototype.pow = _Ze
	ge.prototype.gcd = MZe
	ge.prototype.isProbablePrime = PZe
})
var W0 = x((XSt, Vle) => {
	"use strict"
	var Au = Yt()
	du()
	Sr()
	var Ole = (Vle.exports = Au.sha1 = Au.sha1 || {})
	Au.md.sha1 = Au.md.algorithms.sha1 = Ole
	Ole.create = function () {
		qle || OZe()
		var e = null,
			t = Au.util.createBuffer(),
			r = new Array(80),
			n = {
				algorithm: "sha1",
				blockLength: 64,
				digestLength: 20,
				messageLength: 0,
				fullMessageLength: null,
				messageLengthSize: 8,
			}
		return (
			(n.start = function () {
				;(n.messageLength = 0), (n.fullMessageLength = n.messageLength64 = [])
				for (var i = n.messageLengthSize / 4, s = 0; s < i; ++s) n.fullMessageLength.push(0)
				return (
					(t = Au.util.createBuffer()),
					(e = {
						h0: 1732584193,
						h1: 4023233417,
						h2: 2562383102,
						h3: 271733878,
						h4: 3285377520,
					}),
					n
				)
			}),
			n.start(),
			(n.update = function (i, s) {
				s === "utf8" && (i = Au.util.encodeUtf8(i))
				var o = i.length
				;(n.messageLength += o), (o = [(o / 4294967296) >>> 0, o >>> 0])
				for (var a = n.fullMessageLength.length - 1; a >= 0; --a)
					(n.fullMessageLength[a] += o[1]),
						(o[1] = o[0] + ((n.fullMessageLength[a] / 4294967296) >>> 0)),
						(n.fullMessageLength[a] = n.fullMessageLength[a] >>> 0),
						(o[0] = (o[1] / 4294967296) >>> 0)
				return t.putBytes(i), Ule(e, r, t), (t.read > 2048 || t.length() === 0) && t.compact(), n
			}),
			(n.digest = function () {
				var i = Au.util.createBuffer()
				i.putBytes(t.bytes())
				var s = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize,
					o = s & (n.blockLength - 1)
				i.putBytes(S5.substr(0, n.blockLength - o))
				for (var a, l, c = n.fullMessageLength[0] * 8, u = 0; u < n.fullMessageLength.length - 1; ++u)
					(a = n.fullMessageLength[u + 1] * 8),
						(l = (a / 4294967296) >>> 0),
						(c += l),
						i.putInt32(c >>> 0),
						(c = a >>> 0)
				i.putInt32(c)
				var f = { h0: e.h0, h1: e.h1, h2: e.h2, h3: e.h3, h4: e.h4 }
				Ule(f, r, i)
				var p = Au.util.createBuffer()
				return p.putInt32(f.h0), p.putInt32(f.h1), p.putInt32(f.h2), p.putInt32(f.h3), p.putInt32(f.h4), p
			}),
			n
		)
	}
	var S5 = null,
		qle = !1
	function OZe() {
		;(S5 = "\x80"), (S5 += Au.util.fillString("\0", 64)), (qle = !0)
	}
	function Ule(e, t, r) {
		for (var n, i, s, o, a, l, c, u, f = r.length(); f >= 64; ) {
			for (i = e.h0, s = e.h1, o = e.h2, a = e.h3, l = e.h4, u = 0; u < 16; ++u)
				(n = r.getInt32()),
					(t[u] = n),
					(c = a ^ (s & (o ^ a))),
					(n = ((i << 5) | (i >>> 27)) + c + l + 1518500249 + n),
					(l = a),
					(a = o),
					(o = ((s << 30) | (s >>> 2)) >>> 0),
					(s = i),
					(i = n)
			for (; u < 20; ++u)
				(n = t[u - 3] ^ t[u - 8] ^ t[u - 14] ^ t[u - 16]),
					(n = (n << 1) | (n >>> 31)),
					(t[u] = n),
					(c = a ^ (s & (o ^ a))),
					(n = ((i << 5) | (i >>> 27)) + c + l + 1518500249 + n),
					(l = a),
					(a = o),
					(o = ((s << 30) | (s >>> 2)) >>> 0),
					(s = i),
					(i = n)
			for (; u < 32; ++u)
				(n = t[u - 3] ^ t[u - 8] ^ t[u - 14] ^ t[u - 16]),
					(n = (n << 1) | (n >>> 31)),
					(t[u] = n),
					(c = s ^ o ^ a),
					(n = ((i << 5) | (i >>> 27)) + c + l + 1859775393 + n),
					(l = a),
					(a = o),
					(o = ((s << 30) | (s >>> 2)) >>> 0),
					(s = i),
					(i = n)
			for (; u < 40; ++u)
				(n = t[u - 6] ^ t[u - 16] ^ t[u - 28] ^ t[u - 32]),
					(n = (n << 2) | (n >>> 30)),
					(t[u] = n),
					(c = s ^ o ^ a),
					(n = ((i << 5) | (i >>> 27)) + c + l + 1859775393 + n),
					(l = a),
					(a = o),
					(o = ((s << 30) | (s >>> 2)) >>> 0),
					(s = i),
					(i = n)
			for (; u < 60; ++u)
				(n = t[u - 6] ^ t[u - 16] ^ t[u - 28] ^ t[u - 32]),
					(n = (n << 2) | (n >>> 30)),
					(t[u] = n),
					(c = (s & o) | (a & (s ^ o))),
					(n = ((i << 5) | (i >>> 27)) + c + l + 2400959708 + n),
					(l = a),
					(a = o),
					(o = ((s << 30) | (s >>> 2)) >>> 0),
					(s = i),
					(i = n)
			for (; u < 80; ++u)
				(n = t[u - 6] ^ t[u - 16] ^ t[u - 28] ^ t[u - 32]),
					(n = (n << 2) | (n >>> 30)),
					(t[u] = n),
					(c = s ^ o ^ a),
					(n = ((i << 5) | (i >>> 27)) + c + l + 3395469782 + n),
					(l = a),
					(a = o),
					(o = ((s << 30) | (s >>> 2)) >>> 0),
					(s = i),
					(i = n)
			;(e.h0 = (e.h0 + i) | 0),
				(e.h1 = (e.h1 + s) | 0),
				(e.h2 = (e.h2 + o) | 0),
				(e.h3 = (e.h3 + a) | 0),
				(e.h4 = (e.h4 + l) | 0),
				(f -= 64)
		}
	}
})
var B5 = x((eBt, Wle) => {
	"use strict"
	var mu = Yt()
	Sr()
	cl()
	W0()
	var Hle = (Wle.exports = mu.pkcs1 = mu.pkcs1 || {})
	Hle.encode_rsa_oaep = function (e, t, r) {
		var n, i, s, o
		typeof r == "string"
			? ((n = r), (i = arguments[3] || void 0), (s = arguments[4] || void 0))
			: r &&
				((n = r.label || void 0),
				(i = r.seed || void 0),
				(s = r.md || void 0),
				r.mgf1 && r.mgf1.md && (o = r.mgf1.md)),
			s ? s.start() : (s = mu.md.sha1.create()),
			o || (o = s)
		var a = Math.ceil(e.n.bitLength() / 8),
			l = a - 2 * s.digestLength - 2
		if (t.length > l) {
			var c = new Error("RSAES-OAEP input message length is too long.")
			throw ((c.length = t.length), (c.maxLength = l), c)
		}
		n || (n = ""), s.update(n, "raw")
		for (var u = s.digest(), f = "", p = l - t.length, g = 0; g < p; g++) f += "\0"
		var m = u.getBytes() + f + "" + t
		if (!i) i = mu.random.getBytes(s.digestLength)
		else if (i.length !== s.digestLength) {
			var c = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.")
			throw ((c.seedLength = i.length), (c.digestLength = s.digestLength), c)
		}
		var y = mT(i, a - s.digestLength - 1, o),
			C = mu.util.xorBytes(m, y, m.length),
			v = mT(C, s.digestLength, o),
			b = mu.util.xorBytes(i, v, i.length)
		return "\0" + b + C
	}
	Hle.decode_rsa_oaep = function (e, t, r) {
		var n, i, s
		typeof r == "string"
			? ((n = r), (i = arguments[3] || void 0))
			: r && ((n = r.label || void 0), (i = r.md || void 0), r.mgf1 && r.mgf1.md && (s = r.mgf1.md))
		var o = Math.ceil(e.n.bitLength() / 8)
		if (t.length !== o) {
			var C = new Error("RSAES-OAEP encoded message length is invalid.")
			throw ((C.length = t.length), (C.expectedLength = o), C)
		}
		if ((i === void 0 ? (i = mu.md.sha1.create()) : i.start(), s || (s = i), o < 2 * i.digestLength + 2))
			throw new Error("RSAES-OAEP key is too short for the hash function.")
		n || (n = ""), i.update(n, "raw")
		for (
			var a = i.digest().getBytes(),
				l = t.charAt(0),
				c = t.substring(1, i.digestLength + 1),
				u = t.substring(1 + i.digestLength),
				f = mT(u, i.digestLength, s),
				p = mu.util.xorBytes(c, f, c.length),
				g = mT(p, o - i.digestLength - 1, s),
				m = mu.util.xorBytes(u, g, u.length),
				y = m.substring(0, i.digestLength),
				C = l !== "\0",
				v = 0;
			v < i.digestLength;
			++v
		)
			C |= a.charAt(v) !== y.charAt(v)
		for (var b = 1, w = i.digestLength, B = i.digestLength; B < m.length; B++) {
			var M = m.charCodeAt(B),
				Q = (M & 1) ^ 1,
				O = b ? 65534 : 0
			;(C |= M & O), (b = b & Q), (w += b)
		}
		if (C || m.charCodeAt(w) !== 1) throw new Error("Invalid RSAES-OAEP padding.")
		return m.substring(w + 1)
	}
	function mT(e, t, r) {
		r || (r = mu.md.sha1.create())
		for (var n = "", i = Math.ceil(t / r.digestLength), s = 0; s < i; ++s) {
			var o = String.fromCharCode((s >> 24) & 255, (s >> 16) & 255, (s >> 8) & 255, s & 255)
			r.start(), r.update(e + o), (n += r.digest().getBytes())
		}
		return n.substring(0, t)
	}
})
var T5 = x((tBt, D5) => {
	"use strict"
	var hh = Yt()
	Sr()
	Tb()
	cl()
	;(function () {
		if (hh.prime) {
			D5.exports = hh.prime
			return
		}
		var e = (D5.exports = hh.prime = hh.prime || {}),
			t = hh.jsbn.BigInteger,
			r = [6, 4, 2, 4, 2, 4, 6, 2],
			n = new t(null)
		n.fromInt(30)
		var i = function (f, p) {
			return f | p
		}
		e.generateProbablePrime = function (f, p, g) {
			typeof p == "function" && ((g = p), (p = {})), (p = p || {})
			var m = p.algorithm || "PRIMEINC"
			typeof m == "string" && (m = { name: m }), (m.options = m.options || {})
			var y = p.prng || hh.random,
				C = {
					nextBytes: function (v) {
						for (var b = y.getBytesSync(v.length), w = 0; w < v.length; ++w) v[w] = b.charCodeAt(w)
					},
				}
			if (m.name === "PRIMEINC") return s(f, C, m.options, g)
			throw new Error("Invalid prime generation algorithm: " + m.name)
		}
		function s(f, p, g, m) {
			return "workers" in g ? l(f, p, g, m) : o(f, p, g, m)
		}
		function o(f, p, g, m) {
			var y = c(f, p),
				C = 0,
				v = u(y.bitLength())
			"millerRabinTests" in g && (v = g.millerRabinTests)
			var b = 10
			"maxBlockTime" in g && (b = g.maxBlockTime), a(y, f, p, C, v, b, m)
		}
		function a(f, p, g, m, y, C, v) {
			var b = +new Date()
			do {
				if ((f.bitLength() > p && (f = c(p, g)), f.isProbablePrime(y))) return v(null, f)
				f.dAddOffset(r[m++ % 8], 0)
			} while (C < 0 || +new Date() - b < C)
			hh.util.setImmediate(function () {
				a(f, p, g, m, y, C, v)
			})
		}
		function l(f, p, g, m) {
			if (typeof Worker > "u") return o(f, p, g, m)
			var y = c(f, p),
				C = g.workers,
				v = g.workLoad || 100,
				b = (v * 30) / 8,
				w = g.workerScript || "forge/prime.worker.js"
			if (C === -1)
				return hh.util.estimateCores(function (M, Q) {
					M && (Q = 2), (C = Q - 1), B()
				})
			B()
			function B() {
				C = Math.max(1, C)
				for (var M = [], Q = 0; Q < C; ++Q) M[Q] = new Worker(w)
				for (var O = C, Q = 0; Q < C; ++Q) M[Q].addEventListener("message", j)
				var Y = !1
				function j(ne) {
					if (!Y) {
						--O
						var q = ne.data
						if (q.found) {
							for (var me = 0; me < M.length; ++me) M[me].terminate()
							return (Y = !0), m(null, new t(q.prime, 16))
						}
						y.bitLength() > f && (y = c(f, p))
						var Qe = y.toString(16)
						ne.target.postMessage({ hex: Qe, workLoad: v }), y.dAddOffset(b, 0)
					}
				}
			}
		}
		function c(f, p) {
			var g = new t(f, p),
				m = f - 1
			return g.testBit(m) || g.bitwiseTo(t.ONE.shiftLeft(m), i, g), g.dAddOffset(31 - g.mod(n).byteValue(), 0), g
		}
		function u(f) {
			return f <= 100
				? 27
				: f <= 150
					? 18
					: f <= 200
						? 15
						: f <= 250
							? 12
							: f <= 300
								? 9
								: f <= 350
									? 8
									: f <= 400
										? 7
										: f <= 500
											? 6
											: f <= 600
												? 5
												: f <= 800
													? 4
													: f <= 1250
														? 3
														: 2
		}
	})()
})
var Rb = x((rBt, jle) => {
	"use strict"
	var rt = Yt()
	gc()
	Tb()
	dh()
	B5()
	T5()
	cl()
	Sr()
	typeof br > "u" && (br = rt.jsbn.BigInteger)
	var br,
		R5 = rt.util.isNodejs ? require("crypto") : null,
		ee = rt.asn1,
		dl = rt.util
	rt.pki = rt.pki || {}
	jle.exports = rt.pki.rsa = rt.rsa = rt.rsa || {}
	var kt = rt.pki,
		qZe = [6, 4, 2, 4, 2, 4, 6, 2],
		VZe = {
			name: "PrivateKeyInfo",
			tagClass: ee.Class.UNIVERSAL,
			type: ee.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "PrivateKeyInfo.version",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "privateKeyVersion",
				},
				{
					name: "PrivateKeyInfo.privateKeyAlgorithm",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.SEQUENCE,
					constructed: !0,
					value: [
						{
							name: "AlgorithmIdentifier.algorithm",
							tagClass: ee.Class.UNIVERSAL,
							type: ee.Type.OID,
							constructed: !1,
							capture: "privateKeyOid",
						},
					],
				},
				{
					name: "PrivateKeyInfo",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.OCTETSTRING,
					constructed: !1,
					capture: "privateKey",
				},
			],
		},
		HZe = {
			name: "RSAPrivateKey",
			tagClass: ee.Class.UNIVERSAL,
			type: ee.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "RSAPrivateKey.version",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "privateKeyVersion",
				},
				{
					name: "RSAPrivateKey.modulus",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "privateKeyModulus",
				},
				{
					name: "RSAPrivateKey.publicExponent",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "privateKeyPublicExponent",
				},
				{
					name: "RSAPrivateKey.privateExponent",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "privateKeyPrivateExponent",
				},
				{
					name: "RSAPrivateKey.prime1",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "privateKeyPrime1",
				},
				{
					name: "RSAPrivateKey.prime2",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "privateKeyPrime2",
				},
				{
					name: "RSAPrivateKey.exponent1",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "privateKeyExponent1",
				},
				{
					name: "RSAPrivateKey.exponent2",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "privateKeyExponent2",
				},
				{
					name: "RSAPrivateKey.coefficient",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "privateKeyCoefficient",
				},
			],
		},
		WZe = {
			name: "RSAPublicKey",
			tagClass: ee.Class.UNIVERSAL,
			type: ee.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "RSAPublicKey.modulus",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "publicKeyModulus",
				},
				{
					name: "RSAPublicKey.exponent",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.INTEGER,
					constructed: !1,
					capture: "publicKeyExponent",
				},
			],
		},
		GZe = (rt.pki.rsa.publicKeyValidator = {
			name: "SubjectPublicKeyInfo",
			tagClass: ee.Class.UNIVERSAL,
			type: ee.Type.SEQUENCE,
			constructed: !0,
			captureAsn1: "subjectPublicKeyInfo",
			value: [
				{
					name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.SEQUENCE,
					constructed: !0,
					value: [
						{
							name: "AlgorithmIdentifier.algorithm",
							tagClass: ee.Class.UNIVERSAL,
							type: ee.Type.OID,
							constructed: !1,
							capture: "publicKeyOid",
						},
					],
				},
				{
					name: "SubjectPublicKeyInfo.subjectPublicKey",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.BITSTRING,
					constructed: !1,
					value: [
						{
							name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
							tagClass: ee.Class.UNIVERSAL,
							type: ee.Type.SEQUENCE,
							constructed: !0,
							optional: !0,
							captureAsn1: "rsaPublicKey",
						},
					],
				},
			],
		}),
		$Ze = {
			name: "DigestInfo",
			tagClass: ee.Class.UNIVERSAL,
			type: ee.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "DigestInfo.DigestAlgorithm",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.SEQUENCE,
					constructed: !0,
					value: [
						{
							name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
							tagClass: ee.Class.UNIVERSAL,
							type: ee.Type.OID,
							constructed: !1,
							capture: "algorithmIdentifier",
						},
						{
							name: "DigestInfo.DigestAlgorithm.parameters",
							tagClass: ee.Class.UNIVERSAL,
							type: ee.Type.NULL,
							capture: "parameters",
							optional: !0,
							constructed: !1,
						},
					],
				},
				{
					name: "DigestInfo.digest",
					tagClass: ee.Class.UNIVERSAL,
					type: ee.Type.OCTETSTRING,
					constructed: !1,
					capture: "digest",
				},
			],
		},
		YZe = function (e) {
			var t
			if (e.algorithm in kt.oids) t = kt.oids[e.algorithm]
			else {
				var r = new Error("Unknown message digest algorithm.")
				throw ((r.algorithm = e.algorithm), r)
			}
			var n = ee.oidToDer(t).getBytes(),
				i = ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, !0, []),
				s = ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, !0, [])
			s.value.push(ee.create(ee.Class.UNIVERSAL, ee.Type.OID, !1, n)),
				s.value.push(ee.create(ee.Class.UNIVERSAL, ee.Type.NULL, !1, ""))
			var o = ee.create(ee.Class.UNIVERSAL, ee.Type.OCTETSTRING, !1, e.digest().getBytes())
			return i.value.push(s), i.value.push(o), ee.toDer(i).getBytes()
		},
		Jle = function (e, t, r) {
			if (r) return e.modPow(t.e, t.n)
			if (!t.p || !t.q) return e.modPow(t.d, t.n)
			t.dP || (t.dP = t.d.mod(t.p.subtract(br.ONE))),
				t.dQ || (t.dQ = t.d.mod(t.q.subtract(br.ONE))),
				t.qInv || (t.qInv = t.q.modInverse(t.p))
			var n
			do n = new br(rt.util.bytesToHex(rt.random.getBytes(t.n.bitLength() / 8)), 16)
			while (n.compareTo(t.n) >= 0 || !n.gcd(t.n).equals(br.ONE))
			e = e.multiply(n.modPow(t.e, t.n)).mod(t.n)
			for (var i = e.mod(t.p).modPow(t.dP, t.p), s = e.mod(t.q).modPow(t.dQ, t.q); i.compareTo(s) < 0; )
				i = i.add(t.p)
			var o = i.subtract(s).multiply(t.qInv).mod(t.p).multiply(t.q).add(s)
			return (o = o.multiply(n.modInverse(t.n)).mod(t.n)), o
		}
	kt.rsa.encrypt = function (e, t, r) {
		var n = r,
			i,
			s = Math.ceil(t.n.bitLength() / 8)
		r !== !1 && r !== !0 ? ((n = r === 2), (i = zle(e, t, r))) : ((i = rt.util.createBuffer()), i.putBytes(e))
		for (
			var o = new br(i.toHex(), 16),
				a = Jle(o, t, n),
				l = a.toString(16),
				c = rt.util.createBuffer(),
				u = s - Math.ceil(l.length / 2);
			u > 0;

		)
			c.putByte(0), --u
		return c.putBytes(rt.util.hexToBytes(l)), c.getBytes()
	}
	kt.rsa.decrypt = function (e, t, r, n) {
		var i = Math.ceil(t.n.bitLength() / 8)
		if (e.length !== i) {
			var s = new Error("Encrypted message length is invalid.")
			throw ((s.length = e.length), (s.expected = i), s)
		}
		var o = new br(rt.util.createBuffer(e).toHex(), 16)
		if (o.compareTo(t.n) >= 0) throw new Error("Encrypted message is invalid.")
		for (
			var a = Jle(o, t, r), l = a.toString(16), c = rt.util.createBuffer(), u = i - Math.ceil(l.length / 2);
			u > 0;

		)
			c.putByte(0), --u
		return c.putBytes(rt.util.hexToBytes(l)), n !== !1 ? yT(c.getBytes(), t, r) : c.getBytes()
	}
	kt.rsa.createKeyPairGenerationState = function (e, t, r) {
		typeof e == "string" && (e = parseInt(e, 10)), (e = e || 2048), (r = r || {})
		var n = r.prng || rt.random,
			i = {
				nextBytes: function (a) {
					for (var l = n.getBytesSync(a.length), c = 0; c < a.length; ++c) a[c] = l.charCodeAt(c)
				},
			},
			s = r.algorithm || "PRIMEINC",
			o
		if (s === "PRIMEINC")
			(o = {
				algorithm: s,
				state: 0,
				bits: e,
				rng: i,
				eInt: t || 65537,
				e: new br(null),
				p: null,
				q: null,
				qBits: e >> 1,
				pBits: e - (e >> 1),
				pqState: 0,
				num: null,
				keys: null,
			}),
				o.e.fromInt(o.eInt)
		else throw new Error("Invalid key generation algorithm: " + s)
		return o
	}
	kt.rsa.stepKeyPairGenerationState = function (e, t) {
		"algorithm" in e || (e.algorithm = "PRIMEINC")
		var r = new br(null)
		r.fromInt(30)
		for (
			var n = 0,
				i = function (f, p) {
					return f | p
				},
				s = +new Date(),
				o,
				a = 0;
			e.keys === null && (t <= 0 || a < t);

		) {
			if (e.state === 0) {
				var l = e.p === null ? e.pBits : e.qBits,
					c = l - 1
				e.pqState === 0
					? ((e.num = new br(l, e.rng)),
						e.num.testBit(c) || e.num.bitwiseTo(br.ONE.shiftLeft(c), i, e.num),
						e.num.dAddOffset(31 - e.num.mod(r).byteValue(), 0),
						(n = 0),
						++e.pqState)
					: e.pqState === 1
						? e.num.bitLength() > l
							? (e.pqState = 0)
							: e.num.isProbablePrime(JZe(e.num.bitLength()))
								? ++e.pqState
								: e.num.dAddOffset(qZe[n++ % 8], 0)
						: e.pqState === 2
							? (e.pqState = e.num.subtract(br.ONE).gcd(e.e).compareTo(br.ONE) === 0 ? 3 : 0)
							: e.pqState === 3 &&
								((e.pqState = 0),
								e.p === null ? (e.p = e.num) : (e.q = e.num),
								e.p !== null && e.q !== null && ++e.state,
								(e.num = null))
			} else if (e.state === 1) e.p.compareTo(e.q) < 0 && ((e.num = e.p), (e.p = e.q), (e.q = e.num)), ++e.state
			else if (e.state === 2)
				(e.p1 = e.p.subtract(br.ONE)), (e.q1 = e.q.subtract(br.ONE)), (e.phi = e.p1.multiply(e.q1)), ++e.state
			else if (e.state === 3)
				e.phi.gcd(e.e).compareTo(br.ONE) === 0 ? ++e.state : ((e.p = null), (e.q = null), (e.state = 0))
			else if (e.state === 4)
				(e.n = e.p.multiply(e.q)), e.n.bitLength() === e.bits ? ++e.state : ((e.q = null), (e.state = 0))
			else if (e.state === 5) {
				var u = e.e.modInverse(e.phi)
				e.keys = {
					privateKey: kt.rsa.setPrivateKey(
						e.n,
						e.e,
						u,
						e.p,
						e.q,
						u.mod(e.p1),
						u.mod(e.q1),
						e.q.modInverse(e.p),
					),
					publicKey: kt.rsa.setPublicKey(e.n, e.e),
				}
			}
			;(o = +new Date()), (a += o - s), (s = o)
		}
		return e.keys !== null
	}
	kt.rsa.generateKeyPair = function (e, t, r, n) {
		if (
			(arguments.length === 1
				? typeof e == "object"
					? ((r = e), (e = void 0))
					: typeof e == "function" && ((n = e), (e = void 0))
				: arguments.length === 2
					? typeof e == "number"
						? typeof t == "function"
							? ((n = t), (t = void 0))
							: typeof t != "number" && ((r = t), (t = void 0))
						: ((r = e), (n = t), (e = void 0), (t = void 0))
					: arguments.length === 3 &&
						(typeof t == "number"
							? typeof r == "function" && ((n = r), (r = void 0))
							: ((n = r), (r = t), (t = void 0))),
			(r = r || {}),
			e === void 0 && (e = r.bits || 2048),
			t === void 0 && (t = r.e || 65537),
			!rt.options.usePureJavaScript && !r.prng && e >= 256 && e <= 16384 && (t === 65537 || t === 3))
		) {
			if (n) {
				if (Gle("generateKeyPair"))
					return R5.generateKeyPair(
						"rsa",
						{
							modulusLength: e,
							publicExponent: t,
							publicKeyEncoding: { type: "spki", format: "pem" },
							privateKeyEncoding: { type: "pkcs8", format: "pem" },
						},
						function (a, l, c) {
							if (a) return n(a)
							n(null, {
								privateKey: kt.privateKeyFromPem(c),
								publicKey: kt.publicKeyFromPem(l),
							})
						},
					)
				if ($le("generateKey") && $le("exportKey"))
					return dl.globalScope.crypto.subtle
						.generateKey(
							{
								name: "RSASSA-PKCS1-v1_5",
								modulusLength: e,
								publicExponent: Kle(t),
								hash: { name: "SHA-256" },
							},
							!0,
							["sign", "verify"],
						)
						.then(function (a) {
							return dl.globalScope.crypto.subtle.exportKey("pkcs8", a.privateKey)
						})
						.then(void 0, function (a) {
							n(a)
						})
						.then(function (a) {
							if (a) {
								var l = kt.privateKeyFromAsn1(ee.fromDer(rt.util.createBuffer(a)))
								n(null, {
									privateKey: l,
									publicKey: kt.setRsaPublicKey(l.n, l.e),
								})
							}
						})
				if (Yle("generateKey") && Yle("exportKey")) {
					var i = dl.globalScope.msCrypto.subtle.generateKey(
						{
							name: "RSASSA-PKCS1-v1_5",
							modulusLength: e,
							publicExponent: Kle(t),
							hash: { name: "SHA-256" },
						},
						!0,
						["sign", "verify"],
					)
					;(i.oncomplete = function (a) {
						var l = a.target.result,
							c = dl.globalScope.msCrypto.subtle.exportKey("pkcs8", l.privateKey)
						;(c.oncomplete = function (u) {
							var f = u.target.result,
								p = kt.privateKeyFromAsn1(ee.fromDer(rt.util.createBuffer(f)))
							n(null, {
								privateKey: p,
								publicKey: kt.setRsaPublicKey(p.n, p.e),
							})
						}),
							(c.onerror = function (u) {
								n(u)
							})
					}),
						(i.onerror = function (a) {
							n(a)
						})
					return
				}
			} else if (Gle("generateKeyPairSync")) {
				var s = R5.generateKeyPairSync("rsa", {
					modulusLength: e,
					publicExponent: t,
					publicKeyEncoding: { type: "spki", format: "pem" },
					privateKeyEncoding: { type: "pkcs8", format: "pem" },
				})
				return {
					privateKey: kt.privateKeyFromPem(s.privateKey),
					publicKey: kt.publicKeyFromPem(s.publicKey),
				}
			}
		}
		var o = kt.rsa.createKeyPairGenerationState(e, t, r)
		if (!n) return kt.rsa.stepKeyPairGenerationState(o, 0), o.keys
		KZe(o, r, n)
	}
	kt.setRsaPublicKey = kt.rsa.setPublicKey = function (e, t) {
		var r = { n: e, e: t }
		return (
			(r.encrypt = function (n, i, s) {
				if (
					(typeof i == "string" ? (i = i.toUpperCase()) : i === void 0 && (i = "RSAES-PKCS1-V1_5"),
					i === "RSAES-PKCS1-V1_5")
				)
					i = {
						encode: function (a, l, c) {
							return zle(a, l, 2).getBytes()
						},
					}
				else if (i === "RSA-OAEP" || i === "RSAES-OAEP")
					i = {
						encode: function (a, l) {
							return rt.pkcs1.encode_rsa_oaep(l, a, s)
						},
					}
				else if (["RAW", "NONE", "NULL", null].indexOf(i) !== -1)
					i = {
						encode: function (a) {
							return a
						},
					}
				else if (typeof i == "string") throw new Error('Unsupported encryption scheme: "' + i + '".')
				var o = i.encode(n, r, !0)
				return kt.rsa.encrypt(o, r, !0)
			}),
			(r.verify = function (n, i, s, o) {
				typeof s == "string" ? (s = s.toUpperCase()) : s === void 0 && (s = "RSASSA-PKCS1-V1_5"),
					o === void 0 && (o = { _parseAllDigestBytes: !0 }),
					"_parseAllDigestBytes" in o || (o._parseAllDigestBytes = !0),
					s === "RSASSA-PKCS1-V1_5"
						? (s = {
								verify: function (l, c) {
									c = yT(c, r, !0)
									var u = ee.fromDer(c, {
											parseAllBytes: o._parseAllDigestBytes,
										}),
										f = {},
										p = []
									if (!ee.validate(u, $Ze, f, p)) {
										var g = new Error(
											"ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.",
										)
										throw ((g.errors = p), g)
									}
									var m = ee.derToOid(f.algorithmIdentifier)
									if (
										!(
											m === rt.oids.md2 ||
											m === rt.oids.md5 ||
											m === rt.oids.sha1 ||
											m === rt.oids.sha224 ||
											m === rt.oids.sha256 ||
											m === rt.oids.sha384 ||
											m === rt.oids.sha512 ||
											m === rt.oids["sha512-224"] ||
											m === rt.oids["sha512-256"]
										)
									) {
										var g = new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.")
										throw ((g.oid = m), g)
									}
									if ((m === rt.oids.md2 || m === rt.oids.md5) && !("parameters" in f))
										throw new Error(
											"ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.",
										)
									return l === f.digest
								},
							})
						: (s === "NONE" || s === "NULL" || s === null) &&
							(s = {
								verify: function (l, c) {
									return (c = yT(c, r, !0)), l === c
								},
							})
				var a = kt.rsa.decrypt(i, r, !0, !1)
				return s.verify(n, a, r.n.bitLength())
			}),
			r
		)
	}
	kt.setRsaPrivateKey = kt.rsa.setPrivateKey = function (e, t, r, n, i, s, o, a) {
		var l = { n: e, e: t, d: r, p: n, q: i, dP: s, dQ: o, qInv: a }
		return (
			(l.decrypt = function (c, u, f) {
				typeof u == "string" ? (u = u.toUpperCase()) : u === void 0 && (u = "RSAES-PKCS1-V1_5")
				var p = kt.rsa.decrypt(c, l, !1, !1)
				if (u === "RSAES-PKCS1-V1_5") u = { decode: yT }
				else if (u === "RSA-OAEP" || u === "RSAES-OAEP")
					u = {
						decode: function (g, m) {
							return rt.pkcs1.decode_rsa_oaep(m, g, f)
						},
					}
				else if (["RAW", "NONE", "NULL", null].indexOf(u) !== -1)
					u = {
						decode: function (g) {
							return g
						},
					}
				else throw new Error('Unsupported encryption scheme: "' + u + '".')
				return u.decode(p, l, !1)
			}),
			(l.sign = function (c, u) {
				var f = !1
				typeof u == "string" && (u = u.toUpperCase()),
					u === void 0 || u === "RSASSA-PKCS1-V1_5"
						? ((u = { encode: YZe }), (f = 1))
						: (u === "NONE" || u === "NULL" || u === null) &&
							((u = {
								encode: function () {
									return c
								},
							}),
							(f = 1))
				var p = u.encode(c, l.n.bitLength())
				return kt.rsa.encrypt(p, l, f)
			}),
			l
		)
	}
	kt.wrapRsaPrivateKey = function (e) {
		return ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, !0, [
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, ee.integerToDer(0).getBytes()),
			ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, !0, [
				ee.create(ee.Class.UNIVERSAL, ee.Type.OID, !1, ee.oidToDer(kt.oids.rsaEncryption).getBytes()),
				ee.create(ee.Class.UNIVERSAL, ee.Type.NULL, !1, ""),
			]),
			ee.create(ee.Class.UNIVERSAL, ee.Type.OCTETSTRING, !1, ee.toDer(e).getBytes()),
		])
	}
	kt.privateKeyFromAsn1 = function (e) {
		var t = {},
			r = []
		if (
			(ee.validate(e, VZe, t, r) && (e = ee.fromDer(rt.util.createBuffer(t.privateKey))),
			(t = {}),
			(r = []),
			!ee.validate(e, HZe, t, r))
		) {
			var n = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.")
			throw ((n.errors = r), n)
		}
		var i, s, o, a, l, c, u, f
		return (
			(i = rt.util.createBuffer(t.privateKeyModulus).toHex()),
			(s = rt.util.createBuffer(t.privateKeyPublicExponent).toHex()),
			(o = rt.util.createBuffer(t.privateKeyPrivateExponent).toHex()),
			(a = rt.util.createBuffer(t.privateKeyPrime1).toHex()),
			(l = rt.util.createBuffer(t.privateKeyPrime2).toHex()),
			(c = rt.util.createBuffer(t.privateKeyExponent1).toHex()),
			(u = rt.util.createBuffer(t.privateKeyExponent2).toHex()),
			(f = rt.util.createBuffer(t.privateKeyCoefficient).toHex()),
			kt.setRsaPrivateKey(
				new br(i, 16),
				new br(s, 16),
				new br(o, 16),
				new br(a, 16),
				new br(l, 16),
				new br(c, 16),
				new br(u, 16),
				new br(f, 16),
			)
		)
	}
	kt.privateKeyToAsn1 = kt.privateKeyToRSAPrivateKey = function (e) {
		return ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, !0, [
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, ee.integerToDer(0).getBytes()),
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, yu(e.n)),
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, yu(e.e)),
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, yu(e.d)),
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, yu(e.p)),
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, yu(e.q)),
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, yu(e.dP)),
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, yu(e.dQ)),
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, yu(e.qInv)),
		])
	}
	kt.publicKeyFromAsn1 = function (e) {
		var t = {},
			r = []
		if (ee.validate(e, GZe, t, r)) {
			var n = ee.derToOid(t.publicKeyOid)
			if (n !== kt.oids.rsaEncryption) {
				var i = new Error("Cannot read public key. Unknown OID.")
				throw ((i.oid = n), i)
			}
			e = t.rsaPublicKey
		}
		if (((r = []), !ee.validate(e, WZe, t, r))) {
			var i = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.")
			throw ((i.errors = r), i)
		}
		var s = rt.util.createBuffer(t.publicKeyModulus).toHex(),
			o = rt.util.createBuffer(t.publicKeyExponent).toHex()
		return kt.setRsaPublicKey(new br(s, 16), new br(o, 16))
	}
	kt.publicKeyToAsn1 = kt.publicKeyToSubjectPublicKeyInfo = function (e) {
		return ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, !0, [
			ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, !0, [
				ee.create(ee.Class.UNIVERSAL, ee.Type.OID, !1, ee.oidToDer(kt.oids.rsaEncryption).getBytes()),
				ee.create(ee.Class.UNIVERSAL, ee.Type.NULL, !1, ""),
			]),
			ee.create(ee.Class.UNIVERSAL, ee.Type.BITSTRING, !1, [kt.publicKeyToRSAPublicKey(e)]),
		])
	}
	kt.publicKeyToRSAPublicKey = function (e) {
		return ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, !0, [
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, yu(e.n)),
			ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, !1, yu(e.e)),
		])
	}
	function zle(e, t, r) {
		var n = rt.util.createBuffer(),
			i = Math.ceil(t.n.bitLength() / 8)
		if (e.length > i - 11) {
			var s = new Error("Message is too long for PKCS#1 v1.5 padding.")
			throw ((s.length = e.length), (s.max = i - 11), s)
		}
		n.putByte(0), n.putByte(r)
		var o = i - 3 - e.length,
			a
		if (r === 0 || r === 1) {
			a = r === 0 ? 0 : 255
			for (var l = 0; l < o; ++l) n.putByte(a)
		} else
			for (; o > 0; ) {
				for (var c = 0, u = rt.random.getBytes(o), l = 0; l < o; ++l)
					(a = u.charCodeAt(l)), a === 0 ? ++c : n.putByte(a)
				o = c
			}
		return n.putByte(0), n.putBytes(e), n
	}
	function yT(e, t, r, n) {
		var i = Math.ceil(t.n.bitLength() / 8),
			s = rt.util.createBuffer(e),
			o = s.getByte(),
			a = s.getByte()
		if (o !== 0 || (r && a !== 0 && a !== 1) || (!r && a != 2) || (r && a === 0 && typeof n > "u"))
			throw new Error("Encryption block is invalid.")
		var l = 0
		if (a === 0) {
			l = i - 3 - n
			for (var c = 0; c < l; ++c) if (s.getByte() !== 0) throw new Error("Encryption block is invalid.")
		} else if (a === 1)
			for (l = 0; s.length() > 1; ) {
				if (s.getByte() !== 255) {
					--s.read
					break
				}
				++l
			}
		else if (a === 2)
			for (l = 0; s.length() > 1; ) {
				if (s.getByte() === 0) {
					--s.read
					break
				}
				++l
			}
		var u = s.getByte()
		if (u !== 0 || l !== i - 3 - s.length()) throw new Error("Encryption block is invalid.")
		return s.getBytes()
	}
	function KZe(e, t, r) {
		typeof t == "function" && ((r = t), (t = {})), (t = t || {})
		var n = {
			algorithm: {
				name: t.algorithm || "PRIMEINC",
				options: {
					workers: t.workers || 2,
					workLoad: t.workLoad || 100,
					workerScript: t.workerScript,
				},
			},
		}
		"prng" in t && (n.prng = t.prng), i()
		function i() {
			s(e.pBits, function (a, l) {
				if (a) return r(a)
				if (((e.p = l), e.q !== null)) return o(a, e.q)
				s(e.qBits, o)
			})
		}
		function s(a, l) {
			rt.prime.generateProbablePrime(a, n, l)
		}
		function o(a, l) {
			if (a) return r(a)
			if (((e.q = l), e.p.compareTo(e.q) < 0)) {
				var c = e.p
				;(e.p = e.q), (e.q = c)
			}
			if (e.p.subtract(br.ONE).gcd(e.e).compareTo(br.ONE) !== 0) {
				;(e.p = null), i()
				return
			}
			if (e.q.subtract(br.ONE).gcd(e.e).compareTo(br.ONE) !== 0) {
				;(e.q = null), s(e.qBits, o)
				return
			}
			if (
				((e.p1 = e.p.subtract(br.ONE)),
				(e.q1 = e.q.subtract(br.ONE)),
				(e.phi = e.p1.multiply(e.q1)),
				e.phi.gcd(e.e).compareTo(br.ONE) !== 0)
			) {
				;(e.p = e.q = null), i()
				return
			}
			if (((e.n = e.p.multiply(e.q)), e.n.bitLength() !== e.bits)) {
				;(e.q = null), s(e.qBits, o)
				return
			}
			var u = e.e.modInverse(e.phi)
			;(e.keys = {
				privateKey: kt.rsa.setPrivateKey(e.n, e.e, u, e.p, e.q, u.mod(e.p1), u.mod(e.q1), e.q.modInverse(e.p)),
				publicKey: kt.rsa.setPublicKey(e.n, e.e),
			}),
				r(null, e.keys)
		}
	}
	function yu(e) {
		var t = e.toString(16)
		t[0] >= "8" && (t = "00" + t)
		var r = rt.util.hexToBytes(t)
		return r.length > 1 &&
			((r.charCodeAt(0) === 0 && !(r.charCodeAt(1) & 128)) ||
				(r.charCodeAt(0) === 255 && (r.charCodeAt(1) & 128) === 128))
			? r.substr(1)
			: r
	}
	function JZe(e) {
		return e <= 100
			? 27
			: e <= 150
				? 18
				: e <= 200
					? 15
					: e <= 250
						? 12
						: e <= 300
							? 9
							: e <= 350
								? 8
								: e <= 400
									? 7
									: e <= 500
										? 6
										: e <= 600
											? 5
											: e <= 800
												? 4
												: e <= 1250
													? 3
													: 2
	}
	function Gle(e) {
		return rt.util.isNodejs && typeof R5[e] == "function"
	}
	function $le(e) {
		return (
			typeof dl.globalScope < "u" &&
			typeof dl.globalScope.crypto == "object" &&
			typeof dl.globalScope.crypto.subtle == "object" &&
			typeof dl.globalScope.crypto.subtle[e] == "function"
		)
	}
	function Yle(e) {
		return (
			typeof dl.globalScope < "u" &&
			typeof dl.globalScope.msCrypto == "object" &&
			typeof dl.globalScope.msCrypto.subtle == "object" &&
			typeof dl.globalScope.msCrypto.subtle[e] == "function"
		)
	}
	function Kle(e) {
		for (var t = rt.util.hexToBytes(e.toString(16)), r = new Uint8Array(t.length), n = 0; n < t.length; ++n)
			r[n] = t.charCodeAt(n)
		return r
	}
})
var k5 = x((nBt, rce) => {
	"use strict"
	var Ne = Yt()
	uh()
	gc()
	Bb()
	du()
	dh()
	hT()
	_p()
	cl()
	x5()
	Rb()
	Sr()
	typeof Zle > "u" && (Zle = Ne.jsbn.BigInteger)
	var Zle,
		ae = Ne.asn1,
		Wt = (Ne.pki = Ne.pki || {})
	rce.exports = Wt.pbe = Ne.pbe = Ne.pbe || {}
	var Sp = Wt.oids,
		zZe = {
			name: "EncryptedPrivateKeyInfo",
			tagClass: ae.Class.UNIVERSAL,
			type: ae.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
					tagClass: ae.Class.UNIVERSAL,
					type: ae.Type.SEQUENCE,
					constructed: !0,
					value: [
						{
							name: "AlgorithmIdentifier.algorithm",
							tagClass: ae.Class.UNIVERSAL,
							type: ae.Type.OID,
							constructed: !1,
							capture: "encryptionOid",
						},
						{
							name: "AlgorithmIdentifier.parameters",
							tagClass: ae.Class.UNIVERSAL,
							type: ae.Type.SEQUENCE,
							constructed: !0,
							captureAsn1: "encryptionParams",
						},
					],
				},
				{
					name: "EncryptedPrivateKeyInfo.encryptedData",
					tagClass: ae.Class.UNIVERSAL,
					type: ae.Type.OCTETSTRING,
					constructed: !1,
					capture: "encryptedData",
				},
			],
		},
		jZe = {
			name: "PBES2Algorithms",
			tagClass: ae.Class.UNIVERSAL,
			type: ae.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "PBES2Algorithms.keyDerivationFunc",
					tagClass: ae.Class.UNIVERSAL,
					type: ae.Type.SEQUENCE,
					constructed: !0,
					value: [
						{
							name: "PBES2Algorithms.keyDerivationFunc.oid",
							tagClass: ae.Class.UNIVERSAL,
							type: ae.Type.OID,
							constructed: !1,
							capture: "kdfOid",
						},
						{
							name: "PBES2Algorithms.params",
							tagClass: ae.Class.UNIVERSAL,
							type: ae.Type.SEQUENCE,
							constructed: !0,
							value: [
								{
									name: "PBES2Algorithms.params.salt",
									tagClass: ae.Class.UNIVERSAL,
									type: ae.Type.OCTETSTRING,
									constructed: !1,
									capture: "kdfSalt",
								},
								{
									name: "PBES2Algorithms.params.iterationCount",
									tagClass: ae.Class.UNIVERSAL,
									type: ae.Type.INTEGER,
									constructed: !1,
									capture: "kdfIterationCount",
								},
								{
									name: "PBES2Algorithms.params.keyLength",
									tagClass: ae.Class.UNIVERSAL,
									type: ae.Type.INTEGER,
									constructed: !1,
									optional: !0,
									capture: "keyLength",
								},
								{
									name: "PBES2Algorithms.params.prf",
									tagClass: ae.Class.UNIVERSAL,
									type: ae.Type.SEQUENCE,
									constructed: !0,
									optional: !0,
									value: [
										{
											name: "PBES2Algorithms.params.prf.algorithm",
											tagClass: ae.Class.UNIVERSAL,
											type: ae.Type.OID,
											constructed: !1,
											capture: "prfOid",
										},
									],
								},
							],
						},
					],
				},
				{
					name: "PBES2Algorithms.encryptionScheme",
					tagClass: ae.Class.UNIVERSAL,
					type: ae.Type.SEQUENCE,
					constructed: !0,
					value: [
						{
							name: "PBES2Algorithms.encryptionScheme.oid",
							tagClass: ae.Class.UNIVERSAL,
							type: ae.Type.OID,
							constructed: !1,
							capture: "encOid",
						},
						{
							name: "PBES2Algorithms.encryptionScheme.iv",
							tagClass: ae.Class.UNIVERSAL,
							type: ae.Type.OCTETSTRING,
							constructed: !1,
							capture: "encIv",
						},
					],
				},
			],
		},
		ZZe = {
			name: "pkcs-12PbeParams",
			tagClass: ae.Class.UNIVERSAL,
			type: ae.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "pkcs-12PbeParams.salt",
					tagClass: ae.Class.UNIVERSAL,
					type: ae.Type.OCTETSTRING,
					constructed: !1,
					capture: "salt",
				},
				{
					name: "pkcs-12PbeParams.iterations",
					tagClass: ae.Class.UNIVERSAL,
					type: ae.Type.INTEGER,
					constructed: !1,
					capture: "iterations",
				},
			],
		}
	Wt.encryptPrivateKeyInfo = function (e, t, r) {
		;(r = r || {}),
			(r.saltSize = r.saltSize || 8),
			(r.count = r.count || 2048),
			(r.algorithm = r.algorithm || "aes128"),
			(r.prfAlgorithm = r.prfAlgorithm || "sha1")
		var n = Ne.random.getBytesSync(r.saltSize),
			i = r.count,
			s = ae.integerToDer(i),
			o,
			a,
			l
		if (r.algorithm.indexOf("aes") === 0 || r.algorithm === "des") {
			var c, u, f
			switch (r.algorithm) {
				case "aes128":
					;(o = 16), (c = 16), (u = Sp["aes128-CBC"]), (f = Ne.aes.createEncryptionCipher)
					break
				case "aes192":
					;(o = 24), (c = 16), (u = Sp["aes192-CBC"]), (f = Ne.aes.createEncryptionCipher)
					break
				case "aes256":
					;(o = 32), (c = 16), (u = Sp["aes256-CBC"]), (f = Ne.aes.createEncryptionCipher)
					break
				case "des":
					;(o = 8), (c = 8), (u = Sp.desCBC), (f = Ne.des.createEncryptionCipher)
					break
				default:
					var p = new Error("Cannot encrypt private key. Unknown encryption algorithm.")
					throw ((p.algorithm = r.algorithm), p)
			}
			var g = "hmacWith" + r.prfAlgorithm.toUpperCase(),
				m = tce(g),
				y = Ne.pkcs5.pbkdf2(t, n, i, o, m),
				C = Ne.random.getBytesSync(c),
				v = f(y)
			v.start(C), v.update(ae.toDer(e)), v.finish(), (l = v.output.getBytes())
			var b = XZe(n, s, o, g)
			a = ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
				ae.create(ae.Class.UNIVERSAL, ae.Type.OID, !1, ae.oidToDer(Sp.pkcs5PBES2).getBytes()),
				ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
					ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
						ae.create(ae.Class.UNIVERSAL, ae.Type.OID, !1, ae.oidToDer(Sp.pkcs5PBKDF2).getBytes()),
						b,
					]),
					ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
						ae.create(ae.Class.UNIVERSAL, ae.Type.OID, !1, ae.oidToDer(u).getBytes()),
						ae.create(ae.Class.UNIVERSAL, ae.Type.OCTETSTRING, !1, C),
					]),
				]),
			])
		} else if (r.algorithm === "3des") {
			o = 24
			var w = new Ne.util.ByteBuffer(n),
				y = Wt.pbe.generatePkcs12Key(t, w, 1, i, o),
				C = Wt.pbe.generatePkcs12Key(t, w, 2, i, o),
				v = Ne.des.createEncryptionCipher(y)
			v.start(C),
				v.update(ae.toDer(e)),
				v.finish(),
				(l = v.output.getBytes()),
				(a = ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
					ae.create(
						ae.Class.UNIVERSAL,
						ae.Type.OID,
						!1,
						ae.oidToDer(Sp["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes(),
					),
					ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
						ae.create(ae.Class.UNIVERSAL, ae.Type.OCTETSTRING, !1, n),
						ae.create(ae.Class.UNIVERSAL, ae.Type.INTEGER, !1, s.getBytes()),
					]),
				]))
		} else {
			var p = new Error("Cannot encrypt private key. Unknown encryption algorithm.")
			throw ((p.algorithm = r.algorithm), p)
		}
		var B = ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
			a,
			ae.create(ae.Class.UNIVERSAL, ae.Type.OCTETSTRING, !1, l),
		])
		return B
	}
	Wt.decryptPrivateKeyInfo = function (e, t) {
		var r = null,
			n = {},
			i = []
		if (!ae.validate(e, zZe, n, i)) {
			var s = new Error(
				"Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
			)
			throw ((s.errors = i), s)
		}
		var o = ae.derToOid(n.encryptionOid),
			a = Wt.pbe.getCipher(o, n.encryptionParams, t),
			l = Ne.util.createBuffer(n.encryptedData)
		return a.update(l), a.finish() && (r = ae.fromDer(a.output)), r
	}
	Wt.encryptedPrivateKeyToPem = function (e, t) {
		var r = { type: "ENCRYPTED PRIVATE KEY", body: ae.toDer(e).getBytes() }
		return Ne.pem.encode(r, { maxline: t })
	}
	Wt.encryptedPrivateKeyFromPem = function (e) {
		var t = Ne.pem.decode(e)[0]
		if (t.type !== "ENCRYPTED PRIVATE KEY") {
			var r = new Error(
				'Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".',
			)
			throw ((r.headerType = t.type), r)
		}
		if (t.procType && t.procType.type === "ENCRYPTED")
			throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.")
		return ae.fromDer(t.body)
	}
	Wt.encryptRsaPrivateKey = function (e, t, r) {
		if (((r = r || {}), !r.legacy)) {
			var n = Wt.wrapRsaPrivateKey(Wt.privateKeyToAsn1(e))
			return (n = Wt.encryptPrivateKeyInfo(n, t, r)), Wt.encryptedPrivateKeyToPem(n)
		}
		var i, s, o, a
		switch (r.algorithm) {
			case "aes128":
				;(i = "AES-128-CBC"), (o = 16), (s = Ne.random.getBytesSync(16)), (a = Ne.aes.createEncryptionCipher)
				break
			case "aes192":
				;(i = "AES-192-CBC"), (o = 24), (s = Ne.random.getBytesSync(16)), (a = Ne.aes.createEncryptionCipher)
				break
			case "aes256":
				;(i = "AES-256-CBC"), (o = 32), (s = Ne.random.getBytesSync(16)), (a = Ne.aes.createEncryptionCipher)
				break
			case "3des":
				;(i = "DES-EDE3-CBC"), (o = 24), (s = Ne.random.getBytesSync(8)), (a = Ne.des.createEncryptionCipher)
				break
			case "des":
				;(i = "DES-CBC"), (o = 8), (s = Ne.random.getBytesSync(8)), (a = Ne.des.createEncryptionCipher)
				break
			default:
				var l = new Error(
					'Could not encrypt RSA private key; unsupported encryption algorithm "' + r.algorithm + '".',
				)
				throw ((l.algorithm = r.algorithm), l)
		}
		var c = Ne.pbe.opensslDeriveBytes(t, s.substr(0, 8), o),
			u = a(c)
		u.start(s), u.update(ae.toDer(Wt.privateKeyToAsn1(e))), u.finish()
		var f = {
			type: "RSA PRIVATE KEY",
			procType: { version: "4", type: "ENCRYPTED" },
			dekInfo: {
				algorithm: i,
				parameters: Ne.util.bytesToHex(s).toUpperCase(),
			},
			body: u.output.getBytes(),
		}
		return Ne.pem.encode(f)
	}
	Wt.decryptRsaPrivateKey = function (e, t) {
		var r = null,
			n = Ne.pem.decode(e)[0]
		if (n.type !== "ENCRYPTED PRIVATE KEY" && n.type !== "PRIVATE KEY" && n.type !== "RSA PRIVATE KEY") {
			var i = new Error(
				'Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".',
			)
			throw ((i.headerType = i), i)
		}
		if (n.procType && n.procType.type === "ENCRYPTED") {
			var s, o
			switch (n.dekInfo.algorithm) {
				case "DES-CBC":
					;(s = 8), (o = Ne.des.createDecryptionCipher)
					break
				case "DES-EDE3-CBC":
					;(s = 24), (o = Ne.des.createDecryptionCipher)
					break
				case "AES-128-CBC":
					;(s = 16), (o = Ne.aes.createDecryptionCipher)
					break
				case "AES-192-CBC":
					;(s = 24), (o = Ne.aes.createDecryptionCipher)
					break
				case "AES-256-CBC":
					;(s = 32), (o = Ne.aes.createDecryptionCipher)
					break
				case "RC2-40-CBC":
					;(s = 5),
						(o = function (f) {
							return Ne.rc2.createDecryptionCipher(f, 40)
						})
					break
				case "RC2-64-CBC":
					;(s = 8),
						(o = function (f) {
							return Ne.rc2.createDecryptionCipher(f, 64)
						})
					break
				case "RC2-128-CBC":
					;(s = 16),
						(o = function (f) {
							return Ne.rc2.createDecryptionCipher(f, 128)
						})
					break
				default:
					var i = new Error(
						'Could not decrypt private key; unsupported encryption algorithm "' +
							n.dekInfo.algorithm +
							'".',
					)
					throw ((i.algorithm = n.dekInfo.algorithm), i)
			}
			var a = Ne.util.hexToBytes(n.dekInfo.parameters),
				l = Ne.pbe.opensslDeriveBytes(t, a.substr(0, 8), s),
				c = o(l)
			if ((c.start(a), c.update(Ne.util.createBuffer(n.body)), c.finish())) r = c.output.getBytes()
			else return r
		} else r = n.body
		return (
			n.type === "ENCRYPTED PRIVATE KEY" ? (r = Wt.decryptPrivateKeyInfo(ae.fromDer(r), t)) : (r = ae.fromDer(r)),
			r !== null && (r = Wt.privateKeyFromAsn1(r)),
			r
		)
	}
	Wt.pbe.generatePkcs12Key = function (e, t, r, n, i, s) {
		var o, a
		if (typeof s > "u" || s === null) {
			if (!("sha1" in Ne.md)) throw new Error('"sha1" hash algorithm unavailable.')
			s = Ne.md.sha1.create()
		}
		var l = s.digestLength,
			c = s.blockLength,
			u = new Ne.util.ByteBuffer(),
			f = new Ne.util.ByteBuffer()
		if (e != null) {
			for (a = 0; a < e.length; a++) f.putInt16(e.charCodeAt(a))
			f.putInt16(0)
		}
		var p = f.length(),
			g = t.length(),
			m = new Ne.util.ByteBuffer()
		m.fillWithByte(r, c)
		var y = c * Math.ceil(g / c),
			C = new Ne.util.ByteBuffer()
		for (a = 0; a < y; a++) C.putByte(t.at(a % g))
		var v = c * Math.ceil(p / c),
			b = new Ne.util.ByteBuffer()
		for (a = 0; a < v; a++) b.putByte(f.at(a % p))
		var w = C
		w.putBuffer(b)
		for (var B = Math.ceil(i / l), M = 1; M <= B; M++) {
			var Q = new Ne.util.ByteBuffer()
			Q.putBytes(m.bytes()), Q.putBytes(w.bytes())
			for (var O = 0; O < n; O++) s.start(), s.update(Q.getBytes()), (Q = s.digest())
			var Y = new Ne.util.ByteBuffer()
			for (a = 0; a < c; a++) Y.putByte(Q.at(a % l))
			var j = Math.ceil(g / c) + Math.ceil(p / c),
				ne = new Ne.util.ByteBuffer()
			for (o = 0; o < j; o++) {
				var q = new Ne.util.ByteBuffer(w.getBytes(c)),
					me = 511
				for (a = Y.length() - 1; a >= 0; a--) (me = me >> 8), (me += Y.at(a) + q.at(a)), q.setAt(a, me & 255)
				ne.putBuffer(q)
			}
			;(w = ne), u.putBuffer(Q)
		}
		return u.truncate(u.length() - i), u
	}
	Wt.pbe.getCipher = function (e, t, r) {
		switch (e) {
			case Wt.oids.pkcs5PBES2:
				return Wt.pbe.getCipherForPBES2(e, t, r)
			case Wt.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
			case Wt.oids["pbewithSHAAnd40BitRC2-CBC"]:
				return Wt.pbe.getCipherForPKCS12PBE(e, t, r)
			default:
				var n = new Error("Cannot read encrypted PBE data block. Unsupported OID.")
				throw (
					((n.oid = e),
					(n.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"]),
					n)
				)
		}
	}
	Wt.pbe.getCipherForPBES2 = function (e, t, r) {
		var n = {},
			i = []
		if (!ae.validate(t, jZe, n, i)) {
			var s = new Error(
				"Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
			)
			throw ((s.errors = i), s)
		}
		if (((e = ae.derToOid(n.kdfOid)), e !== Wt.oids.pkcs5PBKDF2)) {
			var s = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.")
			throw ((s.oid = e), (s.supportedOids = ["pkcs5PBKDF2"]), s)
		}
		if (
			((e = ae.derToOid(n.encOid)),
			e !== Wt.oids["aes128-CBC"] &&
				e !== Wt.oids["aes192-CBC"] &&
				e !== Wt.oids["aes256-CBC"] &&
				e !== Wt.oids["des-EDE3-CBC"] &&
				e !== Wt.oids.desCBC)
		) {
			var s = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.")
			throw (
				((s.oid = e),
				(s.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"]),
				s)
			)
		}
		var o = n.kdfSalt,
			a = Ne.util.createBuffer(n.kdfIterationCount)
		a = a.getInt(a.length() << 3)
		var l, c
		switch (Wt.oids[e]) {
			case "aes128-CBC":
				;(l = 16), (c = Ne.aes.createDecryptionCipher)
				break
			case "aes192-CBC":
				;(l = 24), (c = Ne.aes.createDecryptionCipher)
				break
			case "aes256-CBC":
				;(l = 32), (c = Ne.aes.createDecryptionCipher)
				break
			case "des-EDE3-CBC":
				;(l = 24), (c = Ne.des.createDecryptionCipher)
				break
			case "desCBC":
				;(l = 8), (c = Ne.des.createDecryptionCipher)
				break
		}
		var u = ece(n.prfOid),
			f = Ne.pkcs5.pbkdf2(r, o, a, l, u),
			p = n.encIv,
			g = c(f)
		return g.start(p), g
	}
	Wt.pbe.getCipherForPKCS12PBE = function (e, t, r) {
		var n = {},
			i = []
		if (!ae.validate(t, ZZe, n, i)) {
			var s = new Error(
				"Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
			)
			throw ((s.errors = i), s)
		}
		var o = Ne.util.createBuffer(n.salt),
			a = Ne.util.createBuffer(n.iterations)
		a = a.getInt(a.length() << 3)
		var l, c, u
		switch (e) {
			case Wt.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
				;(l = 24), (c = 8), (u = Ne.des.startDecrypting)
				break
			case Wt.oids["pbewithSHAAnd40BitRC2-CBC"]:
				;(l = 5),
					(c = 8),
					(u = function (y, C) {
						var v = Ne.rc2.createDecryptionCipher(y, 40)
						return v.start(C, null), v
					})
				break
			default:
				var s = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.")
				throw ((s.oid = e), s)
		}
		var f = ece(n.prfOid),
			p = Wt.pbe.generatePkcs12Key(r, o, 1, a, l, f)
		f.start()
		var g = Wt.pbe.generatePkcs12Key(r, o, 2, a, c, f)
		return u(p, g)
	}
	Wt.pbe.opensslDeriveBytes = function (e, t, r, n) {
		if (typeof n > "u" || n === null) {
			if (!("md5" in Ne.md)) throw new Error('"md5" hash algorithm unavailable.')
			n = Ne.md.md5.create()
		}
		t === null && (t = "")
		for (var i = [Xle(n, e + t)], s = 16, o = 1; s < r; ++o, s += 16) i.push(Xle(n, i[o - 1] + e + t))
		return i.join("").substr(0, r)
	}
	function Xle(e, t) {
		return e.start().update(t).digest().getBytes()
	}
	function ece(e) {
		var t
		if (!e) t = "hmacWithSHA1"
		else if (((t = Wt.oids[ae.derToOid(e)]), !t)) {
			var r = new Error("Unsupported PRF OID.")
			throw (
				((r.oid = e),
				(r.supported = [
					"hmacWithSHA1",
					"hmacWithSHA224",
					"hmacWithSHA256",
					"hmacWithSHA384",
					"hmacWithSHA512",
				]),
				r)
			)
		}
		return tce(t)
	}
	function tce(e) {
		var t = Ne.md
		switch (e) {
			case "hmacWithSHA224":
				t = Ne.md.sha512
			case "hmacWithSHA1":
			case "hmacWithSHA256":
			case "hmacWithSHA384":
			case "hmacWithSHA512":
				e = e.substr(8).toLowerCase()
				break
			default:
				var r = new Error("Unsupported PRF algorithm.")
				throw (
					((r.algorithm = e),
					(r.supported = [
						"hmacWithSHA1",
						"hmacWithSHA224",
						"hmacWithSHA256",
						"hmacWithSHA384",
						"hmacWithSHA512",
					]),
					r)
				)
		}
		if (!t || !(e in t)) throw new Error("Unknown hash algorithm: " + e)
		return t[e].create()
	}
	function XZe(e, t, r, n) {
		var i = ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
			ae.create(ae.Class.UNIVERSAL, ae.Type.OCTETSTRING, !1, e),
			ae.create(ae.Class.UNIVERSAL, ae.Type.INTEGER, !1, t.getBytes()),
		])
		return (
			n !== "hmacWithSHA1" &&
				i.value.push(
					ae.create(ae.Class.UNIVERSAL, ae.Type.INTEGER, !1, Ne.util.hexToBytes(r.toString(16))),
					ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
						ae.create(ae.Class.UNIVERSAL, ae.Type.OID, !1, ae.oidToDer(Wt.oids[n]).getBytes()),
						ae.create(ae.Class.UNIVERSAL, ae.Type.NULL, !1, ""),
					]),
				),
			i
		)
	}
})
var M5 = x((iBt, sce) => {
	"use strict"
	var G0 = Yt()
	gc()
	Sr()
	var Fe = G0.asn1,
		$0 = (sce.exports = G0.pkcs7asn1 = G0.pkcs7asn1 || {})
	G0.pkcs7 = G0.pkcs7 || {}
	G0.pkcs7.asn1 = $0
	var nce = {
		name: "ContentInfo",
		tagClass: Fe.Class.UNIVERSAL,
		type: Fe.Type.SEQUENCE,
		constructed: !0,
		value: [
			{
				name: "ContentInfo.ContentType",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.OID,
				constructed: !1,
				capture: "contentType",
			},
			{
				name: "ContentInfo.content",
				tagClass: Fe.Class.CONTEXT_SPECIFIC,
				type: 0,
				constructed: !0,
				optional: !0,
				captureAsn1: "content",
			},
		],
	}
	$0.contentInfoValidator = nce
	var ice = {
		name: "EncryptedContentInfo",
		tagClass: Fe.Class.UNIVERSAL,
		type: Fe.Type.SEQUENCE,
		constructed: !0,
		value: [
			{
				name: "EncryptedContentInfo.contentType",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.OID,
				constructed: !1,
				capture: "contentType",
			},
			{
				name: "EncryptedContentInfo.contentEncryptionAlgorithm",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.SEQUENCE,
				constructed: !0,
				value: [
					{
						name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
						tagClass: Fe.Class.UNIVERSAL,
						type: Fe.Type.OID,
						constructed: !1,
						capture: "encAlgorithm",
					},
					{
						name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
						tagClass: Fe.Class.UNIVERSAL,
						captureAsn1: "encParameter",
					},
				],
			},
			{
				name: "EncryptedContentInfo.encryptedContent",
				tagClass: Fe.Class.CONTEXT_SPECIFIC,
				type: 0,
				capture: "encryptedContent",
				captureAsn1: "encryptedContentAsn1",
			},
		],
	}
	$0.envelopedDataValidator = {
		name: "EnvelopedData",
		tagClass: Fe.Class.UNIVERSAL,
		type: Fe.Type.SEQUENCE,
		constructed: !0,
		value: [
			{
				name: "EnvelopedData.Version",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.INTEGER,
				constructed: !1,
				capture: "version",
			},
			{
				name: "EnvelopedData.RecipientInfos",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.SET,
				constructed: !0,
				captureAsn1: "recipientInfos",
			},
		].concat(ice),
	}
	$0.encryptedDataValidator = {
		name: "EncryptedData",
		tagClass: Fe.Class.UNIVERSAL,
		type: Fe.Type.SEQUENCE,
		constructed: !0,
		value: [
			{
				name: "EncryptedData.Version",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.INTEGER,
				constructed: !1,
				capture: "version",
			},
		].concat(ice),
	}
	var eXe = {
		name: "SignerInfo",
		tagClass: Fe.Class.UNIVERSAL,
		type: Fe.Type.SEQUENCE,
		constructed: !0,
		value: [
			{
				name: "SignerInfo.version",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.INTEGER,
				constructed: !1,
			},
			{
				name: "SignerInfo.issuerAndSerialNumber",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.SEQUENCE,
				constructed: !0,
				value: [
					{
						name: "SignerInfo.issuerAndSerialNumber.issuer",
						tagClass: Fe.Class.UNIVERSAL,
						type: Fe.Type.SEQUENCE,
						constructed: !0,
						captureAsn1: "issuer",
					},
					{
						name: "SignerInfo.issuerAndSerialNumber.serialNumber",
						tagClass: Fe.Class.UNIVERSAL,
						type: Fe.Type.INTEGER,
						constructed: !1,
						capture: "serial",
					},
				],
			},
			{
				name: "SignerInfo.digestAlgorithm",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.SEQUENCE,
				constructed: !0,
				value: [
					{
						name: "SignerInfo.digestAlgorithm.algorithm",
						tagClass: Fe.Class.UNIVERSAL,
						type: Fe.Type.OID,
						constructed: !1,
						capture: "digestAlgorithm",
					},
					{
						name: "SignerInfo.digestAlgorithm.parameter",
						tagClass: Fe.Class.UNIVERSAL,
						constructed: !1,
						captureAsn1: "digestParameter",
						optional: !0,
					},
				],
			},
			{
				name: "SignerInfo.authenticatedAttributes",
				tagClass: Fe.Class.CONTEXT_SPECIFIC,
				type: 0,
				constructed: !0,
				optional: !0,
				capture: "authenticatedAttributes",
			},
			{
				name: "SignerInfo.digestEncryptionAlgorithm",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.SEQUENCE,
				constructed: !0,
				capture: "signatureAlgorithm",
			},
			{
				name: "SignerInfo.encryptedDigest",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.OCTETSTRING,
				constructed: !1,
				capture: "signature",
			},
			{
				name: "SignerInfo.unauthenticatedAttributes",
				tagClass: Fe.Class.CONTEXT_SPECIFIC,
				type: 1,
				constructed: !0,
				optional: !0,
				capture: "unauthenticatedAttributes",
			},
		],
	}
	$0.signedDataValidator = {
		name: "SignedData",
		tagClass: Fe.Class.UNIVERSAL,
		type: Fe.Type.SEQUENCE,
		constructed: !0,
		value: [
			{
				name: "SignedData.Version",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.INTEGER,
				constructed: !1,
				capture: "version",
			},
			{
				name: "SignedData.DigestAlgorithms",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.SET,
				constructed: !0,
				captureAsn1: "digestAlgorithms",
			},
			nce,
			{
				name: "SignedData.Certificates",
				tagClass: Fe.Class.CONTEXT_SPECIFIC,
				type: 0,
				optional: !0,
				captureAsn1: "certificates",
			},
			{
				name: "SignedData.CertificateRevocationLists",
				tagClass: Fe.Class.CONTEXT_SPECIFIC,
				type: 1,
				optional: !0,
				captureAsn1: "crls",
			},
			{
				name: "SignedData.SignerInfos",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.SET,
				capture: "signerInfos",
				optional: !0,
				value: [eXe],
			},
		],
	}
	$0.recipientInfoValidator = {
		name: "RecipientInfo",
		tagClass: Fe.Class.UNIVERSAL,
		type: Fe.Type.SEQUENCE,
		constructed: !0,
		value: [
			{
				name: "RecipientInfo.version",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.INTEGER,
				constructed: !1,
				capture: "version",
			},
			{
				name: "RecipientInfo.issuerAndSerial",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.SEQUENCE,
				constructed: !0,
				value: [
					{
						name: "RecipientInfo.issuerAndSerial.issuer",
						tagClass: Fe.Class.UNIVERSAL,
						type: Fe.Type.SEQUENCE,
						constructed: !0,
						captureAsn1: "issuer",
					},
					{
						name: "RecipientInfo.issuerAndSerial.serialNumber",
						tagClass: Fe.Class.UNIVERSAL,
						type: Fe.Type.INTEGER,
						constructed: !1,
						capture: "serial",
					},
				],
			},
			{
				name: "RecipientInfo.keyEncryptionAlgorithm",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.SEQUENCE,
				constructed: !0,
				value: [
					{
						name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
						tagClass: Fe.Class.UNIVERSAL,
						type: Fe.Type.OID,
						constructed: !1,
						capture: "encAlgorithm",
					},
					{
						name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
						tagClass: Fe.Class.UNIVERSAL,
						constructed: !1,
						captureAsn1: "encParameter",
						optional: !0,
					},
				],
			},
			{
				name: "RecipientInfo.encryptedKey",
				tagClass: Fe.Class.UNIVERSAL,
				type: Fe.Type.OCTETSTRING,
				constructed: !1,
				capture: "encKey",
			},
		],
	}
})
var F5 = x((sBt, oce) => {
	"use strict"
	var Bp = Yt()
	Sr()
	Bp.mgf = Bp.mgf || {}
	var tXe = (oce.exports = Bp.mgf.mgf1 = Bp.mgf1 = Bp.mgf1 || {})
	tXe.create = function (e) {
		var t = {
			generate: function (r, n) {
				for (var i = new Bp.util.ByteBuffer(), s = Math.ceil(n / e.digestLength), o = 0; o < s; o++) {
					var a = new Bp.util.ByteBuffer()
					a.putInt32(o), e.start(), e.update(r + a.getBytes()), i.putBuffer(e.digest())
				}
				return i.truncate(i.length() - n), i.getBytes()
			},
		}
		return t
	}
})
var lce = x((oBt, ace) => {
	"use strict"
	var CT = Yt()
	F5()
	ace.exports = CT.mgf = CT.mgf || {}
	CT.mgf.mgf1 = CT.mgf1
})
var vT = x((aBt, cce) => {
	"use strict"
	var Dp = Yt()
	cl()
	Sr()
	var rXe = (cce.exports = Dp.pss = Dp.pss || {})
	rXe.create = function (e) {
		arguments.length === 3 && (e = { md: arguments[0], mgf: arguments[1], saltLength: arguments[2] })
		var t = e.md,
			r = e.mgf,
			n = t.digestLength,
			i = e.salt || null
		typeof i == "string" && (i = Dp.util.createBuffer(i))
		var s
		if ("saltLength" in e) s = e.saltLength
		else if (i !== null) s = i.length()
		else throw new Error("Salt length not specified or specific salt not given.")
		if (i !== null && i.length() !== s) throw new Error("Given salt length does not match length of given salt.")
		var o = e.prng || Dp.random,
			a = {}
		return (
			(a.encode = function (l, c) {
				var u,
					f = c - 1,
					p = Math.ceil(f / 8),
					g = l.digest().getBytes()
				if (p < n + s + 2) throw new Error("Message is too long to encrypt.")
				var m
				i === null ? (m = o.getBytesSync(s)) : (m = i.bytes())
				var y = new Dp.util.ByteBuffer()
				y.fillWithByte(0, 8), y.putBytes(g), y.putBytes(m), t.start(), t.update(y.getBytes())
				var C = t.digest().getBytes(),
					v = new Dp.util.ByteBuffer()
				v.fillWithByte(0, p - s - n - 2), v.putByte(1), v.putBytes(m)
				var b = v.getBytes(),
					w = p - n - 1,
					B = r.generate(C, w),
					M = ""
				for (u = 0; u < w; u++) M += String.fromCharCode(b.charCodeAt(u) ^ B.charCodeAt(u))
				var Q = (65280 >> (8 * p - f)) & 255
				return (M = String.fromCharCode(M.charCodeAt(0) & ~Q) + M.substr(1)), M + C + "\xBC"
			}),
			(a.verify = function (l, c, u) {
				var f,
					p = u - 1,
					g = Math.ceil(p / 8)
				if (((c = c.substr(-g)), g < n + s + 2))
					throw new Error("Inconsistent parameters to PSS signature verification.")
				if (c.charCodeAt(g - 1) !== 188) throw new Error("Encoded message does not end in 0xBC.")
				var m = g - n - 1,
					y = c.substr(0, m),
					C = c.substr(m, n),
					v = (65280 >> (8 * g - p)) & 255
				if (y.charCodeAt(0) & v) throw new Error("Bits beyond keysize not zero as expected.")
				var b = r.generate(C, m),
					w = ""
				for (f = 0; f < m; f++) w += String.fromCharCode(y.charCodeAt(f) ^ b.charCodeAt(f))
				w = String.fromCharCode(w.charCodeAt(0) & ~v) + w.substr(1)
				var B = g - n - s - 2
				for (f = 0; f < B; f++)
					if (w.charCodeAt(f) !== 0) throw new Error("Leftmost octets not zero as expected")
				if (w.charCodeAt(B) !== 1) throw new Error("Inconsistent PSS signature, 0x01 marker not found")
				var M = w.substr(-s),
					Q = new Dp.util.ByteBuffer()
				Q.fillWithByte(0, 8), Q.putBytes(l), Q.putBytes(M), t.start(), t.update(Q.getBytes())
				var O = t.digest().getBytes()
				return C === O
			}),
			a
		)
	}
})
var xT = x((lBt, gce) => {
	"use strict"
	var nt = Yt()
	uh()
	gc()
	Bb()
	du()
	lce()
	dh()
	_p()
	vT()
	Rb()
	Sr()
	var D = nt.asn1,
		we = (gce.exports = nt.pki = nt.pki || {}),
		xr = we.oids,
		ii = {}
	ii.CN = xr.commonName
	ii.commonName = "CN"
	ii.C = xr.countryName
	ii.countryName = "C"
	ii.L = xr.localityName
	ii.localityName = "L"
	ii.ST = xr.stateOrProvinceName
	ii.stateOrProvinceName = "ST"
	ii.O = xr.organizationName
	ii.organizationName = "O"
	ii.OU = xr.organizationalUnitName
	ii.organizationalUnitName = "OU"
	ii.E = xr.emailAddress
	ii.emailAddress = "E"
	var dce = nt.pki.rsa.publicKeyValidator,
		nXe = {
			name: "Certificate",
			tagClass: D.Class.UNIVERSAL,
			type: D.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "Certificate.TBSCertificate",
					tagClass: D.Class.UNIVERSAL,
					type: D.Type.SEQUENCE,
					constructed: !0,
					captureAsn1: "tbsCertificate",
					value: [
						{
							name: "Certificate.TBSCertificate.version",
							tagClass: D.Class.CONTEXT_SPECIFIC,
							type: 0,
							constructed: !0,
							optional: !0,
							value: [
								{
									name: "Certificate.TBSCertificate.version.integer",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.INTEGER,
									constructed: !1,
									capture: "certVersion",
								},
							],
						},
						{
							name: "Certificate.TBSCertificate.serialNumber",
							tagClass: D.Class.UNIVERSAL,
							type: D.Type.INTEGER,
							constructed: !1,
							capture: "certSerialNumber",
						},
						{
							name: "Certificate.TBSCertificate.signature",
							tagClass: D.Class.UNIVERSAL,
							type: D.Type.SEQUENCE,
							constructed: !0,
							value: [
								{
									name: "Certificate.TBSCertificate.signature.algorithm",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.OID,
									constructed: !1,
									capture: "certinfoSignatureOid",
								},
								{
									name: "Certificate.TBSCertificate.signature.parameters",
									tagClass: D.Class.UNIVERSAL,
									optional: !0,
									captureAsn1: "certinfoSignatureParams",
								},
							],
						},
						{
							name: "Certificate.TBSCertificate.issuer",
							tagClass: D.Class.UNIVERSAL,
							type: D.Type.SEQUENCE,
							constructed: !0,
							captureAsn1: "certIssuer",
						},
						{
							name: "Certificate.TBSCertificate.validity",
							tagClass: D.Class.UNIVERSAL,
							type: D.Type.SEQUENCE,
							constructed: !0,
							value: [
								{
									name: "Certificate.TBSCertificate.validity.notBefore (utc)",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.UTCTIME,
									constructed: !1,
									optional: !0,
									capture: "certValidity1UTCTime",
								},
								{
									name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.GENERALIZEDTIME,
									constructed: !1,
									optional: !0,
									capture: "certValidity2GeneralizedTime",
								},
								{
									name: "Certificate.TBSCertificate.validity.notAfter (utc)",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.UTCTIME,
									constructed: !1,
									optional: !0,
									capture: "certValidity3UTCTime",
								},
								{
									name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.GENERALIZEDTIME,
									constructed: !1,
									optional: !0,
									capture: "certValidity4GeneralizedTime",
								},
							],
						},
						{
							name: "Certificate.TBSCertificate.subject",
							tagClass: D.Class.UNIVERSAL,
							type: D.Type.SEQUENCE,
							constructed: !0,
							captureAsn1: "certSubject",
						},
						dce,
						{
							name: "Certificate.TBSCertificate.issuerUniqueID",
							tagClass: D.Class.CONTEXT_SPECIFIC,
							type: 1,
							constructed: !0,
							optional: !0,
							value: [
								{
									name: "Certificate.TBSCertificate.issuerUniqueID.id",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.BITSTRING,
									constructed: !1,
									captureBitStringValue: "certIssuerUniqueId",
								},
							],
						},
						{
							name: "Certificate.TBSCertificate.subjectUniqueID",
							tagClass: D.Class.CONTEXT_SPECIFIC,
							type: 2,
							constructed: !0,
							optional: !0,
							value: [
								{
									name: "Certificate.TBSCertificate.subjectUniqueID.id",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.BITSTRING,
									constructed: !1,
									captureBitStringValue: "certSubjectUniqueId",
								},
							],
						},
						{
							name: "Certificate.TBSCertificate.extensions",
							tagClass: D.Class.CONTEXT_SPECIFIC,
							type: 3,
							constructed: !0,
							captureAsn1: "certExtensions",
							optional: !0,
						},
					],
				},
				{
					name: "Certificate.signatureAlgorithm",
					tagClass: D.Class.UNIVERSAL,
					type: D.Type.SEQUENCE,
					constructed: !0,
					value: [
						{
							name: "Certificate.signatureAlgorithm.algorithm",
							tagClass: D.Class.UNIVERSAL,
							type: D.Type.OID,
							constructed: !1,
							capture: "certSignatureOid",
						},
						{
							name: "Certificate.TBSCertificate.signature.parameters",
							tagClass: D.Class.UNIVERSAL,
							optional: !0,
							captureAsn1: "certSignatureParams",
						},
					],
				},
				{
					name: "Certificate.signatureValue",
					tagClass: D.Class.UNIVERSAL,
					type: D.Type.BITSTRING,
					constructed: !1,
					captureBitStringValue: "certSignature",
				},
			],
		},
		iXe = {
			name: "rsapss",
			tagClass: D.Class.UNIVERSAL,
			type: D.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "rsapss.hashAlgorithm",
					tagClass: D.Class.CONTEXT_SPECIFIC,
					type: 0,
					constructed: !0,
					value: [
						{
							name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
							tagClass: D.Class.UNIVERSAL,
							type: D.Class.SEQUENCE,
							constructed: !0,
							optional: !0,
							value: [
								{
									name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.OID,
									constructed: !1,
									capture: "hashOid",
								},
							],
						},
					],
				},
				{
					name: "rsapss.maskGenAlgorithm",
					tagClass: D.Class.CONTEXT_SPECIFIC,
					type: 1,
					constructed: !0,
					value: [
						{
							name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
							tagClass: D.Class.UNIVERSAL,
							type: D.Class.SEQUENCE,
							constructed: !0,
							optional: !0,
							value: [
								{
									name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.OID,
									constructed: !1,
									capture: "maskGenOid",
								},
								{
									name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.SEQUENCE,
									constructed: !0,
									value: [
										{
											name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
											tagClass: D.Class.UNIVERSAL,
											type: D.Type.OID,
											constructed: !1,
											capture: "maskGenHashOid",
										},
									],
								},
							],
						},
					],
				},
				{
					name: "rsapss.saltLength",
					tagClass: D.Class.CONTEXT_SPECIFIC,
					type: 2,
					optional: !0,
					value: [
						{
							name: "rsapss.saltLength.saltLength",
							tagClass: D.Class.UNIVERSAL,
							type: D.Class.INTEGER,
							constructed: !1,
							capture: "saltLength",
						},
					],
				},
				{
					name: "rsapss.trailerField",
					tagClass: D.Class.CONTEXT_SPECIFIC,
					type: 3,
					optional: !0,
					value: [
						{
							name: "rsapss.trailer.trailer",
							tagClass: D.Class.UNIVERSAL,
							type: D.Class.INTEGER,
							constructed: !1,
							capture: "trailer",
						},
					],
				},
			],
		},
		sXe = {
			name: "CertificationRequestInfo",
			tagClass: D.Class.UNIVERSAL,
			type: D.Type.SEQUENCE,
			constructed: !0,
			captureAsn1: "certificationRequestInfo",
			value: [
				{
					name: "CertificationRequestInfo.integer",
					tagClass: D.Class.UNIVERSAL,
					type: D.Type.INTEGER,
					constructed: !1,
					capture: "certificationRequestInfoVersion",
				},
				{
					name: "CertificationRequestInfo.subject",
					tagClass: D.Class.UNIVERSAL,
					type: D.Type.SEQUENCE,
					constructed: !0,
					captureAsn1: "certificationRequestInfoSubject",
				},
				dce,
				{
					name: "CertificationRequestInfo.attributes",
					tagClass: D.Class.CONTEXT_SPECIFIC,
					type: 0,
					constructed: !0,
					optional: !0,
					capture: "certificationRequestInfoAttributes",
					value: [
						{
							name: "CertificationRequestInfo.attributes",
							tagClass: D.Class.UNIVERSAL,
							type: D.Type.SEQUENCE,
							constructed: !0,
							value: [
								{
									name: "CertificationRequestInfo.attributes.type",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.OID,
									constructed: !1,
								},
								{
									name: "CertificationRequestInfo.attributes.value",
									tagClass: D.Class.UNIVERSAL,
									type: D.Type.SET,
									constructed: !0,
								},
							],
						},
					],
				},
			],
		},
		oXe = {
			name: "CertificationRequest",
			tagClass: D.Class.UNIVERSAL,
			type: D.Type.SEQUENCE,
			constructed: !0,
			captureAsn1: "csr",
			value: [
				sXe,
				{
					name: "CertificationRequest.signatureAlgorithm",
					tagClass: D.Class.UNIVERSAL,
					type: D.Type.SEQUENCE,
					constructed: !0,
					value: [
						{
							name: "CertificationRequest.signatureAlgorithm.algorithm",
							tagClass: D.Class.UNIVERSAL,
							type: D.Type.OID,
							constructed: !1,
							capture: "csrSignatureOid",
						},
						{
							name: "CertificationRequest.signatureAlgorithm.parameters",
							tagClass: D.Class.UNIVERSAL,
							optional: !0,
							captureAsn1: "csrSignatureParams",
						},
					],
				},
				{
					name: "CertificationRequest.signature",
					tagClass: D.Class.UNIVERSAL,
					type: D.Type.BITSTRING,
					constructed: !1,
					captureBitStringValue: "csrSignature",
				},
			],
		}
	we.RDNAttributesAsArray = function (e, t) {
		for (var r = [], n, i, s, o = 0; o < e.value.length; ++o) {
			n = e.value[o]
			for (var a = 0; a < n.value.length; ++a)
				(s = {}),
					(i = n.value[a]),
					(s.type = D.derToOid(i.value[0].value)),
					(s.value = i.value[1].value),
					(s.valueTagClass = i.value[1].type),
					s.type in xr && ((s.name = xr[s.type]), s.name in ii && (s.shortName = ii[s.name])),
					t && (t.update(s.type), t.update(s.value)),
					r.push(s)
		}
		return r
	}
	we.CRIAttributesAsArray = function (e) {
		for (var t = [], r = 0; r < e.length; ++r)
			for (var n = e[r], i = D.derToOid(n.value[0].value), s = n.value[1].value, o = 0; o < s.length; ++o) {
				var a = {}
				if (
					((a.type = i),
					(a.value = s[o].value),
					(a.valueTagClass = s[o].type),
					a.type in xr && ((a.name = xr[a.type]), a.name in ii && (a.shortName = ii[a.name])),
					a.type === xr.extensionRequest)
				) {
					a.extensions = []
					for (var l = 0; l < a.value.length; ++l)
						a.extensions.push(we.certificateExtensionFromAsn1(a.value[l]))
				}
				t.push(a)
			}
		return t
	}
	function gh(e, t) {
		typeof t == "string" && (t = { shortName: t })
		for (var r = null, n, i = 0; r === null && i < e.attributes.length; ++i)
			(n = e.attributes[i]),
				((t.type && t.type === n.type) ||
					(t.name && t.name === n.name) ||
					(t.shortName && t.shortName === n.shortName)) &&
					(r = n)
		return r
	}
	var ET = function (e, t, r) {
			var n = {}
			if (e !== xr["RSASSA-PSS"]) return n
			r &&
				(n = {
					hash: { algorithmOid: xr.sha1 },
					mgf: { algorithmOid: xr.mgf1, hash: { algorithmOid: xr.sha1 } },
					saltLength: 20,
				})
			var i = {},
				s = []
			if (!D.validate(t, iXe, i, s)) {
				var o = new Error("Cannot read RSASSA-PSS parameter block.")
				throw ((o.errors = s), o)
			}
			return (
				i.hashOid !== void 0 && ((n.hash = n.hash || {}), (n.hash.algorithmOid = D.derToOid(i.hashOid))),
				i.maskGenOid !== void 0 &&
					((n.mgf = n.mgf || {}),
					(n.mgf.algorithmOid = D.derToOid(i.maskGenOid)),
					(n.mgf.hash = n.mgf.hash || {}),
					(n.mgf.hash.algorithmOid = D.derToOid(i.maskGenHashOid))),
				i.saltLength !== void 0 && (n.saltLength = i.saltLength.charCodeAt(0)),
				n
			)
		},
		bT = function (e) {
			switch (xr[e.signatureOid]) {
				case "sha1WithRSAEncryption":
				case "sha1WithRSASignature":
					return nt.md.sha1.create()
				case "md5WithRSAEncryption":
					return nt.md.md5.create()
				case "sha256WithRSAEncryption":
					return nt.md.sha256.create()
				case "sha384WithRSAEncryption":
					return nt.md.sha384.create()
				case "sha512WithRSAEncryption":
					return nt.md.sha512.create()
				case "RSASSA-PSS":
					return nt.md.sha256.create()
				default:
					var t = new Error("Could not compute " + e.type + " digest. Unknown signature OID.")
					throw ((t.signatureOid = e.signatureOid), t)
			}
		},
		fce = function (e) {
			var t = e.certificate,
				r
			switch (t.signatureOid) {
				case xr.sha1WithRSAEncryption:
				case xr.sha1WithRSASignature:
					break
				case xr["RSASSA-PSS"]:
					var n, i
					if (((n = xr[t.signatureParameters.mgf.hash.algorithmOid]), n === void 0 || nt.md[n] === void 0)) {
						var s = new Error("Unsupported MGF hash function.")
						throw ((s.oid = t.signatureParameters.mgf.hash.algorithmOid), (s.name = n), s)
					}
					if (((i = xr[t.signatureParameters.mgf.algorithmOid]), i === void 0 || nt.mgf[i] === void 0)) {
						var s = new Error("Unsupported MGF function.")
						throw ((s.oid = t.signatureParameters.mgf.algorithmOid), (s.name = i), s)
					}
					if (
						((i = nt.mgf[i].create(nt.md[n].create())),
						(n = xr[t.signatureParameters.hash.algorithmOid]),
						n === void 0 || nt.md[n] === void 0)
					) {
						var s = new Error("Unsupported RSASSA-PSS hash function.")
						throw ((s.oid = t.signatureParameters.hash.algorithmOid), (s.name = n), s)
					}
					r = nt.pss.create(nt.md[n].create(), i, t.signatureParameters.saltLength)
					break
			}
			return t.publicKey.verify(e.md.digest().getBytes(), e.signature, r)
		}
	we.certificateFromPem = function (e, t, r) {
		var n = nt.pem.decode(e)[0]
		if (n.type !== "CERTIFICATE" && n.type !== "X509 CERTIFICATE" && n.type !== "TRUSTED CERTIFICATE") {
			var i = new Error(
				'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',
			)
			throw ((i.headerType = n.type), i)
		}
		if (n.procType && n.procType.type === "ENCRYPTED")
			throw new Error("Could not convert certificate from PEM; PEM is encrypted.")
		var s = D.fromDer(n.body, r)
		return we.certificateFromAsn1(s, t)
	}
	we.certificateToPem = function (e, t) {
		var r = {
			type: "CERTIFICATE",
			body: D.toDer(we.certificateToAsn1(e)).getBytes(),
		}
		return nt.pem.encode(r, { maxline: t })
	}
	we.publicKeyFromPem = function (e) {
		var t = nt.pem.decode(e)[0]
		if (t.type !== "PUBLIC KEY" && t.type !== "RSA PUBLIC KEY") {
			var r = new Error(
				'Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".',
			)
			throw ((r.headerType = t.type), r)
		}
		if (t.procType && t.procType.type === "ENCRYPTED")
			throw new Error("Could not convert public key from PEM; PEM is encrypted.")
		var n = D.fromDer(t.body)
		return we.publicKeyFromAsn1(n)
	}
	we.publicKeyToPem = function (e, t) {
		var r = {
			type: "PUBLIC KEY",
			body: D.toDer(we.publicKeyToAsn1(e)).getBytes(),
		}
		return nt.pem.encode(r, { maxline: t })
	}
	we.publicKeyToRSAPublicKeyPem = function (e, t) {
		var r = {
			type: "RSA PUBLIC KEY",
			body: D.toDer(we.publicKeyToRSAPublicKey(e)).getBytes(),
		}
		return nt.pem.encode(r, { maxline: t })
	}
	we.getPublicKeyFingerprint = function (e, t) {
		t = t || {}
		var r = t.md || nt.md.sha1.create(),
			n = t.type || "RSAPublicKey",
			i
		switch (n) {
			case "RSAPublicKey":
				i = D.toDer(we.publicKeyToRSAPublicKey(e)).getBytes()
				break
			case "SubjectPublicKeyInfo":
				i = D.toDer(we.publicKeyToAsn1(e)).getBytes()
				break
			default:
				throw new Error('Unknown fingerprint type "' + t.type + '".')
		}
		r.start(), r.update(i)
		var s = r.digest()
		if (t.encoding === "hex") {
			var o = s.toHex()
			return t.delimiter ? o.match(/.{2}/g).join(t.delimiter) : o
		} else {
			if (t.encoding === "binary") return s.getBytes()
			if (t.encoding) throw new Error('Unknown encoding "' + t.encoding + '".')
		}
		return s
	}
	we.certificationRequestFromPem = function (e, t, r) {
		var n = nt.pem.decode(e)[0]
		if (n.type !== "CERTIFICATE REQUEST") {
			var i = new Error(
				'Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".',
			)
			throw ((i.headerType = n.type), i)
		}
		if (n.procType && n.procType.type === "ENCRYPTED")
			throw new Error("Could not convert certification request from PEM; PEM is encrypted.")
		var s = D.fromDer(n.body, r)
		return we.certificationRequestFromAsn1(s, t)
	}
	we.certificationRequestToPem = function (e, t) {
		var r = {
			type: "CERTIFICATE REQUEST",
			body: D.toDer(we.certificationRequestToAsn1(e)).getBytes(),
		}
		return nt.pem.encode(r, { maxline: t })
	}
	we.createCertificate = function () {
		var e = {}
		return (
			(e.version = 2),
			(e.serialNumber = "00"),
			(e.signatureOid = null),
			(e.signature = null),
			(e.siginfo = {}),
			(e.siginfo.algorithmOid = null),
			(e.validity = {}),
			(e.validity.notBefore = new Date()),
			(e.validity.notAfter = new Date()),
			(e.issuer = {}),
			(e.issuer.getField = function (t) {
				return gh(e.issuer, t)
			}),
			(e.issuer.addField = function (t) {
				fl([t]), e.issuer.attributes.push(t)
			}),
			(e.issuer.attributes = []),
			(e.issuer.hash = null),
			(e.subject = {}),
			(e.subject.getField = function (t) {
				return gh(e.subject, t)
			}),
			(e.subject.addField = function (t) {
				fl([t]), e.subject.attributes.push(t)
			}),
			(e.subject.attributes = []),
			(e.subject.hash = null),
			(e.extensions = []),
			(e.publicKey = null),
			(e.md = null),
			(e.setSubject = function (t, r) {
				fl(t),
					(e.subject.attributes = t),
					delete e.subject.uniqueId,
					r && (e.subject.uniqueId = r),
					(e.subject.hash = null)
			}),
			(e.setIssuer = function (t, r) {
				fl(t),
					(e.issuer.attributes = t),
					delete e.issuer.uniqueId,
					r && (e.issuer.uniqueId = r),
					(e.issuer.hash = null)
			}),
			(e.setExtensions = function (t) {
				for (var r = 0; r < t.length; ++r) hce(t[r], { cert: e })
				e.extensions = t
			}),
			(e.getExtension = function (t) {
				typeof t == "string" && (t = { name: t })
				for (var r = null, n, i = 0; r === null && i < e.extensions.length; ++i)
					(n = e.extensions[i]), ((t.id && n.id === t.id) || (t.name && n.name === t.name)) && (r = n)
				return r
			}),
			(e.sign = function (t, r) {
				e.md = r || nt.md.sha1.create()
				var n = xr[e.md.algorithm + "WithRSAEncryption"]
				if (!n) {
					var i = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.")
					throw ((i.algorithm = e.md.algorithm), i)
				}
				;(e.signatureOid = e.siginfo.algorithmOid = n), (e.tbsCertificate = we.getTBSCertificate(e))
				var s = D.toDer(e.tbsCertificate)
				e.md.update(s.getBytes()), (e.signature = t.sign(e.md))
			}),
			(e.verify = function (t) {
				var r = !1
				if (!e.issued(t)) {
					var n = t.issuer,
						i = e.subject,
						s = new Error(
							"The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.",
						)
					throw ((s.expectedIssuer = i.attributes), (s.actualIssuer = n.attributes), s)
				}
				var o = t.md
				if (o === null) {
					o = bT({ signatureOid: t.signatureOid, type: "certificate" })
					var a = t.tbsCertificate || we.getTBSCertificate(t),
						l = D.toDer(a)
					o.update(l.getBytes())
				}
				return o !== null && (r = fce({ certificate: e, md: o, signature: t.signature })), r
			}),
			(e.isIssuer = function (t) {
				var r = !1,
					n = e.issuer,
					i = t.subject
				if (n.hash && i.hash) r = n.hash === i.hash
				else if (n.attributes.length === i.attributes.length) {
					r = !0
					for (var s, o, a = 0; r && a < n.attributes.length; ++a)
						(s = n.attributes[a]),
							(o = i.attributes[a]),
							(s.type !== o.type || s.value !== o.value) && (r = !1)
				}
				return r
			}),
			(e.issued = function (t) {
				return t.isIssuer(e)
			}),
			(e.generateSubjectKeyIdentifier = function () {
				return we.getPublicKeyFingerprint(e.publicKey, {
					type: "RSAPublicKey",
				})
			}),
			(e.verifySubjectKeyIdentifier = function () {
				for (var t = xr.subjectKeyIdentifier, r = 0; r < e.extensions.length; ++r) {
					var n = e.extensions[r]
					if (n.id === t) {
						var i = e.generateSubjectKeyIdentifier().getBytes()
						return nt.util.hexToBytes(n.subjectKeyIdentifier) === i
					}
				}
				return !1
			}),
			e
		)
	}
	we.certificateFromAsn1 = function (e, t) {
		var r = {},
			n = []
		if (!D.validate(e, nXe, r, n)) {
			var i = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.")
			throw ((i.errors = n), i)
		}
		var s = D.derToOid(r.publicKeyOid)
		if (s !== we.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.")
		var o = we.createCertificate()
		o.version = r.certVersion ? r.certVersion.charCodeAt(0) : 0
		var a = nt.util.createBuffer(r.certSerialNumber)
		;(o.serialNumber = a.toHex()),
			(o.signatureOid = nt.asn1.derToOid(r.certSignatureOid)),
			(o.signatureParameters = ET(o.signatureOid, r.certSignatureParams, !0)),
			(o.siginfo.algorithmOid = nt.asn1.derToOid(r.certinfoSignatureOid)),
			(o.siginfo.parameters = ET(o.siginfo.algorithmOid, r.certinfoSignatureParams, !1)),
			(o.signature = r.certSignature)
		var l = []
		if (
			(r.certValidity1UTCTime !== void 0 && l.push(D.utcTimeToDate(r.certValidity1UTCTime)),
			r.certValidity2GeneralizedTime !== void 0 &&
				l.push(D.generalizedTimeToDate(r.certValidity2GeneralizedTime)),
			r.certValidity3UTCTime !== void 0 && l.push(D.utcTimeToDate(r.certValidity3UTCTime)),
			r.certValidity4GeneralizedTime !== void 0 &&
				l.push(D.generalizedTimeToDate(r.certValidity4GeneralizedTime)),
			l.length > 2)
		)
			throw new Error(
				"Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.",
			)
		if (l.length < 2)
			throw new Error(
				"Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.",
			)
		if (((o.validity.notBefore = l[0]), (o.validity.notAfter = l[1]), (o.tbsCertificate = r.tbsCertificate), t)) {
			o.md = bT({ signatureOid: o.signatureOid, type: "certificate" })
			var c = D.toDer(o.tbsCertificate)
			o.md.update(c.getBytes())
		}
		var u = nt.md.sha1.create(),
			f = D.toDer(r.certIssuer)
		u.update(f.getBytes()),
			(o.issuer.getField = function (m) {
				return gh(o.issuer, m)
			}),
			(o.issuer.addField = function (m) {
				fl([m]), o.issuer.attributes.push(m)
			}),
			(o.issuer.attributes = we.RDNAttributesAsArray(r.certIssuer)),
			r.certIssuerUniqueId && (o.issuer.uniqueId = r.certIssuerUniqueId),
			(o.issuer.hash = u.digest().toHex())
		var p = nt.md.sha1.create(),
			g = D.toDer(r.certSubject)
		return (
			p.update(g.getBytes()),
			(o.subject.getField = function (m) {
				return gh(o.subject, m)
			}),
			(o.subject.addField = function (m) {
				fl([m]), o.subject.attributes.push(m)
			}),
			(o.subject.attributes = we.RDNAttributesAsArray(r.certSubject)),
			r.certSubjectUniqueId && (o.subject.uniqueId = r.certSubjectUniqueId),
			(o.subject.hash = p.digest().toHex()),
			r.certExtensions
				? (o.extensions = we.certificateExtensionsFromAsn1(r.certExtensions))
				: (o.extensions = []),
			(o.publicKey = we.publicKeyFromAsn1(r.subjectPublicKeyInfo)),
			o
		)
	}
	we.certificateExtensionsFromAsn1 = function (e) {
		for (var t = [], r = 0; r < e.value.length; ++r)
			for (var n = e.value[r], i = 0; i < n.value.length; ++i) t.push(we.certificateExtensionFromAsn1(n.value[i]))
		return t
	}
	we.certificateExtensionFromAsn1 = function (e) {
		var t = {}
		if (
			((t.id = D.derToOid(e.value[0].value)),
			(t.critical = !1),
			e.value[1].type === D.Type.BOOLEAN
				? ((t.critical = e.value[1].value.charCodeAt(0) !== 0), (t.value = e.value[2].value))
				: (t.value = e.value[1].value),
			t.id in xr)
		) {
			if (((t.name = xr[t.id]), t.name === "keyUsage")) {
				var r = D.fromDer(t.value),
					n = 0,
					i = 0
				r.value.length > 1 &&
					((n = r.value.charCodeAt(1)), (i = r.value.length > 2 ? r.value.charCodeAt(2) : 0)),
					(t.digitalSignature = (n & 128) === 128),
					(t.nonRepudiation = (n & 64) === 64),
					(t.keyEncipherment = (n & 32) === 32),
					(t.dataEncipherment = (n & 16) === 16),
					(t.keyAgreement = (n & 8) === 8),
					(t.keyCertSign = (n & 4) === 4),
					(t.cRLSign = (n & 2) === 2),
					(t.encipherOnly = (n & 1) === 1),
					(t.decipherOnly = (i & 128) === 128)
			} else if (t.name === "basicConstraints") {
				var r = D.fromDer(t.value)
				r.value.length > 0 && r.value[0].type === D.Type.BOOLEAN
					? (t.cA = r.value[0].value.charCodeAt(0) !== 0)
					: (t.cA = !1)
				var s = null
				r.value.length > 0 && r.value[0].type === D.Type.INTEGER
					? (s = r.value[0].value)
					: r.value.length > 1 && (s = r.value[1].value),
					s !== null && (t.pathLenConstraint = D.derToInteger(s))
			} else if (t.name === "extKeyUsage")
				for (var r = D.fromDer(t.value), o = 0; o < r.value.length; ++o) {
					var a = D.derToOid(r.value[o].value)
					a in xr ? (t[xr[a]] = !0) : (t[a] = !0)
				}
			else if (t.name === "nsCertType") {
				var r = D.fromDer(t.value),
					n = 0
				r.value.length > 1 && (n = r.value.charCodeAt(1)),
					(t.client = (n & 128) === 128),
					(t.server = (n & 64) === 64),
					(t.email = (n & 32) === 32),
					(t.objsign = (n & 16) === 16),
					(t.reserved = (n & 8) === 8),
					(t.sslCA = (n & 4) === 4),
					(t.emailCA = (n & 2) === 2),
					(t.objCA = (n & 1) === 1)
			} else if (t.name === "subjectAltName" || t.name === "issuerAltName") {
				t.altNames = []
				for (var l, r = D.fromDer(t.value), c = 0; c < r.value.length; ++c) {
					l = r.value[c]
					var u = { type: l.type, value: l.value }
					switch ((t.altNames.push(u), l.type)) {
						case 1:
						case 2:
						case 6:
							break
						case 7:
							u.ip = nt.util.bytesToIP(l.value)
							break
						case 8:
							u.oid = D.derToOid(l.value)
							break
						default:
					}
				}
			} else if (t.name === "subjectKeyIdentifier") {
				var r = D.fromDer(t.value)
				t.subjectKeyIdentifier = nt.util.bytesToHex(r.value)
			}
		}
		return t
	}
	we.certificationRequestFromAsn1 = function (e, t) {
		var r = {},
			n = []
		if (!D.validate(e, oXe, r, n)) {
			var i = new Error(
				"Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.",
			)
			throw ((i.errors = n), i)
		}
		var s = D.derToOid(r.publicKeyOid)
		if (s !== we.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.")
		var o = we.createCertificationRequest()
		if (
			((o.version = r.csrVersion ? r.csrVersion.charCodeAt(0) : 0),
			(o.signatureOid = nt.asn1.derToOid(r.csrSignatureOid)),
			(o.signatureParameters = ET(o.signatureOid, r.csrSignatureParams, !0)),
			(o.siginfo.algorithmOid = nt.asn1.derToOid(r.csrSignatureOid)),
			(o.siginfo.parameters = ET(o.siginfo.algorithmOid, r.csrSignatureParams, !1)),
			(o.signature = r.csrSignature),
			(o.certificationRequestInfo = r.certificationRequestInfo),
			t)
		) {
			o.md = bT({
				signatureOid: o.signatureOid,
				type: "certification request",
			})
			var a = D.toDer(o.certificationRequestInfo)
			o.md.update(a.getBytes())
		}
		var l = nt.md.sha1.create()
		return (
			(o.subject.getField = function (c) {
				return gh(o.subject, c)
			}),
			(o.subject.addField = function (c) {
				fl([c]), o.subject.attributes.push(c)
			}),
			(o.subject.attributes = we.RDNAttributesAsArray(r.certificationRequestInfoSubject, l)),
			(o.subject.hash = l.digest().toHex()),
			(o.publicKey = we.publicKeyFromAsn1(r.subjectPublicKeyInfo)),
			(o.getAttribute = function (c) {
				return gh(o, c)
			}),
			(o.addAttribute = function (c) {
				fl([c]), o.attributes.push(c)
			}),
			(o.attributes = we.CRIAttributesAsArray(r.certificationRequestInfoAttributes || [])),
			o
		)
	}
	we.createCertificationRequest = function () {
		var e = {}
		return (
			(e.version = 0),
			(e.signatureOid = null),
			(e.signature = null),
			(e.siginfo = {}),
			(e.siginfo.algorithmOid = null),
			(e.subject = {}),
			(e.subject.getField = function (t) {
				return gh(e.subject, t)
			}),
			(e.subject.addField = function (t) {
				fl([t]), e.subject.attributes.push(t)
			}),
			(e.subject.attributes = []),
			(e.subject.hash = null),
			(e.publicKey = null),
			(e.attributes = []),
			(e.getAttribute = function (t) {
				return gh(e, t)
			}),
			(e.addAttribute = function (t) {
				fl([t]), e.attributes.push(t)
			}),
			(e.md = null),
			(e.setSubject = function (t) {
				fl(t), (e.subject.attributes = t), (e.subject.hash = null)
			}),
			(e.setAttributes = function (t) {
				fl(t), (e.attributes = t)
			}),
			(e.sign = function (t, r) {
				e.md = r || nt.md.sha1.create()
				var n = xr[e.md.algorithm + "WithRSAEncryption"]
				if (!n) {
					var i = new Error(
						"Could not compute certification request digest. Unknown message digest algorithm OID.",
					)
					throw ((i.algorithm = e.md.algorithm), i)
				}
				;(e.signatureOid = e.siginfo.algorithmOid = n),
					(e.certificationRequestInfo = we.getCertificationRequestInfo(e))
				var s = D.toDer(e.certificationRequestInfo)
				e.md.update(s.getBytes()), (e.signature = t.sign(e.md))
			}),
			(e.verify = function () {
				var t = !1,
					r = e.md
				if (r === null) {
					r = bT({
						signatureOid: e.signatureOid,
						type: "certification request",
					})
					var n = e.certificationRequestInfo || we.getCertificationRequestInfo(e),
						i = D.toDer(n)
					r.update(i.getBytes())
				}
				return r !== null && (t = fce({ certificate: e, md: r, signature: e.signature })), t
			}),
			e
		)
	}
	function Y0(e) {
		for (
			var t = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, []), r, n, i = e.attributes, s = 0;
			s < i.length;
			++s
		) {
			r = i[s]
			var o = r.value,
				a = D.Type.PRINTABLESTRING
			"valueTagClass" in r && ((a = r.valueTagClass), a === D.Type.UTF8 && (o = nt.util.encodeUtf8(o))),
				(n = D.create(D.Class.UNIVERSAL, D.Type.SET, !0, [
					D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
						D.create(D.Class.UNIVERSAL, D.Type.OID, !1, D.oidToDer(r.type).getBytes()),
						D.create(D.Class.UNIVERSAL, a, !1, o),
					]),
				])),
				t.value.push(n)
		}
		return t
	}
	function fl(e) {
		for (var t, r = 0; r < e.length; ++r) {
			if (
				((t = e[r]),
				typeof t.name > "u" &&
					(t.type && t.type in we.oids
						? (t.name = we.oids[t.type])
						: t.shortName && t.shortName in ii && (t.name = we.oids[ii[t.shortName]])),
				typeof t.type > "u")
			)
				if (t.name && t.name in we.oids) t.type = we.oids[t.name]
				else {
					var n = new Error("Attribute type not specified.")
					throw ((n.attribute = t), n)
				}
			if (
				(typeof t.shortName > "u" && t.name && t.name in ii && (t.shortName = ii[t.name]),
				t.type === xr.extensionRequest &&
					((t.valueConstructed = !0), (t.valueTagClass = D.Type.SEQUENCE), !t.value && t.extensions))
			) {
				t.value = []
				for (var i = 0; i < t.extensions.length; ++i)
					t.value.push(we.certificateExtensionToAsn1(hce(t.extensions[i])))
			}
			if (typeof t.value > "u") {
				var n = new Error("Attribute value not specified.")
				throw ((n.attribute = t), n)
			}
		}
	}
	function hce(e, t) {
		if (
			((t = t || {}),
			typeof e.name > "u" && e.id && e.id in we.oids && (e.name = we.oids[e.id]),
			typeof e.id > "u")
		)
			if (e.name && e.name in we.oids) e.id = we.oids[e.name]
			else {
				var r = new Error("Extension ID not specified.")
				throw ((r.extension = e), r)
			}
		if (typeof e.value < "u") return e
		if (e.name === "keyUsage") {
			var n = 0,
				i = 0,
				s = 0
			e.digitalSignature && ((i |= 128), (n = 7)),
				e.nonRepudiation && ((i |= 64), (n = 6)),
				e.keyEncipherment && ((i |= 32), (n = 5)),
				e.dataEncipherment && ((i |= 16), (n = 4)),
				e.keyAgreement && ((i |= 8), (n = 3)),
				e.keyCertSign && ((i |= 4), (n = 2)),
				e.cRLSign && ((i |= 2), (n = 1)),
				e.encipherOnly && ((i |= 1), (n = 0)),
				e.decipherOnly && ((s |= 128), (n = 7))
			var o = String.fromCharCode(n)
			s !== 0 ? (o += String.fromCharCode(i) + String.fromCharCode(s)) : i !== 0 && (o += String.fromCharCode(i)),
				(e.value = D.create(D.Class.UNIVERSAL, D.Type.BITSTRING, !1, o))
		} else if (e.name === "basicConstraints")
			(e.value = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [])),
				e.cA && e.value.value.push(D.create(D.Class.UNIVERSAL, D.Type.BOOLEAN, !1, "\xFF")),
				"pathLenConstraint" in e &&
					e.value.value.push(
						D.create(D.Class.UNIVERSAL, D.Type.INTEGER, !1, D.integerToDer(e.pathLenConstraint).getBytes()),
					)
		else if (e.name === "extKeyUsage") {
			e.value = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [])
			var a = e.value.value
			for (var l in e)
				e[l] === !0 &&
					(l in xr
						? a.push(D.create(D.Class.UNIVERSAL, D.Type.OID, !1, D.oidToDer(xr[l]).getBytes()))
						: l.indexOf(".") !== -1 &&
							a.push(D.create(D.Class.UNIVERSAL, D.Type.OID, !1, D.oidToDer(l).getBytes())))
		} else if (e.name === "nsCertType") {
			var n = 0,
				i = 0
			e.client && ((i |= 128), (n = 7)),
				e.server && ((i |= 64), (n = 6)),
				e.email && ((i |= 32), (n = 5)),
				e.objsign && ((i |= 16), (n = 4)),
				e.reserved && ((i |= 8), (n = 3)),
				e.sslCA && ((i |= 4), (n = 2)),
				e.emailCA && ((i |= 2), (n = 1)),
				e.objCA && ((i |= 1), (n = 0))
			var o = String.fromCharCode(n)
			i !== 0 && (o += String.fromCharCode(i)), (e.value = D.create(D.Class.UNIVERSAL, D.Type.BITSTRING, !1, o))
		} else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
			e.value = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [])
			for (var c, u = 0; u < e.altNames.length; ++u) {
				c = e.altNames[u]
				var o = c.value
				if (c.type === 7 && c.ip) {
					if (((o = nt.util.bytesFromIP(c.ip)), o === null)) {
						var r = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')
						throw ((r.extension = e), r)
					}
				} else c.type === 8 && (c.oid ? (o = D.oidToDer(D.oidToDer(c.oid))) : (o = D.oidToDer(o)))
				e.value.value.push(D.create(D.Class.CONTEXT_SPECIFIC, c.type, !1, o))
			}
		} else if (e.name === "nsComment" && t.cert) {
			if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128)
				throw new Error('Invalid "nsComment" content.')
			e.value = D.create(D.Class.UNIVERSAL, D.Type.IA5STRING, !1, e.comment)
		} else if (e.name === "subjectKeyIdentifier" && t.cert) {
			var f = t.cert.generateSubjectKeyIdentifier()
			;(e.subjectKeyIdentifier = f.toHex()),
				(e.value = D.create(D.Class.UNIVERSAL, D.Type.OCTETSTRING, !1, f.getBytes()))
		} else if (e.name === "authorityKeyIdentifier" && t.cert) {
			e.value = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [])
			var a = e.value.value
			if (e.keyIdentifier) {
				var p = e.keyIdentifier === !0 ? t.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier
				a.push(D.create(D.Class.CONTEXT_SPECIFIC, 0, !1, p))
			}
			if (e.authorityCertIssuer) {
				var g = [
					D.create(D.Class.CONTEXT_SPECIFIC, 4, !0, [
						Y0(e.authorityCertIssuer === !0 ? t.cert.issuer : e.authorityCertIssuer),
					]),
				]
				a.push(D.create(D.Class.CONTEXT_SPECIFIC, 1, !0, g))
			}
			if (e.serialNumber) {
				var m = nt.util.hexToBytes(e.serialNumber === !0 ? t.cert.serialNumber : e.serialNumber)
				a.push(D.create(D.Class.CONTEXT_SPECIFIC, 2, !1, m))
			}
		} else if (e.name === "cRLDistributionPoints") {
			e.value = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [])
			for (
				var a = e.value.value,
					y = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, []),
					C = D.create(D.Class.CONTEXT_SPECIFIC, 0, !0, []),
					c,
					u = 0;
				u < e.altNames.length;
				++u
			) {
				c = e.altNames[u]
				var o = c.value
				if (c.type === 7 && c.ip) {
					if (((o = nt.util.bytesFromIP(c.ip)), o === null)) {
						var r = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')
						throw ((r.extension = e), r)
					}
				} else c.type === 8 && (c.oid ? (o = D.oidToDer(D.oidToDer(c.oid))) : (o = D.oidToDer(o)))
				C.value.push(D.create(D.Class.CONTEXT_SPECIFIC, c.type, !1, o))
			}
			y.value.push(D.create(D.Class.CONTEXT_SPECIFIC, 0, !0, [C])), a.push(y)
		}
		if (typeof e.value > "u") {
			var r = new Error("Extension value not specified.")
			throw ((r.extension = e), r)
		}
		return e
	}
	function Q5(e, t) {
		switch (e) {
			case xr["RSASSA-PSS"]:
				var r = []
				return (
					t.hash.algorithmOid !== void 0 &&
						r.push(
							D.create(D.Class.CONTEXT_SPECIFIC, 0, !0, [
								D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
									D.create(
										D.Class.UNIVERSAL,
										D.Type.OID,
										!1,
										D.oidToDer(t.hash.algorithmOid).getBytes(),
									),
									D.create(D.Class.UNIVERSAL, D.Type.NULL, !1, ""),
								]),
							]),
						),
					t.mgf.algorithmOid !== void 0 &&
						r.push(
							D.create(D.Class.CONTEXT_SPECIFIC, 1, !0, [
								D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
									D.create(
										D.Class.UNIVERSAL,
										D.Type.OID,
										!1,
										D.oidToDer(t.mgf.algorithmOid).getBytes(),
									),
									D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
										D.create(
											D.Class.UNIVERSAL,
											D.Type.OID,
											!1,
											D.oidToDer(t.mgf.hash.algorithmOid).getBytes(),
										),
										D.create(D.Class.UNIVERSAL, D.Type.NULL, !1, ""),
									]),
								]),
							]),
						),
					t.saltLength !== void 0 &&
						r.push(
							D.create(D.Class.CONTEXT_SPECIFIC, 2, !0, [
								D.create(
									D.Class.UNIVERSAL,
									D.Type.INTEGER,
									!1,
									D.integerToDer(t.saltLength).getBytes(),
								),
							]),
						),
					D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, r)
				)
			default:
				return D.create(D.Class.UNIVERSAL, D.Type.NULL, !1, "")
		}
	}
	function aXe(e) {
		var t = D.create(D.Class.CONTEXT_SPECIFIC, 0, !0, [])
		if (e.attributes.length === 0) return t
		for (var r = e.attributes, n = 0; n < r.length; ++n) {
			var i = r[n],
				s = i.value,
				o = D.Type.UTF8
			"valueTagClass" in i && (o = i.valueTagClass), o === D.Type.UTF8 && (s = nt.util.encodeUtf8(s))
			var a = !1
			"valueConstructed" in i && (a = i.valueConstructed)
			var l = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
				D.create(D.Class.UNIVERSAL, D.Type.OID, !1, D.oidToDer(i.type).getBytes()),
				D.create(D.Class.UNIVERSAL, D.Type.SET, !0, [D.create(D.Class.UNIVERSAL, o, a, s)]),
			])
			t.value.push(l)
		}
		return t
	}
	var lXe = new Date("1950-01-01T00:00:00Z"),
		cXe = new Date("2050-01-01T00:00:00Z")
	function uce(e) {
		return e >= lXe && e < cXe
			? D.create(D.Class.UNIVERSAL, D.Type.UTCTIME, !1, D.dateToUtcTime(e))
			: D.create(D.Class.UNIVERSAL, D.Type.GENERALIZEDTIME, !1, D.dateToGeneralizedTime(e))
	}
	we.getTBSCertificate = function (e) {
		var t = uce(e.validity.notBefore),
			r = uce(e.validity.notAfter),
			n = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
				D.create(D.Class.CONTEXT_SPECIFIC, 0, !0, [
					D.create(D.Class.UNIVERSAL, D.Type.INTEGER, !1, D.integerToDer(e.version).getBytes()),
				]),
				D.create(D.Class.UNIVERSAL, D.Type.INTEGER, !1, nt.util.hexToBytes(e.serialNumber)),
				D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
					D.create(D.Class.UNIVERSAL, D.Type.OID, !1, D.oidToDer(e.siginfo.algorithmOid).getBytes()),
					Q5(e.siginfo.algorithmOid, e.siginfo.parameters),
				]),
				Y0(e.issuer),
				D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [t, r]),
				Y0(e.subject),
				we.publicKeyToAsn1(e.publicKey),
			])
		return (
			e.issuer.uniqueId &&
				n.value.push(
					D.create(D.Class.CONTEXT_SPECIFIC, 1, !0, [
						D.create(D.Class.UNIVERSAL, D.Type.BITSTRING, !1, "\0" + e.issuer.uniqueId),
					]),
				),
			e.subject.uniqueId &&
				n.value.push(
					D.create(D.Class.CONTEXT_SPECIFIC, 2, !0, [
						D.create(D.Class.UNIVERSAL, D.Type.BITSTRING, !1, "\0" + e.subject.uniqueId),
					]),
				),
			e.extensions.length > 0 && n.value.push(we.certificateExtensionsToAsn1(e.extensions)),
			n
		)
	}
	we.getCertificationRequestInfo = function (e) {
		var t = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
			D.create(D.Class.UNIVERSAL, D.Type.INTEGER, !1, D.integerToDer(e.version).getBytes()),
			Y0(e.subject),
			we.publicKeyToAsn1(e.publicKey),
			aXe(e),
		])
		return t
	}
	we.distinguishedNameToAsn1 = function (e) {
		return Y0(e)
	}
	we.certificateToAsn1 = function (e) {
		var t = e.tbsCertificate || we.getTBSCertificate(e)
		return D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
			t,
			D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
				D.create(D.Class.UNIVERSAL, D.Type.OID, !1, D.oidToDer(e.signatureOid).getBytes()),
				Q5(e.signatureOid, e.signatureParameters),
			]),
			D.create(D.Class.UNIVERSAL, D.Type.BITSTRING, !1, "\0" + e.signature),
		])
	}
	we.certificateExtensionsToAsn1 = function (e) {
		var t = D.create(D.Class.CONTEXT_SPECIFIC, 3, !0, []),
			r = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [])
		t.value.push(r)
		for (var n = 0; n < e.length; ++n) r.value.push(we.certificateExtensionToAsn1(e[n]))
		return t
	}
	we.certificateExtensionToAsn1 = function (e) {
		var t = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [])
		t.value.push(D.create(D.Class.UNIVERSAL, D.Type.OID, !1, D.oidToDer(e.id).getBytes())),
			e.critical && t.value.push(D.create(D.Class.UNIVERSAL, D.Type.BOOLEAN, !1, "\xFF"))
		var r = e.value
		return (
			typeof e.value != "string" && (r = D.toDer(r).getBytes()),
			t.value.push(D.create(D.Class.UNIVERSAL, D.Type.OCTETSTRING, !1, r)),
			t
		)
	}
	we.certificationRequestToAsn1 = function (e) {
		var t = e.certificationRequestInfo || we.getCertificationRequestInfo(e)
		return D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
			t,
			D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, !0, [
				D.create(D.Class.UNIVERSAL, D.Type.OID, !1, D.oidToDer(e.signatureOid).getBytes()),
				Q5(e.signatureOid, e.signatureParameters),
			]),
			D.create(D.Class.UNIVERSAL, D.Type.BITSTRING, !1, "\0" + e.signature),
		])
	}
	we.createCaStore = function (e) {
		var t = { certs: {} }
		;(t.getIssuer = function (o) {
			var a = r(o.issuer)
			return a
		}),
			(t.addCertificate = function (o) {
				if ((typeof o == "string" && (o = nt.pki.certificateFromPem(o)), n(o.subject), !t.hasCertificate(o)))
					if (o.subject.hash in t.certs) {
						var a = t.certs[o.subject.hash]
						nt.util.isArray(a) || (a = [a]), a.push(o), (t.certs[o.subject.hash] = a)
					} else t.certs[o.subject.hash] = o
			}),
			(t.hasCertificate = function (o) {
				typeof o == "string" && (o = nt.pki.certificateFromPem(o))
				var a = r(o.subject)
				if (!a) return !1
				nt.util.isArray(a) || (a = [a])
				for (var l = D.toDer(we.certificateToAsn1(o)).getBytes(), c = 0; c < a.length; ++c) {
					var u = D.toDer(we.certificateToAsn1(a[c])).getBytes()
					if (l === u) return !0
				}
				return !1
			}),
			(t.listAllCertificates = function () {
				var o = []
				for (var a in t.certs)
					if (t.certs.hasOwnProperty(a)) {
						var l = t.certs[a]
						if (!nt.util.isArray(l)) o.push(l)
						else for (var c = 0; c < l.length; ++c) o.push(l[c])
					}
				return o
			}),
			(t.removeCertificate = function (o) {
				var a
				if ((typeof o == "string" && (o = nt.pki.certificateFromPem(o)), n(o.subject), !t.hasCertificate(o)))
					return null
				var l = r(o.subject)
				if (!nt.util.isArray(l)) return (a = t.certs[o.subject.hash]), delete t.certs[o.subject.hash], a
				for (var c = D.toDer(we.certificateToAsn1(o)).getBytes(), u = 0; u < l.length; ++u) {
					var f = D.toDer(we.certificateToAsn1(l[u])).getBytes()
					c === f && ((a = l[u]), l.splice(u, 1))
				}
				return l.length === 0 && delete t.certs[o.subject.hash], a
			})
		function r(o) {
			return n(o), t.certs[o.hash] || null
		}
		function n(o) {
			if (!o.hash) {
				var a = nt.md.sha1.create()
				;(o.attributes = we.RDNAttributesAsArray(Y0(o), a)), (o.hash = a.digest().toHex())
			}
		}
		if (e)
			for (var i = 0; i < e.length; ++i) {
				var s = e[i]
				t.addCertificate(s)
			}
		return t
	}
	we.certificateError = {
		bad_certificate: "forge.pki.BadCertificate",
		unsupported_certificate: "forge.pki.UnsupportedCertificate",
		certificate_revoked: "forge.pki.CertificateRevoked",
		certificate_expired: "forge.pki.CertificateExpired",
		certificate_unknown: "forge.pki.CertificateUnknown",
		unknown_ca: "forge.pki.UnknownCertificateAuthority",
	}
	we.verifyCertificateChain = function (e, t, r) {
		typeof r == "function" && (r = { verify: r }), (r = r || {}), (t = t.slice(0))
		var n = t.slice(0),
			i = r.validityCheckDate
		typeof i > "u" && (i = new Date())
		var s = !0,
			o = null,
			a = 0
		do {
			var l = t.shift(),
				c = null,
				u = !1
			if (
				(i &&
					(i < l.validity.notBefore || i > l.validity.notAfter) &&
					(o = {
						message: "Certificate is not valid yet or has expired.",
						error: we.certificateError.certificate_expired,
						notBefore: l.validity.notBefore,
						notAfter: l.validity.notAfter,
						now: i,
					}),
				o === null)
			) {
				if (((c = t[0] || e.getIssuer(l)), c === null && l.isIssuer(l) && ((u = !0), (c = l)), c)) {
					var f = c
					nt.util.isArray(f) || (f = [f])
					for (var p = !1; !p && f.length > 0; ) {
						c = f.shift()
						try {
							p = c.verify(l)
						} catch {}
					}
					p ||
						(o = {
							message: "Certificate signature is invalid.",
							error: we.certificateError.bad_certificate,
						})
				}
				o === null &&
					(!c || u) &&
					!e.hasCertificate(l) &&
					(o = {
						message: "Certificate is not trusted.",
						error: we.certificateError.unknown_ca,
					})
			}
			if (
				(o === null &&
					c &&
					!l.isIssuer(c) &&
					(o = {
						message: "Certificate issuer is invalid.",
						error: we.certificateError.bad_certificate,
					}),
				o === null)
			)
				for (
					var g = { keyUsage: !0, basicConstraints: !0 }, m = 0;
					o === null && m < l.extensions.length;
					++m
				) {
					var y = l.extensions[m]
					y.critical &&
						!(y.name in g) &&
						(o = {
							message: "Certificate has an unsupported critical extension.",
							error: we.certificateError.unsupported_certificate,
						})
				}
			if (o === null && (!s || (t.length === 0 && (!c || u)))) {
				var C = l.getExtension("basicConstraints"),
					v = l.getExtension("keyUsage")
				if (
					(v !== null &&
						(!v.keyCertSign || C === null) &&
						(o = {
							message:
								"Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
							error: we.certificateError.bad_certificate,
						}),
					o === null &&
						C !== null &&
						!C.cA &&
						(o = {
							message: "Certificate basicConstraints indicates the certificate is not a CA.",
							error: we.certificateError.bad_certificate,
						}),
					o === null && v !== null && "pathLenConstraint" in C)
				) {
					var b = a - 1
					b > C.pathLenConstraint &&
						(o = {
							message: "Certificate basicConstraints pathLenConstraint violated.",
							error: we.certificateError.bad_certificate,
						})
				}
			}
			var w = o === null ? !0 : o.error,
				B = r.verify ? r.verify(w, a, n) : w
			if (B === !0) o = null
			else
				throw (
					(w === !0 &&
						(o = {
							message: "The application rejected the certificate.",
							error: we.certificateError.bad_certificate,
						}),
					(B || B === 0) &&
						(typeof B == "object" && !nt.util.isArray(B)
							? (B.message && (o.message = B.message), B.error && (o.error = B.error))
							: typeof B == "string" && (o.error = B)),
					o)
				)
			;(s = !1), ++a
		} while (t.length > 0)
		return !0
	}
})
var P5 = x((cBt, Ace) => {
	"use strict"
	var gn = Yt()
	gc()
	O0()
	dh()
	M5()
	k5()
	cl()
	Rb()
	W0()
	Sr()
	xT()
	var V = gn.asn1,
		or = gn.pki,
		Mb = (Ace.exports = gn.pkcs12 = gn.pkcs12 || {}),
		pce = {
			name: "ContentInfo",
			tagClass: V.Class.UNIVERSAL,
			type: V.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "ContentInfo.contentType",
					tagClass: V.Class.UNIVERSAL,
					type: V.Type.OID,
					constructed: !1,
					capture: "contentType",
				},
				{
					name: "ContentInfo.content",
					tagClass: V.Class.CONTEXT_SPECIFIC,
					constructed: !0,
					captureAsn1: "content",
				},
			],
		},
		uXe = {
			name: "PFX",
			tagClass: V.Class.UNIVERSAL,
			type: V.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "PFX.version",
					tagClass: V.Class.UNIVERSAL,
					type: V.Type.INTEGER,
					constructed: !1,
					capture: "version",
				},
				pce,
				{
					name: "PFX.macData",
					tagClass: V.Class.UNIVERSAL,
					type: V.Type.SEQUENCE,
					constructed: !0,
					optional: !0,
					captureAsn1: "mac",
					value: [
						{
							name: "PFX.macData.mac",
							tagClass: V.Class.UNIVERSAL,
							type: V.Type.SEQUENCE,
							constructed: !0,
							value: [
								{
									name: "PFX.macData.mac.digestAlgorithm",
									tagClass: V.Class.UNIVERSAL,
									type: V.Type.SEQUENCE,
									constructed: !0,
									value: [
										{
											name: "PFX.macData.mac.digestAlgorithm.algorithm",
											tagClass: V.Class.UNIVERSAL,
											type: V.Type.OID,
											constructed: !1,
											capture: "macAlgorithm",
										},
										{
											name: "PFX.macData.mac.digestAlgorithm.parameters",
											tagClass: V.Class.UNIVERSAL,
											captureAsn1: "macAlgorithmParameters",
										},
									],
								},
								{
									name: "PFX.macData.mac.digest",
									tagClass: V.Class.UNIVERSAL,
									type: V.Type.OCTETSTRING,
									constructed: !1,
									capture: "macDigest",
								},
							],
						},
						{
							name: "PFX.macData.macSalt",
							tagClass: V.Class.UNIVERSAL,
							type: V.Type.OCTETSTRING,
							constructed: !1,
							capture: "macSalt",
						},
						{
							name: "PFX.macData.iterations",
							tagClass: V.Class.UNIVERSAL,
							type: V.Type.INTEGER,
							constructed: !1,
							optional: !0,
							capture: "macIterations",
						},
					],
				},
			],
		},
		dXe = {
			name: "SafeBag",
			tagClass: V.Class.UNIVERSAL,
			type: V.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "SafeBag.bagId",
					tagClass: V.Class.UNIVERSAL,
					type: V.Type.OID,
					constructed: !1,
					capture: "bagId",
				},
				{
					name: "SafeBag.bagValue",
					tagClass: V.Class.CONTEXT_SPECIFIC,
					constructed: !0,
					captureAsn1: "bagValue",
				},
				{
					name: "SafeBag.bagAttributes",
					tagClass: V.Class.UNIVERSAL,
					type: V.Type.SET,
					constructed: !0,
					optional: !0,
					capture: "bagAttributes",
				},
			],
		},
		fXe = {
			name: "Attribute",
			tagClass: V.Class.UNIVERSAL,
			type: V.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "Attribute.attrId",
					tagClass: V.Class.UNIVERSAL,
					type: V.Type.OID,
					constructed: !1,
					capture: "oid",
				},
				{
					name: "Attribute.attrValues",
					tagClass: V.Class.UNIVERSAL,
					type: V.Type.SET,
					constructed: !0,
					capture: "values",
				},
			],
		},
		hXe = {
			name: "CertBag",
			tagClass: V.Class.UNIVERSAL,
			type: V.Type.SEQUENCE,
			constructed: !0,
			value: [
				{
					name: "CertBag.certId",
					tagClass: V.Class.UNIVERSAL,
					type: V.Type.OID,
					constructed: !1,
					capture: "certId",
				},
				{
					name: "CertBag.certValue",
					tagClass: V.Class.CONTEXT_SPECIFIC,
					constructed: !0,
					value: [
						{
							name: "CertBag.certValue[0]",
							tagClass: V.Class.UNIVERSAL,
							type: V.Class.OCTETSTRING,
							constructed: !1,
							capture: "cert",
						},
					],
				},
			],
		}
	function kb(e, t, r, n) {
		for (var i = [], s = 0; s < e.length; s++)
			for (var o = 0; o < e[s].safeBags.length; o++) {
				var a = e[s].safeBags[o]
				if (!(n !== void 0 && a.type !== n)) {
					if (t === null) {
						i.push(a)
						continue
					}
					a.attributes[t] !== void 0 && a.attributes[t].indexOf(r) >= 0 && i.push(a)
				}
			}
		return i
	}
	Mb.pkcs12FromAsn1 = function (e, t, r) {
		typeof t == "string" ? ((r = t), (t = !0)) : t === void 0 && (t = !0)
		var n = {},
			i = []
		if (!V.validate(e, uXe, n, i)) {
			var s = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.")
			throw ((s.errors = s), s)
		}
		var o = {
			version: n.version.charCodeAt(0),
			safeContents: [],
			getBags: function (C) {
				var v = {},
					b
				return (
					"localKeyId" in C
						? (b = C.localKeyId)
						: "localKeyIdHex" in C && (b = gn.util.hexToBytes(C.localKeyIdHex)),
					b === void 0 &&
						!("friendlyName" in C) &&
						"bagType" in C &&
						(v[C.bagType] = kb(o.safeContents, null, null, C.bagType)),
					b !== void 0 && (v.localKeyId = kb(o.safeContents, "localKeyId", b, C.bagType)),
					"friendlyName" in C &&
						(v.friendlyName = kb(o.safeContents, "friendlyName", C.friendlyName, C.bagType)),
					v
				)
			},
			getBagsByFriendlyName: function (C, v) {
				return kb(o.safeContents, "friendlyName", C, v)
			},
			getBagsByLocalKeyId: function (C, v) {
				return kb(o.safeContents, "localKeyId", C, v)
			},
		}
		if (n.version.charCodeAt(0) !== 3) {
			var s = new Error("PKCS#12 PFX of version other than 3 not supported.")
			throw ((s.version = n.version.charCodeAt(0)), s)
		}
		if (V.derToOid(n.contentType) !== or.oids.data) {
			var s = new Error("Only PKCS#12 PFX in password integrity mode supported.")
			throw ((s.oid = V.derToOid(n.contentType)), s)
		}
		var a = n.content.value[0]
		if (a.tagClass !== V.Class.UNIVERSAL || a.type !== V.Type.OCTETSTRING)
			throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.")
		if (((a = N5(a)), n.mac)) {
			var l = null,
				c = 0,
				u = V.derToOid(n.macAlgorithm)
			switch (u) {
				case or.oids.sha1:
					;(l = gn.md.sha1.create()), (c = 20)
					break
				case or.oids.sha256:
					;(l = gn.md.sha256.create()), (c = 32)
					break
				case or.oids.sha384:
					;(l = gn.md.sha384.create()), (c = 48)
					break
				case or.oids.sha512:
					;(l = gn.md.sha512.create()), (c = 64)
					break
				case or.oids.md5:
					;(l = gn.md.md5.create()), (c = 16)
					break
			}
			if (l === null) throw new Error("PKCS#12 uses unsupported MAC algorithm: " + u)
			var f = new gn.util.ByteBuffer(n.macSalt),
				p = "macIterations" in n ? parseInt(gn.util.bytesToHex(n.macIterations), 16) : 1,
				g = Mb.generateKey(r, f, 3, p, c, l),
				m = gn.hmac.create()
			m.start(l, g), m.update(a.value)
			var y = m.getMac()
			if (y.getBytes() !== n.macDigest) throw new Error("PKCS#12 MAC could not be verified. Invalid password?")
		}
		return gXe(o, a.value, t, r), o
	}
	function N5(e) {
		if (e.composed || e.constructed) {
			for (var t = gn.util.createBuffer(), r = 0; r < e.value.length; ++r) t.putBytes(e.value[r].value)
			;(e.composed = e.constructed = !1), (e.value = t.getBytes())
		}
		return e
	}
	function gXe(e, t, r, n) {
		if (
			((t = V.fromDer(t, r)),
			t.tagClass !== V.Class.UNIVERSAL || t.type !== V.Type.SEQUENCE || t.constructed !== !0)
		)
			throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo")
		for (var i = 0; i < t.value.length; i++) {
			var s = t.value[i],
				o = {},
				a = []
			if (!V.validate(s, pce, o, a)) {
				var l = new Error("Cannot read ContentInfo.")
				throw ((l.errors = a), l)
			}
			var c = { encrypted: !1 },
				u = null,
				f = o.content.value[0]
			switch (V.derToOid(o.contentType)) {
				case or.oids.data:
					if (f.tagClass !== V.Class.UNIVERSAL || f.type !== V.Type.OCTETSTRING)
						throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.")
					u = N5(f).value
					break
				case or.oids.encryptedData:
					;(u = pXe(f, n)), (c.encrypted = !0)
					break
				default:
					var l = new Error("Unsupported PKCS#12 contentType.")
					throw ((l.contentType = V.derToOid(o.contentType)), l)
			}
			;(c.safeBags = AXe(u, r, n)), e.safeContents.push(c)
		}
	}
	function pXe(e, t) {
		var r = {},
			n = []
		if (!V.validate(e, gn.pkcs7.asn1.encryptedDataValidator, r, n)) {
			var i = new Error("Cannot read EncryptedContentInfo.")
			throw ((i.errors = n), i)
		}
		var s = V.derToOid(r.contentType)
		if (s !== or.oids.data) {
			var i = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.")
			throw ((i.oid = s), i)
		}
		s = V.derToOid(r.encAlgorithm)
		var o = or.pbe.getCipher(s, r.encParameter, t),
			a = N5(r.encryptedContentAsn1),
			l = gn.util.createBuffer(a.value)
		if ((o.update(l), !o.finish())) throw new Error("Failed to decrypt PKCS#12 SafeContents.")
		return o.output.getBytes()
	}
	function AXe(e, t, r) {
		if (!t && e.length === 0) return []
		if (
			((e = V.fromDer(e, t)),
			e.tagClass !== V.Class.UNIVERSAL || e.type !== V.Type.SEQUENCE || e.constructed !== !0)
		)
			throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.")
		for (var n = [], i = 0; i < e.value.length; i++) {
			var s = e.value[i],
				o = {},
				a = []
			if (!V.validate(s, dXe, o, a)) {
				var l = new Error("Cannot read SafeBag.")
				throw ((l.errors = a), l)
			}
			var c = { type: V.derToOid(o.bagId), attributes: mXe(o.bagAttributes) }
			n.push(c)
			var u,
				f,
				p = o.bagValue.value[0]
			switch (c.type) {
				case or.oids.pkcs8ShroudedKeyBag:
					if (((p = or.decryptPrivateKeyInfo(p, r)), p === null))
						throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?")
				case or.oids.keyBag:
					try {
						c.key = or.privateKeyFromAsn1(p)
					} catch {
						;(c.key = null), (c.asn1 = p)
					}
					continue
				case or.oids.certBag:
					;(u = hXe),
						(f = function () {
							if (V.derToOid(o.certId) !== or.oids.x509Certificate) {
								var m = new Error("Unsupported certificate type, only X.509 supported.")
								throw ((m.oid = V.derToOid(o.certId)), m)
							}
							var y = V.fromDer(o.cert, t)
							try {
								c.cert = or.certificateFromAsn1(y, !0)
							} catch {
								;(c.cert = null), (c.asn1 = y)
							}
						})
					break
				default:
					var l = new Error("Unsupported PKCS#12 SafeBag type.")
					throw ((l.oid = c.type), l)
			}
			if (u !== void 0 && !V.validate(p, u, o, a)) {
				var l = new Error("Cannot read PKCS#12 " + u.name)
				throw ((l.errors = a), l)
			}
			f()
		}
		return n
	}
	function mXe(e) {
		var t = {}
		if (e !== void 0)
			for (var r = 0; r < e.length; ++r) {
				var n = {},
					i = []
				if (!V.validate(e[r], fXe, n, i)) {
					var s = new Error("Cannot read PKCS#12 BagAttribute.")
					throw ((s.errors = i), s)
				}
				var o = V.derToOid(n.oid)
				if (or.oids[o] !== void 0) {
					t[or.oids[o]] = []
					for (var a = 0; a < n.values.length; ++a) t[or.oids[o]].push(n.values[a].value)
				}
			}
		return t
	}
	Mb.toPkcs12Asn1 = function (e, t, r, n) {
		;(n = n || {}),
			(n.saltSize = n.saltSize || 8),
			(n.count = n.count || 2048),
			(n.algorithm = n.algorithm || n.encAlgorithm || "aes128"),
			"useMac" in n || (n.useMac = !0),
			"localKeyId" in n || (n.localKeyId = null),
			"generateLocalKeyId" in n || (n.generateLocalKeyId = !0)
		var i = n.localKeyId,
			s
		if (i !== null) i = gn.util.hexToBytes(i)
		else if (n.generateLocalKeyId)
			if (t) {
				var o = gn.util.isArray(t) ? t[0] : t
				typeof o == "string" && (o = or.certificateFromPem(o))
				var a = gn.md.sha1.create()
				a.update(V.toDer(or.certificateToAsn1(o)).getBytes()), (i = a.digest().getBytes())
			} else i = gn.random.getBytes(20)
		var l = []
		i !== null &&
			l.push(
				V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
					V.create(V.Class.UNIVERSAL, V.Type.OID, !1, V.oidToDer(or.oids.localKeyId).getBytes()),
					V.create(V.Class.UNIVERSAL, V.Type.SET, !0, [
						V.create(V.Class.UNIVERSAL, V.Type.OCTETSTRING, !1, i),
					]),
				]),
			),
			"friendlyName" in n &&
				l.push(
					V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
						V.create(V.Class.UNIVERSAL, V.Type.OID, !1, V.oidToDer(or.oids.friendlyName).getBytes()),
						V.create(V.Class.UNIVERSAL, V.Type.SET, !0, [
							V.create(V.Class.UNIVERSAL, V.Type.BMPSTRING, !1, n.friendlyName),
						]),
					]),
				),
			l.length > 0 && (s = V.create(V.Class.UNIVERSAL, V.Type.SET, !0, l))
		var c = [],
			u = []
		t !== null && (gn.util.isArray(t) ? (u = t) : (u = [t]))
		for (var f = [], p = 0; p < u.length; ++p) {
			;(t = u[p]), typeof t == "string" && (t = or.certificateFromPem(t))
			var g = p === 0 ? s : void 0,
				m = or.certificateToAsn1(t),
				y = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
					V.create(V.Class.UNIVERSAL, V.Type.OID, !1, V.oidToDer(or.oids.certBag).getBytes()),
					V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, [
						V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
							V.create(V.Class.UNIVERSAL, V.Type.OID, !1, V.oidToDer(or.oids.x509Certificate).getBytes()),
							V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, [
								V.create(V.Class.UNIVERSAL, V.Type.OCTETSTRING, !1, V.toDer(m).getBytes()),
							]),
						]),
					]),
					g,
				])
			f.push(y)
		}
		if (f.length > 0) {
			var C = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, f),
				v = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
					V.create(V.Class.UNIVERSAL, V.Type.OID, !1, V.oidToDer(or.oids.data).getBytes()),
					V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, [
						V.create(V.Class.UNIVERSAL, V.Type.OCTETSTRING, !1, V.toDer(C).getBytes()),
					]),
				])
			c.push(v)
		}
		var b = null
		if (e !== null) {
			var w = or.wrapRsaPrivateKey(or.privateKeyToAsn1(e))
			r === null
				? (b = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
						V.create(V.Class.UNIVERSAL, V.Type.OID, !1, V.oidToDer(or.oids.keyBag).getBytes()),
						V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, [w]),
						s,
					]))
				: (b = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
						V.create(V.Class.UNIVERSAL, V.Type.OID, !1, V.oidToDer(or.oids.pkcs8ShroudedKeyBag).getBytes()),
						V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, [or.encryptPrivateKeyInfo(w, r, n)]),
						s,
					]))
			var B = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [b]),
				M = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
					V.create(V.Class.UNIVERSAL, V.Type.OID, !1, V.oidToDer(or.oids.data).getBytes()),
					V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, [
						V.create(V.Class.UNIVERSAL, V.Type.OCTETSTRING, !1, V.toDer(B).getBytes()),
					]),
				])
			c.push(M)
		}
		var Q = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, c),
			O
		if (n.useMac) {
			var a = gn.md.sha1.create(),
				Y = new gn.util.ByteBuffer(gn.random.getBytes(n.saltSize)),
				j = n.count,
				e = Mb.generateKey(r, Y, 3, j, 20),
				ne = gn.hmac.create()
			ne.start(a, e), ne.update(V.toDer(Q).getBytes())
			var q = ne.getMac()
			O = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
				V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
					V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
						V.create(V.Class.UNIVERSAL, V.Type.OID, !1, V.oidToDer(or.oids.sha1).getBytes()),
						V.create(V.Class.UNIVERSAL, V.Type.NULL, !1, ""),
					]),
					V.create(V.Class.UNIVERSAL, V.Type.OCTETSTRING, !1, q.getBytes()),
				]),
				V.create(V.Class.UNIVERSAL, V.Type.OCTETSTRING, !1, Y.getBytes()),
				V.create(V.Class.UNIVERSAL, V.Type.INTEGER, !1, V.integerToDer(j).getBytes()),
			])
		}
		return V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
			V.create(V.Class.UNIVERSAL, V.Type.INTEGER, !1, V.integerToDer(3).getBytes()),
			V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
				V.create(V.Class.UNIVERSAL, V.Type.OID, !1, V.oidToDer(or.oids.data).getBytes()),
				V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, [
					V.create(V.Class.UNIVERSAL, V.Type.OCTETSTRING, !1, V.toDer(Q).getBytes()),
				]),
			]),
			O,
		])
	}
	Mb.generateKey = gn.pbe.generatePkcs12Key
})
var U5 = x((uBt, mce) => {
	"use strict"
	var ph = Yt()
	gc()
	dh()
	k5()
	_p()
	hT()
	P5()
	vT()
	Rb()
	Sr()
	xT()
	var L5 = ph.asn1,
		K0 = (mce.exports = ph.pki = ph.pki || {})
	K0.pemToDer = function (e) {
		var t = ph.pem.decode(e)[0]
		if (t.procType && t.procType.type === "ENCRYPTED")
			throw new Error("Could not convert PEM to DER; PEM is encrypted.")
		return ph.util.createBuffer(t.body)
	}
	K0.privateKeyFromPem = function (e) {
		var t = ph.pem.decode(e)[0]
		if (t.type !== "PRIVATE KEY" && t.type !== "RSA PRIVATE KEY") {
			var r = new Error(
				'Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".',
			)
			throw ((r.headerType = t.type), r)
		}
		if (t.procType && t.procType.type === "ENCRYPTED")
			throw new Error("Could not convert private key from PEM; PEM is encrypted.")
		var n = L5.fromDer(t.body)
		return K0.privateKeyFromAsn1(n)
	}
	K0.privateKeyToPem = function (e, t) {
		var r = {
			type: "RSA PRIVATE KEY",
			body: L5.toDer(K0.privateKeyToAsn1(e)).getBytes(),
		}
		return ph.pem.encode(r, { maxline: t })
	}
	K0.privateKeyInfoToPem = function (e, t) {
		var r = { type: "PRIVATE KEY", body: L5.toDer(e).getBytes() }
		return ph.pem.encode(r, { maxline: t })
	}
})
var G5 = x((dBt, wce) => {
	"use strict"
	var pe = Yt()
	gc()
	O0()
	cT()
	_p()
	U5()
	cl()
	W0()
	Sr()
	var ST = function (e, t, r, n) {
			var i = pe.util.createBuffer(),
				s = e.length >> 1,
				o = s + (e.length & 1),
				a = e.substr(0, o),
				l = e.substr(s, o),
				c = pe.util.createBuffer(),
				u = pe.hmac.create()
			r = t + r
			var f = Math.ceil(n / 16),
				p = Math.ceil(n / 20)
			u.start("MD5", a)
			var g = pe.util.createBuffer()
			c.putBytes(r)
			for (var m = 0; m < f; ++m)
				u.start(null, null),
					u.update(c.getBytes()),
					c.putBuffer(u.digest()),
					u.start(null, null),
					u.update(c.bytes() + r),
					g.putBuffer(u.digest())
			u.start("SHA1", l)
			var y = pe.util.createBuffer()
			c.clear(), c.putBytes(r)
			for (var m = 0; m < p; ++m)
				u.start(null, null),
					u.update(c.getBytes()),
					c.putBuffer(u.digest()),
					u.start(null, null),
					u.update(c.bytes() + r),
					y.putBuffer(u.digest())
			return i.putBytes(pe.util.xorBytes(g.getBytes(), y.getBytes(), n)), i
		},
		yXe = function (e, t, r) {
			var n = pe.hmac.create()
			n.start("SHA1", e)
			var i = pe.util.createBuffer()
			return (
				i.putInt32(t[0]),
				i.putInt32(t[1]),
				i.putByte(r.type),
				i.putByte(r.version.major),
				i.putByte(r.version.minor),
				i.putInt16(r.length),
				i.putBytes(r.fragment.bytes()),
				n.update(i.getBytes()),
				n.digest().getBytes()
			)
		},
		CXe = function (e, t, r) {
			var n = !1
			try {
				var i = e.deflate(t.fragment.getBytes())
				;(t.fragment = pe.util.createBuffer(i)), (t.length = i.length), (n = !0)
			} catch {}
			return n
		},
		vXe = function (e, t, r) {
			var n = !1
			try {
				var i = e.inflate(t.fragment.getBytes())
				;(t.fragment = pe.util.createBuffer(i)), (t.length = i.length), (n = !0)
			} catch {}
			return n
		},
		ba = function (e, t) {
			var r = 0
			switch (t) {
				case 1:
					r = e.getByte()
					break
				case 2:
					r = e.getInt16()
					break
				case 3:
					r = e.getInt24()
					break
				case 4:
					r = e.getInt32()
					break
			}
			return pe.util.createBuffer(e.getBytes(r))
		},
		hl = function (e, t, r) {
			e.putInt(r.length(), t << 3), e.putBuffer(r)
		},
		k = {}
	k.Versions = {
		TLS_1_0: { major: 3, minor: 1 },
		TLS_1_1: { major: 3, minor: 2 },
		TLS_1_2: { major: 3, minor: 3 },
	}
	k.SupportedVersions = [k.Versions.TLS_1_1, k.Versions.TLS_1_0]
	k.Version = k.SupportedVersions[0]
	k.MaxFragment = 15360
	k.ConnectionEnd = { server: 0, client: 1 }
	k.PRFAlgorithm = { tls_prf_sha256: 0 }
	k.BulkCipherAlgorithm = { none: null, rc4: 0, des3: 1, aes: 2 }
	k.CipherType = { stream: 0, block: 1, aead: 2 }
	k.MACAlgorithm = {
		none: null,
		hmac_md5: 0,
		hmac_sha1: 1,
		hmac_sha256: 2,
		hmac_sha384: 3,
		hmac_sha512: 4,
	}
	k.CompressionMethod = { none: 0, deflate: 1 }
	k.ContentType = {
		change_cipher_spec: 20,
		alert: 21,
		handshake: 22,
		application_data: 23,
		heartbeat: 24,
	}
	k.HandshakeType = {
		hello_request: 0,
		client_hello: 1,
		server_hello: 2,
		certificate: 11,
		server_key_exchange: 12,
		certificate_request: 13,
		server_hello_done: 14,
		certificate_verify: 15,
		client_key_exchange: 16,
		finished: 20,
	}
	k.Alert = {}
	k.Alert.Level = { warning: 1, fatal: 2 }
	k.Alert.Description = {
		close_notify: 0,
		unexpected_message: 10,
		bad_record_mac: 20,
		decryption_failed: 21,
		record_overflow: 22,
		decompression_failure: 30,
		handshake_failure: 40,
		bad_certificate: 42,
		unsupported_certificate: 43,
		certificate_revoked: 44,
		certificate_expired: 45,
		certificate_unknown: 46,
		illegal_parameter: 47,
		unknown_ca: 48,
		access_denied: 49,
		decode_error: 50,
		decrypt_error: 51,
		export_restriction: 60,
		protocol_version: 70,
		insufficient_security: 71,
		internal_error: 80,
		user_canceled: 90,
		no_renegotiation: 100,
	}
	k.HeartbeatMessageType = { heartbeat_request: 1, heartbeat_response: 2 }
	k.CipherSuites = {}
	k.getCipherSuite = function (e) {
		var t = null
		for (var r in k.CipherSuites) {
			var n = k.CipherSuites[r]
			if (n.id[0] === e.charCodeAt(0) && n.id[1] === e.charCodeAt(1)) {
				t = n
				break
			}
		}
		return t
	}
	k.handleUnexpected = function (e, t) {
		var r = !e.open && e.entity === k.ConnectionEnd.client
		r ||
			e.error(e, {
				message: "Unexpected message. Received TLS record out of order.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.unexpected_message,
				},
			})
	}
	k.handleHelloRequest = function (e, t, r) {
		!e.handshaking &&
			e.handshakes > 0 &&
			(k.queue(
				e,
				k.createAlert(e, {
					level: k.Alert.Level.warning,
					description: k.Alert.Description.no_renegotiation,
				}),
			),
			k.flush(e)),
			e.process()
	}
	k.parseHelloMessage = function (e, t, r) {
		var n = null,
			i = e.entity === k.ConnectionEnd.client
		if (r < 38)
			e.error(e, {
				message: i
					? "Invalid ServerHello message. Message too short."
					: "Invalid ClientHello message. Message too short.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.illegal_parameter,
				},
			})
		else {
			var s = t.fragment,
				o = s.length()
			if (
				((n = {
					version: { major: s.getByte(), minor: s.getByte() },
					random: pe.util.createBuffer(s.getBytes(32)),
					session_id: ba(s, 1),
					extensions: [],
				}),
				i
					? ((n.cipher_suite = s.getBytes(2)), (n.compression_method = s.getByte()))
					: ((n.cipher_suites = ba(s, 2)), (n.compression_methods = ba(s, 1))),
				(o = r - (o - s.length())),
				o > 0)
			) {
				for (var a = ba(s, 2); a.length() > 0; )
					n.extensions.push({
						type: [a.getByte(), a.getByte()],
						data: ba(a, 2),
					})
				if (!i)
					for (var l = 0; l < n.extensions.length; ++l) {
						var c = n.extensions[l]
						if (c.type[0] === 0 && c.type[1] === 0)
							for (var u = ba(c.data, 2); u.length() > 0; ) {
								var f = u.getByte()
								if (f !== 0) break
								e.session.extensions.server_name.serverNameList.push(ba(u, 2).getBytes())
							}
					}
			}
			if (
				e.session.version &&
				(n.version.major !== e.session.version.major || n.version.minor !== e.session.version.minor)
			)
				return e.error(e, {
					message: "TLS version change is disallowed during renegotiation.",
					send: !0,
					alert: {
						level: k.Alert.Level.fatal,
						description: k.Alert.Description.protocol_version,
					},
				})
			if (i) e.session.cipherSuite = k.getCipherSuite(n.cipher_suite)
			else
				for (
					var p = pe.util.createBuffer(n.cipher_suites.bytes());
					p.length() > 0 &&
					((e.session.cipherSuite = k.getCipherSuite(p.getBytes(2))), e.session.cipherSuite === null);

				);
			if (e.session.cipherSuite === null)
				return e.error(e, {
					message: "No cipher suites in common.",
					send: !0,
					alert: {
						level: k.Alert.Level.fatal,
						description: k.Alert.Description.handshake_failure,
					},
					cipherSuite: pe.util.bytesToHex(n.cipher_suite),
				})
			i
				? (e.session.compressionMethod = n.compression_method)
				: (e.session.compressionMethod = k.CompressionMethod.none)
		}
		return n
	}
	k.createSecurityParameters = function (e, t) {
		var r = e.entity === k.ConnectionEnd.client,
			n = t.random.bytes(),
			i = r ? e.session.sp.client_random : n,
			s = r ? n : k.createRandom().getBytes()
		e.session.sp = {
			entity: e.entity,
			prf_algorithm: k.PRFAlgorithm.tls_prf_sha256,
			bulk_cipher_algorithm: null,
			cipher_type: null,
			enc_key_length: null,
			block_length: null,
			fixed_iv_length: null,
			record_iv_length: null,
			mac_algorithm: null,
			mac_length: null,
			mac_key_length: null,
			compression_algorithm: e.session.compressionMethod,
			pre_master_secret: null,
			master_secret: null,
			client_random: i,
			server_random: s,
		}
	}
	k.handleServerHello = function (e, t, r) {
		var n = k.parseHelloMessage(e, t, r)
		if (!e.fail) {
			if (n.version.minor <= e.version.minor) e.version.minor = n.version.minor
			else
				return e.error(e, {
					message: "Incompatible TLS version.",
					send: !0,
					alert: {
						level: k.Alert.Level.fatal,
						description: k.Alert.Description.protocol_version,
					},
				})
			e.session.version = e.version
			var i = n.session_id.bytes()
			i.length > 0 && i === e.session.id
				? ((e.expect = vce), (e.session.resuming = !0), (e.session.sp.server_random = n.random.bytes()))
				: ((e.expect = bXe), (e.session.resuming = !1), k.createSecurityParameters(e, n)),
				(e.session.id = i),
				e.process()
		}
	}
	k.handleClientHello = function (e, t, r) {
		var n = k.parseHelloMessage(e, t, r)
		if (!e.fail) {
			var i = n.session_id.bytes(),
				s = null
			if (
				(e.sessionCache &&
					((s = e.sessionCache.getSession(i)),
					s === null
						? (i = "")
						: (s.version.major !== n.version.major || s.version.minor > n.version.minor) &&
							((s = null), (i = ""))),
				i.length === 0 && (i = pe.random.getBytes(32)),
				(e.session.id = i),
				(e.session.clientHelloVersion = n.version),
				(e.session.sp = {}),
				s)
			)
				(e.version = e.session.version = s.version), (e.session.sp = s.sp)
			else {
				for (
					var o, a = 1;
					a < k.SupportedVersions.length && ((o = k.SupportedVersions[a]), !(o.minor <= n.version.minor));
					++a
				);
				;(e.version = { major: o.major, minor: o.minor }), (e.session.version = e.version)
			}
			s !== null
				? ((e.expect = H5), (e.session.resuming = !0), (e.session.sp.client_random = n.random.bytes()))
				: ((e.expect = e.verifyClient !== !1 ? DXe : V5),
					(e.session.resuming = !1),
					k.createSecurityParameters(e, n)),
				(e.open = !0),
				k.queue(
					e,
					k.createRecord(e, {
						type: k.ContentType.handshake,
						data: k.createServerHello(e),
					}),
				),
				e.session.resuming
					? (k.queue(
							e,
							k.createRecord(e, {
								type: k.ContentType.change_cipher_spec,
								data: k.createChangeCipherSpec(),
							}),
						),
						(e.state.pending = k.createConnectionState(e)),
						(e.state.current.write = e.state.pending.write),
						k.queue(
							e,
							k.createRecord(e, {
								type: k.ContentType.handshake,
								data: k.createFinished(e),
							}),
						))
					: (k.queue(
							e,
							k.createRecord(e, {
								type: k.ContentType.handshake,
								data: k.createCertificate(e),
							}),
						),
						e.fail ||
							(k.queue(
								e,
								k.createRecord(e, {
									type: k.ContentType.handshake,
									data: k.createServerKeyExchange(e),
								}),
							),
							e.verifyClient !== !1 &&
								k.queue(
									e,
									k.createRecord(e, {
										type: k.ContentType.handshake,
										data: k.createCertificateRequest(e),
									}),
								),
							k.queue(
								e,
								k.createRecord(e, {
									type: k.ContentType.handshake,
									data: k.createServerHelloDone(e),
								}),
							))),
				k.flush(e),
				e.process()
		}
	}
	k.handleCertificate = function (e, t, r) {
		if (r < 3)
			return e.error(e, {
				message: "Invalid Certificate message. Message too short.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.illegal_parameter,
				},
			})
		var n = t.fragment,
			i = { certificate_list: ba(n, 3) },
			s,
			o,
			a = []
		try {
			for (; i.certificate_list.length() > 0; )
				(s = ba(i.certificate_list, 3)),
					(o = pe.asn1.fromDer(s)),
					(s = pe.pki.certificateFromAsn1(o, !0)),
					a.push(s)
		} catch (c) {
			return e.error(e, {
				message: "Could not parse certificate list.",
				cause: c,
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.bad_certificate,
				},
			})
		}
		var l = e.entity === k.ConnectionEnd.client
		;(l || e.verifyClient === !0) && a.length === 0
			? e.error(e, {
					message: l ? "No server certificate provided." : "No client certificate provided.",
					send: !0,
					alert: {
						level: k.Alert.Level.fatal,
						description: k.Alert.Description.illegal_parameter,
					},
				})
			: a.length === 0
				? (e.expect = l ? yce : V5)
				: (l ? (e.session.serverCertificate = a[0]) : (e.session.clientCertificate = a[0]),
					k.verifyCertificateChain(e, a) && (e.expect = l ? yce : V5)),
			e.process()
	}
	k.handleServerKeyExchange = function (e, t, r) {
		if (r > 0)
			return e.error(e, {
				message: "Invalid key parameters. Only RSA is supported.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.unsupported_certificate,
				},
			})
		;(e.expect = xXe), e.process()
	}
	k.handleClientKeyExchange = function (e, t, r) {
		if (r < 48)
			return e.error(e, {
				message: "Invalid key parameters. Only RSA is supported.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.unsupported_certificate,
				},
			})
		var n = t.fragment,
			i = { enc_pre_master_secret: ba(n, 2).getBytes() },
			s = null
		if (e.getPrivateKey)
			try {
				;(s = e.getPrivateKey(e, e.session.serverCertificate)), (s = pe.pki.privateKeyFromPem(s))
			} catch (l) {
				e.error(e, {
					message: "Could not get private key.",
					cause: l,
					send: !0,
					alert: {
						level: k.Alert.Level.fatal,
						description: k.Alert.Description.internal_error,
					},
				})
			}
		if (s === null)
			return e.error(e, {
				message: "No private key set.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.internal_error,
				},
			})
		try {
			var o = e.session.sp
			o.pre_master_secret = s.decrypt(i.enc_pre_master_secret)
			var a = e.session.clientHelloVersion
			if (a.major !== o.pre_master_secret.charCodeAt(0) || a.minor !== o.pre_master_secret.charCodeAt(1))
				throw new Error("TLS version rollback attack detected.")
		} catch {
			o.pre_master_secret = pe.random.getBytes(48)
		}
		;(e.expect = H5), e.session.clientCertificate !== null && (e.expect = TXe), e.process()
	}
	k.handleCertificateRequest = function (e, t, r) {
		if (r < 3)
			return e.error(e, {
				message: "Invalid CertificateRequest. Message too short.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.illegal_parameter,
				},
			})
		var n = t.fragment,
			i = { certificate_types: ba(n, 1), certificate_authorities: ba(n, 2) }
		;(e.session.certificateRequest = i), (e.expect = _Xe), e.process()
	}
	k.handleCertificateVerify = function (e, t, r) {
		if (r < 2)
			return e.error(e, {
				message: "Invalid CertificateVerify. Message too short.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.illegal_parameter,
				},
			})
		var n = t.fragment
		n.read -= 4
		var i = n.bytes()
		n.read += 4
		var s = { signature: ba(n, 2).getBytes() },
			o = pe.util.createBuffer()
		o.putBuffer(e.session.md5.digest()), o.putBuffer(e.session.sha1.digest()), (o = o.getBytes())
		try {
			var a = e.session.clientCertificate
			if (!a.publicKey.verify(o, s.signature, "NONE"))
				throw new Error("CertificateVerify signature does not match.")
			e.session.md5.update(i), e.session.sha1.update(i)
		} catch {
			return e.error(e, {
				message: "Bad signature in CertificateVerify.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.handshake_failure,
				},
			})
		}
		;(e.expect = H5), e.process()
	}
	k.handleServerHelloDone = function (e, t, r) {
		if (r > 0)
			return e.error(e, {
				message: "Invalid ServerHelloDone message. Invalid length.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.record_overflow,
				},
			})
		if (e.serverCertificate === null) {
			var n = {
					message: "No server certificate provided. Not enough security.",
					send: !0,
					alert: {
						level: k.Alert.Level.fatal,
						description: k.Alert.Description.insufficient_security,
					},
				},
				i = 0,
				s = e.verify(e, n.alert.description, i, [])
			if (s !== !0)
				return (
					(s || s === 0) &&
						(typeof s == "object" && !pe.util.isArray(s)
							? (s.message && (n.message = s.message), s.alert && (n.alert.description = s.alert))
							: typeof s == "number" && (n.alert.description = s)),
					e.error(e, n)
				)
		}
		e.session.certificateRequest !== null &&
			((t = k.createRecord(e, {
				type: k.ContentType.handshake,
				data: k.createCertificate(e),
			})),
			k.queue(e, t)),
			(t = k.createRecord(e, {
				type: k.ContentType.handshake,
				data: k.createClientKeyExchange(e),
			})),
			k.queue(e, t),
			(e.expect = SXe)
		var o = function (a, l) {
			a.session.certificateRequest !== null &&
				a.session.clientCertificate !== null &&
				k.queue(
					a,
					k.createRecord(a, {
						type: k.ContentType.handshake,
						data: k.createCertificateVerify(a, l),
					}),
				),
				k.queue(
					a,
					k.createRecord(a, {
						type: k.ContentType.change_cipher_spec,
						data: k.createChangeCipherSpec(),
					}),
				),
				(a.state.pending = k.createConnectionState(a)),
				(a.state.current.write = a.state.pending.write),
				k.queue(
					a,
					k.createRecord(a, {
						type: k.ContentType.handshake,
						data: k.createFinished(a),
					}),
				),
				(a.expect = vce),
				k.flush(a),
				a.process()
		}
		if (e.session.certificateRequest === null || e.session.clientCertificate === null) return o(e, null)
		k.getClientSignature(e, o)
	}
	k.handleChangeCipherSpec = function (e, t) {
		if (t.fragment.getByte() !== 1)
			return e.error(e, {
				message: "Invalid ChangeCipherSpec message received.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.illegal_parameter,
				},
			})
		var r = e.entity === k.ConnectionEnd.client
		;((e.session.resuming && r) || (!e.session.resuming && !r)) && (e.state.pending = k.createConnectionState(e)),
			(e.state.current.read = e.state.pending.read),
			((!e.session.resuming && r) || (e.session.resuming && !r)) && (e.state.pending = null),
			(e.expect = r ? wXe : RXe),
			e.process()
	}
	k.handleFinished = function (e, t, r) {
		var n = t.fragment
		n.read -= 4
		var i = n.bytes()
		n.read += 4
		var s = t.fragment.getBytes()
		;(n = pe.util.createBuffer()), n.putBuffer(e.session.md5.digest()), n.putBuffer(e.session.sha1.digest())
		var o = e.entity === k.ConnectionEnd.client,
			a = o ? "server finished" : "client finished",
			l = e.session.sp,
			c = 12,
			u = ST
		if (((n = u(l.master_secret, a, n.getBytes(), c)), n.getBytes() !== s))
			return e.error(e, {
				message: "Invalid verify_data in Finished message.",
				send: !0,
				alert: {
					level: k.Alert.Level.fatal,
					description: k.Alert.Description.decrypt_error,
				},
			})
		e.session.md5.update(i),
			e.session.sha1.update(i),
			((e.session.resuming && o) || (!e.session.resuming && !o)) &&
				(k.queue(
					e,
					k.createRecord(e, {
						type: k.ContentType.change_cipher_spec,
						data: k.createChangeCipherSpec(),
					}),
				),
				(e.state.current.write = e.state.pending.write),
				(e.state.pending = null),
				k.queue(
					e,
					k.createRecord(e, {
						type: k.ContentType.handshake,
						data: k.createFinished(e),
					}),
				)),
			(e.expect = o ? IXe : kXe),
			(e.handshaking = !1),
			++e.handshakes,
			(e.peerCertificate = o ? e.session.serverCertificate : e.session.clientCertificate),
			k.flush(e),
			(e.isConnected = !0),
			e.connected(e),
			e.process()
	}
	k.handleAlert = function (e, t) {
		var r = t.fragment,
			n = { level: r.getByte(), description: r.getByte() },
			i
		switch (n.description) {
			case k.Alert.Description.close_notify:
				i = "Connection closed."
				break
			case k.Alert.Description.unexpected_message:
				i = "Unexpected message."
				break
			case k.Alert.Description.bad_record_mac:
				i = "Bad record MAC."
				break
			case k.Alert.Description.decryption_failed:
				i = "Decryption failed."
				break
			case k.Alert.Description.record_overflow:
				i = "Record overflow."
				break
			case k.Alert.Description.decompression_failure:
				i = "Decompression failed."
				break
			case k.Alert.Description.handshake_failure:
				i = "Handshake failure."
				break
			case k.Alert.Description.bad_certificate:
				i = "Bad certificate."
				break
			case k.Alert.Description.unsupported_certificate:
				i = "Unsupported certificate."
				break
			case k.Alert.Description.certificate_revoked:
				i = "Certificate revoked."
				break
			case k.Alert.Description.certificate_expired:
				i = "Certificate expired."
				break
			case k.Alert.Description.certificate_unknown:
				i = "Certificate unknown."
				break
			case k.Alert.Description.illegal_parameter:
				i = "Illegal parameter."
				break
			case k.Alert.Description.unknown_ca:
				i = "Unknown certificate authority."
				break
			case k.Alert.Description.access_denied:
				i = "Access denied."
				break
			case k.Alert.Description.decode_error:
				i = "Decode error."
				break
			case k.Alert.Description.decrypt_error:
				i = "Decrypt error."
				break
			case k.Alert.Description.export_restriction:
				i = "Export restriction."
				break
			case k.Alert.Description.protocol_version:
				i = "Unsupported protocol version."
				break
			case k.Alert.Description.insufficient_security:
				i = "Insufficient security."
				break
			case k.Alert.Description.internal_error:
				i = "Internal error."
				break
			case k.Alert.Description.user_canceled:
				i = "User canceled."
				break
			case k.Alert.Description.no_renegotiation:
				i = "Renegotiation not supported."
				break
			default:
				i = "Unknown error."
				break
		}
		if (n.description === k.Alert.Description.close_notify) return e.close()
		e.error(e, {
			message: i,
			send: !1,
			origin: e.entity === k.ConnectionEnd.client ? "server" : "client",
			alert: n,
		}),
			e.process()
	}
	k.handleHandshake = function (e, t) {
		var r = t.fragment,
			n = r.getByte(),
			i = r.getInt24()
		if (i > r.length()) return (e.fragmented = t), (t.fragment = pe.util.createBuffer()), (r.read -= 4), e.process()
		;(e.fragmented = null), (r.read -= 4)
		var s = r.bytes(i + 4)
		;(r.read += 4),
			n in IT[e.entity][e.expect]
				? (e.entity === k.ConnectionEnd.server &&
						!e.open &&
						!e.fail &&
						((e.handshaking = !0),
						(e.session = {
							version: null,
							extensions: { server_name: { serverNameList: [] } },
							cipherSuite: null,
							compressionMethod: null,
							serverCertificate: null,
							clientCertificate: null,
							md5: pe.md.md5.create(),
							sha1: pe.md.sha1.create(),
						})),
					n !== k.HandshakeType.hello_request &&
						n !== k.HandshakeType.certificate_verify &&
						n !== k.HandshakeType.finished &&
						(e.session.md5.update(s), e.session.sha1.update(s)),
					IT[e.entity][e.expect][n](e, t, i))
				: k.handleUnexpected(e, t)
	}
	k.handleApplicationData = function (e, t) {
		e.data.putBuffer(t.fragment), e.dataReady(e), e.process()
	}
	k.handleHeartbeat = function (e, t) {
		var r = t.fragment,
			n = r.getByte(),
			i = r.getInt16(),
			s = r.getBytes(i)
		if (n === k.HeartbeatMessageType.heartbeat_request) {
			if (e.handshaking || i > s.length) return e.process()
			k.queue(
				e,
				k.createRecord(e, {
					type: k.ContentType.heartbeat,
					data: k.createHeartbeat(k.HeartbeatMessageType.heartbeat_response, s),
				}),
			),
				k.flush(e)
		} else if (n === k.HeartbeatMessageType.heartbeat_response) {
			if (s !== e.expectedHeartbeatPayload) return e.process()
			e.heartbeatReceived && e.heartbeatReceived(e, pe.util.createBuffer(s))
		}
		e.process()
	}
	var EXe = 0,
		bXe = 1,
		yce = 2,
		xXe = 3,
		_Xe = 4,
		vce = 5,
		wXe = 6,
		IXe = 7,
		SXe = 8,
		BXe = 0,
		DXe = 1,
		V5 = 2,
		TXe = 3,
		H5 = 4,
		RXe = 5,
		kXe = 6,
		T = k.handleUnexpected,
		Ece = k.handleChangeCipherSpec,
		Cs = k.handleAlert,
		ao = k.handleHandshake,
		bce = k.handleApplicationData,
		vs = k.handleHeartbeat,
		W5 = []
	W5[k.ConnectionEnd.client] = [
		[T, Cs, ao, T, vs],
		[T, Cs, ao, T, vs],
		[T, Cs, ao, T, vs],
		[T, Cs, ao, T, vs],
		[T, Cs, ao, T, vs],
		[Ece, Cs, T, T, vs],
		[T, Cs, ao, T, vs],
		[T, Cs, ao, bce, vs],
		[T, Cs, ao, T, vs],
	]
	W5[k.ConnectionEnd.server] = [
		[T, Cs, ao, T, vs],
		[T, Cs, ao, T, vs],
		[T, Cs, ao, T, vs],
		[T, Cs, ao, T, vs],
		[Ece, Cs, T, T, vs],
		[T, Cs, ao, T, vs],
		[T, Cs, ao, bce, vs],
		[T, Cs, ao, T, vs],
	]
	var Ah = k.handleHelloRequest,
		MXe = k.handleServerHello,
		xce = k.handleCertificate,
		Cce = k.handleServerKeyExchange,
		O5 = k.handleCertificateRequest,
		_T = k.handleServerHelloDone,
		_ce = k.handleFinished,
		IT = []
	IT[k.ConnectionEnd.client] = [
		[T, T, MXe, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
		[Ah, T, T, T, T, T, T, T, T, T, T, xce, Cce, O5, _T, T, T, T, T, T, T],
		[Ah, T, T, T, T, T, T, T, T, T, T, T, Cce, O5, _T, T, T, T, T, T, T],
		[Ah, T, T, T, T, T, T, T, T, T, T, T, T, O5, _T, T, T, T, T, T, T],
		[Ah, T, T, T, T, T, T, T, T, T, T, T, T, T, _T, T, T, T, T, T, T],
		[Ah, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
		[Ah, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, _ce],
		[Ah, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
		[Ah, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
	]
	var FXe = k.handleClientHello,
		QXe = k.handleClientKeyExchange,
		NXe = k.handleCertificateVerify
	IT[k.ConnectionEnd.server] = [
		[T, FXe, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
		[T, T, T, T, T, T, T, T, T, T, T, xce, T, T, T, T, T, T, T, T, T],
		[T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, QXe, T, T, T, T],
		[T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, NXe, T, T, T, T, T],
		[T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
		[T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, _ce],
		[T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
		[T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
	]
	k.generateKeys = function (e, t) {
		var r = ST,
			n = t.client_random + t.server_random
		e.session.resuming ||
			((t.master_secret = r(t.pre_master_secret, "master secret", n, 48).bytes()), (t.pre_master_secret = null)),
			(n = t.server_random + t.client_random)
		var i = 2 * t.mac_key_length + 2 * t.enc_key_length,
			s = e.version.major === k.Versions.TLS_1_0.major && e.version.minor === k.Versions.TLS_1_0.minor
		s && (i += 2 * t.fixed_iv_length)
		var o = r(t.master_secret, "key expansion", n, i),
			a = {
				client_write_MAC_key: o.getBytes(t.mac_key_length),
				server_write_MAC_key: o.getBytes(t.mac_key_length),
				client_write_key: o.getBytes(t.enc_key_length),
				server_write_key: o.getBytes(t.enc_key_length),
			}
		return (
			s &&
				((a.client_write_IV = o.getBytes(t.fixed_iv_length)),
				(a.server_write_IV = o.getBytes(t.fixed_iv_length))),
			a
		)
	}
	k.createConnectionState = function (e) {
		var t = e.entity === k.ConnectionEnd.client,
			r = function () {
				var s = {
					sequenceNumber: [0, 0],
					macKey: null,
					macLength: 0,
					macFunction: null,
					cipherState: null,
					cipherFunction: function (o) {
						return !0
					},
					compressionState: null,
					compressFunction: function (o) {
						return !0
					},
					updateSequenceNumber: function () {
						s.sequenceNumber[1] === 4294967295
							? ((s.sequenceNumber[1] = 0), ++s.sequenceNumber[0])
							: ++s.sequenceNumber[1]
					},
				}
				return s
			},
			n = { read: r(), write: r() }
		if (
			((n.read.update = function (s, o) {
				return (
					n.read.cipherFunction(o, n.read)
						? n.read.compressFunction(s, o, n.read) ||
							s.error(s, {
								message: "Could not decompress record.",
								send: !0,
								alert: {
									level: k.Alert.Level.fatal,
									description: k.Alert.Description.decompression_failure,
								},
							})
						: s.error(s, {
								message: "Could not decrypt record or bad MAC.",
								send: !0,
								alert: {
									level: k.Alert.Level.fatal,
									description: k.Alert.Description.bad_record_mac,
								},
							}),
					!s.fail
				)
			}),
			(n.write.update = function (s, o) {
				return (
					n.write.compressFunction(s, o, n.write)
						? n.write.cipherFunction(o, n.write) ||
							s.error(s, {
								message: "Could not encrypt record.",
								send: !1,
								alert: {
									level: k.Alert.Level.fatal,
									description: k.Alert.Description.internal_error,
								},
							})
						: s.error(s, {
								message: "Could not compress record.",
								send: !1,
								alert: {
									level: k.Alert.Level.fatal,
									description: k.Alert.Description.internal_error,
								},
							}),
					!s.fail
				)
			}),
			e.session)
		) {
			var i = e.session.sp
			switch (
				(e.session.cipherSuite.initSecurityParameters(i),
				(i.keys = k.generateKeys(e, i)),
				(n.read.macKey = t ? i.keys.server_write_MAC_key : i.keys.client_write_MAC_key),
				(n.write.macKey = t ? i.keys.client_write_MAC_key : i.keys.server_write_MAC_key),
				e.session.cipherSuite.initConnectionState(n, e, i),
				i.compression_algorithm)
			) {
				case k.CompressionMethod.none:
					break
				case k.CompressionMethod.deflate:
					;(n.read.compressFunction = vXe), (n.write.compressFunction = CXe)
					break
				default:
					throw new Error("Unsupported compression algorithm.")
			}
		}
		return n
	}
	k.createRandom = function () {
		var e = new Date(),
			t = +e + e.getTimezoneOffset() * 6e4,
			r = pe.util.createBuffer()
		return r.putInt32(t), r.putBytes(pe.random.getBytes(28)), r
	}
	k.createRecord = function (e, t) {
		if (!t.data) return null
		var r = {
			type: t.type,
			version: { major: e.version.major, minor: e.version.minor },
			length: t.data.length(),
			fragment: t.data,
		}
		return r
	}
	k.createAlert = function (e, t) {
		var r = pe.util.createBuffer()
		return r.putByte(t.level), r.putByte(t.description), k.createRecord(e, { type: k.ContentType.alert, data: r })
	}
	k.createClientHello = function (e) {
		e.session.clientHelloVersion = {
			major: e.version.major,
			minor: e.version.minor,
		}
		for (var t = pe.util.createBuffer(), r = 0; r < e.cipherSuites.length; ++r) {
			var n = e.cipherSuites[r]
			t.putByte(n.id[0]), t.putByte(n.id[1])
		}
		var i = t.length(),
			s = pe.util.createBuffer()
		s.putByte(k.CompressionMethod.none)
		var o = s.length(),
			a = pe.util.createBuffer()
		if (e.virtualHost) {
			var l = pe.util.createBuffer()
			l.putByte(0), l.putByte(0)
			var c = pe.util.createBuffer()
			c.putByte(0), hl(c, 2, pe.util.createBuffer(e.virtualHost))
			var u = pe.util.createBuffer()
			hl(u, 2, c), hl(l, 2, u), a.putBuffer(l)
		}
		var f = a.length()
		f > 0 && (f += 2)
		var p = e.session.id,
			g = p.length + 1 + 2 + 4 + 28 + 2 + i + 1 + o + f,
			m = pe.util.createBuffer()
		return (
			m.putByte(k.HandshakeType.client_hello),
			m.putInt24(g),
			m.putByte(e.version.major),
			m.putByte(e.version.minor),
			m.putBytes(e.session.sp.client_random),
			hl(m, 1, pe.util.createBuffer(p)),
			hl(m, 2, t),
			hl(m, 1, s),
			f > 0 && hl(m, 2, a),
			m
		)
	}
	k.createServerHello = function (e) {
		var t = e.session.id,
			r = t.length + 1 + 2 + 4 + 28 + 2 + 1,
			n = pe.util.createBuffer()
		return (
			n.putByte(k.HandshakeType.server_hello),
			n.putInt24(r),
			n.putByte(e.version.major),
			n.putByte(e.version.minor),
			n.putBytes(e.session.sp.server_random),
			hl(n, 1, pe.util.createBuffer(t)),
			n.putByte(e.session.cipherSuite.id[0]),
			n.putByte(e.session.cipherSuite.id[1]),
			n.putByte(e.session.compressionMethod),
			n
		)
	}
	k.createCertificate = function (e) {
		var t = e.entity === k.ConnectionEnd.client,
			r = null
		if (e.getCertificate) {
			var n
			t ? (n = e.session.certificateRequest) : (n = e.session.extensions.server_name.serverNameList),
				(r = e.getCertificate(e, n))
		}
		var i = pe.util.createBuffer()
		if (r !== null)
			try {
				pe.util.isArray(r) || (r = [r])
				for (var s = null, o = 0; o < r.length; ++o) {
					var a = pe.pem.decode(r[o])[0]
					if (a.type !== "CERTIFICATE" && a.type !== "X509 CERTIFICATE" && a.type !== "TRUSTED CERTIFICATE") {
						var l = new Error(
							'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',
						)
						throw ((l.headerType = a.type), l)
					}
					if (a.procType && a.procType.type === "ENCRYPTED")
						throw new Error("Could not convert certificate from PEM; PEM is encrypted.")
					var c = pe.util.createBuffer(a.body)
					s === null && (s = pe.asn1.fromDer(c.bytes(), !1))
					var u = pe.util.createBuffer()
					hl(u, 3, c), i.putBuffer(u)
				}
				;(r = pe.pki.certificateFromAsn1(s)),
					t ? (e.session.clientCertificate = r) : (e.session.serverCertificate = r)
			} catch (g) {
				return e.error(e, {
					message: "Could not send certificate list.",
					cause: g,
					send: !0,
					alert: {
						level: k.Alert.Level.fatal,
						description: k.Alert.Description.bad_certificate,
					},
				})
			}
		var f = 3 + i.length(),
			p = pe.util.createBuffer()
		return p.putByte(k.HandshakeType.certificate), p.putInt24(f), hl(p, 3, i), p
	}
	k.createClientKeyExchange = function (e) {
		var t = pe.util.createBuffer()
		t.putByte(e.session.clientHelloVersion.major),
			t.putByte(e.session.clientHelloVersion.minor),
			t.putBytes(pe.random.getBytes(46))
		var r = e.session.sp
		r.pre_master_secret = t.getBytes()
		var n = e.session.serverCertificate.publicKey
		t = n.encrypt(r.pre_master_secret)
		var i = t.length + 2,
			s = pe.util.createBuffer()
		return s.putByte(k.HandshakeType.client_key_exchange), s.putInt24(i), s.putInt16(t.length), s.putBytes(t), s
	}
	k.createServerKeyExchange = function (e) {
		var t = 0,
			r = pe.util.createBuffer()
		return t > 0 && (r.putByte(k.HandshakeType.server_key_exchange), r.putInt24(t)), r
	}
	k.getClientSignature = function (e, t) {
		var r = pe.util.createBuffer()
		r.putBuffer(e.session.md5.digest()),
			r.putBuffer(e.session.sha1.digest()),
			(r = r.getBytes()),
			(e.getSignature =
				e.getSignature ||
				function (n, i, s) {
					var o = null
					if (n.getPrivateKey)
						try {
							;(o = n.getPrivateKey(n, n.session.clientCertificate)), (o = pe.pki.privateKeyFromPem(o))
						} catch (a) {
							n.error(n, {
								message: "Could not get private key.",
								cause: a,
								send: !0,
								alert: {
									level: k.Alert.Level.fatal,
									description: k.Alert.Description.internal_error,
								},
							})
						}
					o === null
						? n.error(n, {
								message: "No private key set.",
								send: !0,
								alert: {
									level: k.Alert.Level.fatal,
									description: k.Alert.Description.internal_error,
								},
							})
						: (i = o.sign(i, null)),
						s(n, i)
				}),
			e.getSignature(e, r, t)
	}
	k.createCertificateVerify = function (e, t) {
		var r = t.length + 2,
			n = pe.util.createBuffer()
		return n.putByte(k.HandshakeType.certificate_verify), n.putInt24(r), n.putInt16(t.length), n.putBytes(t), n
	}
	k.createCertificateRequest = function (e) {
		var t = pe.util.createBuffer()
		t.putByte(1)
		var r = pe.util.createBuffer()
		for (var n in e.caStore.certs) {
			var i = e.caStore.certs[n],
				s = pe.pki.distinguishedNameToAsn1(i.subject),
				o = pe.asn1.toDer(s)
			r.putInt16(o.length()), r.putBuffer(o)
		}
		var a = 1 + t.length() + 2 + r.length(),
			l = pe.util.createBuffer()
		return l.putByte(k.HandshakeType.certificate_request), l.putInt24(a), hl(l, 1, t), hl(l, 2, r), l
	}
	k.createServerHelloDone = function (e) {
		var t = pe.util.createBuffer()
		return t.putByte(k.HandshakeType.server_hello_done), t.putInt24(0), t
	}
	k.createChangeCipherSpec = function () {
		var e = pe.util.createBuffer()
		return e.putByte(1), e
	}
	k.createFinished = function (e) {
		var t = pe.util.createBuffer()
		t.putBuffer(e.session.md5.digest()), t.putBuffer(e.session.sha1.digest())
		var r = e.entity === k.ConnectionEnd.client,
			n = e.session.sp,
			i = 12,
			s = ST,
			o = r ? "client finished" : "server finished"
		t = s(n.master_secret, o, t.getBytes(), i)
		var a = pe.util.createBuffer()
		return a.putByte(k.HandshakeType.finished), a.putInt24(t.length()), a.putBuffer(t), a
	}
	k.createHeartbeat = function (e, t, r) {
		typeof r > "u" && (r = t.length)
		var n = pe.util.createBuffer()
		n.putByte(e), n.putInt16(r), n.putBytes(t)
		var i = n.length(),
			s = Math.max(16, i - r - 3)
		return n.putBytes(pe.random.getBytes(s)), n
	}
	k.queue = function (e, t) {
		if (
			t &&
			!(
				t.fragment.length() === 0 &&
				(t.type === k.ContentType.handshake ||
					t.type === k.ContentType.alert ||
					t.type === k.ContentType.change_cipher_spec)
			)
		) {
			if (t.type === k.ContentType.handshake) {
				var r = t.fragment.bytes()
				e.session.md5.update(r), e.session.sha1.update(r), (r = null)
			}
			var n
			if (t.fragment.length() <= k.MaxFragment) n = [t]
			else {
				n = []
				for (var i = t.fragment.bytes(); i.length > k.MaxFragment; )
					n.push(
						k.createRecord(e, {
							type: t.type,
							data: pe.util.createBuffer(i.slice(0, k.MaxFragment)),
						}),
					),
						(i = i.slice(k.MaxFragment))
				i.length > 0 && n.push(k.createRecord(e, { type: t.type, data: pe.util.createBuffer(i) }))
			}
			for (var s = 0; s < n.length && !e.fail; ++s) {
				var o = n[s],
					a = e.state.current.write
				a.update(e, o) && e.records.push(o)
			}
		}
	}
	k.flush = function (e) {
		for (var t = 0; t < e.records.length; ++t) {
			var r = e.records[t]
			e.tlsData.putByte(r.type),
				e.tlsData.putByte(r.version.major),
				e.tlsData.putByte(r.version.minor),
				e.tlsData.putInt16(r.fragment.length()),
				e.tlsData.putBuffer(e.records[t].fragment)
		}
		return (e.records = []), e.tlsDataReady(e)
	}
	var q5 = function (e) {
			switch (e) {
				case !0:
					return !0
				case pe.pki.certificateError.bad_certificate:
					return k.Alert.Description.bad_certificate
				case pe.pki.certificateError.unsupported_certificate:
					return k.Alert.Description.unsupported_certificate
				case pe.pki.certificateError.certificate_revoked:
					return k.Alert.Description.certificate_revoked
				case pe.pki.certificateError.certificate_expired:
					return k.Alert.Description.certificate_expired
				case pe.pki.certificateError.certificate_unknown:
					return k.Alert.Description.certificate_unknown
				case pe.pki.certificateError.unknown_ca:
					return k.Alert.Description.unknown_ca
				default:
					return k.Alert.Description.bad_certificate
			}
		},
		PXe = function (e) {
			switch (e) {
				case !0:
					return !0
				case k.Alert.Description.bad_certificate:
					return pe.pki.certificateError.bad_certificate
				case k.Alert.Description.unsupported_certificate:
					return pe.pki.certificateError.unsupported_certificate
				case k.Alert.Description.certificate_revoked:
					return pe.pki.certificateError.certificate_revoked
				case k.Alert.Description.certificate_expired:
					return pe.pki.certificateError.certificate_expired
				case k.Alert.Description.certificate_unknown:
					return pe.pki.certificateError.certificate_unknown
				case k.Alert.Description.unknown_ca:
					return pe.pki.certificateError.unknown_ca
				default:
					return pe.pki.certificateError.bad_certificate
			}
		}
	k.verifyCertificateChain = function (e, t) {
		try {
			var r = {}
			for (var n in e.verifyOptions) r[n] = e.verifyOptions[n]
			;(r.verify = function (s, o, a) {
				var l = q5(s),
					c = e.verify(e, s, o, a)
				if (c !== !0) {
					if (typeof c == "object" && !pe.util.isArray(c)) {
						var u = new Error("The application rejected the certificate.")
						throw (
							((u.send = !0),
							(u.alert = {
								level: k.Alert.Level.fatal,
								description: k.Alert.Description.bad_certificate,
							}),
							c.message && (u.message = c.message),
							c.alert && (u.alert.description = c.alert),
							u)
						)
					}
					c !== s && (c = PXe(c))
				}
				return c
			}),
				pe.pki.verifyCertificateChain(e.caStore, t, r)
		} catch (s) {
			var i = s
			;(typeof i != "object" || pe.util.isArray(i)) &&
				(i = {
					send: !0,
					alert: { level: k.Alert.Level.fatal, description: q5(s) },
				}),
				"send" in i || (i.send = !0),
				"alert" in i || (i.alert = { level: k.Alert.Level.fatal, description: q5(i.error) }),
				e.error(e, i)
		}
		return !e.fail
	}
	k.createSessionCache = function (e, t) {
		var r = null
		if (e && e.getSession && e.setSession && e.order) r = e
		else {
			;(r = {}), (r.cache = e || {}), (r.capacity = Math.max(t || 100, 1)), (r.order = [])
			for (var n in e) r.order.length <= t ? r.order.push(n) : delete e[n]
			;(r.getSession = function (i) {
				var s = null,
					o = null
				if (
					(i ? (o = pe.util.bytesToHex(i)) : r.order.length > 0 && (o = r.order[0]),
					o !== null && o in r.cache)
				) {
					;(s = r.cache[o]), delete r.cache[o]
					for (var a in r.order)
						if (r.order[a] === o) {
							r.order.splice(a, 1)
							break
						}
				}
				return s
			}),
				(r.setSession = function (i, s) {
					if (r.order.length === r.capacity) {
						var o = r.order.shift()
						delete r.cache[o]
					}
					var o = pe.util.bytesToHex(i)
					r.order.push(o), (r.cache[o] = s)
				})
		}
		return r
	}
	k.createConnection = function (e) {
		var t = null
		e.caStore
			? pe.util.isArray(e.caStore)
				? (t = pe.pki.createCaStore(e.caStore))
				: (t = e.caStore)
			: (t = pe.pki.createCaStore())
		var r = e.cipherSuites || null
		if (r === null) {
			r = []
			for (var n in k.CipherSuites) r.push(k.CipherSuites[n])
		}
		var i = e.server ? k.ConnectionEnd.server : k.ConnectionEnd.client,
			s = e.sessionCache ? k.createSessionCache(e.sessionCache) : null,
			o = {
				version: { major: k.Version.major, minor: k.Version.minor },
				entity: i,
				sessionId: e.sessionId,
				caStore: t,
				sessionCache: s,
				cipherSuites: r,
				connected: e.connected,
				virtualHost: e.virtualHost || null,
				verifyClient: e.verifyClient || !1,
				verify:
					e.verify ||
					function (u, f, p, g) {
						return f
					},
				verifyOptions: e.verifyOptions || {},
				getCertificate: e.getCertificate || null,
				getPrivateKey: e.getPrivateKey || null,
				getSignature: e.getSignature || null,
				input: pe.util.createBuffer(),
				tlsData: pe.util.createBuffer(),
				data: pe.util.createBuffer(),
				tlsDataReady: e.tlsDataReady,
				dataReady: e.dataReady,
				heartbeatReceived: e.heartbeatReceived,
				closed: e.closed,
				error: function (u, f) {
					;(f.origin = f.origin || (u.entity === k.ConnectionEnd.client ? "client" : "server")),
						f.send && (k.queue(u, k.createAlert(u, f.alert)), k.flush(u))
					var p = f.fatal !== !1
					p && (u.fail = !0), e.error(u, f), p && u.close(!1)
				},
				deflate: e.deflate || null,
				inflate: e.inflate || null,
			}
		;(o.reset = function (u) {
			;(o.version = { major: k.Version.major, minor: k.Version.minor }),
				(o.record = null),
				(o.session = null),
				(o.peerCertificate = null),
				(o.state = { pending: null, current: null }),
				(o.expect = o.entity === k.ConnectionEnd.client ? EXe : BXe),
				(o.fragmented = null),
				(o.records = []),
				(o.open = !1),
				(o.handshakes = 0),
				(o.handshaking = !1),
				(o.isConnected = !1),
				(o.fail = !(u || typeof u > "u")),
				o.input.clear(),
				o.tlsData.clear(),
				o.data.clear(),
				(o.state.current = k.createConnectionState(o))
		}),
			o.reset()
		var a = function (u, f) {
				var p = f.type - k.ContentType.change_cipher_spec,
					g = W5[u.entity][u.expect]
				p in g ? g[p](u, f) : k.handleUnexpected(u, f)
			},
			l = function (u) {
				var f = 0,
					p = u.input,
					g = p.length()
				if (g < 5) f = 5 - g
				else {
					u.record = {
						type: p.getByte(),
						version: { major: p.getByte(), minor: p.getByte() },
						length: p.getInt16(),
						fragment: pe.util.createBuffer(),
						ready: !1,
					}
					var m = u.record.version.major === u.version.major
					m && u.session && u.session.version && (m = u.record.version.minor === u.version.minor),
						m ||
							u.error(u, {
								message: "Incompatible TLS version.",
								send: !0,
								alert: {
									level: k.Alert.Level.fatal,
									description: k.Alert.Description.protocol_version,
								},
							})
				}
				return f
			},
			c = function (u) {
				var f = 0,
					p = u.input,
					g = p.length()
				if (g < u.record.length) f = u.record.length - g
				else {
					u.record.fragment.putBytes(p.getBytes(u.record.length)), p.compact()
					var m = u.state.current.read
					m.update(u, u.record) &&
						(u.fragmented !== null &&
							(u.fragmented.type === u.record.type
								? (u.fragmented.fragment.putBuffer(u.record.fragment), (u.record = u.fragmented))
								: u.error(u, {
										message: "Invalid fragmented record.",
										send: !0,
										alert: {
											level: k.Alert.Level.fatal,
											description: k.Alert.Description.unexpected_message,
										},
									})),
						(u.record.ready = !0))
				}
				return f
			}
		return (
			(o.handshake = function (u) {
				if (o.entity !== k.ConnectionEnd.client)
					o.error(o, {
						message: "Cannot initiate handshake as a server.",
						fatal: !1,
					})
				else if (o.handshaking) o.error(o, { message: "Handshake already in progress.", fatal: !1 })
				else {
					o.fail && !o.open && o.handshakes === 0 && (o.fail = !1), (o.handshaking = !0), (u = u || "")
					var f = null
					u.length > 0 && (o.sessionCache && (f = o.sessionCache.getSession(u)), f === null && (u = "")),
						u.length === 0 &&
							o.sessionCache &&
							((f = o.sessionCache.getSession()), f !== null && (u = f.id)),
						(o.session = {
							id: u,
							version: null,
							cipherSuite: null,
							compressionMethod: null,
							serverCertificate: null,
							certificateRequest: null,
							clientCertificate: null,
							sp: {},
							md5: pe.md.md5.create(),
							sha1: pe.md.sha1.create(),
						}),
						f && ((o.version = f.version), (o.session.sp = f.sp)),
						(o.session.sp.client_random = k.createRandom().getBytes()),
						(o.open = !0),
						k.queue(
							o,
							k.createRecord(o, {
								type: k.ContentType.handshake,
								data: k.createClientHello(o),
							}),
						),
						k.flush(o)
				}
			}),
			(o.process = function (u) {
				var f = 0
				return (
					u && o.input.putBytes(u),
					o.fail ||
						(o.record !== null && o.record.ready && o.record.fragment.isEmpty() && (o.record = null),
						o.record === null && (f = l(o)),
						!o.fail && o.record !== null && !o.record.ready && (f = c(o)),
						!o.fail && o.record !== null && o.record.ready && a(o, o.record)),
					f
				)
			}),
			(o.prepare = function (u) {
				return (
					k.queue(
						o,
						k.createRecord(o, {
							type: k.ContentType.application_data,
							data: pe.util.createBuffer(u),
						}),
					),
					k.flush(o)
				)
			}),
			(o.prepareHeartbeatRequest = function (u, f) {
				return (
					u instanceof pe.util.ByteBuffer && (u = u.bytes()),
					typeof f > "u" && (f = u.length),
					(o.expectedHeartbeatPayload = u),
					k.queue(
						o,
						k.createRecord(o, {
							type: k.ContentType.heartbeat,
							data: k.createHeartbeat(k.HeartbeatMessageType.heartbeat_request, u, f),
						}),
					),
					k.flush(o)
				)
			}),
			(o.close = function (u) {
				if (!o.fail && o.sessionCache && o.session) {
					var f = {
						id: o.session.id,
						version: o.session.version,
						sp: o.session.sp,
					}
					;(f.sp.keys = null), o.sessionCache.setSession(f.id, f)
				}
				o.open &&
					((o.open = !1),
					o.input.clear(),
					(o.isConnected || o.handshaking) &&
						((o.isConnected = o.handshaking = !1),
						k.queue(
							o,
							k.createAlert(o, {
								level: k.Alert.Level.warning,
								description: k.Alert.Description.close_notify,
							}),
						),
						k.flush(o)),
					o.closed(o)),
					o.reset(u)
			}),
			o
		)
	}
	wce.exports = pe.tls = pe.tls || {}
	for (wT in k) typeof k[wT] != "function" && (pe.tls[wT] = k[wT])
	var wT
	pe.tls.prf_tls1 = ST
	pe.tls.hmac_sha1 = yXe
	pe.tls.createSessionCache = k.createSessionCache
	pe.tls.createConnection = k.createConnection
})
var Bce = x((fBt, Sce) => {
	"use strict"
	var mh = Yt()
	uh()
	G5()
	var gl = (Sce.exports = mh.tls)
	gl.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
		id: [0, 47],
		name: "TLS_RSA_WITH_AES_128_CBC_SHA",
		initSecurityParameters: function (e) {
			;(e.bulk_cipher_algorithm = gl.BulkCipherAlgorithm.aes),
				(e.cipher_type = gl.CipherType.block),
				(e.enc_key_length = 16),
				(e.block_length = 16),
				(e.fixed_iv_length = 16),
				(e.record_iv_length = 16),
				(e.mac_algorithm = gl.MACAlgorithm.hmac_sha1),
				(e.mac_length = 20),
				(e.mac_key_length = 20)
		},
		initConnectionState: Ice,
	}
	gl.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
		id: [0, 53],
		name: "TLS_RSA_WITH_AES_256_CBC_SHA",
		initSecurityParameters: function (e) {
			;(e.bulk_cipher_algorithm = gl.BulkCipherAlgorithm.aes),
				(e.cipher_type = gl.CipherType.block),
				(e.enc_key_length = 32),
				(e.block_length = 16),
				(e.fixed_iv_length = 16),
				(e.record_iv_length = 16),
				(e.mac_algorithm = gl.MACAlgorithm.hmac_sha1),
				(e.mac_length = 20),
				(e.mac_key_length = 20)
		},
		initConnectionState: Ice,
	}
	function Ice(e, t, r) {
		var n = t.entity === mh.tls.ConnectionEnd.client
		;(e.read.cipherState = {
			init: !1,
			cipher: mh.cipher.createDecipher("AES-CBC", n ? r.keys.server_write_key : r.keys.client_write_key),
			iv: n ? r.keys.server_write_IV : r.keys.client_write_IV,
		}),
			(e.write.cipherState = {
				init: !1,
				cipher: mh.cipher.createCipher("AES-CBC", n ? r.keys.client_write_key : r.keys.server_write_key),
				iv: n ? r.keys.client_write_IV : r.keys.server_write_IV,
			}),
			(e.read.cipherFunction = qXe),
			(e.write.cipherFunction = LXe),
			(e.read.macLength = e.write.macLength = r.mac_length),
			(e.read.macFunction = e.write.macFunction = gl.hmac_sha1)
	}
	function LXe(e, t) {
		var r = !1,
			n = t.macFunction(t.macKey, t.sequenceNumber, e)
		e.fragment.putBytes(n), t.updateSequenceNumber()
		var i
		e.version.minor === gl.Versions.TLS_1_0.minor
			? (i = t.cipherState.init ? null : t.cipherState.iv)
			: (i = mh.random.getBytesSync(16)),
			(t.cipherState.init = !0)
		var s = t.cipherState.cipher
		return (
			s.start({ iv: i }),
			e.version.minor >= gl.Versions.TLS_1_1.minor && s.output.putBytes(i),
			s.update(e.fragment),
			s.finish(UXe) && ((e.fragment = s.output), (e.length = e.fragment.length()), (r = !0)),
			r
		)
	}
	function UXe(e, t, r) {
		if (!r) {
			var n = e - (t.length() % e)
			t.fillWithByte(n - 1, n)
		}
		return !0
	}
	function OXe(e, t, r) {
		var n = !0
		if (r) {
			for (var i = t.length(), s = t.last(), o = i - 1 - s; o < i - 1; ++o) n = n && t.at(o) == s
			n && t.truncate(s + 1)
		}
		return n
	}
	function qXe(e, t) {
		var r = !1,
			n
		e.version.minor === gl.Versions.TLS_1_0.minor
			? (n = t.cipherState.init ? null : t.cipherState.iv)
			: (n = e.fragment.getBytes(16)),
			(t.cipherState.init = !0)
		var i = t.cipherState.cipher
		i.start({ iv: n }), i.update(e.fragment), (r = i.finish(OXe))
		var s = t.macLength,
			o = mh.random.getBytesSync(s),
			a = i.output.length()
		a >= s
			? ((e.fragment = i.output.getBytes(a - s)), (o = i.output.getBytes(s)))
			: (e.fragment = i.output.getBytes()),
			(e.fragment = mh.util.createBuffer(e.fragment)),
			(e.length = e.fragment.length())
		var l = t.macFunction(t.macKey, t.sequenceNumber, e)
		return t.updateSequenceNumber(), (r = VXe(t.macKey, o, l) && r), r
	}
	function VXe(e, t, r) {
		var n = mh.hmac.create()
		return (
			n.start("SHA1", e),
			n.update(t),
			(t = n.digest().getBytes()),
			n.start(null, null),
			n.update(r),
			(r = n.digest().getBytes()),
			t === r
		)
	}
})
var K5 = x((hBt, kce) => {
	"use strict"
	var wn = Yt()
	du()
	Sr()
	var Fb = (kce.exports = wn.sha512 = wn.sha512 || {})
	wn.md.sha512 = wn.md.algorithms.sha512 = Fb
	var Tce = (wn.sha384 = wn.sha512.sha384 = wn.sha512.sha384 || {})
	Tce.create = function () {
		return Fb.create("SHA-384")
	}
	wn.md.sha384 = wn.md.algorithms.sha384 = Tce
	wn.sha512.sha256 = wn.sha512.sha256 || {
		create: function () {
			return Fb.create("SHA-512/256")
		},
	}
	wn.md["sha512/256"] = wn.md.algorithms["sha512/256"] = wn.sha512.sha256
	wn.sha512.sha224 = wn.sha512.sha224 || {
		create: function () {
			return Fb.create("SHA-512/224")
		},
	}
	wn.md["sha512/224"] = wn.md.algorithms["sha512/224"] = wn.sha512.sha224
	Fb.create = function (e) {
		if ((Rce || HXe(), typeof e > "u" && (e = "SHA-512"), !(e in Tp)))
			throw new Error("Invalid SHA-512 algorithm: " + e)
		for (var t = Tp[e], r = null, n = wn.util.createBuffer(), i = new Array(80), s = 0; s < 80; ++s)
			i[s] = new Array(2)
		var o = 64
		switch (e) {
			case "SHA-384":
				o = 48
				break
			case "SHA-512/256":
				o = 32
				break
			case "SHA-512/224":
				o = 28
				break
		}
		var a = {
			algorithm: e.replace("-", "").toLowerCase(),
			blockLength: 128,
			digestLength: o,
			messageLength: 0,
			fullMessageLength: null,
			messageLengthSize: 16,
		}
		return (
			(a.start = function () {
				;(a.messageLength = 0), (a.fullMessageLength = a.messageLength128 = [])
				for (var l = a.messageLengthSize / 4, c = 0; c < l; ++c) a.fullMessageLength.push(0)
				;(n = wn.util.createBuffer()), (r = new Array(t.length))
				for (var c = 0; c < t.length; ++c) r[c] = t[c].slice(0)
				return a
			}),
			a.start(),
			(a.update = function (l, c) {
				c === "utf8" && (l = wn.util.encodeUtf8(l))
				var u = l.length
				;(a.messageLength += u), (u = [(u / 4294967296) >>> 0, u >>> 0])
				for (var f = a.fullMessageLength.length - 1; f >= 0; --f)
					(a.fullMessageLength[f] += u[1]),
						(u[1] = u[0] + ((a.fullMessageLength[f] / 4294967296) >>> 0)),
						(a.fullMessageLength[f] = a.fullMessageLength[f] >>> 0),
						(u[0] = (u[1] / 4294967296) >>> 0)
				return n.putBytes(l), Dce(r, i, n), (n.read > 2048 || n.length() === 0) && n.compact(), a
			}),
			(a.digest = function () {
				var l = wn.util.createBuffer()
				l.putBytes(n.bytes())
				var c = a.fullMessageLength[a.fullMessageLength.length - 1] + a.messageLengthSize,
					u = c & (a.blockLength - 1)
				l.putBytes($5.substr(0, a.blockLength - u))
				for (var f, p, g = a.fullMessageLength[0] * 8, m = 0; m < a.fullMessageLength.length - 1; ++m)
					(f = a.fullMessageLength[m + 1] * 8),
						(p = (f / 4294967296) >>> 0),
						(g += p),
						l.putInt32(g >>> 0),
						(g = f >>> 0)
				l.putInt32(g)
				for (var y = new Array(r.length), m = 0; m < r.length; ++m) y[m] = r[m].slice(0)
				Dce(y, i, l)
				var C = wn.util.createBuffer(),
					v
				e === "SHA-512" ? (v = y.length) : e === "SHA-384" ? (v = y.length - 2) : (v = y.length - 4)
				for (var m = 0; m < v; ++m)
					C.putInt32(y[m][0]), (m !== v - 1 || e !== "SHA-512/224") && C.putInt32(y[m][1])
				return C
			}),
			a
		)
	}
	var $5 = null,
		Rce = !1,
		Y5 = null,
		Tp = null
	function HXe() {
		;($5 = "\x80"),
			($5 += wn.util.fillString("\0", 128)),
			(Y5 = [
				[1116352408, 3609767458],
				[1899447441, 602891725],
				[3049323471, 3964484399],
				[3921009573, 2173295548],
				[961987163, 4081628472],
				[1508970993, 3053834265],
				[2453635748, 2937671579],
				[2870763221, 3664609560],
				[3624381080, 2734883394],
				[310598401, 1164996542],
				[607225278, 1323610764],
				[1426881987, 3590304994],
				[1925078388, 4068182383],
				[2162078206, 991336113],
				[2614888103, 633803317],
				[3248222580, 3479774868],
				[3835390401, 2666613458],
				[4022224774, 944711139],
				[264347078, 2341262773],
				[604807628, 2007800933],
				[770255983, 1495990901],
				[1249150122, 1856431235],
				[1555081692, 3175218132],
				[1996064986, 2198950837],
				[2554220882, 3999719339],
				[2821834349, 766784016],
				[2952996808, 2566594879],
				[3210313671, 3203337956],
				[3336571891, 1034457026],
				[3584528711, 2466948901],
				[113926993, 3758326383],
				[338241895, 168717936],
				[666307205, 1188179964],
				[773529912, 1546045734],
				[1294757372, 1522805485],
				[1396182291, 2643833823],
				[1695183700, 2343527390],
				[1986661051, 1014477480],
				[2177026350, 1206759142],
				[2456956037, 344077627],
				[2730485921, 1290863460],
				[2820302411, 3158454273],
				[3259730800, 3505952657],
				[3345764771, 106217008],
				[3516065817, 3606008344],
				[3600352804, 1432725776],
				[4094571909, 1467031594],
				[275423344, 851169720],
				[430227734, 3100823752],
				[506948616, 1363258195],
				[659060556, 3750685593],
				[883997877, 3785050280],
				[958139571, 3318307427],
				[1322822218, 3812723403],
				[1537002063, 2003034995],
				[1747873779, 3602036899],
				[1955562222, 1575990012],
				[2024104815, 1125592928],
				[2227730452, 2716904306],
				[2361852424, 442776044],
				[2428436474, 593698344],
				[2756734187, 3733110249],
				[3204031479, 2999351573],
				[3329325298, 3815920427],
				[3391569614, 3928383900],
				[3515267271, 566280711],
				[3940187606, 3454069534],
				[4118630271, 4000239992],
				[116418474, 1914138554],
				[174292421, 2731055270],
				[289380356, 3203993006],
				[460393269, 320620315],
				[685471733, 587496836],
				[852142971, 1086792851],
				[1017036298, 365543100],
				[1126000580, 2618297676],
				[1288033470, 3409855158],
				[1501505948, 4234509866],
				[1607167915, 987167468],
				[1816402316, 1246189591],
			]),
			(Tp = {}),
			(Tp["SHA-512"] = [
				[1779033703, 4089235720],
				[3144134277, 2227873595],
				[1013904242, 4271175723],
				[2773480762, 1595750129],
				[1359893119, 2917565137],
				[2600822924, 725511199],
				[528734635, 4215389547],
				[1541459225, 327033209],
			]),
			(Tp["SHA-384"] = [
				[3418070365, 3238371032],
				[1654270250, 914150663],
				[2438529370, 812702999],
				[355462360, 4144912697],
				[1731405415, 4290775857],
				[2394180231, 1750603025],
				[3675008525, 1694076839],
				[1203062813, 3204075428],
			]),
			(Tp["SHA-512/256"] = [
				[573645204, 4230739756],
				[2673172387, 3360449730],
				[596883563, 1867755857],
				[2520282905, 1497426621],
				[2519219938, 2827943907],
				[3193839141, 1401305490],
				[721525244, 746961066],
				[246885852, 2177182882],
			]),
			(Tp["SHA-512/224"] = [
				[2352822216, 424955298],
				[1944164710, 2312950998],
				[502970286, 855612546],
				[1738396948, 1479516111],
				[258812777, 2077511080],
				[2011393907, 79989058],
				[1067287976, 1780299464],
				[286451373, 2446758561],
			]),
			(Rce = !0)
	}
	function Dce(e, t, r) {
		for (
			var n,
				i,
				s,
				o,
				a,
				l,
				c,
				u,
				f,
				p,
				g,
				m,
				y,
				C,
				v,
				b,
				w,
				B,
				M,
				Q,
				O,
				Y,
				j,
				ne,
				q,
				me,
				Qe,
				N,
				re,
				K,
				se,
				Ze,
				It,
				Ce,
				Et,
				jt = r.length();
			jt >= 128;

		) {
			for (re = 0; re < 16; ++re) (t[re][0] = r.getInt32() >>> 0), (t[re][1] = r.getInt32() >>> 0)
			for (; re < 80; ++re)
				(Ze = t[re - 2]),
					(K = Ze[0]),
					(se = Ze[1]),
					(n = (((K >>> 19) | (se << 13)) ^ ((se >>> 29) | (K << 3)) ^ (K >>> 6)) >>> 0),
					(i = (((K << 13) | (se >>> 19)) ^ ((se << 3) | (K >>> 29)) ^ ((K << 26) | (se >>> 6))) >>> 0),
					(Ce = t[re - 15]),
					(K = Ce[0]),
					(se = Ce[1]),
					(s = (((K >>> 1) | (se << 31)) ^ ((K >>> 8) | (se << 24)) ^ (K >>> 7)) >>> 0),
					(o = (((K << 31) | (se >>> 1)) ^ ((K << 24) | (se >>> 8)) ^ ((K << 25) | (se >>> 7))) >>> 0),
					(It = t[re - 7]),
					(Et = t[re - 16]),
					(se = i + It[1] + o + Et[1]),
					(t[re][0] = (n + It[0] + s + Et[0] + ((se / 4294967296) >>> 0)) >>> 0),
					(t[re][1] = se >>> 0)
			for (
				y = e[0][0],
					C = e[0][1],
					v = e[1][0],
					b = e[1][1],
					w = e[2][0],
					B = e[2][1],
					M = e[3][0],
					Q = e[3][1],
					O = e[4][0],
					Y = e[4][1],
					j = e[5][0],
					ne = e[5][1],
					q = e[6][0],
					me = e[6][1],
					Qe = e[7][0],
					N = e[7][1],
					re = 0;
				re < 80;
				++re
			)
				(c = (((O >>> 14) | (Y << 18)) ^ ((O >>> 18) | (Y << 14)) ^ ((Y >>> 9) | (O << 23))) >>> 0),
					(u = (((O << 18) | (Y >>> 14)) ^ ((O << 14) | (Y >>> 18)) ^ ((Y << 23) | (O >>> 9))) >>> 0),
					(f = (q ^ (O & (j ^ q))) >>> 0),
					(p = (me ^ (Y & (ne ^ me))) >>> 0),
					(a = (((y >>> 28) | (C << 4)) ^ ((C >>> 2) | (y << 30)) ^ ((C >>> 7) | (y << 25))) >>> 0),
					(l = (((y << 4) | (C >>> 28)) ^ ((C << 30) | (y >>> 2)) ^ ((C << 25) | (y >>> 7))) >>> 0),
					(g = ((y & v) | (w & (y ^ v))) >>> 0),
					(m = ((C & b) | (B & (C ^ b))) >>> 0),
					(se = N + u + p + Y5[re][1] + t[re][1]),
					(n = (Qe + c + f + Y5[re][0] + t[re][0] + ((se / 4294967296) >>> 0)) >>> 0),
					(i = se >>> 0),
					(se = l + m),
					(s = (a + g + ((se / 4294967296) >>> 0)) >>> 0),
					(o = se >>> 0),
					(Qe = q),
					(N = me),
					(q = j),
					(me = ne),
					(j = O),
					(ne = Y),
					(se = Q + i),
					(O = (M + n + ((se / 4294967296) >>> 0)) >>> 0),
					(Y = se >>> 0),
					(M = w),
					(Q = B),
					(w = v),
					(B = b),
					(v = y),
					(b = C),
					(se = i + o),
					(y = (n + s + ((se / 4294967296) >>> 0)) >>> 0),
					(C = se >>> 0)
			;(se = e[0][1] + C),
				(e[0][0] = (e[0][0] + y + ((se / 4294967296) >>> 0)) >>> 0),
				(e[0][1] = se >>> 0),
				(se = e[1][1] + b),
				(e[1][0] = (e[1][0] + v + ((se / 4294967296) >>> 0)) >>> 0),
				(e[1][1] = se >>> 0),
				(se = e[2][1] + B),
				(e[2][0] = (e[2][0] + w + ((se / 4294967296) >>> 0)) >>> 0),
				(e[2][1] = se >>> 0),
				(se = e[3][1] + Q),
				(e[3][0] = (e[3][0] + M + ((se / 4294967296) >>> 0)) >>> 0),
				(e[3][1] = se >>> 0),
				(se = e[4][1] + Y),
				(e[4][0] = (e[4][0] + O + ((se / 4294967296) >>> 0)) >>> 0),
				(e[4][1] = se >>> 0),
				(se = e[5][1] + ne),
				(e[5][0] = (e[5][0] + j + ((se / 4294967296) >>> 0)) >>> 0),
				(e[5][1] = se >>> 0),
				(se = e[6][1] + me),
				(e[6][0] = (e[6][0] + q + ((se / 4294967296) >>> 0)) >>> 0),
				(e[6][1] = se >>> 0),
				(se = e[7][1] + N),
				(e[7][0] = (e[7][0] + Qe + ((se / 4294967296) >>> 0)) >>> 0),
				(e[7][1] = se >>> 0),
				(jt -= 128)
		}
	}
})
var Mce = x((J5) => {
	"use strict"
	var WXe = Yt()
	gc()
	var es = WXe.asn1
	J5.privateKeyValidator = {
		name: "PrivateKeyInfo",
		tagClass: es.Class.UNIVERSAL,
		type: es.Type.SEQUENCE,
		constructed: !0,
		value: [
			{
				name: "PrivateKeyInfo.version",
				tagClass: es.Class.UNIVERSAL,
				type: es.Type.INTEGER,
				constructed: !1,
				capture: "privateKeyVersion",
			},
			{
				name: "PrivateKeyInfo.privateKeyAlgorithm",
				tagClass: es.Class.UNIVERSAL,
				type: es.Type.SEQUENCE,
				constructed: !0,
				value: [
					{
						name: "AlgorithmIdentifier.algorithm",
						tagClass: es.Class.UNIVERSAL,
						type: es.Type.OID,
						constructed: !1,
						capture: "privateKeyOid",
					},
				],
			},
			{
				name: "PrivateKeyInfo",
				tagClass: es.Class.UNIVERSAL,
				type: es.Type.OCTETSTRING,
				constructed: !1,
				capture: "privateKey",
			},
		],
	}
	J5.publicKeyValidator = {
		name: "SubjectPublicKeyInfo",
		tagClass: es.Class.UNIVERSAL,
		type: es.Type.SEQUENCE,
		constructed: !0,
		captureAsn1: "subjectPublicKeyInfo",
		value: [
			{
				name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
				tagClass: es.Class.UNIVERSAL,
				type: es.Type.SEQUENCE,
				constructed: !0,
				value: [
					{
						name: "AlgorithmIdentifier.algorithm",
						tagClass: es.Class.UNIVERSAL,
						type: es.Type.OID,
						constructed: !1,
						capture: "publicKeyOid",
					},
				],
			},
			{
				tagClass: es.Class.UNIVERSAL,
				type: es.Type.BITSTRING,
				constructed: !1,
				composed: !0,
				captureBitStringValue: "ed25519PublicKey",
			},
		],
	}
})
var $ce = x((pBt, Gce) => {
	"use strict"
	var Es = Yt()
	Tb()
	cl()
	K5()
	Sr()
	var Uce = Mce(),
		GXe = Uce.publicKeyValidator,
		$Xe = Uce.privateKeyValidator
	typeof Fce > "u" && (Fce = Es.jsbn.BigInteger)
	var Fce,
		Z5 = Es.util.ByteBuffer,
		Ho = typeof Buffer > "u" ? Uint8Array : Buffer
	Es.pki = Es.pki || {}
	Gce.exports = Es.pki.ed25519 = Es.ed25519 = Es.ed25519 || {}
	var ar = Es.ed25519
	ar.constants = {}
	ar.constants.PUBLIC_KEY_BYTE_LENGTH = 32
	ar.constants.PRIVATE_KEY_BYTE_LENGTH = 64
	ar.constants.SEED_BYTE_LENGTH = 32
	ar.constants.SIGN_BYTE_LENGTH = 64
	ar.constants.HASH_BYTE_LENGTH = 64
	ar.generateKeyPair = function (e) {
		e = e || {}
		var t = e.seed
		if (t === void 0) t = Es.random.getBytesSync(ar.constants.SEED_BYTE_LENGTH)
		else if (typeof t == "string") {
			if (t.length !== ar.constants.SEED_BYTE_LENGTH)
				throw new TypeError('"seed" must be ' + ar.constants.SEED_BYTE_LENGTH + " bytes in length.")
		} else if (!(t instanceof Uint8Array))
			throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.')
		t = Od({ message: t, encoding: "binary" })
		for (
			var r = new Ho(ar.constants.PUBLIC_KEY_BYTE_LENGTH),
				n = new Ho(ar.constants.PRIVATE_KEY_BYTE_LENGTH),
				i = 0;
			i < 32;
			++i
		)
			n[i] = t[i]
		return zXe(r, n), { publicKey: r, privateKey: n }
	}
	ar.privateKeyFromAsn1 = function (e) {
		var t = {},
			r = [],
			n = Es.asn1.validate(e, $Xe, t, r)
		if (!n) {
			var i = new Error("Invalid Key.")
			throw ((i.errors = r), i)
		}
		var s = Es.asn1.derToOid(t.privateKeyOid),
			o = Es.oids.EdDSA25519
		if (s !== o) throw new Error('Invalid OID "' + s + '"; OID must be "' + o + '".')
		var a = t.privateKey,
			l = Od({ message: Es.asn1.fromDer(a).value, encoding: "binary" })
		return { privateKeyBytes: l }
	}
	ar.publicKeyFromAsn1 = function (e) {
		var t = {},
			r = [],
			n = Es.asn1.validate(e, GXe, t, r)
		if (!n) {
			var i = new Error("Invalid Key.")
			throw ((i.errors = r), i)
		}
		var s = Es.asn1.derToOid(t.publicKeyOid),
			o = Es.oids.EdDSA25519
		if (s !== o) throw new Error('Invalid OID "' + s + '"; OID must be "' + o + '".')
		var a = t.ed25519PublicKey
		if (a.length !== ar.constants.PUBLIC_KEY_BYTE_LENGTH) throw new Error("Key length is invalid.")
		return Od({ message: a, encoding: "binary" })
	}
	ar.publicKeyFromPrivateKey = function (e) {
		e = e || {}
		var t = Od({ message: e.privateKey, encoding: "binary" })
		if (t.length !== ar.constants.PRIVATE_KEY_BYTE_LENGTH)
			throw new TypeError(
				'"options.privateKey" must have a byte length of ' + ar.constants.PRIVATE_KEY_BYTE_LENGTH,
			)
		for (var r = new Ho(ar.constants.PUBLIC_KEY_BYTE_LENGTH), n = 0; n < r.length; ++n) r[n] = t[32 + n]
		return r
	}
	ar.sign = function (e) {
		e = e || {}
		var t = Od(e),
			r = Od({ message: e.privateKey, encoding: "binary" })
		if (r.length === ar.constants.SEED_BYTE_LENGTH) {
			var n = ar.generateKeyPair({ seed: r })
			r = n.privateKey
		} else if (r.length !== ar.constants.PRIVATE_KEY_BYTE_LENGTH)
			throw new TypeError(
				'"options.privateKey" must have a byte length of ' +
					ar.constants.SEED_BYTE_LENGTH +
					" or " +
					ar.constants.PRIVATE_KEY_BYTE_LENGTH,
			)
		var i = new Ho(ar.constants.SIGN_BYTE_LENGTH + t.length)
		jXe(i, t, t.length, r)
		for (var s = new Ho(ar.constants.SIGN_BYTE_LENGTH), o = 0; o < s.length; ++o) s[o] = i[o]
		return s
	}
	ar.verify = function (e) {
		e = e || {}
		var t = Od(e)
		if (e.signature === void 0)
			throw new TypeError(
				'"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.',
			)
		var r = Od({ message: e.signature, encoding: "binary" })
		if (r.length !== ar.constants.SIGN_BYTE_LENGTH)
			throw new TypeError('"options.signature" must have a byte length of ' + ar.constants.SIGN_BYTE_LENGTH)
		var n = Od({ message: e.publicKey, encoding: "binary" })
		if (n.length !== ar.constants.PUBLIC_KEY_BYTE_LENGTH)
			throw new TypeError('"options.publicKey" must have a byte length of ' + ar.constants.PUBLIC_KEY_BYTE_LENGTH)
		var i = new Ho(ar.constants.SIGN_BYTE_LENGTH + t.length),
			s = new Ho(ar.constants.SIGN_BYTE_LENGTH + t.length),
			o
		for (o = 0; o < ar.constants.SIGN_BYTE_LENGTH; ++o) i[o] = r[o]
		for (o = 0; o < t.length; ++o) i[o + ar.constants.SIGN_BYTE_LENGTH] = t[o]
		return ZXe(s, i, i.length, n) >= 0
	}
	function Od(e) {
		var t = e.message
		if (t instanceof Uint8Array || t instanceof Ho) return t
		var r = e.encoding
		if (t === void 0)
			if (e.md) (t = e.md.digest().getBytes()), (r = "binary")
			else throw new TypeError('"options.message" or "options.md" not specified.')
		if (typeof t == "string" && !r) throw new TypeError('"options.encoding" must be "binary" or "utf8".')
		if (typeof t == "string") {
			if (typeof Buffer < "u") return Buffer.from(t, r)
			t = new Z5(t, r)
		} else if (!(t instanceof Z5))
			throw new TypeError(
				'"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.',
			)
		for (var n = new Ho(t.length()), i = 0; i < n.length; ++i) n[i] = t.at(i)
		return n
	}
	var X5 = pt(),
		BT = pt([1]),
		YXe = pt([
			30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995,
		]),
		KXe = pt([
			61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222,
		]),
		Qce = pt([
			54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035,
			8553,
		]),
		Nce = pt([
			26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214,
			26214,
		]),
		z5 = new Float64Array([
			237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 16,
		]),
		JXe = pt([
			41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139,
		])
	function Qb(e, t) {
		var r = Es.md.sha512.create(),
			n = new Z5(e)
		r.update(n.getBytes(t), "binary")
		var i = r.digest().getBytes()
		if (typeof Buffer < "u") return Buffer.from(i, "binary")
		for (var s = new Ho(ar.constants.HASH_BYTE_LENGTH), o = 0; o < 64; ++o) s[o] = i.charCodeAt(o)
		return s
	}
	function zXe(e, t) {
		var r = [pt(), pt(), pt(), pt()],
			n,
			i = Qb(t, 32)
		for (i[0] &= 248, i[31] &= 127, i[31] |= 64, n3(r, i), r3(e, r), n = 0; n < 32; ++n) t[n + 32] = e[n]
		return 0
	}
	function jXe(e, t, r, n) {
		var i,
			s,
			o = new Float64Array(64),
			a = [pt(), pt(), pt(), pt()],
			l = Qb(n, 32)
		;(l[0] &= 248), (l[31] &= 127), (l[31] |= 64)
		var c = r + 64
		for (i = 0; i < r; ++i) e[64 + i] = t[i]
		for (i = 0; i < 32; ++i) e[32 + i] = l[32 + i]
		var u = Qb(e.subarray(32), r + 32)
		for (e3(u), n3(a, u), r3(e, a), i = 32; i < 64; ++i) e[i] = n[i]
		var f = Qb(e, r + 64)
		for (e3(f), i = 32; i < 64; ++i) o[i] = 0
		for (i = 0; i < 32; ++i) o[i] = u[i]
		for (i = 0; i < 32; ++i) for (s = 0; s < 32; s++) o[i + s] += f[i] * l[s]
		return Oce(e.subarray(32), o), c
	}
	function ZXe(e, t, r, n) {
		var i,
			s,
			o = new Ho(32),
			a = [pt(), pt(), pt(), pt()],
			l = [pt(), pt(), pt(), pt()]
		if (((s = -1), r < 64 || XXe(l, n))) return -1
		for (i = 0; i < r; ++i) e[i] = t[i]
		for (i = 0; i < 32; ++i) e[i + 32] = n[i]
		var c = Qb(e, r)
		if ((e3(c), Hce(a, l, c), n3(l, t.subarray(32)), t3(a, l), r3(o, a), (r -= 64), qce(t, 0, o, 0))) {
			for (i = 0; i < r; ++i) e[i] = 0
			return -1
		}
		for (i = 0; i < r; ++i) e[i] = t[i + 64]
		return (s = r), s
	}
	function Oce(e, t) {
		var r, n, i, s
		for (n = 63; n >= 32; --n) {
			for (r = 0, i = n - 32, s = n - 12; i < s; ++i)
				(t[i] += r - 16 * t[n] * z5[i - (n - 32)]), (r = (t[i] + 128) >> 8), (t[i] -= r * 256)
			;(t[i] += r), (t[n] = 0)
		}
		for (r = 0, i = 0; i < 32; ++i) (t[i] += r - (t[31] >> 4) * z5[i]), (r = t[i] >> 8), (t[i] &= 255)
		for (i = 0; i < 32; ++i) t[i] -= r * z5[i]
		for (n = 0; n < 32; ++n) (t[n + 1] += t[n] >> 8), (e[n] = t[n] & 255)
	}
	function e3(e) {
		for (var t = new Float64Array(64), r = 0; r < 64; ++r) (t[r] = e[r]), (e[r] = 0)
		Oce(e, t)
	}
	function t3(e, t) {
		var r = pt(),
			n = pt(),
			i = pt(),
			s = pt(),
			o = pt(),
			a = pt(),
			l = pt(),
			c = pt(),
			u = pt()
		z0(r, e[1], e[0]),
			z0(u, t[1], t[0]),
			un(r, r, u),
			J0(n, e[0], e[1]),
			J0(u, t[0], t[1]),
			un(n, n, u),
			un(i, e[3], t[3]),
			un(i, i, KXe),
			un(s, e[2], t[2]),
			J0(s, s, s),
			z0(o, n, r),
			z0(a, s, i),
			J0(l, s, i),
			J0(c, n, r),
			un(e[0], o, a),
			un(e[1], c, l),
			un(e[2], l, a),
			un(e[3], o, c)
	}
	function Pce(e, t, r) {
		for (var n = 0; n < 4; ++n) Wce(e[n], t[n], r)
	}
	function r3(e, t) {
		var r = pt(),
			n = pt(),
			i = pt()
		net(i, t[2]), un(r, t[0], i), un(n, t[1], i), DT(e, n), (e[31] ^= Vce(r) << 7)
	}
	function DT(e, t) {
		var r,
			n,
			i,
			s = pt(),
			o = pt()
		for (r = 0; r < 16; ++r) o[r] = t[r]
		for (j5(o), j5(o), j5(o), n = 0; n < 2; ++n) {
			for (s[0] = o[0] - 65517, r = 1; r < 15; ++r)
				(s[r] = o[r] - 65535 - ((s[r - 1] >> 16) & 1)), (s[r - 1] &= 65535)
			;(s[15] = o[15] - 32767 - ((s[14] >> 16) & 1)), (i = (s[15] >> 16) & 1), (s[14] &= 65535), Wce(o, s, 1 - i)
		}
		for (r = 0; r < 16; r++) (e[2 * r] = o[r] & 255), (e[2 * r + 1] = o[r] >> 8)
	}
	function XXe(e, t) {
		var r = pt(),
			n = pt(),
			i = pt(),
			s = pt(),
			o = pt(),
			a = pt(),
			l = pt()
		return (
			yh(e[2], BT),
			eet(e[1], t),
			Rp(i, e[1]),
			un(s, i, YXe),
			z0(i, i, e[2]),
			J0(s, e[2], s),
			Rp(o, s),
			Rp(a, o),
			un(l, a, o),
			un(r, l, i),
			un(r, r, s),
			tet(r, r),
			un(r, r, i),
			un(r, r, s),
			un(r, r, s),
			un(e[0], r, s),
			Rp(n, e[0]),
			un(n, n, s),
			Lce(n, i) && un(e[0], e[0], JXe),
			Rp(n, e[0]),
			un(n, n, s),
			Lce(n, i) ? -1 : (Vce(e[0]) === t[31] >> 7 && z0(e[0], X5, e[0]), un(e[3], e[0], e[1]), 0)
		)
	}
	function eet(e, t) {
		var r
		for (r = 0; r < 16; ++r) e[r] = t[2 * r] + (t[2 * r + 1] << 8)
		e[15] &= 32767
	}
	function tet(e, t) {
		var r = pt(),
			n
		for (n = 0; n < 16; ++n) r[n] = t[n]
		for (n = 250; n >= 0; --n) Rp(r, r), n !== 1 && un(r, r, t)
		for (n = 0; n < 16; ++n) e[n] = r[n]
	}
	function Lce(e, t) {
		var r = new Ho(32),
			n = new Ho(32)
		return DT(r, e), DT(n, t), qce(r, 0, n, 0)
	}
	function qce(e, t, r, n) {
		return ret(e, t, r, n, 32)
	}
	function ret(e, t, r, n, i) {
		var s,
			o = 0
		for (s = 0; s < i; ++s) o |= e[t + s] ^ r[n + s]
		return (1 & ((o - 1) >>> 8)) - 1
	}
	function Vce(e) {
		var t = new Ho(32)
		return DT(t, e), t[0] & 1
	}
	function Hce(e, t, r) {
		var n, i
		for (yh(e[0], X5), yh(e[1], BT), yh(e[2], BT), yh(e[3], X5), i = 255; i >= 0; --i)
			(n = (r[(i / 8) | 0] >> (i & 7)) & 1), Pce(e, t, n), t3(t, e), t3(e, e), Pce(e, t, n)
	}
	function n3(e, t) {
		var r = [pt(), pt(), pt(), pt()]
		yh(r[0], Qce), yh(r[1], Nce), yh(r[2], BT), un(r[3], Qce, Nce), Hce(e, r, t)
	}
	function yh(e, t) {
		var r
		for (r = 0; r < 16; r++) e[r] = t[r] | 0
	}
	function net(e, t) {
		var r = pt(),
			n
		for (n = 0; n < 16; ++n) r[n] = t[n]
		for (n = 253; n >= 0; --n) Rp(r, r), n !== 2 && n !== 4 && un(r, r, t)
		for (n = 0; n < 16; ++n) e[n] = r[n]
	}
	function j5(e) {
		var t,
			r,
			n = 1
		for (t = 0; t < 16; ++t) (r = e[t] + n + 65535), (n = Math.floor(r / 65536)), (e[t] = r - n * 65536)
		e[0] += n - 1 + 37 * (n - 1)
	}
	function Wce(e, t, r) {
		for (var n, i = ~(r - 1), s = 0; s < 16; ++s) (n = i & (e[s] ^ t[s])), (e[s] ^= n), (t[s] ^= n)
	}
	function pt(e) {
		var t,
			r = new Float64Array(16)
		if (e) for (t = 0; t < e.length; ++t) r[t] = e[t]
		return r
	}
	function J0(e, t, r) {
		for (var n = 0; n < 16; ++n) e[n] = t[n] + r[n]
	}
	function z0(e, t, r) {
		for (var n = 0; n < 16; ++n) e[n] = t[n] - r[n]
	}
	function Rp(e, t) {
		un(e, t, t)
	}
	function un(e, t, r) {
		var n,
			i,
			s = 0,
			o = 0,
			a = 0,
			l = 0,
			c = 0,
			u = 0,
			f = 0,
			p = 0,
			g = 0,
			m = 0,
			y = 0,
			C = 0,
			v = 0,
			b = 0,
			w = 0,
			B = 0,
			M = 0,
			Q = 0,
			O = 0,
			Y = 0,
			j = 0,
			ne = 0,
			q = 0,
			me = 0,
			Qe = 0,
			N = 0,
			re = 0,
			K = 0,
			se = 0,
			Ze = 0,
			It = 0,
			Ce = r[0],
			Et = r[1],
			jt = r[2],
			Ar = r[3],
			de = r[4],
			Tr = r[5],
			tr = r[6],
			Nr = r[7],
			Ve = r[8],
			en = r[9],
			Pr = r[10],
			cr = r[11],
			be = r[12],
			Rr = r[13],
			fe = r[14],
			Ee = r[15]
		;(n = t[0]),
			(s += n * Ce),
			(o += n * Et),
			(a += n * jt),
			(l += n * Ar),
			(c += n * de),
			(u += n * Tr),
			(f += n * tr),
			(p += n * Nr),
			(g += n * Ve),
			(m += n * en),
			(y += n * Pr),
			(C += n * cr),
			(v += n * be),
			(b += n * Rr),
			(w += n * fe),
			(B += n * Ee),
			(n = t[1]),
			(o += n * Ce),
			(a += n * Et),
			(l += n * jt),
			(c += n * Ar),
			(u += n * de),
			(f += n * Tr),
			(p += n * tr),
			(g += n * Nr),
			(m += n * Ve),
			(y += n * en),
			(C += n * Pr),
			(v += n * cr),
			(b += n * be),
			(w += n * Rr),
			(B += n * fe),
			(M += n * Ee),
			(n = t[2]),
			(a += n * Ce),
			(l += n * Et),
			(c += n * jt),
			(u += n * Ar),
			(f += n * de),
			(p += n * Tr),
			(g += n * tr),
			(m += n * Nr),
			(y += n * Ve),
			(C += n * en),
			(v += n * Pr),
			(b += n * cr),
			(w += n * be),
			(B += n * Rr),
			(M += n * fe),
			(Q += n * Ee),
			(n = t[3]),
			(l += n * Ce),
			(c += n * Et),
			(u += n * jt),
			(f += n * Ar),
			(p += n * de),
			(g += n * Tr),
			(m += n * tr),
			(y += n * Nr),
			(C += n * Ve),
			(v += n * en),
			(b += n * Pr),
			(w += n * cr),
			(B += n * be),
			(M += n * Rr),
			(Q += n * fe),
			(O += n * Ee),
			(n = t[4]),
			(c += n * Ce),
			(u += n * Et),
			(f += n * jt),
			(p += n * Ar),
			(g += n * de),
			(m += n * Tr),
			(y += n * tr),
			(C += n * Nr),
			(v += n * Ve),
			(b += n * en),
			(w += n * Pr),
			(B += n * cr),
			(M += n * be),
			(Q += n * Rr),
			(O += n * fe),
			(Y += n * Ee),
			(n = t[5]),
			(u += n * Ce),
			(f += n * Et),
			(p += n * jt),
			(g += n * Ar),
			(m += n * de),
			(y += n * Tr),
			(C += n * tr),
			(v += n * Nr),
			(b += n * Ve),
			(w += n * en),
			(B += n * Pr),
			(M += n * cr),
			(Q += n * be),
			(O += n * Rr),
			(Y += n * fe),
			(j += n * Ee),
			(n = t[6]),
			(f += n * Ce),
			(p += n * Et),
			(g += n * jt),
			(m += n * Ar),
			(y += n * de),
			(C += n * Tr),
			(v += n * tr),
			(b += n * Nr),
			(w += n * Ve),
			(B += n * en),
			(M += n * Pr),
			(Q += n * cr),
			(O += n * be),
			(Y += n * Rr),
			(j += n * fe),
			(ne += n * Ee),
			(n = t[7]),
			(p += n * Ce),
			(g += n * Et),
			(m += n * jt),
			(y += n * Ar),
			(C += n * de),
			(v += n * Tr),
			(b += n * tr),
			(w += n * Nr),
			(B += n * Ve),
			(M += n * en),
			(Q += n * Pr),
			(O += n * cr),
			(Y += n * be),
			(j += n * Rr),
			(ne += n * fe),
			(q += n * Ee),
			(n = t[8]),
			(g += n * Ce),
			(m += n * Et),
			(y += n * jt),
			(C += n * Ar),
			(v += n * de),
			(b += n * Tr),
			(w += n * tr),
			(B += n * Nr),
			(M += n * Ve),
			(Q += n * en),
			(O += n * Pr),
			(Y += n * cr),
			(j += n * be),
			(ne += n * Rr),
			(q += n * fe),
			(me += n * Ee),
			(n = t[9]),
			(m += n * Ce),
			(y += n * Et),
			(C += n * jt),
			(v += n * Ar),
			(b += n * de),
			(w += n * Tr),
			(B += n * tr),
			(M += n * Nr),
			(Q += n * Ve),
			(O += n * en),
			(Y += n * Pr),
			(j += n * cr),
			(ne += n * be),
			(q += n * Rr),
			(me += n * fe),
			(Qe += n * Ee),
			(n = t[10]),
			(y += n * Ce),
			(C += n * Et),
			(v += n * jt),
			(b += n * Ar),
			(w += n * de),
			(B += n * Tr),
			(M += n * tr),
			(Q += n * Nr),
			(O += n * Ve),
			(Y += n * en),
			(j += n * Pr),
			(ne += n * cr),
			(q += n * be),
			(me += n * Rr),
			(Qe += n * fe),
			(N += n * Ee),
			(n = t[11]),
			(C += n * Ce),
			(v += n * Et),
			(b += n * jt),
			(w += n * Ar),
			(B += n * de),
			(M += n * Tr),
			(Q += n * tr),
			(O += n * Nr),
			(Y += n * Ve),
			(j += n * en),
			(ne += n * Pr),
			(q += n * cr),
			(me += n * be),
			(Qe += n * Rr),
			(N += n * fe),
			(re += n * Ee),
			(n = t[12]),
			(v += n * Ce),
			(b += n * Et),
			(w += n * jt),
			(B += n * Ar),
			(M += n * de),
			(Q += n * Tr),
			(O += n * tr),
			(Y += n * Nr),
			(j += n * Ve),
			(ne += n * en),
			(q += n * Pr),
			(me += n * cr),
			(Qe += n * be),
			(N += n * Rr),
			(re += n * fe),
			(K += n * Ee),
			(n = t[13]),
			(b += n * Ce),
			(w += n * Et),
			(B += n * jt),
			(M += n * Ar),
			(Q += n * de),
			(O += n * Tr),
			(Y += n * tr),
			(j += n * Nr),
			(ne += n * Ve),
			(q += n * en),
			(me += n * Pr),
			(Qe += n * cr),
			(N += n * be),
			(re += n * Rr),
			(K += n * fe),
			(se += n * Ee),
			(n = t[14]),
			(w += n * Ce),
			(B += n * Et),
			(M += n * jt),
			(Q += n * Ar),
			(O += n * de),
			(Y += n * Tr),
			(j += n * tr),
			(ne += n * Nr),
			(q += n * Ve),
			(me += n * en),
			(Qe += n * Pr),
			(N += n * cr),
			(re += n * be),
			(K += n * Rr),
			(se += n * fe),
			(Ze += n * Ee),
			(n = t[15]),
			(B += n * Ce),
			(M += n * Et),
			(Q += n * jt),
			(O += n * Ar),
			(Y += n * de),
			(j += n * Tr),
			(ne += n * tr),
			(q += n * Nr),
			(me += n * Ve),
			(Qe += n * en),
			(N += n * Pr),
			(re += n * cr),
			(K += n * be),
			(se += n * Rr),
			(Ze += n * fe),
			(It += n * Ee),
			(s += 38 * M),
			(o += 38 * Q),
			(a += 38 * O),
			(l += 38 * Y),
			(c += 38 * j),
			(u += 38 * ne),
			(f += 38 * q),
			(p += 38 * me),
			(g += 38 * Qe),
			(m += 38 * N),
			(y += 38 * re),
			(C += 38 * K),
			(v += 38 * se),
			(b += 38 * Ze),
			(w += 38 * It),
			(i = 1),
			(n = s + i + 65535),
			(i = Math.floor(n / 65536)),
			(s = n - i * 65536),
			(n = o + i + 65535),
			(i = Math.floor(n / 65536)),
			(o = n - i * 65536),
			(n = a + i + 65535),
			(i = Math.floor(n / 65536)),
			(a = n - i * 65536),
			(n = l + i + 65535),
			(i = Math.floor(n / 65536)),
			(l = n - i * 65536),
			(n = c + i + 65535),
			(i = Math.floor(n / 65536)),
			(c = n - i * 65536),
			(n = u + i + 65535),
			(i = Math.floor(n / 65536)),
			(u = n - i * 65536),
			(n = f + i + 65535),
			(i = Math.floor(n / 65536)),
			(f = n - i * 65536),
			(n = p + i + 65535),
			(i = Math.floor(n / 65536)),
			(p = n - i * 65536),
			(n = g + i + 65535),
			(i = Math.floor(n / 65536)),
			(g = n - i * 65536),
			(n = m + i + 65535),
			(i = Math.floor(n / 65536)),
			(m = n - i * 65536),
			(n = y + i + 65535),
			(i = Math.floor(n / 65536)),
			(y = n - i * 65536),
			(n = C + i + 65535),
			(i = Math.floor(n / 65536)),
			(C = n - i * 65536),
			(n = v + i + 65535),
			(i = Math.floor(n / 65536)),
			(v = n - i * 65536),
			(n = b + i + 65535),
			(i = Math.floor(n / 65536)),
			(b = n - i * 65536),
			(n = w + i + 65535),
			(i = Math.floor(n / 65536)),
			(w = n - i * 65536),
			(n = B + i + 65535),
			(i = Math.floor(n / 65536)),
			(B = n - i * 65536),
			(s += i - 1 + 37 * (i - 1)),
			(i = 1),
			(n = s + i + 65535),
			(i = Math.floor(n / 65536)),
			(s = n - i * 65536),
			(n = o + i + 65535),
			(i = Math.floor(n / 65536)),
			(o = n - i * 65536),
			(n = a + i + 65535),
			(i = Math.floor(n / 65536)),
			(a = n - i * 65536),
			(n = l + i + 65535),
			(i = Math.floor(n / 65536)),
			(l = n - i * 65536),
			(n = c + i + 65535),
			(i = Math.floor(n / 65536)),
			(c = n - i * 65536),
			(n = u + i + 65535),
			(i = Math.floor(n / 65536)),
			(u = n - i * 65536),
			(n = f + i + 65535),
			(i = Math.floor(n / 65536)),
			(f = n - i * 65536),
			(n = p + i + 65535),
			(i = Math.floor(n / 65536)),
			(p = n - i * 65536),
			(n = g + i + 65535),
			(i = Math.floor(n / 65536)),
			(g = n - i * 65536),
			(n = m + i + 65535),
			(i = Math.floor(n / 65536)),
			(m = n - i * 65536),
			(n = y + i + 65535),
			(i = Math.floor(n / 65536)),
			(y = n - i * 65536),
			(n = C + i + 65535),
			(i = Math.floor(n / 65536)),
			(C = n - i * 65536),
			(n = v + i + 65535),
			(i = Math.floor(n / 65536)),
			(v = n - i * 65536),
			(n = b + i + 65535),
			(i = Math.floor(n / 65536)),
			(b = n - i * 65536),
			(n = w + i + 65535),
			(i = Math.floor(n / 65536)),
			(w = n - i * 65536),
			(n = B + i + 65535),
			(i = Math.floor(n / 65536)),
			(B = n - i * 65536),
			(s += i - 1 + 37 * (i - 1)),
			(e[0] = s),
			(e[1] = o),
			(e[2] = a),
			(e[3] = l),
			(e[4] = c),
			(e[5] = u),
			(e[6] = f),
			(e[7] = p),
			(e[8] = g),
			(e[9] = m),
			(e[10] = y),
			(e[11] = C),
			(e[12] = v),
			(e[13] = b),
			(e[14] = w),
			(e[15] = B)
	}
})
var zce = x((ABt, Jce) => {
	"use strict"
	var xa = Yt()
	Sr()
	cl()
	Tb()
	Jce.exports = xa.kem = xa.kem || {}
	var Yce = xa.jsbn.BigInteger
	xa.kem.rsa = {}
	xa.kem.rsa.create = function (e, t) {
		t = t || {}
		var r = t.prng || xa.random,
			n = {}
		return (
			(n.encrypt = function (i, s) {
				var o = Math.ceil(i.n.bitLength() / 8),
					a
				do a = new Yce(xa.util.bytesToHex(r.getBytesSync(o)), 16).mod(i.n)
				while (a.compareTo(Yce.ONE) <= 0)
				a = xa.util.hexToBytes(a.toString(16))
				var l = o - a.length
				l > 0 && (a = xa.util.fillString("\0", l) + a)
				var c = i.encrypt(a, "NONE"),
					u = e.generate(a, s)
				return { encapsulation: c, key: u }
			}),
			(n.decrypt = function (i, s, o) {
				var a = i.decrypt(s, "NONE")
				return e.generate(a, o)
			}),
			n
		)
	}
	xa.kem.kdf1 = function (e, t) {
		Kce(this, e, 0, t || e.digestLength)
	}
	xa.kem.kdf2 = function (e, t) {
		Kce(this, e, 1, t || e.digestLength)
	}
	function Kce(e, t, r, n) {
		e.generate = function (i, s) {
			for (
				var o = new xa.util.ByteBuffer(), a = Math.ceil(s / n) + r, l = new xa.util.ByteBuffer(), c = r;
				c < a;
				++c
			) {
				l.putInt32(c), t.start(), t.update(i + l.getBytes())
				var u = t.digest()
				o.putBytes(u.getBytes(n))
			}
			return o.truncate(o.length() - s), o.getBytes()
		}
	}
})
var eue = x((mBt, Xce) => {
	"use strict"
	var hr = Yt()
	Sr()
	Xce.exports = hr.log = hr.log || {}
	hr.log.levels = ["none", "error", "warning", "info", "debug", "verbose", "max"]
	var TT = {},
		o3 = [],
		Pb = null
	hr.log.LEVEL_LOCKED = 2
	hr.log.NO_LEVEL_CHECK = 4
	hr.log.INTERPOLATE = 8
	for (Cu = 0; Cu < hr.log.levels.length; ++Cu)
		(i3 = hr.log.levels[Cu]), (TT[i3] = { index: Cu, name: i3.toUpperCase() })
	var i3, Cu
	hr.log.logMessage = function (e) {
		for (var t = TT[e.level].index, r = 0; r < o3.length; ++r) {
			var n = o3[r]
			if (n.flags & hr.log.NO_LEVEL_CHECK) n.f(e)
			else {
				var i = TT[n.level].index
				t <= i && n.f(n, e)
			}
		}
	}
	hr.log.prepareStandard = function (e) {
		"standard" in e || (e.standard = TT[e.level].name + " [" + e.category + "] " + e.message)
	}
	hr.log.prepareFull = function (e) {
		if (!("full" in e)) {
			var t = [e.message]
			;(t = t.concat([])), (e.full = hr.util.format.apply(this, t))
		}
	}
	hr.log.prepareStandardFull = function (e) {
		"standardFull" in e || (hr.log.prepareStandard(e), (e.standardFull = e.standard))
	}
	for (s3 = ["error", "warning", "info", "debug", "verbose"], Cu = 0; Cu < s3.length; ++Cu)
		(function (t) {
			hr.log[t] = function (r, n) {
				var i = Array.prototype.slice.call(arguments).slice(2),
					s = {
						timestamp: new Date(),
						level: t,
						category: r,
						message: n,
						arguments: i,
					}
				hr.log.logMessage(s)
			}
		})(s3[Cu])
	var s3, Cu
	hr.log.makeLogger = function (e) {
		var t = { flags: 0, f: e }
		return hr.log.setLevel(t, "none"), t
	}
	hr.log.setLevel = function (e, t) {
		var r = !1
		if (e && !(e.flags & hr.log.LEVEL_LOCKED))
			for (var n = 0; n < hr.log.levels.length; ++n) {
				var i = hr.log.levels[n]
				if (t == i) {
					;(e.level = t), (r = !0)
					break
				}
			}
		return r
	}
	hr.log.lock = function (e, t) {
		typeof t > "u" || t ? (e.flags |= hr.log.LEVEL_LOCKED) : (e.flags &= ~hr.log.LEVEL_LOCKED)
	}
	hr.log.addLogger = function (e) {
		o3.push(e)
	}
	typeof console < "u" && "log" in console
		? (console.error && console.warn && console.info && console.debug
				? ((jce = {
						error: console.error,
						warning: console.warn,
						info: console.info,
						debug: console.debug,
						verbose: console.debug,
					}),
					(Lb = function (e, t) {
						hr.log.prepareStandard(t)
						var r = jce[t.level],
							n = [t.standard]
						;(n = n.concat(t.arguments.slice())), r.apply(console, n)
					}),
					(j0 = hr.log.makeLogger(Lb)))
				: ((Lb = function (t, r) {
						hr.log.prepareStandardFull(r), console.log(r.standardFull)
					}),
					(j0 = hr.log.makeLogger(Lb))),
			hr.log.setLevel(j0, "debug"),
			hr.log.addLogger(j0),
			(Pb = j0))
		: (console = { log: function () {} })
	var j0, jce, Lb
	Pb !== null &&
		typeof window < "u" &&
		window.location &&
		((Nb = new URL(window.location.href).searchParams),
		Nb.has("console.level") && hr.log.setLevel(Pb, Nb.get("console.level").slice(-1)[0]),
		Nb.has("console.lock") && ((Zce = Nb.get("console.lock").slice(-1)[0]), Zce == "true" && hr.log.lock(Pb)))
	var Nb, Zce
	hr.log.consoleLogger = Pb
})
var rue = x((yBt, tue) => {
	"use strict"
	tue.exports = du()
	cT()
	W0()
	C5()
	K5()
})
var sue = x((CBt, iue) => {
	"use strict"
	var De = Yt()
	uh()
	gc()
	Bb()
	dh()
	_p()
	M5()
	cl()
	Sr()
	xT()
	var G = De.asn1,
		lo = (iue.exports = De.pkcs7 = De.pkcs7 || {})
	lo.messageFromPem = function (e) {
		var t = De.pem.decode(e)[0]
		if (t.type !== "PKCS7") {
			var r = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".')
			throw ((r.headerType = t.type), r)
		}
		if (t.procType && t.procType.type === "ENCRYPTED")
			throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.")
		var n = G.fromDer(t.body)
		return lo.messageFromAsn1(n)
	}
	lo.messageToPem = function (e, t) {
		var r = { type: "PKCS7", body: G.toDer(e.toAsn1()).getBytes() }
		return De.pem.encode(r, { maxline: t })
	}
	lo.messageFromAsn1 = function (e) {
		var t = {},
			r = []
		if (!G.validate(e, lo.asn1.contentInfoValidator, t, r)) {
			var n = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.")
			throw ((n.errors = r), n)
		}
		var i = G.derToOid(t.contentType),
			s
		switch (i) {
			case De.pki.oids.envelopedData:
				s = lo.createEnvelopedData()
				break
			case De.pki.oids.encryptedData:
				s = lo.createEncryptedData()
				break
			case De.pki.oids.signedData:
				s = lo.createSignedData()
				break
			default:
				throw new Error("Cannot read PKCS#7 message. ContentType with OID " + i + " is not (yet) supported.")
		}
		return s.fromAsn1(t.content.value[0]), s
	}
	lo.createSignedData = function () {
		var e = null
		return (
			(e = {
				type: De.pki.oids.signedData,
				version: 1,
				certificates: [],
				crls: [],
				signers: [],
				digestAlgorithmIdentifiers: [],
				contentInfo: null,
				signerInfos: [],
				fromAsn1: function (n) {
					if (
						(l3(e, n, lo.asn1.signedDataValidator),
						(e.certificates = []),
						(e.crls = []),
						(e.digestAlgorithmIdentifiers = []),
						(e.contentInfo = null),
						(e.signerInfos = []),
						e.rawCapture.certificates)
					)
						for (var i = e.rawCapture.certificates.value, s = 0; s < i.length; ++s)
							e.certificates.push(De.pki.certificateFromAsn1(i[s]))
				},
				toAsn1: function () {
					e.contentInfo || e.sign()
					for (var n = [], i = 0; i < e.certificates.length; ++i)
						n.push(De.pki.certificateToAsn1(e.certificates[i]))
					var s = [],
						o = G.create(G.Class.CONTEXT_SPECIFIC, 0, !0, [
							G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
								G.create(G.Class.UNIVERSAL, G.Type.INTEGER, !1, G.integerToDer(e.version).getBytes()),
								G.create(G.Class.UNIVERSAL, G.Type.SET, !0, e.digestAlgorithmIdentifiers),
								e.contentInfo,
							]),
						])
					return (
						n.length > 0 && o.value[0].value.push(G.create(G.Class.CONTEXT_SPECIFIC, 0, !0, n)),
						s.length > 0 && o.value[0].value.push(G.create(G.Class.CONTEXT_SPECIFIC, 1, !0, s)),
						o.value[0].value.push(G.create(G.Class.UNIVERSAL, G.Type.SET, !0, e.signerInfos)),
						G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
							G.create(G.Class.UNIVERSAL, G.Type.OID, !1, G.oidToDer(e.type).getBytes()),
							o,
						])
					)
				},
				addSigner: function (n) {
					var i = n.issuer,
						s = n.serialNumber
					if (n.certificate) {
						var o = n.certificate
						typeof o == "string" && (o = De.pki.certificateFromPem(o)),
							(i = o.issuer.attributes),
							(s = o.serialNumber)
					}
					var a = n.key
					if (!a) throw new Error("Could not add PKCS#7 signer; no private key specified.")
					typeof a == "string" && (a = De.pki.privateKeyFromPem(a))
					var l = n.digestAlgorithm || De.pki.oids.sha1
					switch (l) {
						case De.pki.oids.sha1:
						case De.pki.oids.sha256:
						case De.pki.oids.sha384:
						case De.pki.oids.sha512:
						case De.pki.oids.md5:
							break
						default:
							throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + l)
					}
					var c = n.authenticatedAttributes || []
					if (c.length > 0) {
						for (var u = !1, f = !1, p = 0; p < c.length; ++p) {
							var g = c[p]
							if (!u && g.type === De.pki.oids.contentType) {
								if (((u = !0), f)) break
								continue
							}
							if (!f && g.type === De.pki.oids.messageDigest) {
								if (((f = !0), u)) break
								continue
							}
						}
						if (!u || !f)
							throw new Error(
								"Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.",
							)
					}
					e.signers.push({
						key: a,
						version: 1,
						issuer: i,
						serialNumber: s,
						digestAlgorithm: l,
						signatureAlgorithm: De.pki.oids.rsaEncryption,
						signature: null,
						authenticatedAttributes: c,
						unauthenticatedAttributes: [],
					})
				},
				sign: function (n) {
					if (
						((n = n || {}),
						(typeof e.content != "object" || e.contentInfo === null) &&
							((e.contentInfo = G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
								G.create(G.Class.UNIVERSAL, G.Type.OID, !1, G.oidToDer(De.pki.oids.data).getBytes()),
							])),
							"content" in e))
					) {
						var i
						e.content instanceof De.util.ByteBuffer
							? (i = e.content.bytes())
							: typeof e.content == "string" && (i = De.util.encodeUtf8(e.content)),
							n.detached
								? (e.detachedContent = G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, !1, i))
								: e.contentInfo.value.push(
										G.create(G.Class.CONTEXT_SPECIFIC, 0, !0, [
											G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, !1, i),
										]),
									)
					}
					if (e.signers.length !== 0) {
						var s = t()
						r(s)
					}
				},
				verify: function () {
					throw new Error("PKCS#7 signature verification not yet implemented.")
				},
				addCertificate: function (n) {
					typeof n == "string" && (n = De.pki.certificateFromPem(n)), e.certificates.push(n)
				},
				addCertificateRevokationList: function (n) {
					throw new Error("PKCS#7 CRL support not yet implemented.")
				},
			}),
			e
		)
		function t() {
			for (var n = {}, i = 0; i < e.signers.length; ++i) {
				var s = e.signers[i],
					o = s.digestAlgorithm
				o in n || (n[o] = De.md[De.pki.oids[o]].create()),
					s.authenticatedAttributes.length === 0 ? (s.md = n[o]) : (s.md = De.md[De.pki.oids[o]].create())
			}
			e.digestAlgorithmIdentifiers = []
			for (var o in n)
				e.digestAlgorithmIdentifiers.push(
					G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
						G.create(G.Class.UNIVERSAL, G.Type.OID, !1, G.oidToDer(o).getBytes()),
						G.create(G.Class.UNIVERSAL, G.Type.NULL, !1, ""),
					]),
				)
			return n
		}
		function r(n) {
			var i
			if ((e.detachedContent ? (i = e.detachedContent) : ((i = e.contentInfo.value[1]), (i = i.value[0])), !i))
				throw new Error("Could not sign PKCS#7 message; there is no content to sign.")
			var s = G.derToOid(e.contentInfo.value[0].value),
				o = G.toDer(i)
			o.getByte(), G.getBerValueLength(o), (o = o.getBytes())
			for (var a in n) n[a].start().update(o)
			for (var l = new Date(), c = 0; c < e.signers.length; ++c) {
				var u = e.signers[c]
				if (u.authenticatedAttributes.length === 0) {
					if (s !== De.pki.oids.data)
						throw new Error(
							"Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.",
						)
				} else {
					u.authenticatedAttributesAsn1 = G.create(G.Class.CONTEXT_SPECIFIC, 0, !0, [])
					for (
						var f = G.create(G.Class.UNIVERSAL, G.Type.SET, !0, []), p = 0;
						p < u.authenticatedAttributes.length;
						++p
					) {
						var g = u.authenticatedAttributes[p]
						g.type === De.pki.oids.messageDigest
							? (g.value = n[u.digestAlgorithm].digest())
							: g.type === De.pki.oids.signingTime && (g.value || (g.value = l)),
							f.value.push(a3(g)),
							u.authenticatedAttributesAsn1.value.push(a3(g))
					}
					;(o = G.toDer(f).getBytes()), u.md.start().update(o)
				}
				u.signature = u.key.sign(u.md, "RSASSA-PKCS1-V1_5")
			}
			e.signerInfos = uet(e.signers)
		}
	}
	lo.createEncryptedData = function () {
		var e = null
		return (
			(e = {
				type: De.pki.oids.encryptedData,
				version: 0,
				encryptedContent: { algorithm: De.pki.oids["aes256-CBC"] },
				fromAsn1: function (t) {
					l3(e, t, lo.asn1.encryptedDataValidator)
				},
				decrypt: function (t) {
					t !== void 0 && (e.encryptedContent.key = t), nue(e)
				},
			}),
			e
		)
	}
	lo.createEnvelopedData = function () {
		var e = null
		return (
			(e = {
				type: De.pki.oids.envelopedData,
				version: 0,
				recipients: [],
				encryptedContent: { algorithm: De.pki.oids["aes256-CBC"] },
				fromAsn1: function (t) {
					var r = l3(e, t, lo.asn1.envelopedDataValidator)
					e.recipients = oet(r.recipientInfos.value)
				},
				toAsn1: function () {
					return G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
						G.create(G.Class.UNIVERSAL, G.Type.OID, !1, G.oidToDer(e.type).getBytes()),
						G.create(G.Class.CONTEXT_SPECIFIC, 0, !0, [
							G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
								G.create(G.Class.UNIVERSAL, G.Type.INTEGER, !1, G.integerToDer(e.version).getBytes()),
								G.create(G.Class.UNIVERSAL, G.Type.SET, !0, aet(e.recipients)),
								G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, det(e.encryptedContent)),
							]),
						]),
					])
				},
				findRecipient: function (t) {
					for (var r = t.issuer.attributes, n = 0; n < e.recipients.length; ++n) {
						var i = e.recipients[n],
							s = i.issuer
						if (i.serialNumber === t.serialNumber && s.length === r.length) {
							for (var o = !0, a = 0; a < r.length; ++a)
								if (s[a].type !== r[a].type || s[a].value !== r[a].value) {
									o = !1
									break
								}
							if (o) return i
						}
					}
					return null
				},
				decrypt: function (t, r) {
					if (e.encryptedContent.key === void 0 && t !== void 0 && r !== void 0)
						switch (t.encryptedContent.algorithm) {
							case De.pki.oids.rsaEncryption:
							case De.pki.oids.desCBC:
								var n = r.decrypt(t.encryptedContent.content)
								e.encryptedContent.key = De.util.createBuffer(n)
								break
							default:
								throw new Error("Unsupported asymmetric cipher, OID " + t.encryptedContent.algorithm)
						}
					nue(e)
				},
				addRecipient: function (t) {
					e.recipients.push({
						version: 0,
						issuer: t.issuer.attributes,
						serialNumber: t.serialNumber,
						encryptedContent: {
							algorithm: De.pki.oids.rsaEncryption,
							key: t.publicKey,
						},
					})
				},
				encrypt: function (t, r) {
					if (e.encryptedContent.content === void 0) {
						;(r = r || e.encryptedContent.algorithm), (t = t || e.encryptedContent.key)
						var n, i, s
						switch (r) {
							case De.pki.oids["aes128-CBC"]:
								;(n = 16), (i = 16), (s = De.aes.createEncryptionCipher)
								break
							case De.pki.oids["aes192-CBC"]:
								;(n = 24), (i = 16), (s = De.aes.createEncryptionCipher)
								break
							case De.pki.oids["aes256-CBC"]:
								;(n = 32), (i = 16), (s = De.aes.createEncryptionCipher)
								break
							case De.pki.oids["des-EDE3-CBC"]:
								;(n = 24), (i = 8), (s = De.des.createEncryptionCipher)
								break
							default:
								throw new Error("Unsupported symmetric cipher, OID " + r)
						}
						if (t === void 0) t = De.util.createBuffer(De.random.getBytes(n))
						else if (t.length() != n)
							throw new Error(
								"Symmetric key has wrong length; got " + t.length() + " bytes, expected " + n + ".",
							)
						;(e.encryptedContent.algorithm = r),
							(e.encryptedContent.key = t),
							(e.encryptedContent.parameter = De.util.createBuffer(De.random.getBytes(i)))
						var o = s(t)
						if ((o.start(e.encryptedContent.parameter.copy()), o.update(e.content), !o.finish()))
							throw new Error("Symmetric encryption failed.")
						e.encryptedContent.content = o.output
					}
					for (var a = 0; a < e.recipients.length; ++a) {
						var l = e.recipients[a]
						if (l.encryptedContent.content === void 0)
							switch (l.encryptedContent.algorithm) {
								case De.pki.oids.rsaEncryption:
									l.encryptedContent.content = l.encryptedContent.key.encrypt(
										e.encryptedContent.key.data,
									)
									break
								default:
									throw new Error(
										"Unsupported asymmetric cipher, OID " + l.encryptedContent.algorithm,
									)
							}
					}
				},
			}),
			e
		)
	}
	function iet(e) {
		var t = {},
			r = []
		if (!G.validate(e, lo.asn1.recipientInfoValidator, t, r)) {
			var n = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.")
			throw ((n.errors = r), n)
		}
		return {
			version: t.version.charCodeAt(0),
			issuer: De.pki.RDNAttributesAsArray(t.issuer),
			serialNumber: De.util.createBuffer(t.serial).toHex(),
			encryptedContent: {
				algorithm: G.derToOid(t.encAlgorithm),
				parameter: t.encParameter ? t.encParameter.value : void 0,
				content: t.encKey,
			},
		}
	}
	function set(e) {
		return G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
			G.create(G.Class.UNIVERSAL, G.Type.INTEGER, !1, G.integerToDer(e.version).getBytes()),
			G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
				De.pki.distinguishedNameToAsn1({ attributes: e.issuer }),
				G.create(G.Class.UNIVERSAL, G.Type.INTEGER, !1, De.util.hexToBytes(e.serialNumber)),
			]),
			G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
				G.create(G.Class.UNIVERSAL, G.Type.OID, !1, G.oidToDer(e.encryptedContent.algorithm).getBytes()),
				G.create(G.Class.UNIVERSAL, G.Type.NULL, !1, ""),
			]),
			G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, !1, e.encryptedContent.content),
		])
	}
	function oet(e) {
		for (var t = [], r = 0; r < e.length; ++r) t.push(iet(e[r]))
		return t
	}
	function aet(e) {
		for (var t = [], r = 0; r < e.length; ++r) t.push(set(e[r]))
		return t
	}
	function cet(e) {
		var t = G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
			G.create(G.Class.UNIVERSAL, G.Type.INTEGER, !1, G.integerToDer(e.version).getBytes()),
			G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
				De.pki.distinguishedNameToAsn1({ attributes: e.issuer }),
				G.create(G.Class.UNIVERSAL, G.Type.INTEGER, !1, De.util.hexToBytes(e.serialNumber)),
			]),
			G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
				G.create(G.Class.UNIVERSAL, G.Type.OID, !1, G.oidToDer(e.digestAlgorithm).getBytes()),
				G.create(G.Class.UNIVERSAL, G.Type.NULL, !1, ""),
			]),
		])
		if (
			(e.authenticatedAttributesAsn1 && t.value.push(e.authenticatedAttributesAsn1),
			t.value.push(
				G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
					G.create(G.Class.UNIVERSAL, G.Type.OID, !1, G.oidToDer(e.signatureAlgorithm).getBytes()),
					G.create(G.Class.UNIVERSAL, G.Type.NULL, !1, ""),
				]),
			),
			t.value.push(G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, !1, e.signature)),
			e.unauthenticatedAttributes.length > 0)
		) {
			for (
				var r = G.create(G.Class.CONTEXT_SPECIFIC, 1, !0, []), n = 0;
				n < e.unauthenticatedAttributes.length;
				++n
			) {
				var i = e.unauthenticatedAttributes[n]
				r.values.push(a3(i))
			}
			t.value.push(r)
		}
		return t
	}
	function uet(e) {
		for (var t = [], r = 0; r < e.length; ++r) t.push(cet(e[r]))
		return t
	}
	function a3(e) {
		var t
		if (e.type === De.pki.oids.contentType)
			t = G.create(G.Class.UNIVERSAL, G.Type.OID, !1, G.oidToDer(e.value).getBytes())
		else if (e.type === De.pki.oids.messageDigest)
			t = G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, !1, e.value.bytes())
		else if (e.type === De.pki.oids.signingTime) {
			var r = new Date("1950-01-01T00:00:00Z"),
				n = new Date("2050-01-01T00:00:00Z"),
				i = e.value
			if (typeof i == "string") {
				var s = Date.parse(i)
				isNaN(s)
					? i.length === 13
						? (i = G.utcTimeToDate(i))
						: (i = G.generalizedTimeToDate(i))
					: (i = new Date(s))
			}
			i >= r && i < n
				? (t = G.create(G.Class.UNIVERSAL, G.Type.UTCTIME, !1, G.dateToUtcTime(i)))
				: (t = G.create(G.Class.UNIVERSAL, G.Type.GENERALIZEDTIME, !1, G.dateToGeneralizedTime(i)))
		}
		return G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
			G.create(G.Class.UNIVERSAL, G.Type.OID, !1, G.oidToDer(e.type).getBytes()),
			G.create(G.Class.UNIVERSAL, G.Type.SET, !0, [t]),
		])
	}
	function det(e) {
		return [
			G.create(G.Class.UNIVERSAL, G.Type.OID, !1, G.oidToDer(De.pki.oids.data).getBytes()),
			G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, !0, [
				G.create(G.Class.UNIVERSAL, G.Type.OID, !1, G.oidToDer(e.algorithm).getBytes()),
				e.parameter ? G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, !1, e.parameter.getBytes()) : void 0,
			]),
			G.create(G.Class.CONTEXT_SPECIFIC, 0, !0, [
				G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, !1, e.content.getBytes()),
			]),
		]
	}
	function l3(e, t, r) {
		var n = {},
			i = []
		if (!G.validate(t, r, n, i)) {
			var s = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.")
			throw ((s.errors = s), s)
		}
		var o = G.derToOid(n.contentType)
		if (o !== De.pki.oids.data)
			throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.")
		if (n.encryptedContent) {
			var a = ""
			if (De.util.isArray(n.encryptedContent))
				for (var l = 0; l < n.encryptedContent.length; ++l) {
					if (n.encryptedContent[l].type !== G.Type.OCTETSTRING)
						throw new Error(
							"Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.",
						)
					a += n.encryptedContent[l].value
				}
			else a = n.encryptedContent
			e.encryptedContent = {
				algorithm: G.derToOid(n.encAlgorithm),
				parameter: De.util.createBuffer(n.encParameter.value),
				content: De.util.createBuffer(a),
			}
		}
		if (n.content) {
			var a = ""
			if (De.util.isArray(n.content))
				for (var l = 0; l < n.content.length; ++l) {
					if (n.content[l].type !== G.Type.OCTETSTRING)
						throw new Error(
							"Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.",
						)
					a += n.content[l].value
				}
			else a = n.content
			e.content = De.util.createBuffer(a)
		}
		return (e.version = n.version.charCodeAt(0)), (e.rawCapture = n), n
	}
	function nue(e) {
		if (e.encryptedContent.key === void 0) throw new Error("Symmetric key not available.")
		if (e.content === void 0) {
			var t
			switch (e.encryptedContent.algorithm) {
				case De.pki.oids["aes128-CBC"]:
				case De.pki.oids["aes192-CBC"]:
				case De.pki.oids["aes256-CBC"]:
					t = De.aes.createDecryptionCipher(e.encryptedContent.key)
					break
				case De.pki.oids.desCBC:
				case De.pki.oids["des-EDE3-CBC"]:
					t = De.des.createDecryptionCipher(e.encryptedContent.key)
					break
				default:
					throw new Error("Unsupported symmetric cipher, OID " + e.encryptedContent.algorithm)
			}
			if ((t.start(e.encryptedContent.parameter), t.update(e.encryptedContent.content), !t.finish()))
				throw new Error("Symmetric decryption failed.")
			e.content = t.output
		}
	}
})
var aue = x((vBt, oue) => {
	"use strict"
	var Si = Yt()
	uh()
	O0()
	cT()
	W0()
	Sr()
	var kT = (oue.exports = Si.ssh = Si.ssh || {})
	kT.privateKeyToPutty = function (e, t, r) {
		;(r = r || ""), (t = t || "")
		var n = "ssh-rsa",
			i = t === "" ? "none" : "aes256-cbc",
			s =
				"PuTTY-User-Key-File-2: " +
				n +
				`\r
`
		;(s +=
			"Encryption: " +
			i +
			`\r
`),
			(s +=
				"Comment: " +
				r +
				`\r
`)
		var o = Si.util.createBuffer()
		Z0(o, n), vu(o, e.e), vu(o, e.n)
		var a = Si.util.encode64(o.bytes(), 64),
			l = Math.floor(a.length / 66) + 1
		;(s +=
			"Public-Lines: " +
			l +
			`\r
`),
			(s += a)
		var c = Si.util.createBuffer()
		vu(c, e.d), vu(c, e.p), vu(c, e.q), vu(c, e.qInv)
		var u
		if (!t) u = Si.util.encode64(c.bytes(), 64)
		else {
			var f = c.length() + 16 - 1
			f -= f % 16
			var p = RT(c.bytes())
			p.truncate(p.length() - f + c.length()), c.putBuffer(p)
			var g = Si.util.createBuffer()
			g.putBuffer(RT("\0\0\0\0", t)), g.putBuffer(RT("\0\0\0", t))
			var m = Si.aes.createEncryptionCipher(g.truncate(8), "CBC")
			m.start(Si.util.createBuffer().fillWithByte(0, 16)), m.update(c.copy()), m.finish()
			var y = m.output
			y.truncate(16), (u = Si.util.encode64(y.bytes(), 64))
		}
		;(l = Math.floor(u.length / 66) + 1),
			(s +=
				`\r
Private-Lines: ` +
				l +
				`\r
`),
			(s += u)
		var C = RT("putty-private-key-file-mac-key", t),
			v = Si.util.createBuffer()
		Z0(v, n), Z0(v, i), Z0(v, r), v.putInt32(o.length()), v.putBuffer(o), v.putInt32(c.length()), v.putBuffer(c)
		var b = Si.hmac.create()
		return (
			b.start("sha1", C),
			b.update(v.bytes()),
			(s +=
				`\r
Private-MAC: ` +
				b.digest().toHex() +
				`\r
`),
			s
		)
	}
	kT.publicKeyToOpenSSH = function (e, t) {
		var r = "ssh-rsa"
		t = t || ""
		var n = Si.util.createBuffer()
		return Z0(n, r), vu(n, e.e), vu(n, e.n), r + " " + Si.util.encode64(n.bytes()) + " " + t
	}
	kT.privateKeyToOpenSSH = function (e, t) {
		return t ? Si.pki.encryptRsaPrivateKey(e, t, { legacy: !0, algorithm: "aes128" }) : Si.pki.privateKeyToPem(e)
	}
	kT.getPublicKeyFingerprint = function (e, t) {
		t = t || {}
		var r = t.md || Si.md.md5.create(),
			n = "ssh-rsa",
			i = Si.util.createBuffer()
		Z0(i, n), vu(i, e.e), vu(i, e.n), r.start(), r.update(i.getBytes())
		var s = r.digest()
		if (t.encoding === "hex") {
			var o = s.toHex()
			return t.delimiter ? o.match(/.{2}/g).join(t.delimiter) : o
		} else {
			if (t.encoding === "binary") return s.getBytes()
			if (t.encoding) throw new Error('Unknown encoding "' + t.encoding + '".')
		}
		return s
	}
	function vu(e, t) {
		var r = t.toString(16)
		r[0] >= "8" && (r = "00" + r)
		var n = Si.util.hexToBytes(r)
		e.putInt32(n.length), e.putBytes(n)
	}
	function Z0(e, t) {
		e.putInt32(t.length), e.putString(t)
	}
	function RT() {
		for (var e = Si.md.sha1.create(), t = arguments.length, r = 0; r < t; ++r) e.update(arguments[r])
		return e.digest()
	}
})
var cue = x((EBt, lue) => {
	"use strict"
	lue.exports = Yt()
	uh()
	Bce()
	gc()
	rT()
	Bb()
	$ce()
	O0()
	zce()
	eue()
	rue()
	F5()
	hT()
	_p()
	B5()
	P5()
	sue()
	U5()
	T5()
	v5()
	vT()
	cl()
	x5()
	aue()
	G5()
	Sr()
})
var fue = x((kp) => {
	"use strict"
	Object.defineProperty(kp, "__esModule", { value: !0 })
	kp.convert = kp.Format = void 0
	var Ub = cue(),
		Ch
	;(function (e) {
		;(e.der = "der"),
			(e.pem = "pem"),
			(e.txt = "txt"),
			(e.asn1 = "asn1"),
			(e.x509 = "x509"),
			(e.fingerprint = "fingerprint")
	})((Ch = kp.Format || (kp.Format = {})))
	function uue(e) {
		var t = Ub.pki.pemToDer(e),
			r = Ub.asn1,
			n = r.fromDer(t.data.toString("binary")).value[0].value,
			i = n[0],
			s = i.tagClass === r.Class.CONTEXT_SPECIFIC && i.type === 0 && i.constructed,
			o = n.slice(s)
		return { serial: o[0], issuer: o[2], valid: o[3], subject: o[4] }
	}
	function fet(e) {
		var t = uue(e),
			r = t.subject.value
				.map(function (i) {
					return i.value[0].value[1].value
				})
				.join("/"),
			n = t.valid.value
				.map(function (i) {
					return i.value
				})
				.join(" - ")
		return ["Subject	".concat(r), "Valid	".concat(n), String(e)].join(`
`)
	}
	function due(e, t) {
		switch (t) {
			case Ch.der:
				return Ub.pki.pemToDer(e)
			case Ch.pem:
				return e
			case Ch.txt:
				return fet(e)
			case Ch.asn1:
				return uue(e)
			case Ch.fingerprint:
				var r = Ub.md.sha1.create(),
					n = due(e, Ch.der)
				return r.update(n.getBytes()), r.digest().toHex()
			case Ch.x509:
				return Ub.pki.certificateFromPem(e)
			default:
				throw new Error("unknown format ".concat(t))
		}
	}
	kp.convert = due
})
var yue = x((Wo) => {
	"use strict"
	var vh =
			(Wo && Wo.__assign) ||
			function () {
				return (
					(vh =
						Object.assign ||
						function (e) {
							for (var t, r = 1, n = arguments.length; r < n; r++) {
								t = arguments[r]
								for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
							}
							return e
						}),
					vh.apply(this, arguments)
				)
			},
		MT =
			(Wo && Wo.__spreadArray) ||
			function (e, t, r) {
				if (r || arguments.length === 2)
					for (var n = 0, i = t.length, s; n < i; n++)
						(s || !(n in t)) && (s || (s = Array.prototype.slice.call(t, 0, n)), (s[n] = t[n]))
				return e.concat(s || Array.prototype.slice.call(t))
			}
	Object.defineProperty(Wo, "__esModule", { value: !0 })
	Wo.convert = Wo.Format = Wo.addToGlobalAgent = Wo.get = void 0
	var c3 = require("https"),
		het = require("tls"),
		hue = require("child_process"),
		gue = Yae(),
		qd = fue()
	Object.defineProperty(Wo, "Format", {
		enumerable: !0,
		get: function () {
			return qd.Format
		},
	})
	Object.defineProperty(Wo, "convert", {
		enumerable: !0,
		get: function () {
			return qd.convert
		},
	})
	var pue = process.platform === "darwin",
		Aue = c3.globalAgent,
		QT = {
			keychain: "all",
			unique: !0,
			excludeBundled: !0,
			format: qd.Format.pem,
		}
	function mue(e) {
		if ((e === void 0 && (e = QT), !pue)) return []
		e = vh(vh({}, QT), e)
		var t = /(?=-----BEGIN\sCERTIFICATE-----)/g,
			r = ["find-certificate", "-a", "-p"],
			n = []
		if (e.keychain === "all" || e.keychain === "SystemRootCertificates") {
			var i = "/System/Library/Keychains/SystemRootCertificates.keychain",
				s = (0, hue.spawnSync)("/usr/bin/security", r.concat(i))
					.stdout.toString()
					.split(t)
					.map(function (c) {
						return c.trim()
					})
			n = MT(MT([], n, !0), s, !0)
		}
		if (e.keychain === "all" || e.keychain === "current") {
			var o = (0, hue.spawnSync)("/usr/bin/security", r)
				.stdout.toString()
				.split(t)
				.map(function (c) {
					return c.trim()
				})
			n = MT(MT([], n, !0), o, !0)
		}
		if (e.unique || e.excludeBundled) {
			var a = n.map(function (c) {
					return (0, qd.convert)(c, qd.Format.fingerprint)
				}),
				l = e.excludeBundled
					? het.rootCertificates.map(function (c) {
							return (0, qd.convert)(c, qd.Format.fingerprint)
						})
					: []
			n = n.filter(function (c, u) {
				var f = a[u]
				return !((e.unique && u !== a.indexOf(f)) || (e.excludeBundled && l.includes(f)))
			})
		}
		return n.map(function (c) {
			return (0, qd.convert)(c, e.format)
		})
	}
	Wo.get = mue
	var FT = Aue.options.ca,
		get = function (e) {
			if ((e === void 0 && (e = QT), !!pue)) {
				var t
				Array.isArray(FT) ? (t = Array.from(FT)) : (t = typeof FT < "u" ? [FT] : []),
					mue(vh(vh(vh({}, QT), e), { format: qd.Format.pem, excludeBundled: !1 })).forEach(function (r) {
						return t.push(r)
					}),
					(Aue.options.ca = t),
					(c3.Agent = (function (r) {
						return function (n) {
							var i = typeof n < "u" ? vh({}, n) : {}
							return typeof i.ca > "u" && (i.ca = t), r.call(this, i)
						}
					})(c3.Agent)),
					(0, gue.setGlobalDispatcher)(new gue.Agent({ connect: { ca: t } }))
			}
		}
	Wo.addToGlobalAgent = get
})
var _ue = x((LBt, xue) => {
	"use strict"
	function yet(e, t) {
		for (var r = -1, n = e == null ? 0 : e.length; ++r < n && t(e[r], r, e) !== !1; );
		return e
	}
	xue.exports = yet
})
var Iue = x((UBt, wue) => {
	"use strict"
	var Cet = Wf(),
		vet = (function () {
			try {
				var e = Cet(Object, "defineProperty")
				return e({}, "", {}), e
			} catch {}
		})()
	wue.exports = vet
})
var h3 = x((OBt, Bue) => {
	"use strict"
	var Sue = Iue()
	function Eet(e, t, r) {
		t == "__proto__" && Sue ? Sue(e, t, { configurable: !0, enumerable: !0, value: r, writable: !0 }) : (e[t] = r)
	}
	Bue.exports = Eet
})
var g3 = x((qBt, Due) => {
	"use strict"
	var bet = h3(),
		xet = zS(),
		_et = Object.prototype,
		wet = _et.hasOwnProperty
	function Iet(e, t, r) {
		var n = e[t]
		;(!(wet.call(e, t) && xet(n, r)) || (r === void 0 && !(t in e))) && bet(e, t, r)
	}
	Due.exports = Iet
})
var qb = x((VBt, Tue) => {
	"use strict"
	var Bet = g3(),
		Det = h3()
	function Tet(e, t, r, n) {
		var i = !r
		r || (r = {})
		for (var s = -1, o = t.length; ++s < o; ) {
			var a = t[s],
				l = n ? n(r[a], e[a], a, r, e) : void 0
			l === void 0 && (l = e[a]), i ? Det(r, a, l) : Bet(r, a, l)
		}
		return r
	}
	Tue.exports = Tet
})
var kue = x((HBt, Rue) => {
	"use strict"
	var Ret = qb(),
		ket = iB()
	function Met(e, t) {
		return e && Ret(t, ket(t), e)
	}
	Rue.exports = Met
})
var Fue = x((WBt, Mue) => {
	"use strict"
	function Fet(e) {
		var t = []
		if (e != null) for (var r in Object(e)) t.push(r)
		return t
	}
	Mue.exports = Fet
})
var Nue = x((GBt, Que) => {
	"use strict"
	var Qet = gd(),
		Net = nB(),
		Pet = Fue(),
		Let = Object.prototype,
		Uet = Let.hasOwnProperty
	function Oet(e) {
		if (!Qet(e)) return Pet(e)
		var t = Net(e),
			r = []
		for (var n in e) (n == "constructor" && (t || !Uet.call(e, n))) || r.push(n)
		return r
	}
	Que.exports = Oet
})
var UT = x(($Bt, Pue) => {
	"use strict"
	var qet = kU(),
		Vet = Nue(),
		Het = FU()
	function Wet(e) {
		return Het(e) ? qet(e, !0) : Vet(e)
	}
	Pue.exports = Wet
})
var Uue = x((YBt, Lue) => {
	"use strict"
	var Get = qb(),
		$et = UT()
	function Yet(e, t) {
		return e && Get(t, $et(t), e)
	}
	Lue.exports = Yet
})
var Wue = x((Vb, X0) => {
	"use strict"
	var Ket = Ka(),
		Hue = typeof Vb == "object" && Vb && !Vb.nodeType && Vb,
		Oue = Hue && typeof X0 == "object" && X0 && !X0.nodeType && X0,
		Jet = Oue && Oue.exports === Hue,
		que = Jet ? Ket.Buffer : void 0,
		Vue = que ? que.allocUnsafe : void 0
	function zet(e, t) {
		if (t) return e.slice()
		var r = e.length,
			n = Vue ? Vue(r) : new e.constructor(r)
		return e.copy(n), n
	}
	X0.exports = zet
})
var $ue = x((KBt, Gue) => {
	"use strict"
	function jet(e, t) {
		var r = -1,
			n = e.length
		for (t || (t = Array(n)); ++r < n; ) t[r] = e[r]
		return t
	}
	Gue.exports = jet
})
var Kue = x((JBt, Yue) => {
	"use strict"
	var Zet = qb(),
		Xet = XS()
	function ett(e, t) {
		return Zet(e, Xet(e), t)
	}
	Yue.exports = ett
})
var p3 = x((zBt, Jue) => {
	"use strict"
	var ttt = MU(),
		rtt = ttt(Object.getPrototypeOf, Object)
	Jue.exports = rtt
})
var A3 = x((jBt, zue) => {
	"use strict"
	var ntt = IU(),
		itt = p3(),
		stt = XS(),
		ott = BU(),
		att = Object.getOwnPropertySymbols,
		ltt = att
			? function (e) {
					for (var t = []; e; ) ntt(t, stt(e)), (e = itt(e))
					return t
				}
			: ott
	zue.exports = ltt
})
var Zue = x((ZBt, jue) => {
	"use strict"
	var ctt = qb(),
		utt = A3()
	function dtt(e, t) {
		return ctt(e, utt(e), t)
	}
	jue.exports = dtt
})
var ede = x((XBt, Xue) => {
	"use strict"
	var ftt = SU(),
		htt = A3(),
		gtt = UT()
	function ptt(e) {
		return ftt(e, gtt, htt)
	}
	Xue.exports = ptt
})
var rde = x((eDt, tde) => {
	"use strict"
	var Att = Object.prototype,
		mtt = Att.hasOwnProperty
	function ytt(e) {
		var t = e.length,
			r = new e.constructor(t)
		return t && typeof e[0] == "string" && mtt.call(e, "index") && ((r.index = e.index), (r.input = e.input)), r
	}
	tde.exports = ytt
})
var OT = x((tDt, ide) => {
	"use strict"
	var nde = _U()
	function Ctt(e) {
		var t = new e.constructor(e.byteLength)
		return new nde(t).set(new nde(e)), t
	}
	ide.exports = Ctt
})
var ode = x((rDt, sde) => {
	"use strict"
	var vtt = OT()
	function Ett(e, t) {
		var r = t ? vtt(e.buffer) : e.buffer
		return new e.constructor(r, e.byteOffset, e.byteLength)
	}
	sde.exports = Ett
})
var lde = x((nDt, ade) => {
	"use strict"
	var btt = /\w*$/
	function xtt(e) {
		var t = new e.constructor(e.source, btt.exec(e))
		return (t.lastIndex = e.lastIndex), t
	}
	ade.exports = xtt
})
var hde = x((iDt, fde) => {
	"use strict"
	var cde = Iv(),
		ude = cde ? cde.prototype : void 0,
		dde = ude ? ude.valueOf : void 0
	function _tt(e) {
		return dde ? Object(dde.call(e)) : {}
	}
	fde.exports = _tt
})
var pde = x((sDt, gde) => {
	"use strict"
	var wtt = OT()
	function Itt(e, t) {
		var r = t ? wtt(e.buffer) : e.buffer
		return new e.constructor(r, e.byteOffset, e.length)
	}
	gde.exports = Itt
})
var mde = x((oDt, Ade) => {
	"use strict"
	var Stt = OT(),
		Btt = ode(),
		Dtt = lde(),
		Ttt = hde(),
		Rtt = pde(),
		ktt = "[object Boolean]",
		Mtt = "[object Date]",
		Ftt = "[object Map]",
		Qtt = "[object Number]",
		Ntt = "[object RegExp]",
		Ptt = "[object Set]",
		Ltt = "[object String]",
		Utt = "[object Symbol]",
		Ott = "[object ArrayBuffer]",
		qtt = "[object DataView]",
		Vtt = "[object Float32Array]",
		Htt = "[object Float64Array]",
		Wtt = "[object Int8Array]",
		Gtt = "[object Int16Array]",
		$tt = "[object Int32Array]",
		Ytt = "[object Uint8Array]",
		Ktt = "[object Uint8ClampedArray]",
		Jtt = "[object Uint16Array]",
		ztt = "[object Uint32Array]"
	function jtt(e, t, r) {
		var n = e.constructor
		switch (t) {
			case Ott:
				return Stt(e)
			case ktt:
			case Mtt:
				return new n(+e)
			case qtt:
				return Btt(e, r)
			case Vtt:
			case Htt:
			case Wtt:
			case Gtt:
			case $tt:
			case Ytt:
			case Ktt:
			case Jtt:
			case ztt:
				return Rtt(e, r)
			case Ftt:
				return new n()
			case Qtt:
			case Ltt:
				return new n(e)
			case Ntt:
				return Dtt(e)
			case Ptt:
				return new n()
			case Utt:
				return Ttt(e)
		}
	}
	Ade.exports = jtt
})
var vde = x((aDt, Cde) => {
	"use strict"
	var Ztt = gd(),
		yde = Object.create,
		Xtt = (function () {
			function e() {}
			return function (t) {
				if (!Ztt(t)) return {}
				if (yde) return yde(t)
				e.prototype = t
				var r = new e()
				return (e.prototype = void 0), r
			}
		})()
	Cde.exports = Xtt
})
var bde = x((lDt, Ede) => {
	"use strict"
	var ert = vde(),
		trt = p3(),
		rrt = nB()
	function nrt(e) {
		return typeof e.constructor == "function" && !rrt(e) ? ert(trt(e)) : {}
	}
	Ede.exports = nrt
})
var _de = x((cDt, xde) => {
	"use strict"
	var irt = bE(),
		srt = Tf(),
		ort = "[object Map]"
	function art(e) {
		return srt(e) && irt(e) == ort
	}
	xde.exports = art
})
var Bde = x((uDt, Sde) => {
	"use strict"
	var lrt = _de(),
		crt = tB(),
		wde = rB(),
		Ide = wde && wde.isMap,
		urt = Ide ? crt(Ide) : lrt
	Sde.exports = urt
})
var Tde = x((dDt, Dde) => {
	"use strict"
	var drt = bE(),
		frt = Tf(),
		hrt = "[object Set]"
	function grt(e) {
		return frt(e) && drt(e) == hrt
	}
	Dde.exports = grt
})
var Fde = x((fDt, Mde) => {
	"use strict"
	var prt = Tde(),
		Art = tB(),
		Rde = rB(),
		kde = Rde && Rde.isSet,
		mrt = kde ? Art(kde) : prt
	Mde.exports = mrt
})
var Ude = x((hDt, Lde) => {
	"use strict"
	var yrt = bU(),
		Crt = _ue(),
		vrt = g3(),
		Ert = kue(),
		brt = Uue(),
		xrt = Wue(),
		_rt = $ue(),
		wrt = Kue(),
		Irt = Zue(),
		Srt = QU(),
		Brt = ede(),
		Drt = bE(),
		Trt = rde(),
		Rrt = mde(),
		krt = bde(),
		Mrt = yE(),
		Frt = eB(),
		Qrt = Bde(),
		Nrt = gd(),
		Prt = Fde(),
		Lrt = iB(),
		Urt = UT(),
		Ort = 1,
		qrt = 2,
		Vrt = 4,
		Qde = "[object Arguments]",
		Hrt = "[object Array]",
		Wrt = "[object Boolean]",
		Grt = "[object Date]",
		$rt = "[object Error]",
		Nde = "[object Function]",
		Yrt = "[object GeneratorFunction]",
		Krt = "[object Map]",
		Jrt = "[object Number]",
		Pde = "[object Object]",
		zrt = "[object RegExp]",
		jrt = "[object Set]",
		Zrt = "[object String]",
		Xrt = "[object Symbol]",
		ent = "[object WeakMap]",
		tnt = "[object ArrayBuffer]",
		rnt = "[object DataView]",
		nnt = "[object Float32Array]",
		int = "[object Float64Array]",
		snt = "[object Int8Array]",
		ont = "[object Int16Array]",
		ant = "[object Int32Array]",
		lnt = "[object Uint8Array]",
		cnt = "[object Uint8ClampedArray]",
		unt = "[object Uint16Array]",
		dnt = "[object Uint32Array]",
		pn = {}
	pn[Qde] =
		pn[Hrt] =
		pn[tnt] =
		pn[rnt] =
		pn[Wrt] =
		pn[Grt] =
		pn[nnt] =
		pn[int] =
		pn[snt] =
		pn[ont] =
		pn[ant] =
		pn[Krt] =
		pn[Jrt] =
		pn[Pde] =
		pn[zrt] =
		pn[jrt] =
		pn[Zrt] =
		pn[Xrt] =
		pn[lnt] =
		pn[cnt] =
		pn[unt] =
		pn[dnt] =
			!0
	pn[$rt] = pn[Nde] = pn[ent] = !1
	function qT(e, t, r, n, i, s) {
		var o,
			a = t & Ort,
			l = t & qrt,
			c = t & Vrt
		if ((r && (o = i ? r(e, n, i, s) : r(e)), o !== void 0)) return o
		if (!Nrt(e)) return e
		var u = Mrt(e)
		if (u) {
			if (((o = Trt(e)), !a)) return _rt(e, o)
		} else {
			var f = Drt(e),
				p = f == Nde || f == Yrt
			if (Frt(e)) return xrt(e, a)
			if (f == Pde || f == Qde || (p && !i)) {
				if (((o = l || p ? {} : krt(e)), !a)) return l ? Irt(e, brt(o, e)) : wrt(e, Ert(o, e))
			} else {
				if (!pn[f]) return i ? e : {}
				o = Rrt(e, f, a)
			}
		}
		s || (s = new yrt())
		var g = s.get(e)
		if (g) return g
		s.set(e, o),
			Prt(e)
				? e.forEach(function (C) {
						o.add(qT(C, t, r, C, e, s))
					})
				: Qrt(e) &&
					e.forEach(function (C, v) {
						o.set(v, qT(C, t, r, v, e, s))
					})
		var m = c ? (l ? Brt : Srt) : l ? Urt : Lrt,
			y = u ? void 0 : m(e)
		return (
			Crt(y || e, function (C, v) {
				y && ((v = C), (C = e[v])), vrt(o, v, qT(C, t, r, v, e, s))
			}),
			o
		)
	}
	Lde.exports = qT
})
var qde = x((gDt, Ode) => {
	"use strict"
	var fnt = Ude(),
		hnt = 1,
		gnt = 4
	function pnt(e) {
		return fnt(e, hnt | gnt)
	}
	Ode.exports = pnt
})
var Go = x((pDt, Vde) => {
	"use strict"
	var m3 = class e extends Error {
		constructor(t) {
			super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${
				t.toString().split(`
`)[0]
			}
`),
				Error.captureStackTrace(this, e)
		}
	}
	Vde.exports = (e) => {
		if (e.length > 2) throw new m3(e)
		function t(n = {}) {
			this.options = n
		}
		t.prototype.transform = e
		function r(n) {
			return new t(n)
		}
		return (r.Format = t), r
	}
})
var $de = x((ADt, Gde) => {
	"use strict"
	var Wde = {}
	Gde.exports = Wde
	var Hde = {
		reset: [0, 0],
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		gray: [90, 39],
		grey: [90, 39],
		brightRed: [91, 39],
		brightGreen: [92, 39],
		brightYellow: [93, 39],
		brightBlue: [94, 39],
		brightMagenta: [95, 39],
		brightCyan: [96, 39],
		brightWhite: [97, 39],
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		bgGray: [100, 49],
		bgGrey: [100, 49],
		bgBrightRed: [101, 49],
		bgBrightGreen: [102, 49],
		bgBrightYellow: [103, 49],
		bgBrightBlue: [104, 49],
		bgBrightMagenta: [105, 49],
		bgBrightCyan: [106, 49],
		bgBrightWhite: [107, 49],
		blackBG: [40, 49],
		redBG: [41, 49],
		greenBG: [42, 49],
		yellowBG: [43, 49],
		blueBG: [44, 49],
		magentaBG: [45, 49],
		cyanBG: [46, 49],
		whiteBG: [47, 49],
	}
	Object.keys(Hde).forEach(function (e) {
		var t = Hde[e],
			r = (Wde[e] = [])
		;(r.open = "\x1B[" + t[0] + "m"), (r.close = "\x1B[" + t[1] + "m")
	})
})
var Kde = x((mDt, Yde) => {
	"use strict"
	Yde.exports = function (e, t) {
		t = t || process.argv || []
		var r = t.indexOf("--"),
			n = /^-{1,2}/.test(e) ? "" : "--",
			i = t.indexOf(n + e)
		return i !== -1 && (r === -1 ? !0 : i < r)
	}
})
var zde = x((yDt, Jde) => {
	"use strict"
	var Ant = require("os"),
		Ac = Kde(),
		co = process.env,
		ey = void 0
	Ac("no-color") || Ac("no-colors") || Ac("color=false")
		? (ey = !1)
		: (Ac("color") || Ac("colors") || Ac("color=true") || Ac("color=always")) && (ey = !0)
	"FORCE_COLOR" in co && (ey = co.FORCE_COLOR.length === 0 || parseInt(co.FORCE_COLOR, 10) !== 0)
	function mnt(e) {
		return e === 0 ? !1 : { level: e, hasBasic: !0, has256: e >= 2, has16m: e >= 3 }
	}
	function ynt(e) {
		if (ey === !1) return 0
		if (Ac("color=16m") || Ac("color=full") || Ac("color=truecolor")) return 3
		if (Ac("color=256")) return 2
		if (e && !e.isTTY && ey !== !0) return 0
		var t = ey ? 1 : 0
		if (process.platform === "win32") {
			var r = Ant.release().split(".")
			return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586
				? Number(r[2]) >= 14931
					? 3
					: 2
				: 1
		}
		if ("CI" in co)
			return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function (i) {
				return i in co
			}) || co.CI_NAME === "codeship"
				? 1
				: t
		if ("TEAMCITY_VERSION" in co) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(co.TEAMCITY_VERSION) ? 1 : 0
		if ("TERM_PROGRAM" in co) {
			var n = parseInt((co.TERM_PROGRAM_VERSION || "").split(".")[0], 10)
			switch (co.TERM_PROGRAM) {
				case "iTerm.app":
					return n >= 3 ? 3 : 2
				case "Hyper":
					return 3
				case "Apple_Terminal":
					return 2
			}
		}
		return /-256(color)?$/i.test(co.TERM)
			? 2
			: /^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(co.TERM) || "COLORTERM" in co
				? 1
				: (co.TERM === "dumb", t)
	}
	function y3(e) {
		var t = ynt(e)
		return mnt(t)
	}
	Jde.exports = {
		supportsColor: y3,
		stdout: y3(process.stdout),
		stderr: y3(process.stderr),
	}
})
var Zde = x((CDt, jde) => {
	"use strict"
	jde.exports = function (t, r) {
		var n = ""
		;(t = t || "Run the trap, drop the bass"), (t = t.split(""))
		var i = {
			a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
			b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
			c: ["\xA9", "\u023B", "\u03FE"],
			d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
			e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"],
			f: ["\u04FA"],
			g: ["\u0262"],
			h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
			i: ["\u0F0F"],
			j: ["\u0134"],
			k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
			l: ["\u0139"],
			m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
			n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
			o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"],
			p: ["\u01F7", "\u048E"],
			q: ["\u09CD"],
			r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
			s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
			t: ["\u0141", "\u0166", "\u0373"],
			u: ["\u01B1", "\u054D"],
			v: ["\u05D8"],
			w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
			x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
			y: ["\xA5", "\u04B0", "\u04CB"],
			z: ["\u01B5", "\u0240"],
		}
		return (
			t.forEach(function (s) {
				s = s.toLowerCase()
				var o = i[s] || [" "],
					a = Math.floor(Math.random() * o.length)
				typeof i[s] < "u" ? (n += i[s][a]) : (n += s)
			}),
			n
		)
	}
})
var efe = x((vDt, Xde) => {
	"use strict"
	Xde.exports = function (t, r) {
		t = t || "   he is here   "
		var n = {
				up: [
					"\u030D",
					"\u030E",
					"\u0304",
					"\u0305",
					"\u033F",
					"\u0311",
					"\u0306",
					"\u0310",
					"\u0352",
					"\u0357",
					"\u0351",
					"\u0307",
					"\u0308",
					"\u030A",
					"\u0342",
					"\u0313",
					"\u0308",
					"\u034A",
					"\u034B",
					"\u034C",
					"\u0303",
					"\u0302",
					"\u030C",
					"\u0350",
					"\u0300",
					"\u0301",
					"\u030B",
					"\u030F",
					"\u0312",
					"\u0313",
					"\u0314",
					"\u033D",
					"\u0309",
					"\u0363",
					"\u0364",
					"\u0365",
					"\u0366",
					"\u0367",
					"\u0368",
					"\u0369",
					"\u036A",
					"\u036B",
					"\u036C",
					"\u036D",
					"\u036E",
					"\u036F",
					"\u033E",
					"\u035B",
					"\u0346",
					"\u031A",
				],
				down: [
					"\u0316",
					"\u0317",
					"\u0318",
					"\u0319",
					"\u031C",
					"\u031D",
					"\u031E",
					"\u031F",
					"\u0320",
					"\u0324",
					"\u0325",
					"\u0326",
					"\u0329",
					"\u032A",
					"\u032B",
					"\u032C",
					"\u032D",
					"\u032E",
					"\u032F",
					"\u0330",
					"\u0331",
					"\u0332",
					"\u0333",
					"\u0339",
					"\u033A",
					"\u033B",
					"\u033C",
					"\u0345",
					"\u0347",
					"\u0348",
					"\u0349",
					"\u034D",
					"\u034E",
					"\u0353",
					"\u0354",
					"\u0355",
					"\u0356",
					"\u0359",
					"\u035A",
					"\u0323",
				],
				mid: [
					"\u0315",
					"\u031B",
					"\u0300",
					"\u0301",
					"\u0358",
					"\u0321",
					"\u0322",
					"\u0327",
					"\u0328",
					"\u0334",
					"\u0335",
					"\u0336",
					"\u035C",
					"\u035D",
					"\u035E",
					"\u035F",
					"\u0360",
					"\u0362",
					"\u0338",
					"\u0337",
					"\u0361",
					" \u0489",
				],
			},
			i = [].concat(n.up, n.down, n.mid)
		function s(l) {
			var c = Math.floor(Math.random() * l)
			return c
		}
		function o(l) {
			var c = !1
			return (
				i.filter(function (u) {
					c = u === l
				}),
				c
			)
		}
		function a(l, c) {
			var u = "",
				f,
				p
			;(c = c || {}),
				(c.up = typeof c.up < "u" ? c.up : !0),
				(c.mid = typeof c.mid < "u" ? c.mid : !0),
				(c.down = typeof c.down < "u" ? c.down : !0),
				(c.size = typeof c.size < "u" ? c.size : "maxi"),
				(l = l.split(""))
			for (p in l)
				if (!o(p)) {
					switch (((u = u + l[p]), (f = { up: 0, down: 0, mid: 0 }), c.size)) {
						case "mini":
							;(f.up = s(8)), (f.mid = s(2)), (f.down = s(8))
							break
						case "maxi":
							;(f.up = s(16) + 3), (f.mid = s(4) + 1), (f.down = s(64) + 3)
							break
						default:
							;(f.up = s(8) + 1), (f.mid = s(6) / 2), (f.down = s(8) + 1)
							break
					}
					var g = ["up", "mid", "down"]
					for (var m in g) for (var y = g[m], C = 0; C <= f[y]; C++) c[y] && (u = u + n[y][s(n[y].length)])
				}
			return u
		}
		return a(t, r)
	}
})
var rfe = x((EDt, tfe) => {
	"use strict"
	tfe.exports = function (e) {
		return function (t, r, n) {
			if (t === " ") return t
			switch (r % 3) {
				case 0:
					return e.red(t)
				case 1:
					return e.white(t)
				case 2:
					return e.blue(t)
			}
		}
	}
})
var ife = x((bDt, nfe) => {
	"use strict"
	nfe.exports = function (e) {
		return function (t, r, n) {
			return r % 2 === 0 ? t : e.inverse(t)
		}
	}
})
var ofe = x((xDt, sfe) => {
	"use strict"
	sfe.exports = function (e) {
		var t = ["red", "yellow", "green", "blue", "magenta"]
		return function (r, n, i) {
			return r === " " ? r : e[t[n++ % t.length]](r)
		}
	}
})
var lfe = x((_Dt, afe) => {
	"use strict"
	afe.exports = function (e) {
		var t = [
			"underline",
			"inverse",
			"grey",
			"yellow",
			"red",
			"green",
			"blue",
			"white",
			"cyan",
			"magenta",
			"brightYellow",
			"brightRed",
			"brightGreen",
			"brightBlue",
			"brightWhite",
			"brightCyan",
			"brightMagenta",
		]
		return function (r, n, i) {
			return r === " " ? r : e[t[Math.round(Math.random() * (t.length - 2))]](r)
		}
	}
})
var gfe = x((IDt, hfe) => {
	"use strict"
	var lr = {}
	hfe.exports = lr
	lr.themes = {}
	var Cnt = require("util"),
		Mp = (lr.styles = $de()),
		ufe = Object.defineProperties,
		vnt = new RegExp(/[\r\n]+/g)
	lr.supportsColor = zde().supportsColor
	typeof lr.enabled > "u" && (lr.enabled = lr.supportsColor() !== !1)
	lr.enable = function () {
		lr.enabled = !0
	}
	lr.disable = function () {
		lr.enabled = !1
	}
	lr.stripColors = lr.strip = function (e) {
		return ("" + e).replace(/\x1B\[\d+m/g, "")
	}
	var wDt = (lr.stylize = function (t, r) {
			if (!lr.enabled) return t + ""
			var n = Mp[r]
			return !n && r in lr ? lr[r](t) : n.open + t + n.close
		}),
		Ent = /[|\\{}()[\]^$+*?.]/g,
		bnt = function (e) {
			if (typeof e != "string") throw new TypeError("Expected a string")
			return e.replace(Ent, "\\$&")
		}
	function dfe(e) {
		var t = function r() {
			return _nt.apply(r, arguments)
		}
		return (t._styles = e), (t.__proto__ = xnt), t
	}
	var ffe = (function () {
			var e = {}
			return (
				(Mp.grey = Mp.gray),
				Object.keys(Mp).forEach(function (t) {
					;(Mp[t].closeRe = new RegExp(bnt(Mp[t].close), "g")),
						(e[t] = {
							get: function () {
								return dfe(this._styles.concat(t))
							},
						})
				}),
				e
			)
		})(),
		xnt = ufe(function () {}, ffe)
	function _nt() {
		var e = Array.prototype.slice.call(arguments),
			t = e
				.map(function (o) {
					return o != null && o.constructor === String ? o : Cnt.inspect(o)
				})
				.join(" ")
		if (!lr.enabled || !t) return t
		for (
			var r =
					t.indexOf(`
`) != -1,
				n = this._styles,
				i = n.length;
			i--;

		) {
			var s = Mp[n[i]]
			;(t = s.open + t.replace(s.closeRe, s.open) + s.close),
				r &&
					(t = t.replace(vnt, function (o) {
						return s.close + o + s.open
					}))
		}
		return t
	}
	lr.setTheme = function (e) {
		if (typeof e == "string") {
			console.log(
				"colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));",
			)
			return
		}
		for (var t in e)
			(function (r) {
				lr[r] = function (n) {
					if (typeof e[r] == "object") {
						var i = n
						for (var s in e[r]) i = lr[e[r][s]](i)
						return i
					}
					return lr[e[r]](n)
				}
			})(t)
	}
	function wnt() {
		var e = {}
		return (
			Object.keys(ffe).forEach(function (t) {
				e[t] = {
					get: function () {
						return dfe([t])
					},
				}
			}),
			e
		)
	}
	var Int = function (t, r) {
		var n = r.split("")
		return (n = n.map(t)), n.join("")
	}
	lr.trap = Zde()
	lr.zalgo = efe()
	lr.maps = {}
	lr.maps.america = rfe()(lr)
	lr.maps.zebra = ife()(lr)
	lr.maps.rainbow = ofe()(lr)
	lr.maps.random = lfe()(lr)
	for (cfe in lr.maps)
		(function (e) {
			lr[e] = function (t) {
				return Int(lr.maps[e], t)
			}
		})(cfe)
	var cfe
	ufe(lr, wnt())
})
var C3 = x((SDt, pfe) => {
	"use strict"
	var Snt = gfe()
	pfe.exports = Snt
})
var Afe = x((v3) => {
	"use strict"
	v3.levels = {
		error: 0,
		warn: 1,
		help: 2,
		data: 3,
		info: 4,
		debug: 5,
		prompt: 6,
		verbose: 7,
		input: 8,
		silly: 9,
	}
	v3.colors = {
		error: "red",
		warn: "yellow",
		help: "cyan",
		data: "grey",
		info: "green",
		debug: "blue",
		prompt: "grey",
		verbose: "cyan",
		input: "grey",
		silly: "magenta",
	}
})
var mfe = x((E3) => {
	"use strict"
	E3.levels = {
		error: 0,
		warn: 1,
		info: 2,
		http: 3,
		verbose: 4,
		debug: 5,
		silly: 6,
	}
	E3.colors = {
		error: "red",
		warn: "yellow",
		info: "green",
		http: "green",
		verbose: "cyan",
		debug: "blue",
		silly: "magenta",
	}
})
var yfe = x((b3) => {
	"use strict"
	b3.levels = {
		emerg: 0,
		alert: 1,
		crit: 2,
		error: 3,
		warning: 4,
		notice: 5,
		info: 6,
		debug: 7,
	}
	b3.colors = {
		emerg: "red",
		alert: "yellow",
		crit: "red",
		error: "red",
		warning: "red",
		notice: "yellow",
		info: "green",
		debug: "blue",
	}
})
var Cfe = x((VT) => {
	"use strict"
	Object.defineProperty(VT, "cli", { value: Afe() })
	Object.defineProperty(VT, "npm", { value: mfe() })
	Object.defineProperty(VT, "syslog", { value: yfe() })
})
var Bi = x((Hb) => {
	"use strict"
	Object.defineProperty(Hb, "LEVEL", { value: Symbol.for("level") })
	Object.defineProperty(Hb, "MESSAGE", { value: Symbol.for("message") })
	Object.defineProperty(Hb, "SPLAT", { value: Symbol.for("splat") })
	Object.defineProperty(Hb, "configs", { value: Cfe() })
})
var GT = x((MDt, WT) => {
	"use strict"
	var w3 = C3(),
		{ LEVEL: x3, MESSAGE: _3 } = Bi()
	w3.enabled = !0
	var vfe = /\s+/,
		HT = class e {
			constructor(t = {}) {
				t.colors && this.addColors(t.colors), (this.options = t)
			}
			static addColors(t) {
				let r = Object.keys(t).reduce((n, i) => ((n[i] = vfe.test(t[i]) ? t[i].split(vfe) : t[i]), n), {})
				return (e.allColors = Object.assign({}, e.allColors || {}, r)), e.allColors
			}
			addColors(t) {
				return e.addColors(t)
			}
			colorize(t, r, n) {
				if ((typeof n > "u" && (n = r), !Array.isArray(e.allColors[t]))) return w3[e.allColors[t]](n)
				for (let i = 0, s = e.allColors[t].length; i < s; i++) n = w3[e.allColors[t][i]](n)
				return n
			}
			transform(t, r) {
				return (
					r.all && typeof t[_3] == "string" && (t[_3] = this.colorize(t[x3], t.level, t[_3])),
					(r.level || r.all || !r.message) && (t.level = this.colorize(t[x3], t.level)),
					(r.all || r.message) && (t.message = this.colorize(t[x3], t.level, t.message)),
					t
				)
			}
		}
	WT.exports = (e) => new HT(e)
	WT.exports.Colorizer = WT.exports.Format = HT
})
var bfe = x((FDt, Efe) => {
	"use strict"
	var { Colorizer: Bnt } = GT()
	Efe.exports = (e) => (Bnt.addColors(e.colors || e), e)
})
var _fe = x((QDt, xfe) => {
	"use strict"
	var Dnt = Go()
	xfe.exports = Dnt((e) => ((e.message = `	${e.message}`), e))
})
var Sfe = x((NDt, Ife) => {
	"use strict"
	var Tnt = Go(),
		{ LEVEL: wfe, MESSAGE: I3 } = Bi()
	Ife.exports = Tnt((e, { stack: t, cause: r }) => {
		if (e instanceof Error) {
			let i = Object.assign({}, e, {
				level: e.level,
				[wfe]: e[wfe] || e.level,
				message: e.message,
				[I3]: e[I3] || e.message,
			})
			return t && (i.stack = e.stack), r && (i.cause = e.cause), i
		}
		if (!(e.message instanceof Error)) return e
		let n = e.message
		return (
			Object.assign(e, n),
			(e.message = n.message),
			(e[I3] = n.message),
			t && (e.stack = n.stack),
			r && (e.cause = n.cause),
			e
		)
	})
})
var B3 = x((PDt, YT) => {
	"use strict"
	var { configs: Rnt, LEVEL: Bfe, MESSAGE: S3 } = Bi(),
		$T = class e {
			constructor(t = { levels: Rnt.npm.levels }) {
				;(this.paddings = e.paddingForLevels(t.levels, t.filler)), (this.options = t)
			}
			static getLongestLevel(t) {
				let r = Object.keys(t).map((n) => n.length)
				return Math.max(...r)
			}
			static paddingForLevel(t, r, n) {
				let i = n + 1 - t.length,
					s = Math.floor(i / r.length)
				return `${r}${r.repeat(s)}`.slice(0, i)
			}
			static paddingForLevels(t, r = " ") {
				let n = e.getLongestLevel(t)
				return Object.keys(t).reduce((i, s) => ((i[s] = e.paddingForLevel(s, r, n)), i), {})
			}
			transform(t, r) {
				return (
					(t.message = `${this.paddings[t[Bfe]]}${t.message}`),
					t[S3] && (t[S3] = `${this.paddings[t[Bfe]]}${t[S3]}`),
					t
				)
			}
		}
	YT.exports = (e) => new $T(e)
	YT.exports.Padder = YT.exports.Format = $T
})
var Dfe = x((LDt, D3) => {
	"use strict"
	var { Colorizer: knt } = GT(),
		{ Padder: Mnt } = B3(),
		{ configs: Fnt, MESSAGE: Qnt } = Bi(),
		KT = class {
			constructor(t = {}) {
				t.levels || (t.levels = Fnt.cli.levels),
					(this.colorizer = new knt(t)),
					(this.padder = new Mnt(t)),
					(this.options = t)
			}
			transform(t, r) {
				return this.colorizer.transform(this.padder.transform(t, r), r), (t[Qnt] = `${t.level}:${t.message}`), t
			}
		}
	D3.exports = (e) => new KT(e)
	D3.exports.Format = KT
})
var Rfe = x((UDt, T3) => {
	"use strict"
	var Nnt = Go()
	function Tfe(e) {
		if (e.every(Pnt))
			return (t) => {
				let r = t
				for (let n = 0; n < e.length; n++) if (((r = e[n].transform(r, e[n].options)), !r)) return !1
				return r
			}
	}
	function Pnt(e) {
		if (typeof e.transform != "function")
			throw new Error(
				[
					"No transform function found on format. Did you create a format instance?",
					"const myFormat = format(formatFn);",
					"const instance = myFormat();",
				].join(`
`),
			)
		return !0
	}
	T3.exports = (...e) => {
		let t = Nnt(Tfe(e)),
			r = t()
		return (r.Format = t.Format), r
	}
	T3.exports.cascade = Tfe
})
var Wb = x((F3, Qfe) => {
	"use strict"
	var { hasOwnProperty: JT } = Object.prototype,
		Qp = M3()
	Qp.configure = M3
	Qp.stringify = Qp
	Qp.default = Qp
	F3.stringify = Qp
	F3.configure = M3
	Qfe.exports = Qp
	var Lnt =
		/[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/
	function xh(e) {
		return e.length < 5e3 && !Lnt.test(e) ? `"${e}"` : JSON.stringify(e)
	}
	function R3(e) {
		if (e.length > 200) return e.sort()
		for (let t = 1; t < e.length; t++) {
			let r = e[t],
				n = t
			for (; n !== 0 && e[n - 1] > r; ) (e[n] = e[n - 1]), n--
			e[n] = r
		}
		return e
	}
	var Unt = Object.getOwnPropertyDescriptor(
		Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())),
		Symbol.toStringTag,
	).get
	function k3(e) {
		return Unt.call(e) !== void 0 && e.length !== 0
	}
	function kfe(e, t, r) {
		e.length < r && (r = e.length)
		let n = t === "," ? "" : " ",
			i = `"0":${n}${e[0]}`
		for (let s = 1; s < r; s++) i += `${t}"${s}":${n}${e[s]}`
		return i
	}
	function Ont(e) {
		if (JT.call(e, "circularValue")) {
			let t = e.circularValue
			if (typeof t == "string") return `"${t}"`
			if (t == null) return t
			if (t === Error || t === TypeError)
				return {
					toString() {
						throw new TypeError("Converting circular structure to JSON")
					},
				}
			throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined')
		}
		return '"[Circular]"'
	}
	function Mfe(e, t) {
		let r
		if (JT.call(e, t) && ((r = e[t]), typeof r != "boolean"))
			throw new TypeError(`The "${t}" argument must be of type boolean`)
		return r === void 0 ? !0 : r
	}
	function Ffe(e, t) {
		let r
		if (JT.call(e, t)) {
			if (((r = e[t]), typeof r != "number")) throw new TypeError(`The "${t}" argument must be of type number`)
			if (!Number.isInteger(r)) throw new TypeError(`The "${t}" argument must be an integer`)
			if (r < 1) throw new RangeError(`The "${t}" argument must be >= 1`)
		}
		return r === void 0 ? 1 / 0 : r
	}
	function Fp(e) {
		return e === 1 ? "1 item" : `${e} items`
	}
	function qnt(e) {
		let t = new Set()
		for (let r of e) (typeof r == "string" || typeof r == "number") && t.add(String(r))
		return t
	}
	function Vnt(e) {
		if (JT.call(e, "strict")) {
			let t = e.strict
			if (typeof t != "boolean") throw new TypeError('The "strict" argument must be of type boolean')
			if (t)
				return (r) => {
					let n = `Object can not safely be stringified. Received type ${typeof r}`
					throw (typeof r != "function" && (n += ` (${r.toString()})`), new Error(n))
				}
		}
	}
	function M3(e) {
		e = { ...e }
		let t = Vnt(e)
		t && (e.bigint === void 0 && (e.bigint = !1), "circularValue" in e || (e.circularValue = Error))
		let r = Ont(e),
			n = Mfe(e, "bigint"),
			i = Mfe(e, "deterministic"),
			s = Ffe(e, "maximumDepth"),
			o = Ffe(e, "maximumBreadth")
		function a(p, g, m, y, C, v) {
			let b = g[p]
			switch (
				(typeof b == "object" && b !== null && typeof b.toJSON == "function" && (b = b.toJSON(p)),
				(b = y.call(g, p, b)),
				typeof b)
			) {
				case "string":
					return xh(b)
				case "object": {
					if (b === null) return "null"
					if (m.indexOf(b) !== -1) return r
					let w = "",
						B = ",",
						M = v
					if (Array.isArray(b)) {
						if (b.length === 0) return "[]"
						if (s < m.length + 1) return '"[Array]"'
						m.push(b),
							C !== "" &&
								((v += C),
								(w += `
${v}`),
								(B = `,
${v}`))
						let q = Math.min(b.length, o),
							me = 0
						for (; me < q - 1; me++) {
							let N = a(String(me), b, m, y, C, v)
							;(w += N !== void 0 ? N : "null"), (w += B)
						}
						let Qe = a(String(me), b, m, y, C, v)
						if (((w += Qe !== void 0 ? Qe : "null"), b.length - 1 > o)) {
							let N = b.length - o - 1
							w += `${B}"... ${Fp(N)} not stringified"`
						}
						return (
							C !== "" &&
								(w += `
${M}`),
							m.pop(),
							`[${w}]`
						)
					}
					let Q = Object.keys(b),
						O = Q.length
					if (O === 0) return "{}"
					if (s < m.length + 1) return '"[Object]"'
					let Y = "",
						j = ""
					C !== "" &&
						((v += C),
						(B = `,
${v}`),
						(Y = " "))
					let ne = Math.min(O, o)
					i && !k3(b) && (Q = R3(Q)), m.push(b)
					for (let q = 0; q < ne; q++) {
						let me = Q[q],
							Qe = a(me, b, m, y, C, v)
						Qe !== void 0 && ((w += `${j}${xh(me)}:${Y}${Qe}`), (j = B))
					}
					if (O > o) {
						let q = O - o
						;(w += `${j}"...":${Y}"${Fp(q)} not stringified"`), (j = B)
					}
					return (
						C !== "" &&
							j.length > 1 &&
							(w = `
${v}${w}
${M}`),
						m.pop(),
						`{${w}}`
					)
				}
				case "number":
					return isFinite(b) ? String(b) : t ? t(b) : "null"
				case "boolean":
					return b === !0 ? "true" : "false"
				case "undefined":
					return
				case "bigint":
					if (n) return String(b)
				default:
					return t ? t(b) : void 0
			}
		}
		function l(p, g, m, y, C, v) {
			switch (
				(typeof g == "object" && g !== null && typeof g.toJSON == "function" && (g = g.toJSON(p)), typeof g)
			) {
				case "string":
					return xh(g)
				case "object": {
					if (g === null) return "null"
					if (m.indexOf(g) !== -1) return r
					let b = v,
						w = "",
						B = ","
					if (Array.isArray(g)) {
						if (g.length === 0) return "[]"
						if (s < m.length + 1) return '"[Array]"'
						m.push(g),
							C !== "" &&
								((v += C),
								(w += `
${v}`),
								(B = `,
${v}`))
						let O = Math.min(g.length, o),
							Y = 0
						for (; Y < O - 1; Y++) {
							let ne = l(String(Y), g[Y], m, y, C, v)
							;(w += ne !== void 0 ? ne : "null"), (w += B)
						}
						let j = l(String(Y), g[Y], m, y, C, v)
						if (((w += j !== void 0 ? j : "null"), g.length - 1 > o)) {
							let ne = g.length - o - 1
							w += `${B}"... ${Fp(ne)} not stringified"`
						}
						return (
							C !== "" &&
								(w += `
${b}`),
							m.pop(),
							`[${w}]`
						)
					}
					m.push(g)
					let M = ""
					C !== "" &&
						((v += C),
						(B = `,
${v}`),
						(M = " "))
					let Q = ""
					for (let O of y) {
						let Y = l(O, g[O], m, y, C, v)
						Y !== void 0 && ((w += `${Q}${xh(O)}:${M}${Y}`), (Q = B))
					}
					return (
						C !== "" &&
							Q.length > 1 &&
							(w = `
${v}${w}
${b}`),
						m.pop(),
						`{${w}}`
					)
				}
				case "number":
					return isFinite(g) ? String(g) : t ? t(g) : "null"
				case "boolean":
					return g === !0 ? "true" : "false"
				case "undefined":
					return
				case "bigint":
					if (n) return String(g)
				default:
					return t ? t(g) : void 0
			}
		}
		function c(p, g, m, y, C) {
			switch (typeof g) {
				case "string":
					return xh(g)
				case "object": {
					if (g === null) return "null"
					if (typeof g.toJSON == "function") {
						if (((g = g.toJSON(p)), typeof g != "object")) return c(p, g, m, y, C)
						if (g === null) return "null"
					}
					if (m.indexOf(g) !== -1) return r
					let v = C
					if (Array.isArray(g)) {
						if (g.length === 0) return "[]"
						if (s < m.length + 1) return '"[Array]"'
						m.push(g), (C += y)
						let Y = `
${C}`,
							j = `,
${C}`,
							ne = Math.min(g.length, o),
							q = 0
						for (; q < ne - 1; q++) {
							let Qe = c(String(q), g[q], m, y, C)
							;(Y += Qe !== void 0 ? Qe : "null"), (Y += j)
						}
						let me = c(String(q), g[q], m, y, C)
						if (((Y += me !== void 0 ? me : "null"), g.length - 1 > o)) {
							let Qe = g.length - o - 1
							Y += `${j}"... ${Fp(Qe)} not stringified"`
						}
						return (
							(Y += `
${v}`),
							m.pop(),
							`[${Y}]`
						)
					}
					let b = Object.keys(g),
						w = b.length
					if (w === 0) return "{}"
					if (s < m.length + 1) return '"[Object]"'
					C += y
					let B = `,
${C}`,
						M = "",
						Q = "",
						O = Math.min(w, o)
					k3(g) && ((M += kfe(g, B, o)), (b = b.slice(g.length)), (O -= g.length), (Q = B)),
						i && (b = R3(b)),
						m.push(g)
					for (let Y = 0; Y < O; Y++) {
						let j = b[Y],
							ne = c(j, g[j], m, y, C)
						ne !== void 0 && ((M += `${Q}${xh(j)}: ${ne}`), (Q = B))
					}
					if (w > o) {
						let Y = w - o
						;(M += `${Q}"...": "${Fp(Y)} not stringified"`), (Q = B)
					}
					return (
						Q !== "" &&
							(M = `
${C}${M}
${v}`),
						m.pop(),
						`{${M}}`
					)
				}
				case "number":
					return isFinite(g) ? String(g) : t ? t(g) : "null"
				case "boolean":
					return g === !0 ? "true" : "false"
				case "undefined":
					return
				case "bigint":
					if (n) return String(g)
				default:
					return t ? t(g) : void 0
			}
		}
		function u(p, g, m) {
			switch (typeof g) {
				case "string":
					return xh(g)
				case "object": {
					if (g === null) return "null"
					if (typeof g.toJSON == "function") {
						if (((g = g.toJSON(p)), typeof g != "object")) return u(p, g, m)
						if (g === null) return "null"
					}
					if (m.indexOf(g) !== -1) return r
					let y = ""
					if (Array.isArray(g)) {
						if (g.length === 0) return "[]"
						if (s < m.length + 1) return '"[Array]"'
						m.push(g)
						let B = Math.min(g.length, o),
							M = 0
						for (; M < B - 1; M++) {
							let O = u(String(M), g[M], m)
							;(y += O !== void 0 ? O : "null"), (y += ",")
						}
						let Q = u(String(M), g[M], m)
						if (((y += Q !== void 0 ? Q : "null"), g.length - 1 > o)) {
							let O = g.length - o - 1
							y += `,"... ${Fp(O)} not stringified"`
						}
						return m.pop(), `[${y}]`
					}
					let C = Object.keys(g),
						v = C.length
					if (v === 0) return "{}"
					if (s < m.length + 1) return '"[Object]"'
					let b = "",
						w = Math.min(v, o)
					k3(g) && ((y += kfe(g, ",", o)), (C = C.slice(g.length)), (w -= g.length), (b = ",")),
						i && (C = R3(C)),
						m.push(g)
					for (let B = 0; B < w; B++) {
						let M = C[B],
							Q = u(M, g[M], m)
						Q !== void 0 && ((y += `${b}${xh(M)}:${Q}`), (b = ","))
					}
					if (v > o) {
						let B = v - o
						y += `${b}"...":"${Fp(B)} not stringified"`
					}
					return m.pop(), `{${y}}`
				}
				case "number":
					return isFinite(g) ? String(g) : t ? t(g) : "null"
				case "boolean":
					return g === !0 ? "true" : "false"
				case "undefined":
					return
				case "bigint":
					if (n) return String(g)
				default:
					return t ? t(g) : void 0
			}
		}
		function f(p, g, m) {
			if (arguments.length > 1) {
				let y = ""
				if (
					(typeof m == "number"
						? (y = " ".repeat(Math.min(m, 10)))
						: typeof m == "string" && (y = m.slice(0, 10)),
					g != null)
				) {
					if (typeof g == "function") return a("", { "": p }, [], g, y, "")
					if (Array.isArray(g)) return l("", p, [], qnt(g), y, "")
				}
				if (y.length !== 0) return c("", p, [], y, "")
			}
			return u("", p, [])
		}
		return f
	}
})
var Q3 = x((ODt, Nfe) => {
	"use strict"
	var Hnt = Go(),
		{ MESSAGE: Wnt } = Bi(),
		Gnt = Wb()
	function $nt(e, t) {
		return typeof t == "bigint" ? t.toString() : t
	}
	Nfe.exports = Hnt((e, t) => {
		let r = Gnt.configure(t)
		return (e[Wnt] = r(e, t.replacer || $nt, t.space)), e
	})
})
var Lfe = x((qDt, Pfe) => {
	"use strict"
	var Ynt = Go()
	Pfe.exports = Ynt((e, t) => (t.message ? ((e.message = `[${t.label}] ${e.message}`), e) : ((e.label = t.label), e)))
})
var Ofe = x((VDt, Ufe) => {
	"use strict"
	var Knt = Go(),
		{ MESSAGE: Jnt } = Bi(),
		znt = Wb()
	Ufe.exports = Knt((e) => {
		let t = {}
		return (
			e.message && ((t["@message"] = e.message), delete e.message),
			e.timestamp && ((t["@timestamp"] = e.timestamp), delete e.timestamp),
			(t["@fields"] = e),
			(e[Jnt] = znt(t)),
			e
		)
	})
})
var Vfe = x((HDt, qfe) => {
	"use strict"
	var jnt = Go()
	function Znt(e, t, r) {
		let n = t.reduce((s, o) => ((s[o] = e[o]), delete e[o], s), {}),
			i = Object.keys(e).reduce((s, o) => ((s[o] = e[o]), delete e[o], s), {})
		return Object.assign(e, n, { [r]: i }), e
	}
	function Xnt(e, t, r) {
		return (e[r] = t.reduce((n, i) => ((n[i] = e[i]), delete e[i], n), {})), e
	}
	qfe.exports = jnt((e, t = {}) => {
		let r = "metadata"
		t.key && (r = t.key)
		let n = []
		return (
			!t.fillExcept && !t.fillWith && (n.push("level"), n.push("message")),
			t.fillExcept && (n = t.fillExcept),
			n.length > 0 ? Znt(e, n, r) : t.fillWith ? Xnt(e, t.fillWith, r) : e
		)
	})
})
var jT = x((WDt, Hfe) => {
	"use strict"
	var ty = 1e3,
		ry = ty * 60,
		ny = ry * 60,
		Np = ny * 24,
		eit = Np * 7,
		tit = Np * 365.25
	Hfe.exports = function (e, t) {
		t = t || {}
		var r = typeof e
		if (r === "string" && e.length > 0) return rit(e)
		if (r === "number" && isFinite(e)) return t.long ? iit(e) : nit(e)
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e))
	}
	function rit(e) {
		if (((e = String(e)), !(e.length > 100))) {
			var t =
				/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
					e,
				)
			if (t) {
				var r = parseFloat(t[1]),
					n = (t[2] || "ms").toLowerCase()
				switch (n) {
					case "years":
					case "year":
					case "yrs":
					case "yr":
					case "y":
						return r * tit
					case "weeks":
					case "week":
					case "w":
						return r * eit
					case "days":
					case "day":
					case "d":
						return r * Np
					case "hours":
					case "hour":
					case "hrs":
					case "hr":
					case "h":
						return r * ny
					case "minutes":
					case "minute":
					case "mins":
					case "min":
					case "m":
						return r * ry
					case "seconds":
					case "second":
					case "secs":
					case "sec":
					case "s":
						return r * ty
					case "milliseconds":
					case "millisecond":
					case "msecs":
					case "msec":
					case "ms":
						return r
					default:
						return
				}
			}
		}
	}
	function nit(e) {
		var t = Math.abs(e)
		return t >= Np
			? Math.round(e / Np) + "d"
			: t >= ny
				? Math.round(e / ny) + "h"
				: t >= ry
					? Math.round(e / ry) + "m"
					: t >= ty
						? Math.round(e / ty) + "s"
						: e + "ms"
	}
	function iit(e) {
		var t = Math.abs(e)
		return t >= Np
			? zT(e, t, Np, "day")
			: t >= ny
				? zT(e, t, ny, "hour")
				: t >= ry
					? zT(e, t, ry, "minute")
					: t >= ty
						? zT(e, t, ty, "second")
						: e + " ms"
	}
	function zT(e, t, r, n) {
		var i = t >= r * 1.5
		return Math.round(e / r) + " " + n + (i ? "s" : "")
	}
})
var Gfe = x((Gb, Wfe) => {
	"use strict"
	var sit = Go(),
		oit = jT()
	Wfe.exports = sit((e) => {
		let t = +new Date()
		return (Gb.diff = t - (Gb.prevTime || t)), (Gb.prevTime = t), (e.ms = `+${oit(Gb.diff)}`), e
	})
})
var Kfe = x((GDt, Yfe) => {
	"use strict"
	var ait = require("util").inspect,
		lit = Go(),
		{ LEVEL: cit, MESSAGE: $fe, SPLAT: uit } = Bi()
	Yfe.exports = lit((e, t = {}) => {
		let r = Object.assign({}, e)
		return delete r[cit], delete r[$fe], delete r[uit], (e[$fe] = ait(r, !1, t.depth || null, t.colorize)), e
	})
})
var Jfe = x(($Dt, XT) => {
	"use strict"
	var { MESSAGE: dit } = Bi(),
		ZT = class {
			constructor(t) {
				this.template = t
			}
			transform(t) {
				return (t[dit] = this.template(t)), t
			}
		}
	XT.exports = (e) => new ZT(e)
	XT.exports.Printf = XT.exports.Format = ZT
})
var Zfe = x((YDt, jfe) => {
	"use strict"
	var fit = Go(),
		{ MESSAGE: zfe } = Bi(),
		hit = Wb()
	jfe.exports = fit((e) => {
		let t = hit(Object.assign({}, e, { level: void 0, message: void 0, splat: void 0 })),
			r = (e.padding && e.padding[e.level]) || ""
		return (
			t !== "{}" ? (e[zfe] = `${e.level}:${r} ${e.message} ${t}`) : (e[zfe] = `${e.level}:${r} ${e.message}`), e
		)
	})
})
var the = x((KDt, ehe) => {
	"use strict"
	var git = require("util"),
		{ SPLAT: Xfe } = Bi(),
		pit = /%[scdjifoO%]/g,
		Ait = /%%/g,
		N3 = class {
			constructor(t) {
				this.options = t
			}
			_splat(t, r) {
				let n = t.message,
					i = t[Xfe] || t.splat || [],
					s = n.match(Ait),
					o = (s && s.length) || 0,
					l = r.length - o - i.length,
					c = l < 0 ? i.splice(l, -1 * l) : [],
					u = c.length
				if (u) for (let f = 0; f < u; f++) Object.assign(t, c[f])
				return (t.message = git.format(n, ...i)), t
			}
			transform(t) {
				let r = t.message,
					n = t[Xfe] || t.splat
				if (!n || !n.length) return t
				let i = r && r.match && r.match(pit)
				if (!i && (n || n.length)) {
					let s = n.length > 1 ? n.splice(0) : n,
						o = s.length
					if (o) for (let a = 0; a < o; a++) Object.assign(t, s[a])
					return t
				}
				return i ? this._splat(t, i) : t
			}
		}
	ehe.exports = (e) => new N3(e)
})
var nhe = x((eR, rhe) => {
	"use strict"
	;(function (e, t) {
		typeof eR == "object" && typeof rhe < "u"
			? t(eR)
			: typeof define == "function" && define.amd
				? define(["exports"], t)
				: t((e.fecha = {}))
	})(eR, function (e) {
		"use strict"
		var t = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g,
			r = "\\d\\d?",
			n = "\\d\\d",
			i = "\\d{3}",
			s = "\\d{4}",
			o = "[^\\s]+",
			a = /\[([^]*?)\]/gm
		function l(K, se) {
			for (var Ze = [], It = 0, Ce = K.length; It < Ce; It++) Ze.push(K[It].substr(0, se))
			return Ze
		}
		var c = function (K) {
			return function (se, Ze) {
				var It = Ze[K].map(function (Et) {
						return Et.toLowerCase()
					}),
					Ce = It.indexOf(se.toLowerCase())
				return Ce > -1 ? Ce : null
			}
		}
		function u(K) {
			for (var se = [], Ze = 1; Ze < arguments.length; Ze++) se[Ze - 1] = arguments[Ze]
			for (var It = 0, Ce = se; It < Ce.length; It++) {
				var Et = Ce[It]
				for (var jt in Et) K[jt] = Et[jt]
			}
			return K
		}
		var f = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
			p = [
				"January",
				"February",
				"March",
				"April",
				"May",
				"June",
				"July",
				"August",
				"September",
				"October",
				"November",
				"December",
			],
			g = l(p, 3),
			m = l(f, 3),
			y = {
				dayNamesShort: m,
				dayNames: f,
				monthNamesShort: g,
				monthNames: p,
				amPm: ["am", "pm"],
				DoFn: function (K) {
					return K + ["th", "st", "nd", "rd"][K % 10 > 3 ? 0 : ((K - (K % 10) !== 10 ? 1 : 0) * K) % 10]
				},
			},
			C = u({}, y),
			v = function (K) {
				return (C = u(C, K))
			},
			b = function (K) {
				return K.replace(/[|\\{()[^$+*?.-]/g, "\\$&")
			},
			w = function (K, se) {
				for (se === void 0 && (se = 2), K = String(K); K.length < se; ) K = "0" + K
				return K
			},
			B = {
				D: function (K) {
					return String(K.getDate())
				},
				DD: function (K) {
					return w(K.getDate())
				},
				Do: function (K, se) {
					return se.DoFn(K.getDate())
				},
				d: function (K) {
					return String(K.getDay())
				},
				dd: function (K) {
					return w(K.getDay())
				},
				ddd: function (K, se) {
					return se.dayNamesShort[K.getDay()]
				},
				dddd: function (K, se) {
					return se.dayNames[K.getDay()]
				},
				M: function (K) {
					return String(K.getMonth() + 1)
				},
				MM: function (K) {
					return w(K.getMonth() + 1)
				},
				MMM: function (K, se) {
					return se.monthNamesShort[K.getMonth()]
				},
				MMMM: function (K, se) {
					return se.monthNames[K.getMonth()]
				},
				YY: function (K) {
					return w(String(K.getFullYear()), 4).substr(2)
				},
				YYYY: function (K) {
					return w(K.getFullYear(), 4)
				},
				h: function (K) {
					return String(K.getHours() % 12 || 12)
				},
				hh: function (K) {
					return w(K.getHours() % 12 || 12)
				},
				H: function (K) {
					return String(K.getHours())
				},
				HH: function (K) {
					return w(K.getHours())
				},
				m: function (K) {
					return String(K.getMinutes())
				},
				mm: function (K) {
					return w(K.getMinutes())
				},
				s: function (K) {
					return String(K.getSeconds())
				},
				ss: function (K) {
					return w(K.getSeconds())
				},
				S: function (K) {
					return String(Math.round(K.getMilliseconds() / 100))
				},
				SS: function (K) {
					return w(Math.round(K.getMilliseconds() / 10), 2)
				},
				SSS: function (K) {
					return w(K.getMilliseconds(), 3)
				},
				a: function (K, se) {
					return K.getHours() < 12 ? se.amPm[0] : se.amPm[1]
				},
				A: function (K, se) {
					return K.getHours() < 12 ? se.amPm[0].toUpperCase() : se.amPm[1].toUpperCase()
				},
				ZZ: function (K) {
					var se = K.getTimezoneOffset()
					return (se > 0 ? "-" : "+") + w(Math.floor(Math.abs(se) / 60) * 100 + (Math.abs(se) % 60), 4)
				},
				Z: function (K) {
					var se = K.getTimezoneOffset()
					return (se > 0 ? "-" : "+") + w(Math.floor(Math.abs(se) / 60), 2) + ":" + w(Math.abs(se) % 60, 2)
				},
			},
			M = function (K) {
				return +K - 1
			},
			Q = [null, r],
			O = [null, o],
			Y = [
				"isPm",
				o,
				function (K, se) {
					var Ze = K.toLowerCase()
					return Ze === se.amPm[0] ? 0 : Ze === se.amPm[1] ? 1 : null
				},
			],
			j = [
				"timezoneOffset",
				"[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
				function (K) {
					var se = (K + "").match(/([+-]|\d\d)/gi)
					if (se) {
						var Ze = +se[1] * 60 + parseInt(se[2], 10)
						return se[0] === "+" ? Ze : -Ze
					}
					return 0
				},
			],
			ne = {
				D: ["day", r],
				DD: ["day", n],
				Do: [
					"day",
					r + o,
					function (K) {
						return parseInt(K, 10)
					},
				],
				M: ["month", r, M],
				MM: ["month", n, M],
				YY: [
					"year",
					n,
					function (K) {
						var se = new Date(),
							Ze = +("" + se.getFullYear()).substr(0, 2)
						return +("" + (+K > 68 ? Ze - 1 : Ze) + K)
					},
				],
				h: ["hour", r, void 0, "isPm"],
				hh: ["hour", n, void 0, "isPm"],
				H: ["hour", r],
				HH: ["hour", n],
				m: ["minute", r],
				mm: ["minute", n],
				s: ["second", r],
				ss: ["second", n],
				YYYY: ["year", s],
				S: [
					"millisecond",
					"\\d",
					function (K) {
						return +K * 100
					},
				],
				SS: [
					"millisecond",
					n,
					function (K) {
						return +K * 10
					},
				],
				SSS: ["millisecond", i],
				d: Q,
				dd: Q,
				ddd: O,
				dddd: O,
				MMM: ["month", o, c("monthNamesShort")],
				MMMM: ["month", o, c("monthNames")],
				a: Y,
				A: Y,
				ZZ: j,
				Z: j,
			},
			q = {
				default: "ddd MMM DD YYYY HH:mm:ss",
				shortDate: "M/D/YY",
				mediumDate: "MMM D, YYYY",
				longDate: "MMMM D, YYYY",
				fullDate: "dddd, MMMM D, YYYY",
				isoDate: "YYYY-MM-DD",
				isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
				shortTime: "HH:mm",
				mediumTime: "HH:mm:ss",
				longTime: "HH:mm:ss.SSS",
			},
			me = function (K) {
				return u(q, K)
			},
			Qe = function (K, se, Ze) {
				if (
					(se === void 0 && (se = q.default),
					Ze === void 0 && (Ze = {}),
					typeof K == "number" && (K = new Date(K)),
					Object.prototype.toString.call(K) !== "[object Date]" || isNaN(K.getTime()))
				)
					throw new Error("Invalid Date pass to format")
				se = q[se] || se
				var It = []
				se = se.replace(a, function (Et, jt) {
					return It.push(jt), "@@@"
				})
				var Ce = u(u({}, C), Ze)
				return (
					(se = se.replace(t, function (Et) {
						return B[Et](K, Ce)
					})),
					se.replace(/@@@/g, function () {
						return It.shift()
					})
				)
			}
		function N(K, se, Ze) {
			if ((Ze === void 0 && (Ze = {}), typeof se != "string")) throw new Error("Invalid format in fecha parse")
			if (((se = q[se] || se), K.length > 1e3)) return null
			var It = new Date(),
				Ce = {
					year: It.getFullYear(),
					month: 0,
					day: 1,
					hour: 0,
					minute: 0,
					second: 0,
					millisecond: 0,
					isPm: null,
					timezoneOffset: null,
				},
				Et = [],
				jt = [],
				Ar = se.replace(a, function (bt, sn) {
					return jt.push(b(sn)), "@@@"
				}),
				de = {},
				Tr = {}
			;(Ar = b(Ar).replace(t, function (bt) {
				var sn = ne[bt],
					yn = sn[0],
					Ei = sn[1],
					Js = sn[3]
				if (de[yn]) throw new Error("Invalid format. " + yn + " specified twice in format")
				return (de[yn] = !0), Js && (Tr[Js] = !0), Et.push(sn), "(" + Ei + ")"
			})),
				Object.keys(Tr).forEach(function (bt) {
					if (!de[bt]) throw new Error("Invalid format. " + bt + " is required in specified format")
				}),
				(Ar = Ar.replace(/@@@/g, function () {
					return jt.shift()
				}))
			var tr = K.match(new RegExp(Ar, "i"))
			if (!tr) return null
			for (var Nr = u(u({}, C), Ze), Ve = 1; Ve < tr.length; Ve++) {
				var en = Et[Ve - 1],
					Pr = en[0],
					cr = en[2],
					be = cr ? cr(tr[Ve], Nr) : +tr[Ve]
				if (be == null) return null
				Ce[Pr] = be
			}
			Ce.isPm === 1 && Ce.hour != null && +Ce.hour != 12
				? (Ce.hour = +Ce.hour + 12)
				: Ce.isPm === 0 && +Ce.hour == 12 && (Ce.hour = 0)
			var Rr
			if (Ce.timezoneOffset == null) {
				Rr = new Date(Ce.year, Ce.month, Ce.day, Ce.hour, Ce.minute, Ce.second, Ce.millisecond)
				for (
					var fe = [
							["month", "getMonth"],
							["day", "getDate"],
							["hour", "getHours"],
							["minute", "getMinutes"],
							["second", "getSeconds"],
						],
						Ve = 0,
						Ee = fe.length;
					Ve < Ee;
					Ve++
				)
					if (de[fe[Ve][0]] && Ce[fe[Ve][0]] !== Rr[fe[Ve][1]]()) return null
			} else if (
				((Rr = new Date(
					Date.UTC(
						Ce.year,
						Ce.month,
						Ce.day,
						Ce.hour,
						Ce.minute - Ce.timezoneOffset,
						Ce.second,
						Ce.millisecond,
					),
				)),
				Ce.month > 11 ||
					Ce.month < 0 ||
					Ce.day > 31 ||
					Ce.day < 1 ||
					Ce.hour > 23 ||
					Ce.hour < 0 ||
					Ce.minute > 59 ||
					Ce.minute < 0 ||
					Ce.second > 59 ||
					Ce.second < 0)
			)
				return null
			return Rr
		}
		var re = {
			format: Qe,
			parse: N,
			defaultI18n: y,
			setGlobalDateI18n: v,
			setGlobalDateMasks: me,
		}
		;(e.assign = u),
			(e.default = re),
			(e.format = Qe),
			(e.parse = N),
			(e.defaultI18n = y),
			(e.setGlobalDateI18n = v),
			(e.setGlobalDateMasks = me),
			Object.defineProperty(e, "__esModule", { value: !0 })
	})
})
var she = x((JDt, ihe) => {
	"use strict"
	var mit = nhe(),
		yit = Go()
	ihe.exports = yit(
		(e, t = {}) => (
			t.format && (e.timestamp = typeof t.format == "function" ? t.format() : mit.format(new Date(), t.format)),
			e.timestamp || (e.timestamp = new Date().toISOString()),
			t.alias && (e[t.alias] = e.timestamp),
			e
		),
	)
})
var ahe = x((zDt, ohe) => {
	"use strict"
	var P3 = C3(),
		Cit = Go(),
		{ MESSAGE: L3 } = Bi()
	ohe.exports = Cit(
		(e, t) => (
			t.level !== !1 && (e.level = P3.strip(e.level)),
			t.message !== !1 && (e.message = P3.strip(String(e.message))),
			t.raw !== !1 && e[L3] && (e[L3] = P3.strip(String(e[L3]))),
			e
		),
	)
})
var O3 = x((U3) => {
	"use strict"
	var vit = (U3.format = Go())
	U3.levels = bfe()
	function xs(e, t) {
		Object.defineProperty(vit, e, {
			get() {
				return t()
			},
			configurable: !0,
		})
	}
	xs("align", function () {
		return _fe()
	})
	xs("errors", function () {
		return Sfe()
	})
	xs("cli", function () {
		return Dfe()
	})
	xs("combine", function () {
		return Rfe()
	})
	xs("colorize", function () {
		return GT()
	})
	xs("json", function () {
		return Q3()
	})
	xs("label", function () {
		return Lfe()
	})
	xs("logstash", function () {
		return Ofe()
	})
	xs("metadata", function () {
		return Vfe()
	})
	xs("ms", function () {
		return Gfe()
	})
	xs("padLevels", function () {
		return B3()
	})
	xs("prettyPrint", function () {
		return Kfe()
	})
	xs("printf", function () {
		return Jfe()
	})
	xs("simple", function () {
		return Zfe()
	})
	xs("splat", function () {
		return the()
	})
	xs("timestamp", function () {
		return she()
	})
	xs("uncolorize", function () {
		return ahe()
	})
})
var q3 = x((tR) => {
	"use strict"
	var { format: lhe } = require("util")
	tR.warn = {
		deprecated(e) {
			return () => {
				throw new Error(lhe("{ %s } was removed in winston@3.0.0.", e))
			}
		},
		useFormat(e) {
			return () => {
				throw new Error(
					[
						lhe("{ %s } was removed in winston@3.0.0.", e),
						"Use a custom winston.format = winston.format(function) instead.",
					].join(`
`),
				)
			}
		},
		forFunctions(e, t, r) {
			r.forEach((n) => {
				e[n] = tR.warn[t](n)
			})
		},
		forProperties(e, t, r) {
			r.forEach((n) => {
				let i = tR.warn[t](n)
				Object.defineProperty(e, n, { get: i, set: i })
			})
		},
	}
})
var che = x((XDt, Eit) => {
	Eit.exports = {
		name: "winston",
		description: "A logger for just about everything.",
		version: "3.11.0",
		author: "Charlie Robbins <charlie.robbins@gmail.com>",
		maintainers: ["David Hyde <dabh@alumni.stanford.edu>"],
		repository: {
			type: "git",
			url: "https://github.com/winstonjs/winston.git",
		},
		keywords: [
			"winston",
			"logger",
			"logging",
			"logs",
			"sysadmin",
			"bunyan",
			"pino",
			"loglevel",
			"tools",
			"json",
			"stream",
		],
		dependencies: {
			"@dabh/diagnostics": "^2.0.2",
			"@colors/colors": "^1.6.0",
			async: "^3.2.3",
			"is-stream": "^2.0.0",
			logform: "^2.4.0",
			"one-time": "^1.0.0",
			"readable-stream": "^3.4.0",
			"safe-stable-stringify": "^2.3.1",
			"stack-trace": "0.0.x",
			"triple-beam": "^1.3.0",
			"winston-transport": "^4.5.0",
		},
		devDependencies: {
			"@babel/cli": "^7.17.0",
			"@babel/core": "^7.17.2",
			"@babel/preset-env": "^7.16.7",
			"@dabh/eslint-config-populist": "^5.0.0",
			"@types/node": "^20.3.1",
			"abstract-winston-transport": "^0.5.1",
			assume: "^2.2.0",
			"cross-spawn-async": "^2.2.5",
			eslint: "^8.9.0",
			hock: "^1.4.1",
			mocha: "8.1.3",
			nyc: "^15.1.0",
			rimraf: "^5.0.5",
			split2: "^4.1.0",
			"std-mocks": "^1.0.1",
			through2: "^4.0.2",
			"winston-compat": "^0.1.5",
		},
		main: "./lib/winston.js",
		browser: "./dist/winston",
		types: "./index.d.ts",
		scripts: {
			lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
			test: "mocha",
			"test:coverage": "nyc npm run test:unit",
			"test:unit": "mocha test/unit",
			"test:integration": "mocha test/integration",
			build: "rimraf dist && babel lib -d dist",
			prepublishOnly: "npm run build",
		},
		engines: { node: ">= 12.0.0" },
		license: "MIT",
	}
})
var dhe = x((eTt, uhe) => {
	"use strict"
	uhe.exports = require("util").deprecate
})
var V3 = x((tTt, fhe) => {
	"use strict"
	fhe.exports = require("stream")
})
var W3 = x((rTt, ghe) => {
	"use strict"
	function bit(e, t) {
		var r = this,
			n = this._readableState && this._readableState.destroyed,
			i = this._writableState && this._writableState.destroyed
		return n || i
			? (t
					? t(e)
					: e &&
						(this._writableState
							? this._writableState.errorEmitted ||
								((this._writableState.errorEmitted = !0), process.nextTick(H3, this, e))
							: process.nextTick(H3, this, e)),
				this)
			: (this._readableState && (this._readableState.destroyed = !0),
				this._writableState && (this._writableState.destroyed = !0),
				this._destroy(e || null, function (s) {
					!t && s
						? r._writableState
							? r._writableState.errorEmitted
								? process.nextTick(rR, r)
								: ((r._writableState.errorEmitted = !0), process.nextTick(hhe, r, s))
							: process.nextTick(hhe, r, s)
						: t
							? (process.nextTick(rR, r), t(s))
							: process.nextTick(rR, r)
				}),
				this)
	}
	function hhe(e, t) {
		H3(e, t), rR(e)
	}
	function rR(e) {
		;(e._writableState && !e._writableState.emitClose) ||
			(e._readableState && !e._readableState.emitClose) ||
			e.emit("close")
	}
	function xit() {
		this._readableState &&
			((this._readableState.destroyed = !1),
			(this._readableState.reading = !1),
			(this._readableState.ended = !1),
			(this._readableState.endEmitted = !1)),
			this._writableState &&
				((this._writableState.destroyed = !1),
				(this._writableState.ended = !1),
				(this._writableState.ending = !1),
				(this._writableState.finalCalled = !1),
				(this._writableState.prefinished = !1),
				(this._writableState.finished = !1),
				(this._writableState.errorEmitted = !1))
	}
	function H3(e, t) {
		e.emit("error", t)
	}
	function _it(e, t) {
		var r = e._readableState,
			n = e._writableState
		;(r && r.autoDestroy) || (n && n.autoDestroy) ? e.destroy(t) : e.emit("error", t)
	}
	ghe.exports = { destroy: bit, undestroy: xit, errorOrDestroy: _it }
})
var _h = x((nTt, mhe) => {
	"use strict"
	var Ahe = {}
	function pl(e, t, r) {
		r || (r = Error)
		function n(s, o, a) {
			return typeof t == "string" ? t : t(s, o, a)
		}
		class i extends r {
			constructor(o, a, l) {
				super(n(o, a, l))
			}
		}
		;(i.prototype.name = r.name), (i.prototype.code = e), (Ahe[e] = i)
	}
	function phe(e, t) {
		if (Array.isArray(e)) {
			let r = e.length
			return (
				(e = e.map((n) => String(n))),
				r > 2
					? `one of ${t} ${e.slice(0, r - 1).join(", ")}, or ` + e[r - 1]
					: r === 2
						? `one of ${t} ${e[0]} or ${e[1]}`
						: `of ${t} ${e[0]}`
			)
		} else return `of ${t} ${String(e)}`
	}
	function wit(e, t, r) {
		return e.substr(!r || r < 0 ? 0 : +r, t.length) === t
	}
	function Iit(e, t, r) {
		return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t
	}
	function Sit(e, t, r) {
		return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1
	}
	pl(
		"ERR_INVALID_OPT_VALUE",
		function (e, t) {
			return 'The value "' + t + '" is invalid for option "' + e + '"'
		},
		TypeError,
	)
	pl(
		"ERR_INVALID_ARG_TYPE",
		function (e, t, r) {
			let n
			typeof t == "string" && wit(t, "not ")
				? ((n = "must not be"), (t = t.replace(/^not /, "")))
				: (n = "must be")
			let i
			if (Iit(e, " argument")) i = `The ${e} ${n} ${phe(t, "type")}`
			else {
				let s = Sit(e, ".") ? "property" : "argument"
				i = `The "${e}" ${s} ${n} ${phe(t, "type")}`
			}
			return (i += `. Received type ${typeof r}`), i
		},
		TypeError,
	)
	pl("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF")
	pl("ERR_METHOD_NOT_IMPLEMENTED", function (e) {
		return "The " + e + " method is not implemented"
	})
	pl("ERR_STREAM_PREMATURE_CLOSE", "Premature close")
	pl("ERR_STREAM_DESTROYED", function (e) {
		return "Cannot call " + e + " after a stream was destroyed"
	})
	pl("ERR_MULTIPLE_CALLBACK", "Callback called multiple times")
	pl("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable")
	pl("ERR_STREAM_WRITE_AFTER_END", "write after end")
	pl("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError)
	pl(
		"ERR_UNKNOWN_ENCODING",
		function (e) {
			return "Unknown encoding: " + e
		},
		TypeError,
	)
	pl("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event")
	mhe.exports.codes = Ahe
})
var G3 = x((iTt, yhe) => {
	"use strict"
	var Bit = _h().codes.ERR_INVALID_OPT_VALUE
	function Dit(e, t, r) {
		return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null
	}
	function Tit(e, t, r, n) {
		var i = Dit(t, n, r)
		if (i != null) {
			if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
				var s = n ? r : "highWaterMark"
				throw new Bit(s, i)
			}
			return Math.floor(i)
		}
		return e.objectMode ? 16 : 16 * 1024
	}
	yhe.exports = { getHighWaterMark: Tit }
})
var Che = x((sTt, $3) => {
	"use strict"
	typeof Object.create == "function"
		? ($3.exports = function (t, r) {
				r &&
					((t.super_ = r),
					(t.prototype = Object.create(r.prototype, {
						constructor: {
							value: t,
							enumerable: !1,
							writable: !0,
							configurable: !0,
						},
					})))
			})
		: ($3.exports = function (t, r) {
				if (r) {
					t.super_ = r
					var n = function () {}
					;(n.prototype = r.prototype), (t.prototype = new n()), (t.prototype.constructor = t)
				}
			})
})
var iy = x((oTt, K3) => {
	"use strict"
	try {
		if (((Y3 = require("util")), typeof Y3.inherits != "function")) throw ""
		K3.exports = Y3.inherits
	} catch {
		K3.exports = Che()
	}
	var Y3
})
var whe = x((aTt, _he) => {
	"use strict"
	function vhe(e, t) {
		var r = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var n = Object.getOwnPropertySymbols(e)
			t &&
				(n = n.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				r.push.apply(r, n)
		}
		return r
	}
	function Ehe(e) {
		for (var t = 1; t < arguments.length; t++) {
			var r = arguments[t] != null ? arguments[t] : {}
			t % 2
				? vhe(Object(r), !0).forEach(function (n) {
						Rit(e, n, r[n])
					})
				: Object.getOwnPropertyDescriptors
					? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
					: vhe(Object(r)).forEach(function (n) {
							Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n))
						})
		}
		return e
	}
	function Rit(e, t, r) {
		return (
			(t = xhe(t)),
			t in e
				? Object.defineProperty(e, t, {
						value: r,
						enumerable: !0,
						configurable: !0,
						writable: !0,
					})
				: (e[t] = r),
			e
		)
	}
	function kit(e, t) {
		if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
	}
	function bhe(e, t) {
		for (var r = 0; r < t.length; r++) {
			var n = t[r]
			;(n.enumerable = n.enumerable || !1),
				(n.configurable = !0),
				"value" in n && (n.writable = !0),
				Object.defineProperty(e, xhe(n.key), n)
		}
	}
	function Mit(e, t, r) {
		return t && bhe(e.prototype, t), r && bhe(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e
	}
	function xhe(e) {
		var t = Fit(e, "string")
		return typeof t == "symbol" ? t : String(t)
	}
	function Fit(e, t) {
		if (typeof e != "object" || e === null) return e
		var r = e[Symbol.toPrimitive]
		if (r !== void 0) {
			var n = r.call(e, t || "default")
			if (typeof n != "object") return n
			throw new TypeError("@@toPrimitive must return a primitive value.")
		}
		return (t === "string" ? String : Number)(e)
	}
	var Qit = require("buffer"),
		nR = Qit.Buffer,
		Nit = require("util"),
		J3 = Nit.inspect,
		Pit = (J3 && J3.custom) || "inspect"
	function Lit(e, t, r) {
		nR.prototype.copy.call(e, t, r)
	}
	_he.exports = (function () {
		function e() {
			kit(this, e), (this.head = null), (this.tail = null), (this.length = 0)
		}
		return (
			Mit(e, [
				{
					key: "push",
					value: function (r) {
						var n = { data: r, next: null }
						this.length > 0 ? (this.tail.next = n) : (this.head = n), (this.tail = n), ++this.length
					},
				},
				{
					key: "unshift",
					value: function (r) {
						var n = { data: r, next: this.head }
						this.length === 0 && (this.tail = n), (this.head = n), ++this.length
					},
				},
				{
					key: "shift",
					value: function () {
						if (this.length !== 0) {
							var r = this.head.data
							return (
								this.length === 1 ? (this.head = this.tail = null) : (this.head = this.head.next),
								--this.length,
								r
							)
						}
					},
				},
				{
					key: "clear",
					value: function () {
						;(this.head = this.tail = null), (this.length = 0)
					},
				},
				{
					key: "join",
					value: function (r) {
						if (this.length === 0) return ""
						for (var n = this.head, i = "" + n.data; (n = n.next); ) i += r + n.data
						return i
					},
				},
				{
					key: "concat",
					value: function (r) {
						if (this.length === 0) return nR.alloc(0)
						for (var n = nR.allocUnsafe(r >>> 0), i = this.head, s = 0; i; )
							Lit(i.data, n, s), (s += i.data.length), (i = i.next)
						return n
					},
				},
				{
					key: "consume",
					value: function (r, n) {
						var i
						return (
							r < this.head.data.length
								? ((i = this.head.data.slice(0, r)), (this.head.data = this.head.data.slice(r)))
								: r === this.head.data.length
									? (i = this.shift())
									: (i = n ? this._getString(r) : this._getBuffer(r)),
							i
						)
					},
				},
				{
					key: "first",
					value: function () {
						return this.head.data
					},
				},
				{
					key: "_getString",
					value: function (r) {
						var n = this.head,
							i = 1,
							s = n.data
						for (r -= s.length; (n = n.next); ) {
							var o = n.data,
								a = r > o.length ? o.length : r
							if ((a === o.length ? (s += o) : (s += o.slice(0, r)), (r -= a), r === 0)) {
								a === o.length
									? (++i, n.next ? (this.head = n.next) : (this.head = this.tail = null))
									: ((this.head = n), (n.data = o.slice(a)))
								break
							}
							++i
						}
						return (this.length -= i), s
					},
				},
				{
					key: "_getBuffer",
					value: function (r) {
						var n = nR.allocUnsafe(r),
							i = this.head,
							s = 1
						for (i.data.copy(n), r -= i.data.length; (i = i.next); ) {
							var o = i.data,
								a = r > o.length ? o.length : r
							if ((o.copy(n, n.length - r, 0, a), (r -= a), r === 0)) {
								a === o.length
									? (++s, i.next ? (this.head = i.next) : (this.head = this.tail = null))
									: ((this.head = i), (i.data = o.slice(a)))
								break
							}
							++s
						}
						return (this.length -= s), n
					},
				},
				{
					key: Pit,
					value: function (r, n) {
						return J3(this, Ehe(Ehe({}, n), {}, { depth: 0, customInspect: !1 }))
					},
				},
			]),
			e
		)
	})()
})
var Bhe = x((z3, She) => {
	"use strict"
	var iR = require("buffer"),
		Eu = iR.Buffer
	function Ihe(e, t) {
		for (var r in e) t[r] = e[r]
	}
	Eu.from && Eu.alloc && Eu.allocUnsafe && Eu.allocUnsafeSlow ? (She.exports = iR) : (Ihe(iR, z3), (z3.Buffer = Pp))
	function Pp(e, t, r) {
		return Eu(e, t, r)
	}
	Pp.prototype = Object.create(Eu.prototype)
	Ihe(Eu, Pp)
	Pp.from = function (e, t, r) {
		if (typeof e == "number") throw new TypeError("Argument must not be a number")
		return Eu(e, t, r)
	}
	Pp.alloc = function (e, t, r) {
		if (typeof e != "number") throw new TypeError("Argument must be a number")
		var n = Eu(e)
		return t !== void 0 ? (typeof r == "string" ? n.fill(t, r) : n.fill(t)) : n.fill(0), n
	}
	Pp.allocUnsafe = function (e) {
		if (typeof e != "number") throw new TypeError("Argument must be a number")
		return Eu(e)
	}
	Pp.allocUnsafeSlow = function (e) {
		if (typeof e != "number") throw new TypeError("Argument must be a number")
		return iR.SlowBuffer(e)
	}
})
var X3 = x((The) => {
	"use strict"
	var Z3 = Bhe().Buffer,
		Dhe =
			Z3.isEncoding ||
			function (e) {
				switch (((e = "" + e), e && e.toLowerCase())) {
					case "hex":
					case "utf8":
					case "utf-8":
					case "ascii":
					case "binary":
					case "base64":
					case "ucs2":
					case "ucs-2":
					case "utf16le":
					case "utf-16le":
					case "raw":
						return !0
					default:
						return !1
				}
			}
	function Uit(e) {
		if (!e) return "utf8"
		for (var t; ; )
			switch (e) {
				case "utf8":
				case "utf-8":
					return "utf8"
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le":
					return "utf16le"
				case "latin1":
				case "binary":
					return "latin1"
				case "base64":
				case "ascii":
				case "hex":
					return e
				default:
					if (t) return
					;(e = ("" + e).toLowerCase()), (t = !0)
			}
	}
	function Oit(e) {
		var t = Uit(e)
		if (typeof t != "string" && (Z3.isEncoding === Dhe || !Dhe(e))) throw new Error("Unknown encoding: " + e)
		return t || e
	}
	The.StringDecoder = $b
	function $b(e) {
		this.encoding = Oit(e)
		var t
		switch (this.encoding) {
			case "utf16le":
				;(this.text = $it), (this.end = Yit), (t = 4)
				break
			case "utf8":
				;(this.fillLast = Hit), (t = 4)
				break
			case "base64":
				;(this.text = Kit), (this.end = Jit), (t = 3)
				break
			default:
				;(this.write = zit), (this.end = jit)
				return
		}
		;(this.lastNeed = 0), (this.lastTotal = 0), (this.lastChar = Z3.allocUnsafe(t))
	}
	$b.prototype.write = function (e) {
		if (e.length === 0) return ""
		var t, r
		if (this.lastNeed) {
			if (((t = this.fillLast(e)), t === void 0)) return ""
			;(r = this.lastNeed), (this.lastNeed = 0)
		} else r = 0
		return r < e.length ? (t ? t + this.text(e, r) : this.text(e, r)) : t || ""
	}
	$b.prototype.end = Git
	$b.prototype.text = Wit
	$b.prototype.fillLast = function (e) {
		if (this.lastNeed <= e.length)
			return (
				e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed),
				this.lastChar.toString(this.encoding, 0, this.lastTotal)
			)
		e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), (this.lastNeed -= e.length)
	}
	function j3(e) {
		return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2
	}
	function qit(e, t, r) {
		var n = t.length - 1
		if (n < r) return 0
		var i = j3(t[n])
		return i >= 0
			? (i > 0 && (e.lastNeed = i - 1), i)
			: --n < r || i === -2
				? 0
				: ((i = j3(t[n])),
					i >= 0
						? (i > 0 && (e.lastNeed = i - 2), i)
						: --n < r || i === -2
							? 0
							: ((i = j3(t[n])), i >= 0 ? (i > 0 && (i === 2 ? (i = 0) : (e.lastNeed = i - 3)), i) : 0))
	}
	function Vit(e, t, r) {
		if ((t[0] & 192) !== 128) return (e.lastNeed = 0), "\uFFFD"
		if (e.lastNeed > 1 && t.length > 1) {
			if ((t[1] & 192) !== 128) return (e.lastNeed = 1), "\uFFFD"
			if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128) return (e.lastNeed = 2), "\uFFFD"
		}
	}
	function Hit(e) {
		var t = this.lastTotal - this.lastNeed,
			r = Vit(this, e, t)
		if (r !== void 0) return r
		if (this.lastNeed <= e.length)
			return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)
		e.copy(this.lastChar, t, 0, e.length), (this.lastNeed -= e.length)
	}
	function Wit(e, t) {
		var r = qit(this, e, t)
		if (!this.lastNeed) return e.toString("utf8", t)
		this.lastTotal = r
		var n = e.length - (r - this.lastNeed)
		return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n)
	}
	function Git(e) {
		var t = e && e.length ? this.write(e) : ""
		return this.lastNeed ? t + "\uFFFD" : t
	}
	function $it(e, t) {
		if ((e.length - t) % 2 === 0) {
			var r = e.toString("utf16le", t)
			if (r) {
				var n = r.charCodeAt(r.length - 1)
				if (n >= 55296 && n <= 56319)
					return (
						(this.lastNeed = 2),
						(this.lastTotal = 4),
						(this.lastChar[0] = e[e.length - 2]),
						(this.lastChar[1] = e[e.length - 1]),
						r.slice(0, -1)
					)
			}
			return r
		}
		return (
			(this.lastNeed = 1),
			(this.lastTotal = 2),
			(this.lastChar[0] = e[e.length - 1]),
			e.toString("utf16le", t, e.length - 1)
		)
	}
	function Yit(e) {
		var t = e && e.length ? this.write(e) : ""
		if (this.lastNeed) {
			var r = this.lastTotal - this.lastNeed
			return t + this.lastChar.toString("utf16le", 0, r)
		}
		return t
	}
	function Kit(e, t) {
		var r = (e.length - t) % 3
		return r === 0
			? e.toString("base64", t)
			: ((this.lastNeed = 3 - r),
				(this.lastTotal = 3),
				r === 1
					? (this.lastChar[0] = e[e.length - 1])
					: ((this.lastChar[0] = e[e.length - 2]), (this.lastChar[1] = e[e.length - 1])),
				e.toString("base64", t, e.length - r))
	}
	function Jit(e) {
		var t = e && e.length ? this.write(e) : ""
		return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t
	}
	function zit(e) {
		return e.toString(this.encoding)
	}
	function jit(e) {
		return e && e.length ? this.write(e) : ""
	}
})
var sR = x((cTt, Mhe) => {
	"use strict"
	var Rhe = _h().codes.ERR_STREAM_PREMATURE_CLOSE
	function Zit(e) {
		var t = !1
		return function () {
			if (!t) {
				t = !0
				for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i]
				e.apply(this, n)
			}
		}
	}
	function Xit() {}
	function est(e) {
		return e.setHeader && typeof e.abort == "function"
	}
	function khe(e, t, r) {
		if (typeof t == "function") return khe(e, null, t)
		t || (t = {}), (r = Zit(r || Xit))
		var n = t.readable || (t.readable !== !1 && e.readable),
			i = t.writable || (t.writable !== !1 && e.writable),
			s = function () {
				e.writable || a()
			},
			o = e._writableState && e._writableState.finished,
			a = function () {
				;(i = !1), (o = !0), n || r.call(e)
			},
			l = e._readableState && e._readableState.endEmitted,
			c = function () {
				;(n = !1), (l = !0), i || r.call(e)
			},
			u = function (m) {
				r.call(e, m)
			},
			f = function () {
				var m
				if (n && !l) return (!e._readableState || !e._readableState.ended) && (m = new Rhe()), r.call(e, m)
				if (i && !o) return (!e._writableState || !e._writableState.ended) && (m = new Rhe()), r.call(e, m)
			},
			p = function () {
				e.req.on("finish", a)
			}
		return (
			est(e)
				? (e.on("complete", a), e.on("abort", f), e.req ? p() : e.on("request", p))
				: i && !e._writableState && (e.on("end", s), e.on("close", s)),
			e.on("end", c),
			e.on("finish", a),
			t.error !== !1 && e.on("error", u),
			e.on("close", f),
			function () {
				e.removeListener("complete", a),
					e.removeListener("abort", f),
					e.removeListener("request", p),
					e.req && e.req.removeListener("finish", a),
					e.removeListener("end", s),
					e.removeListener("close", s),
					e.removeListener("finish", a),
					e.removeListener("end", c),
					e.removeListener("error", u),
					e.removeListener("close", f)
			}
		)
	}
	Mhe.exports = khe
})
var Qhe = x((uTt, Fhe) => {
	"use strict"
	var oR
	function wh(e, t, r) {
		return (
			(t = tst(t)),
			t in e
				? Object.defineProperty(e, t, {
						value: r,
						enumerable: !0,
						configurable: !0,
						writable: !0,
					})
				: (e[t] = r),
			e
		)
	}
	function tst(e) {
		var t = rst(e, "string")
		return typeof t == "symbol" ? t : String(t)
	}
	function rst(e, t) {
		if (typeof e != "object" || e === null) return e
		var r = e[Symbol.toPrimitive]
		if (r !== void 0) {
			var n = r.call(e, t || "default")
			if (typeof n != "object") return n
			throw new TypeError("@@toPrimitive must return a primitive value.")
		}
		return (t === "string" ? String : Number)(e)
	}
	var nst = sR(),
		Ih = Symbol("lastResolve"),
		Lp = Symbol("lastReject"),
		Yb = Symbol("error"),
		aR = Symbol("ended"),
		Up = Symbol("lastPromise"),
		eH = Symbol("handlePromise"),
		Op = Symbol("stream")
	function Sh(e, t) {
		return { value: e, done: t }
	}
	function ist(e) {
		var t = e[Ih]
		if (t !== null) {
			var r = e[Op].read()
			r !== null && ((e[Up] = null), (e[Ih] = null), (e[Lp] = null), t(Sh(r, !1)))
		}
	}
	function sst(e) {
		process.nextTick(ist, e)
	}
	function ost(e, t) {
		return function (r, n) {
			e.then(function () {
				if (t[aR]) {
					r(Sh(void 0, !0))
					return
				}
				t[eH](r, n)
			}, n)
		}
	}
	var ast = Object.getPrototypeOf(function () {}),
		lst = Object.setPrototypeOf(
			((oR = {
				get stream() {
					return this[Op]
				},
				next: function () {
					var t = this,
						r = this[Yb]
					if (r !== null) return Promise.reject(r)
					if (this[aR]) return Promise.resolve(Sh(void 0, !0))
					if (this[Op].destroyed)
						return new Promise(function (o, a) {
							process.nextTick(function () {
								t[Yb] ? a(t[Yb]) : o(Sh(void 0, !0))
							})
						})
					var n = this[Up],
						i
					if (n) i = new Promise(ost(n, this))
					else {
						var s = this[Op].read()
						if (s !== null) return Promise.resolve(Sh(s, !1))
						i = new Promise(this[eH])
					}
					return (this[Up] = i), i
				},
			}),
			wh(oR, Symbol.asyncIterator, function () {
				return this
			}),
			wh(oR, "return", function () {
				var t = this
				return new Promise(function (r, n) {
					t[Op].destroy(null, function (i) {
						if (i) {
							n(i)
							return
						}
						r(Sh(void 0, !0))
					})
				})
			}),
			oR),
			ast,
		),
		cst = function (t) {
			var r,
				n = Object.create(
					lst,
					((r = {}),
					wh(r, Op, { value: t, writable: !0 }),
					wh(r, Ih, { value: null, writable: !0 }),
					wh(r, Lp, { value: null, writable: !0 }),
					wh(r, Yb, { value: null, writable: !0 }),
					wh(r, aR, { value: t._readableState.endEmitted, writable: !0 }),
					wh(r, eH, {
						value: function (s, o) {
							var a = n[Op].read()
							a
								? ((n[Up] = null), (n[Ih] = null), (n[Lp] = null), s(Sh(a, !1)))
								: ((n[Ih] = s), (n[Lp] = o))
						},
						writable: !0,
					}),
					r),
				)
			return (
				(n[Up] = null),
				nst(t, function (i) {
					if (i && i.code !== "ERR_STREAM_PREMATURE_CLOSE") {
						var s = n[Lp]
						s !== null && ((n[Up] = null), (n[Ih] = null), (n[Lp] = null), s(i)), (n[Yb] = i)
						return
					}
					var o = n[Ih]
					o !== null && ((n[Up] = null), (n[Ih] = null), (n[Lp] = null), o(Sh(void 0, !0))), (n[aR] = !0)
				}),
				t.on("readable", sst.bind(null, n)),
				n
			)
		}
	Fhe.exports = cst
})
var Uhe = x((dTt, Lhe) => {
	"use strict"
	function Nhe(e, t, r, n, i, s, o) {
		try {
			var a = e[s](o),
				l = a.value
		} catch (c) {
			r(c)
			return
		}
		a.done ? t(l) : Promise.resolve(l).then(n, i)
	}
	function ust(e) {
		return function () {
			var t = this,
				r = arguments
			return new Promise(function (n, i) {
				var s = e.apply(t, r)
				function o(l) {
					Nhe(s, n, i, o, a, "next", l)
				}
				function a(l) {
					Nhe(s, n, i, o, a, "throw", l)
				}
				o(void 0)
			})
		}
	}
	function Phe(e, t) {
		var r = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var n = Object.getOwnPropertySymbols(e)
			t &&
				(n = n.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				r.push.apply(r, n)
		}
		return r
	}
	function dst(e) {
		for (var t = 1; t < arguments.length; t++) {
			var r = arguments[t] != null ? arguments[t] : {}
			t % 2
				? Phe(Object(r), !0).forEach(function (n) {
						fst(e, n, r[n])
					})
				: Object.getOwnPropertyDescriptors
					? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
					: Phe(Object(r)).forEach(function (n) {
							Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n))
						})
		}
		return e
	}
	function fst(e, t, r) {
		return (
			(t = hst(t)),
			t in e
				? Object.defineProperty(e, t, {
						value: r,
						enumerable: !0,
						configurable: !0,
						writable: !0,
					})
				: (e[t] = r),
			e
		)
	}
	function hst(e) {
		var t = gst(e, "string")
		return typeof t == "symbol" ? t : String(t)
	}
	function gst(e, t) {
		if (typeof e != "object" || e === null) return e
		var r = e[Symbol.toPrimitive]
		if (r !== void 0) {
			var n = r.call(e, t || "default")
			if (typeof n != "object") return n
			throw new TypeError("@@toPrimitive must return a primitive value.")
		}
		return (t === "string" ? String : Number)(e)
	}
	var pst = _h().codes.ERR_INVALID_ARG_TYPE
	function Ast(e, t, r) {
		var n
		if (t && typeof t.next == "function") n = t
		else if (t && t[Symbol.asyncIterator]) n = t[Symbol.asyncIterator]()
		else if (t && t[Symbol.iterator]) n = t[Symbol.iterator]()
		else throw new pst("iterable", ["Iterable"], t)
		var i = new e(dst({ objectMode: !0 }, r)),
			s = !1
		i._read = function () {
			s || ((s = !0), o())
		}
		function o() {
			return a.apply(this, arguments)
		}
		function a() {
			return (
				(a = ust(function* () {
					try {
						var l = yield n.next(),
							c = l.value,
							u = l.done
						u ? i.push(null) : i.push(yield c) ? o() : (s = !1)
					} catch (f) {
						i.destroy(f)
					}
				})),
				a.apply(this, arguments)
			)
		}
		return i
	}
	Lhe.exports = Ast
})
var uH = x((hTt, Jhe) => {
	"use strict"
	Jhe.exports = Dr
	var sy
	Dr.ReadableState = Hhe
	var fTt = require("events").EventEmitter,
		Vhe = function (t, r) {
			return t.listeners(r).length
		},
		Jb = V3(),
		lR = require("buffer").Buffer,
		mst =
			(typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array ||
			function () {}
	function yst(e) {
		return lR.from(e)
	}
	function Cst(e) {
		return lR.isBuffer(e) || e instanceof mst
	}
	var tH = require("util"),
		er
	tH && tH.debuglog ? (er = tH.debuglog("stream")) : (er = function () {})
	var vst = whe(),
		lH = W3(),
		Est = G3(),
		bst = Est.getHighWaterMark,
		cR = _h().codes,
		xst = cR.ERR_INVALID_ARG_TYPE,
		_st = cR.ERR_STREAM_PUSH_AFTER_EOF,
		wst = cR.ERR_METHOD_NOT_IMPLEMENTED,
		Ist = cR.ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
		oy,
		rH,
		nH
	iy()(Dr, Jb)
	var Kb = lH.errorOrDestroy,
		iH = ["error", "close", "destroy", "pause", "resume"]
	function Sst(e, t, r) {
		if (typeof e.prependListener == "function") return e.prependListener(t, r)
		!e._events || !e._events[t]
			? e.on(t, r)
			: Array.isArray(e._events[t])
				? e._events[t].unshift(r)
				: (e._events[t] = [r, e._events[t]])
	}
	function Hhe(e, t, r) {
		;(sy = sy || qp()),
			(e = e || {}),
			typeof r != "boolean" && (r = t instanceof sy),
			(this.objectMode = !!e.objectMode),
			r && (this.objectMode = this.objectMode || !!e.readableObjectMode),
			(this.highWaterMark = bst(this, e, "readableHighWaterMark", r)),
			(this.buffer = new vst()),
			(this.length = 0),
			(this.pipes = null),
			(this.pipesCount = 0),
			(this.flowing = null),
			(this.ended = !1),
			(this.endEmitted = !1),
			(this.reading = !1),
			(this.sync = !0),
			(this.needReadable = !1),
			(this.emittedReadable = !1),
			(this.readableListening = !1),
			(this.resumeScheduled = !1),
			(this.paused = !0),
			(this.emitClose = e.emitClose !== !1),
			(this.autoDestroy = !!e.autoDestroy),
			(this.destroyed = !1),
			(this.defaultEncoding = e.defaultEncoding || "utf8"),
			(this.awaitDrain = 0),
			(this.readingMore = !1),
			(this.decoder = null),
			(this.encoding = null),
			e.encoding &&
				(oy || (oy = X3().StringDecoder), (this.decoder = new oy(e.encoding)), (this.encoding = e.encoding))
	}
	function Dr(e) {
		if (((sy = sy || qp()), !(this instanceof Dr))) return new Dr(e)
		var t = this instanceof sy
		;(this._readableState = new Hhe(e, this, t)),
			(this.readable = !0),
			e &&
				(typeof e.read == "function" && (this._read = e.read),
				typeof e.destroy == "function" && (this._destroy = e.destroy)),
			Jb.call(this)
	}
	Object.defineProperty(Dr.prototype, "destroyed", {
		enumerable: !1,
		get: function () {
			return this._readableState === void 0 ? !1 : this._readableState.destroyed
		},
		set: function (t) {
			this._readableState && (this._readableState.destroyed = t)
		},
	})
	Dr.prototype.destroy = lH.destroy
	Dr.prototype._undestroy = lH.undestroy
	Dr.prototype._destroy = function (e, t) {
		t(e)
	}
	Dr.prototype.push = function (e, t) {
		var r = this._readableState,
			n
		return (
			r.objectMode
				? (n = !0)
				: typeof e == "string" &&
					((t = t || r.defaultEncoding), t !== r.encoding && ((e = lR.from(e, t)), (t = "")), (n = !0)),
			Whe(this, e, t, !1, n)
		)
	}
	Dr.prototype.unshift = function (e) {
		return Whe(this, e, null, !0, !1)
	}
	function Whe(e, t, r, n, i) {
		er("readableAddChunk", t)
		var s = e._readableState
		if (t === null) (s.reading = !1), Tst(e, s)
		else {
			var o
			if ((i || (o = Bst(s, t)), o)) Kb(e, o)
			else if (s.objectMode || (t && t.length > 0))
				if (
					(typeof t != "string" && !s.objectMode && Object.getPrototypeOf(t) !== lR.prototype && (t = yst(t)),
					n)
				)
					s.endEmitted ? Kb(e, new Ist()) : sH(e, s, t, !0)
				else if (s.ended) Kb(e, new _st())
				else {
					if (s.destroyed) return !1
					;(s.reading = !1),
						s.decoder && !r
							? ((t = s.decoder.write(t)), s.objectMode || t.length !== 0 ? sH(e, s, t, !1) : aH(e, s))
							: sH(e, s, t, !1)
				}
			else n || ((s.reading = !1), aH(e, s))
		}
		return !s.ended && (s.length < s.highWaterMark || s.length === 0)
	}
	function sH(e, t, r, n) {
		t.flowing && t.length === 0 && !t.sync
			? ((t.awaitDrain = 0), e.emit("data", r))
			: ((t.length += t.objectMode ? 1 : r.length),
				n ? t.buffer.unshift(r) : t.buffer.push(r),
				t.needReadable && uR(e)),
			aH(e, t)
	}
	function Bst(e, t) {
		var r
		return (
			!Cst(t) &&
				typeof t != "string" &&
				t !== void 0 &&
				!e.objectMode &&
				(r = new xst("chunk", ["string", "Buffer", "Uint8Array"], t)),
			r
		)
	}
	Dr.prototype.isPaused = function () {
		return this._readableState.flowing === !1
	}
	Dr.prototype.setEncoding = function (e) {
		oy || (oy = X3().StringDecoder)
		var t = new oy(e)
		;(this._readableState.decoder = t), (this._readableState.encoding = this._readableState.decoder.encoding)
		for (var r = this._readableState.buffer.head, n = ""; r !== null; ) (n += t.write(r.data)), (r = r.next)
		return (
			this._readableState.buffer.clear(),
			n !== "" && this._readableState.buffer.push(n),
			(this._readableState.length = n.length),
			this
		)
	}
	var Ohe = 1073741824
	function Dst(e) {
		return (
			e >= Ohe
				? (e = Ohe)
				: (e--, (e |= e >>> 1), (e |= e >>> 2), (e |= e >>> 4), (e |= e >>> 8), (e |= e >>> 16), e++),
			e
		)
	}
	function qhe(e, t) {
		return e <= 0 || (t.length === 0 && t.ended)
			? 0
			: t.objectMode
				? 1
				: e !== e
					? t.flowing && t.length
						? t.buffer.head.data.length
						: t.length
					: (e > t.highWaterMark && (t.highWaterMark = Dst(e)),
						e <= t.length ? e : t.ended ? t.length : ((t.needReadable = !0), 0))
	}
	Dr.prototype.read = function (e) {
		er("read", e), (e = parseInt(e, 10))
		var t = this._readableState,
			r = e
		if (
			(e !== 0 && (t.emittedReadable = !1),
			e === 0 &&
				t.needReadable &&
				((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
		)
			return er("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? oH(this) : uR(this), null
		if (((e = qhe(e, t)), e === 0 && t.ended)) return t.length === 0 && oH(this), null
		var n = t.needReadable
		er("need readable", n),
			(t.length === 0 || t.length - e < t.highWaterMark) && ((n = !0), er("length less than watermark", n)),
			t.ended || t.reading
				? ((n = !1), er("reading or ended", n))
				: n &&
					(er("do read"),
					(t.reading = !0),
					(t.sync = !0),
					t.length === 0 && (t.needReadable = !0),
					this._read(t.highWaterMark),
					(t.sync = !1),
					t.reading || (e = qhe(r, t)))
		var i
		return (
			e > 0 ? (i = Yhe(e, t)) : (i = null),
			i === null
				? ((t.needReadable = t.length <= t.highWaterMark), (e = 0))
				: ((t.length -= e), (t.awaitDrain = 0)),
			t.length === 0 && (t.ended || (t.needReadable = !0), r !== e && t.ended && oH(this)),
			i !== null && this.emit("data", i),
			i
		)
	}
	function Tst(e, t) {
		if ((er("onEofChunk"), !t.ended)) {
			if (t.decoder) {
				var r = t.decoder.end()
				r && r.length && (t.buffer.push(r), (t.length += t.objectMode ? 1 : r.length))
			}
			;(t.ended = !0),
				t.sync ? uR(e) : ((t.needReadable = !1), t.emittedReadable || ((t.emittedReadable = !0), Ghe(e)))
		}
	}
	function uR(e) {
		var t = e._readableState
		er("emitReadable", t.needReadable, t.emittedReadable),
			(t.needReadable = !1),
			t.emittedReadable || (er("emitReadable", t.flowing), (t.emittedReadable = !0), process.nextTick(Ghe, e))
	}
	function Ghe(e) {
		var t = e._readableState
		er("emitReadable_", t.destroyed, t.length, t.ended),
			!t.destroyed && (t.length || t.ended) && (e.emit("readable"), (t.emittedReadable = !1)),
			(t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark),
			cH(e)
	}
	function aH(e, t) {
		t.readingMore || ((t.readingMore = !0), process.nextTick(Rst, e, t))
	}
	function Rst(e, t) {
		for (; !t.reading && !t.ended && (t.length < t.highWaterMark || (t.flowing && t.length === 0)); ) {
			var r = t.length
			if ((er("maybeReadMore read 0"), e.read(0), r === t.length)) break
		}
		t.readingMore = !1
	}
	Dr.prototype._read = function (e) {
		Kb(this, new wst("_read()"))
	}
	Dr.prototype.pipe = function (e, t) {
		var r = this,
			n = this._readableState
		switch (n.pipesCount) {
			case 0:
				n.pipes = e
				break
			case 1:
				n.pipes = [n.pipes, e]
				break
			default:
				n.pipes.push(e)
				break
		}
		;(n.pipesCount += 1), er("pipe count=%d opts=%j", n.pipesCount, t)
		var i = (!t || t.end !== !1) && e !== process.stdout && e !== process.stderr,
			s = i ? a : y
		n.endEmitted ? process.nextTick(s) : r.once("end", s), e.on("unpipe", o)
		function o(C, v) {
			er("onunpipe"), C === r && v && v.hasUnpiped === !1 && ((v.hasUnpiped = !0), u())
		}
		function a() {
			er("onend"), e.end()
		}
		var l = kst(r)
		e.on("drain", l)
		var c = !1
		function u() {
			er("cleanup"),
				e.removeListener("close", g),
				e.removeListener("finish", m),
				e.removeListener("drain", l),
				e.removeListener("error", p),
				e.removeListener("unpipe", o),
				r.removeListener("end", a),
				r.removeListener("end", y),
				r.removeListener("data", f),
				(c = !0),
				n.awaitDrain && (!e._writableState || e._writableState.needDrain) && l()
		}
		r.on("data", f)
		function f(C) {
			er("ondata")
			var v = e.write(C)
			er("dest.write", v),
				v === !1 &&
					(((n.pipesCount === 1 && n.pipes === e) || (n.pipesCount > 1 && Khe(n.pipes, e) !== -1)) &&
						!c &&
						(er("false write response, pause", n.awaitDrain), n.awaitDrain++),
					r.pause())
		}
		function p(C) {
			er("onerror", C), y(), e.removeListener("error", p), Vhe(e, "error") === 0 && Kb(e, C)
		}
		Sst(e, "error", p)
		function g() {
			e.removeListener("finish", m), y()
		}
		e.once("close", g)
		function m() {
			er("onfinish"), e.removeListener("close", g), y()
		}
		e.once("finish", m)
		function y() {
			er("unpipe"), r.unpipe(e)
		}
		return e.emit("pipe", r), n.flowing || (er("pipe resume"), r.resume()), e
	}
	function kst(e) {
		return function () {
			var r = e._readableState
			er("pipeOnDrain", r.awaitDrain),
				r.awaitDrain && r.awaitDrain--,
				r.awaitDrain === 0 && Vhe(e, "data") && ((r.flowing = !0), cH(e))
		}
	}
	Dr.prototype.unpipe = function (e) {
		var t = this._readableState,
			r = { hasUnpiped: !1 }
		if (t.pipesCount === 0) return this
		if (t.pipesCount === 1)
			return e && e !== t.pipes
				? this
				: (e || (e = t.pipes),
					(t.pipes = null),
					(t.pipesCount = 0),
					(t.flowing = !1),
					e && e.emit("unpipe", this, r),
					this)
		if (!e) {
			var n = t.pipes,
				i = t.pipesCount
			;(t.pipes = null), (t.pipesCount = 0), (t.flowing = !1)
			for (var s = 0; s < i; s++) n[s].emit("unpipe", this, { hasUnpiped: !1 })
			return this
		}
		var o = Khe(t.pipes, e)
		return o === -1
			? this
			: (t.pipes.splice(o, 1),
				(t.pipesCount -= 1),
				t.pipesCount === 1 && (t.pipes = t.pipes[0]),
				e.emit("unpipe", this, r),
				this)
	}
	Dr.prototype.on = function (e, t) {
		var r = Jb.prototype.on.call(this, e, t),
			n = this._readableState
		return (
			e === "data"
				? ((n.readableListening = this.listenerCount("readable") > 0), n.flowing !== !1 && this.resume())
				: e === "readable" &&
					!n.endEmitted &&
					!n.readableListening &&
					((n.readableListening = n.needReadable = !0),
					(n.flowing = !1),
					(n.emittedReadable = !1),
					er("on readable", n.length, n.reading),
					n.length ? uR(this) : n.reading || process.nextTick(Mst, this)),
			r
		)
	}
	Dr.prototype.addListener = Dr.prototype.on
	Dr.prototype.removeListener = function (e, t) {
		var r = Jb.prototype.removeListener.call(this, e, t)
		return e === "readable" && process.nextTick($he, this), r
	}
	Dr.prototype.removeAllListeners = function (e) {
		var t = Jb.prototype.removeAllListeners.apply(this, arguments)
		return (e === "readable" || e === void 0) && process.nextTick($he, this), t
	}
	function $he(e) {
		var t = e._readableState
		;(t.readableListening = e.listenerCount("readable") > 0),
			t.resumeScheduled && !t.paused ? (t.flowing = !0) : e.listenerCount("data") > 0 && e.resume()
	}
	function Mst(e) {
		er("readable nexttick read 0"), e.read(0)
	}
	Dr.prototype.resume = function () {
		var e = this._readableState
		return e.flowing || (er("resume"), (e.flowing = !e.readableListening), Fst(this, e)), (e.paused = !1), this
	}
	function Fst(e, t) {
		t.resumeScheduled || ((t.resumeScheduled = !0), process.nextTick(Qst, e, t))
	}
	function Qst(e, t) {
		er("resume", t.reading),
			t.reading || e.read(0),
			(t.resumeScheduled = !1),
			e.emit("resume"),
			cH(e),
			t.flowing && !t.reading && e.read(0)
	}
	Dr.prototype.pause = function () {
		return (
			er("call pause flowing=%j", this._readableState.flowing),
			this._readableState.flowing !== !1 && (er("pause"), (this._readableState.flowing = !1), this.emit("pause")),
			(this._readableState.paused = !0),
			this
		)
	}
	function cH(e) {
		var t = e._readableState
		for (er("flow", t.flowing); t.flowing && e.read() !== null; );
	}
	Dr.prototype.wrap = function (e) {
		var t = this,
			r = this._readableState,
			n = !1
		e.on("end", function () {
			if ((er("wrapped end"), r.decoder && !r.ended)) {
				var o = r.decoder.end()
				o && o.length && t.push(o)
			}
			t.push(null)
		}),
			e.on("data", function (o) {
				if (
					(er("wrapped data"),
					r.decoder && (o = r.decoder.write(o)),
					!(r.objectMode && o == null) && !(!r.objectMode && (!o || !o.length)))
				) {
					var a = t.push(o)
					a || ((n = !0), e.pause())
				}
			})
		for (var i in e)
			this[i] === void 0 &&
				typeof e[i] == "function" &&
				(this[i] = (function (a) {
					return function () {
						return e[a].apply(e, arguments)
					}
				})(i))
		for (var s = 0; s < iH.length; s++) e.on(iH[s], this.emit.bind(this, iH[s]))
		return (
			(this._read = function (o) {
				er("wrapped _read", o), n && ((n = !1), e.resume())
			}),
			this
		)
	}
	typeof Symbol == "function" &&
		(Dr.prototype[Symbol.asyncIterator] = function () {
			return rH === void 0 && (rH = Qhe()), rH(this)
		})
	Object.defineProperty(Dr.prototype, "readableHighWaterMark", {
		enumerable: !1,
		get: function () {
			return this._readableState.highWaterMark
		},
	})
	Object.defineProperty(Dr.prototype, "readableBuffer", {
		enumerable: !1,
		get: function () {
			return this._readableState && this._readableState.buffer
		},
	})
	Object.defineProperty(Dr.prototype, "readableFlowing", {
		enumerable: !1,
		get: function () {
			return this._readableState.flowing
		},
		set: function (t) {
			this._readableState && (this._readableState.flowing = t)
		},
	})
	Dr._fromList = Yhe
	Object.defineProperty(Dr.prototype, "readableLength", {
		enumerable: !1,
		get: function () {
			return this._readableState.length
		},
	})
	function Yhe(e, t) {
		if (t.length === 0) return null
		var r
		return (
			t.objectMode
				? (r = t.buffer.shift())
				: !e || e >= t.length
					? (t.decoder
							? (r = t.buffer.join(""))
							: t.buffer.length === 1
								? (r = t.buffer.first())
								: (r = t.buffer.concat(t.length)),
						t.buffer.clear())
					: (r = t.buffer.consume(e, t.decoder)),
			r
		)
	}
	function oH(e) {
		var t = e._readableState
		er("endReadable", t.endEmitted), t.endEmitted || ((t.ended = !0), process.nextTick(Nst, t, e))
	}
	function Nst(e, t) {
		if (
			(er("endReadableNT", e.endEmitted, e.length),
			!e.endEmitted && e.length === 0 && ((e.endEmitted = !0), (t.readable = !1), t.emit("end"), e.autoDestroy))
		) {
			var r = t._writableState
			;(!r || (r.autoDestroy && r.finished)) && t.destroy()
		}
	}
	typeof Symbol == "function" &&
		(Dr.from = function (e, t) {
			return nH === void 0 && (nH = Uhe()), nH(Dr, e, t)
		})
	function Khe(e, t) {
		for (var r = 0, n = e.length; r < n; r++) if (e[r] === t) return r
		return -1
	}
})
var qp = x((gTt, jhe) => {
	"use strict"
	var Pst =
		Object.keys ||
		function (e) {
			var t = []
			for (var r in e) t.push(r)
			return t
		}
	jhe.exports = bu
	var zhe = uH(),
		fH = hR()
	iy()(bu, zhe)
	for (dH = Pst(fH.prototype), dR = 0; dR < dH.length; dR++)
		(fR = dH[dR]), bu.prototype[fR] || (bu.prototype[fR] = fH.prototype[fR])
	var dH, fR, dR
	function bu(e) {
		if (!(this instanceof bu)) return new bu(e)
		zhe.call(this, e),
			fH.call(this, e),
			(this.allowHalfOpen = !0),
			e &&
				(e.readable === !1 && (this.readable = !1),
				e.writable === !1 && (this.writable = !1),
				e.allowHalfOpen === !1 && ((this.allowHalfOpen = !1), this.once("end", Lst)))
	}
	Object.defineProperty(bu.prototype, "writableHighWaterMark", {
		enumerable: !1,
		get: function () {
			return this._writableState.highWaterMark
		},
	})
	Object.defineProperty(bu.prototype, "writableBuffer", {
		enumerable: !1,
		get: function () {
			return this._writableState && this._writableState.getBuffer()
		},
	})
	Object.defineProperty(bu.prototype, "writableLength", {
		enumerable: !1,
		get: function () {
			return this._writableState.length
		},
	})
	function Lst() {
		this._writableState.ended || process.nextTick(Ust, this)
	}
	function Ust(e) {
		e.end()
	}
	Object.defineProperty(bu.prototype, "destroyed", {
		enumerable: !1,
		get: function () {
			return this._readableState === void 0 || this._writableState === void 0
				? !1
				: this._readableState.destroyed && this._writableState.destroyed
		},
		set: function (t) {
			this._readableState === void 0 ||
				this._writableState === void 0 ||
				((this._readableState.destroyed = t), (this._writableState.destroyed = t))
		},
	})
})
var hR = x((pTt, nge) => {
	"use strict"
	nge.exports = si
	function Xhe(e) {
		var t = this
		;(this.next = null),
			(this.entry = null),
			(this.finish = function () {
				fot(t, e)
			})
	}
	var ay
	si.WritableState = jb
	var Ost = { deprecate: dhe() },
		ege = V3(),
		pR = require("buffer").Buffer,
		qst =
			(typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array ||
			function () {}
	function Vst(e) {
		return pR.from(e)
	}
	function Hst(e) {
		return pR.isBuffer(e) || e instanceof qst
	}
	var gH = W3(),
		Wst = G3(),
		Gst = Wst.getHighWaterMark,
		Bh = _h().codes,
		$st = Bh.ERR_INVALID_ARG_TYPE,
		Yst = Bh.ERR_METHOD_NOT_IMPLEMENTED,
		Kst = Bh.ERR_MULTIPLE_CALLBACK,
		Jst = Bh.ERR_STREAM_CANNOT_PIPE,
		zst = Bh.ERR_STREAM_DESTROYED,
		jst = Bh.ERR_STREAM_NULL_VALUES,
		Zst = Bh.ERR_STREAM_WRITE_AFTER_END,
		Xst = Bh.ERR_UNKNOWN_ENCODING,
		ly = gH.errorOrDestroy
	iy()(si, ege)
	function eot() {}
	function jb(e, t, r) {
		;(ay = ay || qp()),
			(e = e || {}),
			typeof r != "boolean" && (r = t instanceof ay),
			(this.objectMode = !!e.objectMode),
			r && (this.objectMode = this.objectMode || !!e.writableObjectMode),
			(this.highWaterMark = Gst(this, e, "writableHighWaterMark", r)),
			(this.finalCalled = !1),
			(this.needDrain = !1),
			(this.ending = !1),
			(this.ended = !1),
			(this.finished = !1),
			(this.destroyed = !1)
		var n = e.decodeStrings === !1
		;(this.decodeStrings = !n),
			(this.defaultEncoding = e.defaultEncoding || "utf8"),
			(this.length = 0),
			(this.writing = !1),
			(this.corked = 0),
			(this.sync = !0),
			(this.bufferProcessing = !1),
			(this.onwrite = function (i) {
				aot(t, i)
			}),
			(this.writecb = null),
			(this.writelen = 0),
			(this.bufferedRequest = null),
			(this.lastBufferedRequest = null),
			(this.pendingcb = 0),
			(this.prefinished = !1),
			(this.errorEmitted = !1),
			(this.emitClose = e.emitClose !== !1),
			(this.autoDestroy = !!e.autoDestroy),
			(this.bufferedRequestCount = 0),
			(this.corkedRequestsFree = new Xhe(this))
	}
	jb.prototype.getBuffer = function () {
		for (var t = this.bufferedRequest, r = []; t; ) r.push(t), (t = t.next)
		return r
	}
	;(function () {
		try {
			Object.defineProperty(jb.prototype, "buffer", {
				get: Ost.deprecate(
					function () {
						return this.getBuffer()
					},
					"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.",
					"DEP0003",
				),
			})
		} catch {}
	})()
	var gR
	typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function"
		? ((gR = Function.prototype[Symbol.hasInstance]),
			Object.defineProperty(si, Symbol.hasInstance, {
				value: function (t) {
					return gR.call(this, t) ? !0 : this !== si ? !1 : t && t._writableState instanceof jb
				},
			}))
		: (gR = function (t) {
				return t instanceof this
			})
	function si(e) {
		ay = ay || qp()
		var t = this instanceof ay
		if (!t && !gR.call(si, this)) return new si(e)
		;(this._writableState = new jb(e, this, t)),
			(this.writable = !0),
			e &&
				(typeof e.write == "function" && (this._write = e.write),
				typeof e.writev == "function" && (this._writev = e.writev),
				typeof e.destroy == "function" && (this._destroy = e.destroy),
				typeof e.final == "function" && (this._final = e.final)),
			ege.call(this)
	}
	si.prototype.pipe = function () {
		ly(this, new Jst())
	}
	function tot(e, t) {
		var r = new Zst()
		ly(e, r), process.nextTick(t, r)
	}
	function rot(e, t, r, n) {
		var i
		return (
			r === null
				? (i = new jst())
				: typeof r != "string" && !t.objectMode && (i = new $st("chunk", ["string", "Buffer"], r)),
			i ? (ly(e, i), process.nextTick(n, i), !1) : !0
		)
	}
	si.prototype.write = function (e, t, r) {
		var n = this._writableState,
			i = !1,
			s = !n.objectMode && Hst(e)
		return (
			s && !pR.isBuffer(e) && (e = Vst(e)),
			typeof t == "function" && ((r = t), (t = null)),
			s ? (t = "buffer") : t || (t = n.defaultEncoding),
			typeof r != "function" && (r = eot),
			n.ending ? tot(this, r) : (s || rot(this, n, e, r)) && (n.pendingcb++, (i = iot(this, n, s, e, t, r))),
			i
		)
	}
	si.prototype.cork = function () {
		this._writableState.corked++
	}
	si.prototype.uncork = function () {
		var e = this._writableState
		e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && tge(this, e))
	}
	si.prototype.setDefaultEncoding = function (t) {
		if (
			(typeof t == "string" && (t = t.toLowerCase()),
			!(
				[
					"hex",
					"utf8",
					"utf-8",
					"ascii",
					"binary",
					"base64",
					"ucs2",
					"ucs-2",
					"utf16le",
					"utf-16le",
					"raw",
				].indexOf((t + "").toLowerCase()) > -1
			))
		)
			throw new Xst(t)
		return (this._writableState.defaultEncoding = t), this
	}
	Object.defineProperty(si.prototype, "writableBuffer", {
		enumerable: !1,
		get: function () {
			return this._writableState && this._writableState.getBuffer()
		},
	})
	function not(e, t, r) {
		return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = pR.from(t, r)), t
	}
	Object.defineProperty(si.prototype, "writableHighWaterMark", {
		enumerable: !1,
		get: function () {
			return this._writableState.highWaterMark
		},
	})
	function iot(e, t, r, n, i, s) {
		if (!r) {
			var o = not(t, n, i)
			n !== o && ((r = !0), (i = "buffer"), (n = o))
		}
		var a = t.objectMode ? 1 : n.length
		t.length += a
		var l = t.length < t.highWaterMark
		if ((l || (t.needDrain = !0), t.writing || t.corked)) {
			var c = t.lastBufferedRequest
			;(t.lastBufferedRequest = {
				chunk: n,
				encoding: i,
				isBuf: r,
				callback: s,
				next: null,
			}),
				c ? (c.next = t.lastBufferedRequest) : (t.bufferedRequest = t.lastBufferedRequest),
				(t.bufferedRequestCount += 1)
		} else hH(e, t, !1, a, n, i, s)
		return l
	}
	function hH(e, t, r, n, i, s, o) {
		;(t.writelen = n),
			(t.writecb = o),
			(t.writing = !0),
			(t.sync = !0),
			t.destroyed ? t.onwrite(new zst("write")) : r ? e._writev(i, t.onwrite) : e._write(i, s, t.onwrite),
			(t.sync = !1)
	}
	function sot(e, t, r, n, i) {
		--t.pendingcb,
			r
				? (process.nextTick(i, n), process.nextTick(zb, e, t), (e._writableState.errorEmitted = !0), ly(e, n))
				: (i(n), (e._writableState.errorEmitted = !0), ly(e, n), zb(e, t))
	}
	function oot(e) {
		;(e.writing = !1), (e.writecb = null), (e.length -= e.writelen), (e.writelen = 0)
	}
	function aot(e, t) {
		var r = e._writableState,
			n = r.sync,
			i = r.writecb
		if (typeof i != "function") throw new Kst()
		if ((oot(r), t)) sot(e, r, n, t, i)
		else {
			var s = rge(r) || e.destroyed
			!s && !r.corked && !r.bufferProcessing && r.bufferedRequest && tge(e, r),
				n ? process.nextTick(Zhe, e, r, s, i) : Zhe(e, r, s, i)
		}
	}
	function Zhe(e, t, r, n) {
		r || lot(e, t), t.pendingcb--, n(), zb(e, t)
	}
	function lot(e, t) {
		t.length === 0 && t.needDrain && ((t.needDrain = !1), e.emit("drain"))
	}
	function tge(e, t) {
		t.bufferProcessing = !0
		var r = t.bufferedRequest
		if (e._writev && r && r.next) {
			var n = t.bufferedRequestCount,
				i = new Array(n),
				s = t.corkedRequestsFree
			s.entry = r
			for (var o = 0, a = !0; r; ) (i[o] = r), r.isBuf || (a = !1), (r = r.next), (o += 1)
			;(i.allBuffers = a),
				hH(e, t, !0, t.length, i, "", s.finish),
				t.pendingcb++,
				(t.lastBufferedRequest = null),
				s.next ? ((t.corkedRequestsFree = s.next), (s.next = null)) : (t.corkedRequestsFree = new Xhe(t)),
				(t.bufferedRequestCount = 0)
		} else {
			for (; r; ) {
				var l = r.chunk,
					c = r.encoding,
					u = r.callback,
					f = t.objectMode ? 1 : l.length
				if ((hH(e, t, !1, f, l, c, u), (r = r.next), t.bufferedRequestCount--, t.writing)) break
			}
			r === null && (t.lastBufferedRequest = null)
		}
		;(t.bufferedRequest = r), (t.bufferProcessing = !1)
	}
	si.prototype._write = function (e, t, r) {
		r(new Yst("_write()"))
	}
	si.prototype._writev = null
	si.prototype.end = function (e, t, r) {
		var n = this._writableState
		return (
			typeof e == "function"
				? ((r = e), (e = null), (t = null))
				: typeof t == "function" && ((r = t), (t = null)),
			e != null && this.write(e, t),
			n.corked && ((n.corked = 1), this.uncork()),
			n.ending || dot(this, n, r),
			this
		)
	}
	Object.defineProperty(si.prototype, "writableLength", {
		enumerable: !1,
		get: function () {
			return this._writableState.length
		},
	})
	function rge(e) {
		return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing
	}
	function cot(e, t) {
		e._final(function (r) {
			t.pendingcb--, r && ly(e, r), (t.prefinished = !0), e.emit("prefinish"), zb(e, t)
		})
	}
	function uot(e, t) {
		!t.prefinished &&
			!t.finalCalled &&
			(typeof e._final == "function" && !t.destroyed
				? (t.pendingcb++, (t.finalCalled = !0), process.nextTick(cot, e, t))
				: ((t.prefinished = !0), e.emit("prefinish")))
	}
	function zb(e, t) {
		var r = rge(t)
		if (r && (uot(e, t), t.pendingcb === 0 && ((t.finished = !0), e.emit("finish"), t.autoDestroy))) {
			var n = e._readableState
			;(!n || (n.autoDestroy && n.endEmitted)) && e.destroy()
		}
		return r
	}
	function dot(e, t, r) {
		;(t.ending = !0),
			zb(e, t),
			r && (t.finished ? process.nextTick(r) : e.once("finish", r)),
			(t.ended = !0),
			(e.writable = !1)
	}
	function fot(e, t, r) {
		var n = e.entry
		for (e.entry = null; n; ) {
			var i = n.callback
			t.pendingcb--, i(r), (n = n.next)
		}
		t.corkedRequestsFree.next = e
	}
	Object.defineProperty(si.prototype, "destroyed", {
		enumerable: !1,
		get: function () {
			return this._writableState === void 0 ? !1 : this._writableState.destroyed
		},
		set: function (t) {
			this._writableState && (this._writableState.destroyed = t)
		},
	})
	si.prototype.destroy = gH.destroy
	si.prototype._undestroy = gH.undestroy
	si.prototype._destroy = function (e, t) {
		t(e)
	}
})
var AH = x((ATt, sge) => {
	"use strict"
	var hot = require("util"),
		{ LEVEL: pH } = Bi(),
		ige = Dh(),
		Zb = (sge.exports = function (t = {}) {
			if ((ige.call(this, t), !t.transport || typeof t.transport.log != "function"))
				throw new Error("Invalid transport, must be an object with a log method.")
			;(this.transport = t.transport),
				(this.level = this.level || t.transport.level),
				(this.handleExceptions = this.handleExceptions || t.transport.handleExceptions),
				this._deprecated()
			function r(n) {
				this.emit("error", n, this.transport)
			}
			this.transport.__winstonError ||
				((this.transport.__winstonError = r.bind(this)),
				this.transport.on("error", this.transport.__winstonError))
		})
	hot.inherits(Zb, ige)
	Zb.prototype._write = function (t, r, n) {
		if (this.silent || (t.exception === !0 && !this.handleExceptions)) return n(null)
		;(!this.level || this.levels[this.level] >= this.levels[t[pH]]) &&
			this.transport.log(t[pH], t.message, t, this._nop),
			n(null)
	}
	Zb.prototype._writev = function (t, r) {
		for (let n = 0; n < t.length; n++)
			this._accept(t[n]) &&
				(this.transport.log(t[n].chunk[pH], t[n].chunk.message, t[n].chunk, this._nop), t[n].callback())
		return r(null)
	}
	Zb.prototype._deprecated = function () {
		console.error(
			[
				`${this.transport.name} is a legacy winston transport. Consider upgrading: `,
				"- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md",
			].join(`
`),
		)
	}
	Zb.prototype.close = function () {
		this.transport.close && this.transport.close(),
			this.transport.__winstonError &&
				(this.transport.removeListener("error", this.transport.__winstonError),
				(this.transport.__winstonError = null))
	}
})
var Dh = x((mTt, mH) => {
	"use strict"
	var got = require("util"),
		oge = hR(),
		{ LEVEL: age } = Bi(),
		Xb = (mH.exports = function (t = {}) {
			oge.call(this, { objectMode: !0, highWaterMark: t.highWaterMark }),
				(this.format = t.format),
				(this.level = t.level),
				(this.handleExceptions = t.handleExceptions),
				(this.handleRejections = t.handleRejections),
				(this.silent = t.silent),
				t.log && (this.log = t.log),
				t.logv && (this.logv = t.logv),
				t.close && (this.close = t.close),
				this.once("pipe", (r) => {
					;(this.levels = r.levels), (this.parent = r)
				}),
				this.once("unpipe", (r) => {
					r === this.parent && ((this.parent = null), this.close && this.close())
				})
		})
	got.inherits(Xb, oge)
	Xb.prototype._write = function (t, r, n) {
		if (this.silent || (t.exception === !0 && !this.handleExceptions)) return n(null)
		let i = this.level || (this.parent && this.parent.level)
		if (!i || this.levels[i] >= this.levels[t[age]]) {
			if (t && !this.format) return this.log(t, n)
			let s, o
			try {
				o = this.format.transform(Object.assign({}, t), this.format.options)
			} catch (a) {
				s = a
			}
			if (s || !o) {
				if ((n(), s)) throw s
				return
			}
			return this.log(o, n)
		}
		return (this._writableState.sync = !1), n(null)
	}
	Xb.prototype._writev = function (t, r) {
		if (this.logv) {
			let n = t.filter(this._accept, this)
			return n.length ? this.logv(n, r) : r(null)
		}
		for (let n = 0; n < t.length; n++) {
			if (!this._accept(t[n])) continue
			if (t[n].chunk && !this.format) {
				this.log(t[n].chunk, t[n].callback)
				continue
			}
			let i, s
			try {
				s = this.format.transform(Object.assign({}, t[n].chunk), this.format.options)
			} catch (o) {
				i = o
			}
			if (i || !s) {
				if ((t[n].callback(), i)) throw (r(null), i)
			} else this.log(s, t[n].callback)
		}
		return r(null)
	}
	Xb.prototype._accept = function (t) {
		let r = t.chunk
		if (this.silent) return !1
		let n = this.level || (this.parent && this.parent.level)
		return !!(
			(r.exception === !0 || !n || this.levels[n] >= this.levels[r[age]]) &&
			(this.handleExceptions || r.exception !== !0)
		)
	}
	Xb.prototype._nop = function () {}
	mH.exports.LegacyTransportStream = AH()
})
var uge = x((CTt, cge) => {
	"use strict"
	var pot = require("os"),
		{ LEVEL: lge, MESSAGE: cy } = Bi(),
		Aot = Dh()
	cge.exports = class extends Aot {
		constructor(t = {}) {
			super(t),
				(this.name = t.name || "console"),
				(this.stderrLevels = this._stringArrayToSet(t.stderrLevels)),
				(this.consoleWarnLevels = this._stringArrayToSet(t.consoleWarnLevels)),
				(this.eol = typeof t.eol == "string" ? t.eol : pot.EOL),
				this.setMaxListeners(30)
		}
		log(t, r) {
			if ((setImmediate(() => this.emit("logged", t)), this.stderrLevels[t[lge]])) {
				console._stderr ? console._stderr.write(`${t[cy]}${this.eol}`) : console.error(t[cy]), r && r()
				return
			} else if (this.consoleWarnLevels[t[lge]]) {
				console._stderr ? console._stderr.write(`${t[cy]}${this.eol}`) : console.warn(t[cy]), r && r()
				return
			}
			console._stdout ? console._stdout.write(`${t[cy]}${this.eol}`) : console.log(t[cy]), r && r()
		}
		_stringArrayToSet(t, r) {
			if (!t) return {}
			if (((r = r || "Cannot make set from type other than Array of string elements"), !Array.isArray(t)))
				throw new Error(r)
			return t.reduce((n, i) => {
				if (typeof i != "string") throw new Error(r)
				return (n[i] = !0), n
			}, {})
		}
	}
})
var mR = x((AR, dge) => {
	"use strict"
	Object.defineProperty(AR, "__esModule", { value: !0 })
	AR.default = mot
	function mot(e) {
		return e && typeof e.length == "number" && e.length >= 0 && e.length % 1 === 0
	}
	dge.exports = AR.default
})
var hge = x((yR, fge) => {
	"use strict"
	Object.defineProperty(yR, "__esModule", { value: !0 })
	yR.default = function (e) {
		return function (...t) {
			var r = t.pop()
			return e.call(this, t, r)
		}
	}
	fge.exports = yR.default
})
var Age = x((Th) => {
	"use strict"
	Object.defineProperty(Th, "__esModule", { value: !0 })
	Th.fallback = gge
	Th.wrap = pge
	var yot = (Th.hasQueueMicrotask = typeof queueMicrotask == "function" && queueMicrotask),
		Cot = (Th.hasSetImmediate = typeof setImmediate == "function" && setImmediate),
		vot = (Th.hasNextTick = typeof process == "object" && typeof process.nextTick == "function")
	function gge(e) {
		setTimeout(e, 0)
	}
	function pge(e) {
		return (t, ...r) => e(() => t(...r))
	}
	var ex
	yot ? (ex = queueMicrotask) : Cot ? (ex = setImmediate) : vot ? (ex = process.nextTick) : (ex = gge)
	Th.default = pge(ex)
})
var Ege = x((CR, vge) => {
	"use strict"
	Object.defineProperty(CR, "__esModule", { value: !0 })
	CR.default = Iot
	var Eot = hge(),
		bot = Cge(Eot),
		xot = Age(),
		_ot = Cge(xot),
		wot = Vp()
	function Cge(e) {
		return e && e.__esModule ? e : { default: e }
	}
	function Iot(e) {
		return (0, wot.isAsync)(e)
			? function (...t) {
					let r = t.pop(),
						n = e.apply(this, t)
					return mge(n, r)
				}
			: (0, bot.default)(function (t, r) {
					var n
					try {
						n = e.apply(this, t)
					} catch (i) {
						return r(i)
					}
					if (n && typeof n.then == "function") return mge(n, r)
					r(null, n)
				})
	}
	function mge(e, t) {
		return e.then(
			(r) => {
				yge(t, null, r)
			},
			(r) => {
				yge(t, r && (r instanceof Error || r.message) ? r : new Error(r))
			},
		)
	}
	function yge(e, t, r) {
		try {
			e(t, r)
		} catch (n) {
			;(0, _ot.default)((i) => {
				throw i
			}, n)
		}
	}
	vge.exports = CR.default
})
var Vp = x((Vd) => {
	"use strict"
	Object.defineProperty(Vd, "__esModule", { value: !0 })
	Vd.isAsyncIterable = Vd.isAsyncGenerator = Vd.isAsync = void 0
	var Sot = Ege(),
		Bot = Dot(Sot)
	function Dot(e) {
		return e && e.__esModule ? e : { default: e }
	}
	function bge(e) {
		return e[Symbol.toStringTag] === "AsyncFunction"
	}
	function Tot(e) {
		return e[Symbol.toStringTag] === "AsyncGenerator"
	}
	function Rot(e) {
		return typeof e[Symbol.asyncIterator] == "function"
	}
	function kot(e) {
		if (typeof e != "function") throw new Error("expected a function")
		return bge(e) ? (0, Bot.default)(e) : e
	}
	Vd.default = kot
	Vd.isAsync = bge
	Vd.isAsyncGenerator = Tot
	Vd.isAsyncIterable = Rot
})
var uy = x((vR, xge) => {
	"use strict"
	Object.defineProperty(vR, "__esModule", { value: !0 })
	vR.default = Mot
	function Mot(e, t) {
		if ((t || (t = e.length), !t)) throw new Error("arity is undefined")
		function r(...n) {
			return typeof n[t - 1] == "function"
				? e.apply(this, n)
				: new Promise((i, s) => {
						;(n[t - 1] = (o, ...a) => {
							if (o) return s(o)
							i(a.length > 1 ? a : a[0])
						}),
							e.apply(this, n)
					})
		}
		return r
	}
	xge.exports = vR.default
})
var wge = x((ER, _ge) => {
	"use strict"
	Object.defineProperty(ER, "__esModule", { value: !0 })
	var Fot = mR(),
		Qot = yH(Fot),
		Not = Vp(),
		Pot = yH(Not),
		Lot = uy(),
		Uot = yH(Lot)
	function yH(e) {
		return e && e.__esModule ? e : { default: e }
	}
	ER.default = (0, Uot.default)((e, t, r) => {
		var n = (0, Qot.default)(t) ? [] : {}
		e(
			t,
			(i, s, o) => {
				;(0, Pot.default)(i)((a, ...l) => {
					l.length < 2 && ([l] = l), (n[s] = l), o(a)
				})
			},
			(i) => r(i, n),
		)
	}, 3)
	_ge.exports = ER.default
})
var CH = x((bR, Ige) => {
	"use strict"
	Object.defineProperty(bR, "__esModule", { value: !0 })
	bR.default = Oot
	function Oot(e) {
		function t(...r) {
			if (e !== null) {
				var n = e
				;(e = null), n.apply(this, r)
			}
		}
		return Object.assign(t, e), t
	}
	Ige.exports = bR.default
})
var Bge = x((xR, Sge) => {
	"use strict"
	Object.defineProperty(xR, "__esModule", { value: !0 })
	xR.default = function (e) {
		return e[Symbol.iterator] && e[Symbol.iterator]()
	}
	Sge.exports = xR.default
})
var Rge = x((_R, Tge) => {
	"use strict"
	Object.defineProperty(_R, "__esModule", { value: !0 })
	_R.default = Kot
	var qot = mR(),
		Vot = Dge(qot),
		Hot = Bge(),
		Wot = Dge(Hot)
	function Dge(e) {
		return e && e.__esModule ? e : { default: e }
	}
	function Got(e) {
		var t = -1,
			r = e.length
		return function () {
			return ++t < r ? { value: e[t], key: t } : null
		}
	}
	function $ot(e) {
		var t = -1
		return function () {
			var n = e.next()
			return n.done ? null : (t++, { value: n.value, key: t })
		}
	}
	function Yot(e) {
		var t = e ? Object.keys(e) : [],
			r = -1,
			n = t.length
		return function i() {
			var s = t[++r]
			return s === "__proto__" ? i() : r < n ? { value: e[s], key: s } : null
		}
	}
	function Kot(e) {
		if ((0, Vot.default)(e)) return Got(e)
		var t = (0, Wot.default)(e)
		return t ? $ot(t) : Yot(e)
	}
	Tge.exports = _R.default
})
var vH = x((wR, kge) => {
	"use strict"
	Object.defineProperty(wR, "__esModule", { value: !0 })
	wR.default = Jot
	function Jot(e) {
		return function (...t) {
			if (e === null) throw new Error("Callback was already called.")
			var r = e
			;(e = null), r.apply(this, t)
		}
	}
	kge.exports = wR.default
})
var SR = x((IR, Mge) => {
	"use strict"
	Object.defineProperty(IR, "__esModule", { value: !0 })
	var zot = {}
	IR.default = zot
	Mge.exports = IR.default
})
var Qge = x((BR, Fge) => {
	"use strict"
	Object.defineProperty(BR, "__esModule", { value: !0 })
	BR.default = eat
	var jot = SR(),
		Zot = Xot(jot)
	function Xot(e) {
		return e && e.__esModule ? e : { default: e }
	}
	function eat(e, t, r, n) {
		let i = !1,
			s = !1,
			o = !1,
			a = 0,
			l = 0
		function c() {
			a >= t ||
				o ||
				i ||
				((o = !0),
				e
					.next()
					.then(({ value: p, done: g }) => {
						if (!(s || i)) {
							if (((o = !1), g)) {
								;(i = !0), a <= 0 && n(null)
								return
							}
							a++, r(p, l, u), l++, c()
						}
					})
					.catch(f))
		}
		function u(p, g) {
			if (((a -= 1), !s)) {
				if (p) return f(p)
				if (p === !1) {
					;(i = !0), (s = !0)
					return
				}
				if (g === Zot.default || (i && a <= 0)) return (i = !0), n(null)
				c()
			}
		}
		function f(p) {
			s || ((o = !1), (i = !0), n(p))
		}
		c()
	}
	Fge.exports = BR.default
})
var Uge = x((DR, Lge) => {
	"use strict"
	Object.defineProperty(DR, "__esModule", { value: !0 })
	var tat = CH(),
		rat = tx(tat),
		nat = Rge(),
		iat = tx(nat),
		sat = vH(),
		oat = tx(sat),
		Nge = Vp(),
		aat = Qge(),
		Pge = tx(aat),
		lat = SR(),
		cat = tx(lat)
	function tx(e) {
		return e && e.__esModule ? e : { default: e }
	}
	DR.default = (e) => (t, r, n) => {
		if (((n = (0, rat.default)(n)), e <= 0)) throw new RangeError("concurrency limit cannot be less than 1")
		if (!t) return n(null)
		if ((0, Nge.isAsyncGenerator)(t)) return (0, Pge.default)(t, e, r, n)
		if ((0, Nge.isAsyncIterable)(t)) return (0, Pge.default)(t[Symbol.asyncIterator](), e, r, n)
		var i = (0, iat.default)(t),
			s = !1,
			o = !1,
			a = 0,
			l = !1
		function c(f, p) {
			if (!o)
				if (((a -= 1), f)) (s = !0), n(f)
				else if (f === !1) (s = !0), (o = !0)
				else {
					if (p === cat.default || (s && a <= 0)) return (s = !0), n(null)
					l || u()
				}
		}
		function u() {
			for (l = !0; a < e && !s; ) {
				var f = i()
				if (f === null) {
					;(s = !0), a <= 0 && n(null)
					return
				}
				;(a += 1), r(f.value, f.key, (0, oat.default)(c))
			}
			l = !1
		}
		u()
	}
	Lge.exports = DR.default
})
var bH = x((TR, Oge) => {
	"use strict"
	Object.defineProperty(TR, "__esModule", { value: !0 })
	var uat = Uge(),
		dat = EH(uat),
		fat = Vp(),
		hat = EH(fat),
		gat = uy(),
		pat = EH(gat)
	function EH(e) {
		return e && e.__esModule ? e : { default: e }
	}
	function Aat(e, t, r, n) {
		return (0, dat.default)(t)(e, (0, hat.default)(r), n)
	}
	TR.default = (0, pat.default)(Aat, 4)
	Oge.exports = TR.default
})
var Hge = x((RR, Vge) => {
	"use strict"
	Object.defineProperty(RR, "__esModule", { value: !0 })
	var mat = bH(),
		yat = qge(mat),
		Cat = uy(),
		vat = qge(Cat)
	function qge(e) {
		return e && e.__esModule ? e : { default: e }
	}
	function Eat(e, t, r) {
		return (0, yat.default)(e, 1, t, r)
	}
	RR.default = (0, vat.default)(Eat, 3)
	Vge.exports = RR.default
})
var $ge = x((kR, Gge) => {
	"use strict"
	Object.defineProperty(kR, "__esModule", { value: !0 })
	kR.default = Iat
	var bat = wge(),
		xat = Wge(bat),
		_at = Hge(),
		wat = Wge(_at)
	function Wge(e) {
		return e && e.__esModule ? e : { default: e }
	}
	function Iat(e, t) {
		return (0, xat.default)(wat.default, e, t)
	}
	Gge.exports = kR.default
})
var xH = x((bTt, Kge) => {
	"use strict"
	Kge.exports = Hd
	var MR = _h().codes,
		Sat = MR.ERR_METHOD_NOT_IMPLEMENTED,
		Bat = MR.ERR_MULTIPLE_CALLBACK,
		Dat = MR.ERR_TRANSFORM_ALREADY_TRANSFORMING,
		Tat = MR.ERR_TRANSFORM_WITH_LENGTH_0,
		FR = qp()
	iy()(Hd, FR)
	function Rat(e, t) {
		var r = this._transformState
		r.transforming = !1
		var n = r.writecb
		if (n === null) return this.emit("error", new Bat())
		;(r.writechunk = null), (r.writecb = null), t != null && this.push(t), n(e)
		var i = this._readableState
		;(i.reading = !1), (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
	}
	function Hd(e) {
		if (!(this instanceof Hd)) return new Hd(e)
		FR.call(this, e),
			(this._transformState = {
				afterTransform: Rat.bind(this),
				needTransform: !1,
				transforming: !1,
				writecb: null,
				writechunk: null,
				writeencoding: null,
			}),
			(this._readableState.needReadable = !0),
			(this._readableState.sync = !1),
			e &&
				(typeof e.transform == "function" && (this._transform = e.transform),
				typeof e.flush == "function" && (this._flush = e.flush)),
			this.on("prefinish", kat)
	}
	function kat() {
		var e = this
		typeof this._flush == "function" && !this._readableState.destroyed
			? this._flush(function (t, r) {
					Yge(e, t, r)
				})
			: Yge(this, null, null)
	}
	Hd.prototype.push = function (e, t) {
		return (this._transformState.needTransform = !1), FR.prototype.push.call(this, e, t)
	}
	Hd.prototype._transform = function (e, t, r) {
		r(new Sat("_transform()"))
	}
	Hd.prototype._write = function (e, t, r) {
		var n = this._transformState
		if (((n.writecb = r), (n.writechunk = e), (n.writeencoding = t), !n.transforming)) {
			var i = this._readableState
			;(n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
		}
	}
	Hd.prototype._read = function (e) {
		var t = this._transformState
		t.writechunk !== null && !t.transforming
			? ((t.transforming = !0), this._transform(t.writechunk, t.writeencoding, t.afterTransform))
			: (t.needTransform = !0)
	}
	Hd.prototype._destroy = function (e, t) {
		FR.prototype._destroy.call(this, e, function (r) {
			t(r)
		})
	}
	function Yge(e, t, r) {
		if (t) return e.emit("error", t)
		if ((r != null && e.push(r), e._writableState.length)) throw new Tat()
		if (e._transformState.transforming) throw new Dat()
		return e.push(null)
	}
})
var jge = x((xTt, zge) => {
	"use strict"
	zge.exports = rx
	var Jge = xH()
	iy()(rx, Jge)
	function rx(e) {
		if (!(this instanceof rx)) return new rx(e)
		Jge.call(this, e)
	}
	rx.prototype._transform = function (e, t, r) {
		r(null, e)
	}
})
var rpe = x((_Tt, tpe) => {
	"use strict"
	var _H
	function Mat(e) {
		var t = !1
		return function () {
			t || ((t = !0), e.apply(void 0, arguments))
		}
	}
	var epe = _h().codes,
		Fat = epe.ERR_MISSING_ARGS,
		Qat = epe.ERR_STREAM_DESTROYED
	function Zge(e) {
		if (e) throw e
	}
	function Nat(e) {
		return e.setHeader && typeof e.abort == "function"
	}
	function Pat(e, t, r, n) {
		n = Mat(n)
		var i = !1
		e.on("close", function () {
			i = !0
		}),
			_H === void 0 && (_H = sR()),
			_H(e, { readable: t, writable: r }, function (o) {
				if (o) return n(o)
				;(i = !0), n()
			})
		var s = !1
		return function (o) {
			if (!i && !s) {
				if (((s = !0), Nat(e))) return e.abort()
				if (typeof e.destroy == "function") return e.destroy()
				n(o || new Qat("pipe"))
			}
		}
	}
	function Xge(e) {
		e()
	}
	function Lat(e, t) {
		return e.pipe(t)
	}
	function Uat(e) {
		return !e.length || typeof e[e.length - 1] != "function" ? Zge : e.pop()
	}
	function Oat() {
		for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r]
		var n = Uat(t)
		if ((Array.isArray(t[0]) && (t = t[0]), t.length < 2)) throw new Fat("streams")
		var i,
			s = t.map(function (o, a) {
				var l = a < t.length - 1,
					c = a > 0
				return Pat(o, l, c, function (u) {
					i || (i = u), u && s.forEach(Xge), !l && (s.forEach(Xge), n(i))
				})
			})
		return t.reduce(Lat)
	}
	tpe.exports = Oat
})
var dy = x((Al, ix) => {
	"use strict"
	var nx = require("stream")
	process.env.READABLE_STREAM === "disable" && nx
		? ((ix.exports = nx.Readable), Object.assign(ix.exports, nx), (ix.exports.Stream = nx))
		: ((Al = ix.exports = uH()),
			(Al.Stream = nx || Al),
			(Al.Readable = Al),
			(Al.Writable = hR()),
			(Al.Duplex = qp()),
			(Al.Transform = xH()),
			(Al.PassThrough = jge()),
			(Al.finished = sR()),
			(Al.pipeline = rpe()))
})
var RH = x((wTt, ipe) => {
	"use strict"
	var fy = [],
		sx = [],
		wH = function () {}
	function SH(e) {
		return ~fy.indexOf(e) ? !1 : (fy.push(e), !0)
	}
	function BH(e) {
		wH = e
	}
	function qat(e) {
		for (var t = [], r = 0; r < fy.length; r++) {
			if (fy[r].async) {
				t.push(fy[r])
				continue
			}
			if (fy[r](e)) return !0
		}
		return t.length
			? new Promise(function (i) {
					Promise.all(
						t.map(function (o) {
							return o(e)
						}),
					).then(function (o) {
						i(o.some(Boolean))
					})
				})
			: !1
	}
	function DH(e) {
		return ~sx.indexOf(e) ? !1 : (sx.push(e), !0)
	}
	function IH() {
		wH.apply(wH, arguments)
	}
	function npe(e) {
		for (var t = 0; t < sx.length; t++) e = sx[t].apply(sx[t], arguments)
		return e
	}
	function TH(e, t) {
		var r = Object.prototype.hasOwnProperty
		for (var n in t) r.call(t, n) && (e[n] = t[n])
		return e
	}
	function Vat(e) {
		return (
			(e.enabled = !1),
			(e.modify = DH),
			(e.set = BH),
			(e.use = SH),
			TH(function () {
				return !1
			}, e)
		)
	}
	function Hat(e) {
		function t() {
			var r = Array.prototype.slice.call(arguments, 0)
			return IH.call(IH, e, npe(r, e)), !0
		}
		return (e.enabled = !0), (e.modify = DH), (e.set = BH), (e.use = SH), TH(t, e)
	}
	ipe.exports = function (t) {
		return (
			(t.introduce = TH),
			(t.enabled = qat),
			(t.process = npe),
			(t.modify = DH),
			(t.write = IH),
			(t.nope = Vat),
			(t.yep = Hat),
			(t.set = BH),
			(t.use = SH),
			t
		)
	}
})
var ope = x((ITt, spe) => {
	"use strict"
	var Wat = RH(),
		Gat = Wat(function e(t, r) {
			return (
				(r = r || {}), (r.namespace = t), (r.prod = !0), (r.dev = !1), r.force || e.force ? e.yep(r) : e.nope(r)
			)
		})
	spe.exports = Gat
})
var lpe = x((STt, ape) => {
	"use strict"
	ape.exports = {
		aliceblue: [240, 248, 255],
		antiquewhite: [250, 235, 215],
		aqua: [0, 255, 255],
		aquamarine: [127, 255, 212],
		azure: [240, 255, 255],
		beige: [245, 245, 220],
		bisque: [255, 228, 196],
		black: [0, 0, 0],
		blanchedalmond: [255, 235, 205],
		blue: [0, 0, 255],
		blueviolet: [138, 43, 226],
		brown: [165, 42, 42],
		burlywood: [222, 184, 135],
		cadetblue: [95, 158, 160],
		chartreuse: [127, 255, 0],
		chocolate: [210, 105, 30],
		coral: [255, 127, 80],
		cornflowerblue: [100, 149, 237],
		cornsilk: [255, 248, 220],
		crimson: [220, 20, 60],
		cyan: [0, 255, 255],
		darkblue: [0, 0, 139],
		darkcyan: [0, 139, 139],
		darkgoldenrod: [184, 134, 11],
		darkgray: [169, 169, 169],
		darkgreen: [0, 100, 0],
		darkgrey: [169, 169, 169],
		darkkhaki: [189, 183, 107],
		darkmagenta: [139, 0, 139],
		darkolivegreen: [85, 107, 47],
		darkorange: [255, 140, 0],
		darkorchid: [153, 50, 204],
		darkred: [139, 0, 0],
		darksalmon: [233, 150, 122],
		darkseagreen: [143, 188, 143],
		darkslateblue: [72, 61, 139],
		darkslategray: [47, 79, 79],
		darkslategrey: [47, 79, 79],
		darkturquoise: [0, 206, 209],
		darkviolet: [148, 0, 211],
		deeppink: [255, 20, 147],
		deepskyblue: [0, 191, 255],
		dimgray: [105, 105, 105],
		dimgrey: [105, 105, 105],
		dodgerblue: [30, 144, 255],
		firebrick: [178, 34, 34],
		floralwhite: [255, 250, 240],
		forestgreen: [34, 139, 34],
		fuchsia: [255, 0, 255],
		gainsboro: [220, 220, 220],
		ghostwhite: [248, 248, 255],
		gold: [255, 215, 0],
		goldenrod: [218, 165, 32],
		gray: [128, 128, 128],
		green: [0, 128, 0],
		greenyellow: [173, 255, 47],
		grey: [128, 128, 128],
		honeydew: [240, 255, 240],
		hotpink: [255, 105, 180],
		indianred: [205, 92, 92],
		indigo: [75, 0, 130],
		ivory: [255, 255, 240],
		khaki: [240, 230, 140],
		lavender: [230, 230, 250],
		lavenderblush: [255, 240, 245],
		lawngreen: [124, 252, 0],
		lemonchiffon: [255, 250, 205],
		lightblue: [173, 216, 230],
		lightcoral: [240, 128, 128],
		lightcyan: [224, 255, 255],
		lightgoldenrodyellow: [250, 250, 210],
		lightgray: [211, 211, 211],
		lightgreen: [144, 238, 144],
		lightgrey: [211, 211, 211],
		lightpink: [255, 182, 193],
		lightsalmon: [255, 160, 122],
		lightseagreen: [32, 178, 170],
		lightskyblue: [135, 206, 250],
		lightslategray: [119, 136, 153],
		lightslategrey: [119, 136, 153],
		lightsteelblue: [176, 196, 222],
		lightyellow: [255, 255, 224],
		lime: [0, 255, 0],
		limegreen: [50, 205, 50],
		linen: [250, 240, 230],
		magenta: [255, 0, 255],
		maroon: [128, 0, 0],
		mediumaquamarine: [102, 205, 170],
		mediumblue: [0, 0, 205],
		mediumorchid: [186, 85, 211],
		mediumpurple: [147, 112, 219],
		mediumseagreen: [60, 179, 113],
		mediumslateblue: [123, 104, 238],
		mediumspringgreen: [0, 250, 154],
		mediumturquoise: [72, 209, 204],
		mediumvioletred: [199, 21, 133],
		midnightblue: [25, 25, 112],
		mintcream: [245, 255, 250],
		mistyrose: [255, 228, 225],
		moccasin: [255, 228, 181],
		navajowhite: [255, 222, 173],
		navy: [0, 0, 128],
		oldlace: [253, 245, 230],
		olive: [128, 128, 0],
		olivedrab: [107, 142, 35],
		orange: [255, 165, 0],
		orangered: [255, 69, 0],
		orchid: [218, 112, 214],
		palegoldenrod: [238, 232, 170],
		palegreen: [152, 251, 152],
		paleturquoise: [175, 238, 238],
		palevioletred: [219, 112, 147],
		papayawhip: [255, 239, 213],
		peachpuff: [255, 218, 185],
		peru: [205, 133, 63],
		pink: [255, 192, 203],
		plum: [221, 160, 221],
		powderblue: [176, 224, 230],
		purple: [128, 0, 128],
		rebeccapurple: [102, 51, 153],
		red: [255, 0, 0],
		rosybrown: [188, 143, 143],
		royalblue: [65, 105, 225],
		saddlebrown: [139, 69, 19],
		salmon: [250, 128, 114],
		sandybrown: [244, 164, 96],
		seagreen: [46, 139, 87],
		seashell: [255, 245, 238],
		sienna: [160, 82, 45],
		silver: [192, 192, 192],
		skyblue: [135, 206, 235],
		slateblue: [106, 90, 205],
		slategray: [112, 128, 144],
		slategrey: [112, 128, 144],
		snow: [255, 250, 250],
		springgreen: [0, 255, 127],
		steelblue: [70, 130, 180],
		tan: [210, 180, 140],
		teal: [0, 128, 128],
		thistle: [216, 191, 216],
		tomato: [255, 99, 71],
		turquoise: [64, 224, 208],
		violet: [238, 130, 238],
		wheat: [245, 222, 179],
		white: [255, 255, 255],
		whitesmoke: [245, 245, 245],
		yellow: [255, 255, 0],
		yellowgreen: [154, 205, 50],
	}
})
var upe = x((BTt, cpe) => {
	"use strict"
	cpe.exports = function (t) {
		return !t || typeof t == "string"
			? !1
			: t instanceof Array ||
					Array.isArray(t) ||
					(t.length >= 0 &&
						(t.splice instanceof Function ||
							(Object.getOwnPropertyDescriptor(t, t.length - 1) && t.constructor.name !== "String")))
	}
})
var hpe = x((DTt, fpe) => {
	"use strict"
	var $at = upe(),
		Yat = Array.prototype.concat,
		Kat = Array.prototype.slice,
		dpe = (fpe.exports = function (t) {
			for (var r = [], n = 0, i = t.length; n < i; n++) {
				var s = t[n]
				$at(s) ? (r = Yat.call(r, Kat.call(s))) : r.push(s)
			}
			return r
		})
	dpe.wrap = function (e) {
		return function () {
			return e(dpe(arguments))
		}
	}
})
var mpe = x((TTt, Ape) => {
	"use strict"
	var ox = lpe(),
		ax = hpe(),
		gpe = Object.hasOwnProperty,
		ppe = Object.create(null)
	for (QR in ox) gpe.call(ox, QR) && (ppe[ox[QR]] = QR)
	var QR,
		_a = (Ape.exports = { to: {}, get: {} })
	_a.get = function (e) {
		var t = e.substring(0, 3).toLowerCase(),
			r,
			n
		switch (t) {
			case "hsl":
				;(r = _a.get.hsl(e)), (n = "hsl")
				break
			case "hwb":
				;(r = _a.get.hwb(e)), (n = "hwb")
				break
			default:
				;(r = _a.get.rgb(e)), (n = "rgb")
				break
		}
		return r ? { model: n, value: r } : null
	}
	_a.get.rgb = function (e) {
		if (!e) return null
		var t = /^#([a-f0-9]{3,4})$/i,
			r = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i,
			n =
				/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,
			i =
				/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,
			s = /^(\w+)$/,
			o = [0, 0, 0, 1],
			a,
			l,
			c
		if ((a = e.match(r))) {
			for (c = a[2], a = a[1], l = 0; l < 3; l++) {
				var u = l * 2
				o[l] = parseInt(a.slice(u, u + 2), 16)
			}
			c && (o[3] = parseInt(c, 16) / 255)
		} else if ((a = e.match(t))) {
			for (a = a[1], c = a[3], l = 0; l < 3; l++) o[l] = parseInt(a[l] + a[l], 16)
			c && (o[3] = parseInt(c + c, 16) / 255)
		} else if ((a = e.match(n))) {
			for (l = 0; l < 3; l++) o[l] = parseInt(a[l + 1], 0)
			a[4] && (a[5] ? (o[3] = parseFloat(a[4]) * 0.01) : (o[3] = parseFloat(a[4])))
		} else if ((a = e.match(i))) {
			for (l = 0; l < 3; l++) o[l] = Math.round(parseFloat(a[l + 1]) * 2.55)
			a[4] && (a[5] ? (o[3] = parseFloat(a[4]) * 0.01) : (o[3] = parseFloat(a[4])))
		} else
			return (a = e.match(s))
				? a[1] === "transparent"
					? [0, 0, 0, 0]
					: gpe.call(ox, a[1])
						? ((o = ox[a[1]]), (o[3] = 1), o)
						: null
				: null
		for (l = 0; l < 3; l++) o[l] = Rh(o[l], 0, 255)
		return (o[3] = Rh(o[3], 0, 1)), o
	}
	_a.get.hsl = function (e) {
		if (!e) return null
		var t =
				/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,
			r = e.match(t)
		if (r) {
			var n = parseFloat(r[4]),
				i = ((parseFloat(r[1]) % 360) + 360) % 360,
				s = Rh(parseFloat(r[2]), 0, 100),
				o = Rh(parseFloat(r[3]), 0, 100),
				a = Rh(isNaN(n) ? 1 : n, 0, 1)
			return [i, s, o, a]
		}
		return null
	}
	_a.get.hwb = function (e) {
		if (!e) return null
		var t =
				/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,
			r = e.match(t)
		if (r) {
			var n = parseFloat(r[4]),
				i = ((parseFloat(r[1]) % 360) + 360) % 360,
				s = Rh(parseFloat(r[2]), 0, 100),
				o = Rh(parseFloat(r[3]), 0, 100),
				a = Rh(isNaN(n) ? 1 : n, 0, 1)
			return [i, s, o, a]
		}
		return null
	}
	_a.to.hex = function () {
		var e = ax(arguments)
		return "#" + NR(e[0]) + NR(e[1]) + NR(e[2]) + (e[3] < 1 ? NR(Math.round(e[3] * 255)) : "")
	}
	_a.to.rgb = function () {
		var e = ax(arguments)
		return e.length < 4 || e[3] === 1
			? "rgb(" + Math.round(e[0]) + ", " + Math.round(e[1]) + ", " + Math.round(e[2]) + ")"
			: "rgba(" + Math.round(e[0]) + ", " + Math.round(e[1]) + ", " + Math.round(e[2]) + ", " + e[3] + ")"
	}
	_a.to.rgb.percent = function () {
		var e = ax(arguments),
			t = Math.round((e[0] / 255) * 100),
			r = Math.round((e[1] / 255) * 100),
			n = Math.round((e[2] / 255) * 100)
		return e.length < 4 || e[3] === 1
			? "rgb(" + t + "%, " + r + "%, " + n + "%)"
			: "rgba(" + t + "%, " + r + "%, " + n + "%, " + e[3] + ")"
	}
	_a.to.hsl = function () {
		var e = ax(arguments)
		return e.length < 4 || e[3] === 1
			? "hsl(" + e[0] + ", " + e[1] + "%, " + e[2] + "%)"
			: "hsla(" + e[0] + ", " + e[1] + "%, " + e[2] + "%, " + e[3] + ")"
	}
	_a.to.hwb = function () {
		var e = ax(arguments),
			t = ""
		return (
			e.length >= 4 && e[3] !== 1 && (t = ", " + e[3]), "hwb(" + e[0] + ", " + e[1] + "%, " + e[2] + "%" + t + ")"
		)
	}
	_a.to.keyword = function (e) {
		return ppe[e.slice(0, 3)]
	}
	function Rh(e, t, r) {
		return Math.min(Math.max(t, e), r)
	}
	function NR(e) {
		var t = Math.round(e).toString(16).toUpperCase()
		return t.length < 2 ? "0" + t : t
	}
})
var Cpe = x((RTt, ype) => {
	"use strict"
	ype.exports = {
		aliceblue: [240, 248, 255],
		antiquewhite: [250, 235, 215],
		aqua: [0, 255, 255],
		aquamarine: [127, 255, 212],
		azure: [240, 255, 255],
		beige: [245, 245, 220],
		bisque: [255, 228, 196],
		black: [0, 0, 0],
		blanchedalmond: [255, 235, 205],
		blue: [0, 0, 255],
		blueviolet: [138, 43, 226],
		brown: [165, 42, 42],
		burlywood: [222, 184, 135],
		cadetblue: [95, 158, 160],
		chartreuse: [127, 255, 0],
		chocolate: [210, 105, 30],
		coral: [255, 127, 80],
		cornflowerblue: [100, 149, 237],
		cornsilk: [255, 248, 220],
		crimson: [220, 20, 60],
		cyan: [0, 255, 255],
		darkblue: [0, 0, 139],
		darkcyan: [0, 139, 139],
		darkgoldenrod: [184, 134, 11],
		darkgray: [169, 169, 169],
		darkgreen: [0, 100, 0],
		darkgrey: [169, 169, 169],
		darkkhaki: [189, 183, 107],
		darkmagenta: [139, 0, 139],
		darkolivegreen: [85, 107, 47],
		darkorange: [255, 140, 0],
		darkorchid: [153, 50, 204],
		darkred: [139, 0, 0],
		darksalmon: [233, 150, 122],
		darkseagreen: [143, 188, 143],
		darkslateblue: [72, 61, 139],
		darkslategray: [47, 79, 79],
		darkslategrey: [47, 79, 79],
		darkturquoise: [0, 206, 209],
		darkviolet: [148, 0, 211],
		deeppink: [255, 20, 147],
		deepskyblue: [0, 191, 255],
		dimgray: [105, 105, 105],
		dimgrey: [105, 105, 105],
		dodgerblue: [30, 144, 255],
		firebrick: [178, 34, 34],
		floralwhite: [255, 250, 240],
		forestgreen: [34, 139, 34],
		fuchsia: [255, 0, 255],
		gainsboro: [220, 220, 220],
		ghostwhite: [248, 248, 255],
		gold: [255, 215, 0],
		goldenrod: [218, 165, 32],
		gray: [128, 128, 128],
		green: [0, 128, 0],
		greenyellow: [173, 255, 47],
		grey: [128, 128, 128],
		honeydew: [240, 255, 240],
		hotpink: [255, 105, 180],
		indianred: [205, 92, 92],
		indigo: [75, 0, 130],
		ivory: [255, 255, 240],
		khaki: [240, 230, 140],
		lavender: [230, 230, 250],
		lavenderblush: [255, 240, 245],
		lawngreen: [124, 252, 0],
		lemonchiffon: [255, 250, 205],
		lightblue: [173, 216, 230],
		lightcoral: [240, 128, 128],
		lightcyan: [224, 255, 255],
		lightgoldenrodyellow: [250, 250, 210],
		lightgray: [211, 211, 211],
		lightgreen: [144, 238, 144],
		lightgrey: [211, 211, 211],
		lightpink: [255, 182, 193],
		lightsalmon: [255, 160, 122],
		lightseagreen: [32, 178, 170],
		lightskyblue: [135, 206, 250],
		lightslategray: [119, 136, 153],
		lightslategrey: [119, 136, 153],
		lightsteelblue: [176, 196, 222],
		lightyellow: [255, 255, 224],
		lime: [0, 255, 0],
		limegreen: [50, 205, 50],
		linen: [250, 240, 230],
		magenta: [255, 0, 255],
		maroon: [128, 0, 0],
		mediumaquamarine: [102, 205, 170],
		mediumblue: [0, 0, 205],
		mediumorchid: [186, 85, 211],
		mediumpurple: [147, 112, 219],
		mediumseagreen: [60, 179, 113],
		mediumslateblue: [123, 104, 238],
		mediumspringgreen: [0, 250, 154],
		mediumturquoise: [72, 209, 204],
		mediumvioletred: [199, 21, 133],
		midnightblue: [25, 25, 112],
		mintcream: [245, 255, 250],
		mistyrose: [255, 228, 225],
		moccasin: [255, 228, 181],
		navajowhite: [255, 222, 173],
		navy: [0, 0, 128],
		oldlace: [253, 245, 230],
		olive: [128, 128, 0],
		olivedrab: [107, 142, 35],
		orange: [255, 165, 0],
		orangered: [255, 69, 0],
		orchid: [218, 112, 214],
		palegoldenrod: [238, 232, 170],
		palegreen: [152, 251, 152],
		paleturquoise: [175, 238, 238],
		palevioletred: [219, 112, 147],
		papayawhip: [255, 239, 213],
		peachpuff: [255, 218, 185],
		peru: [205, 133, 63],
		pink: [255, 192, 203],
		plum: [221, 160, 221],
		powderblue: [176, 224, 230],
		purple: [128, 0, 128],
		rebeccapurple: [102, 51, 153],
		red: [255, 0, 0],
		rosybrown: [188, 143, 143],
		royalblue: [65, 105, 225],
		saddlebrown: [139, 69, 19],
		salmon: [250, 128, 114],
		sandybrown: [244, 164, 96],
		seagreen: [46, 139, 87],
		seashell: [255, 245, 238],
		sienna: [160, 82, 45],
		silver: [192, 192, 192],
		skyblue: [135, 206, 235],
		slateblue: [106, 90, 205],
		slategray: [112, 128, 144],
		slategrey: [112, 128, 144],
		snow: [255, 250, 250],
		springgreen: [0, 255, 127],
		steelblue: [70, 130, 180],
		tan: [210, 180, 140],
		teal: [0, 128, 128],
		thistle: [216, 191, 216],
		tomato: [255, 99, 71],
		turquoise: [64, 224, 208],
		violet: [238, 130, 238],
		wheat: [245, 222, 179],
		white: [255, 255, 255],
		whitesmoke: [245, 245, 245],
		yellow: [255, 255, 0],
		yellowgreen: [154, 205, 50],
	}
})
var kH = x((kTt, xpe) => {
	"use strict"
	var Hp = Cpe(),
		bpe = {}
	for (PR in Hp) Hp.hasOwnProperty(PR) && (bpe[Hp[PR]] = PR)
	var PR,
		We = (xpe.exports = {
			rgb: { channels: 3, labels: "rgb" },
			hsl: { channels: 3, labels: "hsl" },
			hsv: { channels: 3, labels: "hsv" },
			hwb: { channels: 3, labels: "hwb" },
			cmyk: { channels: 4, labels: "cmyk" },
			xyz: { channels: 3, labels: "xyz" },
			lab: { channels: 3, labels: "lab" },
			lch: { channels: 3, labels: "lch" },
			hex: { channels: 1, labels: ["hex"] },
			keyword: { channels: 1, labels: ["keyword"] },
			ansi16: { channels: 1, labels: ["ansi16"] },
			ansi256: { channels: 1, labels: ["ansi256"] },
			hcg: { channels: 3, labels: ["h", "c", "g"] },
			apple: { channels: 3, labels: ["r16", "g16", "b16"] },
			gray: { channels: 1, labels: ["gray"] },
		})
	for (uo in We)
		if (We.hasOwnProperty(uo)) {
			if (!("channels" in We[uo])) throw new Error("missing channels property: " + uo)
			if (!("labels" in We[uo])) throw new Error("missing channel labels property: " + uo)
			if (We[uo].labels.length !== We[uo].channels) throw new Error("channel and label counts mismatch: " + uo)
			;(vpe = We[uo].channels),
				(Epe = We[uo].labels),
				delete We[uo].channels,
				delete We[uo].labels,
				Object.defineProperty(We[uo], "channels", { value: vpe }),
				Object.defineProperty(We[uo], "labels", { value: Epe })
		}
	var vpe, Epe, uo
	We.rgb.hsl = function (e) {
		var t = e[0] / 255,
			r = e[1] / 255,
			n = e[2] / 255,
			i = Math.min(t, r, n),
			s = Math.max(t, r, n),
			o = s - i,
			a,
			l,
			c
		return (
			s === i
				? (a = 0)
				: t === s
					? (a = (r - n) / o)
					: r === s
						? (a = 2 + (n - t) / o)
						: n === s && (a = 4 + (t - r) / o),
			(a = Math.min(a * 60, 360)),
			a < 0 && (a += 360),
			(c = (i + s) / 2),
			s === i ? (l = 0) : c <= 0.5 ? (l = o / (s + i)) : (l = o / (2 - s - i)),
			[a, l * 100, c * 100]
		)
	}
	We.rgb.hsv = function (e) {
		var t,
			r,
			n,
			i,
			s,
			o = e[0] / 255,
			a = e[1] / 255,
			l = e[2] / 255,
			c = Math.max(o, a, l),
			u = c - Math.min(o, a, l),
			f = function (p) {
				return (c - p) / 6 / u + 1 / 2
			}
		return (
			u === 0
				? (i = s = 0)
				: ((s = u / c),
					(t = f(o)),
					(r = f(a)),
					(n = f(l)),
					o === c ? (i = n - r) : a === c ? (i = 1 / 3 + t - n) : l === c && (i = 2 / 3 + r - t),
					i < 0 ? (i += 1) : i > 1 && (i -= 1)),
			[i * 360, s * 100, c * 100]
		)
	}
	We.rgb.hwb = function (e) {
		var t = e[0],
			r = e[1],
			n = e[2],
			i = We.rgb.hsl(e)[0],
			s = (1 / 255) * Math.min(t, Math.min(r, n))
		return (n = 1 - (1 / 255) * Math.max(t, Math.max(r, n))), [i, s * 100, n * 100]
	}
	We.rgb.cmyk = function (e) {
		var t = e[0] / 255,
			r = e[1] / 255,
			n = e[2] / 255,
			i,
			s,
			o,
			a
		return (
			(a = Math.min(1 - t, 1 - r, 1 - n)),
			(i = (1 - t - a) / (1 - a) || 0),
			(s = (1 - r - a) / (1 - a) || 0),
			(o = (1 - n - a) / (1 - a) || 0),
			[i * 100, s * 100, o * 100, a * 100]
		)
	}
	function Jat(e, t) {
		return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2) + Math.pow(e[2] - t[2], 2)
	}
	We.rgb.keyword = function (e) {
		var t = bpe[e]
		if (t) return t
		var r = 1 / 0,
			n
		for (var i in Hp)
			if (Hp.hasOwnProperty(i)) {
				var s = Hp[i],
					o = Jat(e, s)
				o < r && ((r = o), (n = i))
			}
		return n
	}
	We.keyword.rgb = function (e) {
		return Hp[e]
	}
	We.rgb.xyz = function (e) {
		var t = e[0] / 255,
			r = e[1] / 255,
			n = e[2] / 255
		;(t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92),
			(r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92),
			(n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92)
		var i = t * 0.4124 + r * 0.3576 + n * 0.1805,
			s = t * 0.2126 + r * 0.7152 + n * 0.0722,
			o = t * 0.0193 + r * 0.1192 + n * 0.9505
		return [i * 100, s * 100, o * 100]
	}
	We.rgb.lab = function (e) {
		var t = We.rgb.xyz(e),
			r = t[0],
			n = t[1],
			i = t[2],
			s,
			o,
			a
		return (
			(r /= 95.047),
			(n /= 100),
			(i /= 108.883),
			(r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116),
			(n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116),
			(i = i > 0.008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116),
			(s = 116 * n - 16),
			(o = 500 * (r - n)),
			(a = 200 * (n - i)),
			[s, o, a]
		)
	}
	We.hsl.rgb = function (e) {
		var t = e[0] / 360,
			r = e[1] / 100,
			n = e[2] / 100,
			i,
			s,
			o,
			a,
			l
		if (r === 0) return (l = n * 255), [l, l, l]
		n < 0.5 ? (s = n * (1 + r)) : (s = n + r - n * r), (i = 2 * n - s), (a = [0, 0, 0])
		for (var c = 0; c < 3; c++)
			(o = t + (1 / 3) * -(c - 1)),
				o < 0 && o++,
				o > 1 && o--,
				6 * o < 1
					? (l = i + (s - i) * 6 * o)
					: 2 * o < 1
						? (l = s)
						: 3 * o < 2
							? (l = i + (s - i) * (2 / 3 - o) * 6)
							: (l = i),
				(a[c] = l * 255)
		return a
	}
	We.hsl.hsv = function (e) {
		var t = e[0],
			r = e[1] / 100,
			n = e[2] / 100,
			i = r,
			s = Math.max(n, 0.01),
			o,
			a
		return (
			(n *= 2),
			(r *= n <= 1 ? n : 2 - n),
			(i *= s <= 1 ? s : 2 - s),
			(a = (n + r) / 2),
			(o = n === 0 ? (2 * i) / (s + i) : (2 * r) / (n + r)),
			[t, o * 100, a * 100]
		)
	}
	We.hsv.rgb = function (e) {
		var t = e[0] / 60,
			r = e[1] / 100,
			n = e[2] / 100,
			i = Math.floor(t) % 6,
			s = t - Math.floor(t),
			o = 255 * n * (1 - r),
			a = 255 * n * (1 - r * s),
			l = 255 * n * (1 - r * (1 - s))
		switch (((n *= 255), i)) {
			case 0:
				return [n, l, o]
			case 1:
				return [a, n, o]
			case 2:
				return [o, n, l]
			case 3:
				return [o, a, n]
			case 4:
				return [l, o, n]
			case 5:
				return [n, o, a]
		}
	}
	We.hsv.hsl = function (e) {
		var t = e[0],
			r = e[1] / 100,
			n = e[2] / 100,
			i = Math.max(n, 0.01),
			s,
			o,
			a
		return (
			(a = (2 - r) * n),
			(s = (2 - r) * i),
			(o = r * i),
			(o /= s <= 1 ? s : 2 - s),
			(o = o || 0),
			(a /= 2),
			[t, o * 100, a * 100]
		)
	}
	We.hwb.rgb = function (e) {
		var t = e[0] / 360,
			r = e[1] / 100,
			n = e[2] / 100,
			i = r + n,
			s,
			o,
			a,
			l
		i > 1 && ((r /= i), (n /= i)),
			(s = Math.floor(6 * t)),
			(o = 1 - n),
			(a = 6 * t - s),
			s & 1 && (a = 1 - a),
			(l = r + a * (o - r))
		var c, u, f
		switch (s) {
			default:
			case 6:
			case 0:
				;(c = o), (u = l), (f = r)
				break
			case 1:
				;(c = l), (u = o), (f = r)
				break
			case 2:
				;(c = r), (u = o), (f = l)
				break
			case 3:
				;(c = r), (u = l), (f = o)
				break
			case 4:
				;(c = l), (u = r), (f = o)
				break
			case 5:
				;(c = o), (u = r), (f = l)
				break
		}
		return [c * 255, u * 255, f * 255]
	}
	We.cmyk.rgb = function (e) {
		var t = e[0] / 100,
			r = e[1] / 100,
			n = e[2] / 100,
			i = e[3] / 100,
			s,
			o,
			a
		return (
			(s = 1 - Math.min(1, t * (1 - i) + i)),
			(o = 1 - Math.min(1, r * (1 - i) + i)),
			(a = 1 - Math.min(1, n * (1 - i) + i)),
			[s * 255, o * 255, a * 255]
		)
	}
	We.xyz.rgb = function (e) {
		var t = e[0] / 100,
			r = e[1] / 100,
			n = e[2] / 100,
			i,
			s,
			o
		return (
			(i = t * 3.2406 + r * -1.5372 + n * -0.4986),
			(s = t * -0.9689 + r * 1.8758 + n * 0.0415),
			(o = t * 0.0557 + r * -0.204 + n * 1.057),
			(i = i > 0.0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i * 12.92),
			(s = s > 0.0031308 ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055 : s * 12.92),
			(o = o > 0.0031308 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92),
			(i = Math.min(Math.max(0, i), 1)),
			(s = Math.min(Math.max(0, s), 1)),
			(o = Math.min(Math.max(0, o), 1)),
			[i * 255, s * 255, o * 255]
		)
	}
	We.xyz.lab = function (e) {
		var t = e[0],
			r = e[1],
			n = e[2],
			i,
			s,
			o
		return (
			(t /= 95.047),
			(r /= 100),
			(n /= 108.883),
			(t = t > 0.008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116),
			(r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116),
			(n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116),
			(i = 116 * r - 16),
			(s = 500 * (t - r)),
			(o = 200 * (r - n)),
			[i, s, o]
		)
	}
	We.lab.xyz = function (e) {
		var t = e[0],
			r = e[1],
			n = e[2],
			i,
			s,
			o
		;(s = (t + 16) / 116), (i = r / 500 + s), (o = s - n / 200)
		var a = Math.pow(s, 3),
			l = Math.pow(i, 3),
			c = Math.pow(o, 3)
		return (
			(s = a > 0.008856 ? a : (s - 16 / 116) / 7.787),
			(i = l > 0.008856 ? l : (i - 16 / 116) / 7.787),
			(o = c > 0.008856 ? c : (o - 16 / 116) / 7.787),
			(i *= 95.047),
			(s *= 100),
			(o *= 108.883),
			[i, s, o]
		)
	}
	We.lab.lch = function (e) {
		var t = e[0],
			r = e[1],
			n = e[2],
			i,
			s,
			o
		return (
			(i = Math.atan2(n, r)),
			(s = (i * 360) / 2 / Math.PI),
			s < 0 && (s += 360),
			(o = Math.sqrt(r * r + n * n)),
			[t, o, s]
		)
	}
	We.lch.lab = function (e) {
		var t = e[0],
			r = e[1],
			n = e[2],
			i,
			s,
			o
		return (o = (n / 360) * 2 * Math.PI), (i = r * Math.cos(o)), (s = r * Math.sin(o)), [t, i, s]
	}
	We.rgb.ansi16 = function (e) {
		var t = e[0],
			r = e[1],
			n = e[2],
			i = 1 in arguments ? arguments[1] : We.rgb.hsv(e)[2]
		if (((i = Math.round(i / 50)), i === 0)) return 30
		var s = 30 + ((Math.round(n / 255) << 2) | (Math.round(r / 255) << 1) | Math.round(t / 255))
		return i === 2 && (s += 60), s
	}
	We.hsv.ansi16 = function (e) {
		return We.rgb.ansi16(We.hsv.rgb(e), e[2])
	}
	We.rgb.ansi256 = function (e) {
		var t = e[0],
			r = e[1],
			n = e[2]
		if (t === r && r === n) return t < 8 ? 16 : t > 248 ? 231 : Math.round(((t - 8) / 247) * 24) + 232
		var i = 16 + 36 * Math.round((t / 255) * 5) + 6 * Math.round((r / 255) * 5) + Math.round((n / 255) * 5)
		return i
	}
	We.ansi16.rgb = function (e) {
		var t = e % 10
		if (t === 0 || t === 7) return e > 50 && (t += 3.5), (t = (t / 10.5) * 255), [t, t, t]
		var r = (~~(e > 50) + 1) * 0.5,
			n = (t & 1) * r * 255,
			i = ((t >> 1) & 1) * r * 255,
			s = ((t >> 2) & 1) * r * 255
		return [n, i, s]
	}
	We.ansi256.rgb = function (e) {
		if (e >= 232) {
			var t = (e - 232) * 10 + 8
			return [t, t, t]
		}
		e -= 16
		var r,
			n = (Math.floor(e / 36) / 5) * 255,
			i = (Math.floor((r = e % 36) / 6) / 5) * 255,
			s = ((r % 6) / 5) * 255
		return [n, i, s]
	}
	We.rgb.hex = function (e) {
		var t = ((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255),
			r = t.toString(16).toUpperCase()
		return "000000".substring(r.length) + r
	}
	We.hex.rgb = function (e) {
		var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
		if (!t) return [0, 0, 0]
		var r = t[0]
		t[0].length === 3 &&
			(r = r
				.split("")
				.map(function (a) {
					return a + a
				})
				.join(""))
		var n = parseInt(r, 16),
			i = (n >> 16) & 255,
			s = (n >> 8) & 255,
			o = n & 255
		return [i, s, o]
	}
	We.rgb.hcg = function (e) {
		var t = e[0] / 255,
			r = e[1] / 255,
			n = e[2] / 255,
			i = Math.max(Math.max(t, r), n),
			s = Math.min(Math.min(t, r), n),
			o = i - s,
			a,
			l
		return (
			o < 1 ? (a = s / (1 - o)) : (a = 0),
			o <= 0
				? (l = 0)
				: i === t
					? (l = ((r - n) / o) % 6)
					: i === r
						? (l = 2 + (n - t) / o)
						: (l = 4 + (t - r) / o + 4),
			(l /= 6),
			(l %= 1),
			[l * 360, o * 100, a * 100]
		)
	}
	We.hsl.hcg = function (e) {
		var t = e[1] / 100,
			r = e[2] / 100,
			n = 1,
			i = 0
		return (
			r < 0.5 ? (n = 2 * t * r) : (n = 2 * t * (1 - r)),
			n < 1 && (i = (r - 0.5 * n) / (1 - n)),
			[e[0], n * 100, i * 100]
		)
	}
	We.hsv.hcg = function (e) {
		var t = e[1] / 100,
			r = e[2] / 100,
			n = t * r,
			i = 0
		return n < 1 && (i = (r - n) / (1 - n)), [e[0], n * 100, i * 100]
	}
	We.hcg.rgb = function (e) {
		var t = e[0] / 360,
			r = e[1] / 100,
			n = e[2] / 100
		if (r === 0) return [n * 255, n * 255, n * 255]
		var i = [0, 0, 0],
			s = (t % 1) * 6,
			o = s % 1,
			a = 1 - o,
			l = 0
		switch (Math.floor(s)) {
			case 0:
				;(i[0] = 1), (i[1] = o), (i[2] = 0)
				break
			case 1:
				;(i[0] = a), (i[1] = 1), (i[2] = 0)
				break
			case 2:
				;(i[0] = 0), (i[1] = 1), (i[2] = o)
				break
			case 3:
				;(i[0] = 0), (i[1] = a), (i[2] = 1)
				break
			case 4:
				;(i[0] = o), (i[1] = 0), (i[2] = 1)
				break
			default:
				;(i[0] = 1), (i[1] = 0), (i[2] = a)
		}
		return (l = (1 - r) * n), [(r * i[0] + l) * 255, (r * i[1] + l) * 255, (r * i[2] + l) * 255]
	}
	We.hcg.hsv = function (e) {
		var t = e[1] / 100,
			r = e[2] / 100,
			n = t + r * (1 - t),
			i = 0
		return n > 0 && (i = t / n), [e[0], i * 100, n * 100]
	}
	We.hcg.hsl = function (e) {
		var t = e[1] / 100,
			r = e[2] / 100,
			n = r * (1 - t) + 0.5 * t,
			i = 0
		return (
			n > 0 && n < 0.5 ? (i = t / (2 * n)) : n >= 0.5 && n < 1 && (i = t / (2 * (1 - n))),
			[e[0], i * 100, n * 100]
		)
	}
	We.hcg.hwb = function (e) {
		var t = e[1] / 100,
			r = e[2] / 100,
			n = t + r * (1 - t)
		return [e[0], (n - t) * 100, (1 - n) * 100]
	}
	We.hwb.hcg = function (e) {
		var t = e[1] / 100,
			r = e[2] / 100,
			n = 1 - r,
			i = n - t,
			s = 0
		return i < 1 && (s = (n - i) / (1 - i)), [e[0], i * 100, s * 100]
	}
	We.apple.rgb = function (e) {
		return [(e[0] / 65535) * 255, (e[1] / 65535) * 255, (e[2] / 65535) * 255]
	}
	We.rgb.apple = function (e) {
		return [(e[0] / 255) * 65535, (e[1] / 255) * 65535, (e[2] / 255) * 65535]
	}
	We.gray.rgb = function (e) {
		return [(e[0] / 100) * 255, (e[0] / 100) * 255, (e[0] / 100) * 255]
	}
	We.gray.hsl = We.gray.hsv = function (e) {
		return [0, 0, e[0]]
	}
	We.gray.hwb = function (e) {
		return [0, 100, e[0]]
	}
	We.gray.cmyk = function (e) {
		return [0, 0, 0, e[0]]
	}
	We.gray.lab = function (e) {
		return [e[0], 0, 0]
	}
	We.gray.hex = function (e) {
		var t = Math.round((e[0] / 100) * 255) & 255,
			r = (t << 16) + (t << 8) + t,
			n = r.toString(16).toUpperCase()
		return "000000".substring(n.length) + n
	}
	We.rgb.gray = function (e) {
		var t = (e[0] + e[1] + e[2]) / 3
		return [(t / 255) * 100]
	}
})
var wpe = x((MTt, _pe) => {
	"use strict"
	var LR = kH()
	function zat() {
		for (var e = {}, t = Object.keys(LR), r = t.length, n = 0; n < r; n++) e[t[n]] = { distance: -1, parent: null }
		return e
	}
	function jat(e) {
		var t = zat(),
			r = [e]
		for (t[e].distance = 0; r.length; )
			for (var n = r.pop(), i = Object.keys(LR[n]), s = i.length, o = 0; o < s; o++) {
				var a = i[o],
					l = t[a]
				l.distance === -1 && ((l.distance = t[n].distance + 1), (l.parent = n), r.unshift(a))
			}
		return t
	}
	function Zat(e, t) {
		return function (r) {
			return t(e(r))
		}
	}
	function Xat(e, t) {
		for (var r = [t[e].parent, e], n = LR[t[e].parent][e], i = t[e].parent; t[i].parent; )
			r.unshift(t[i].parent), (n = Zat(LR[t[i].parent][i], n)), (i = t[i].parent)
		return (n.conversion = r), n
	}
	_pe.exports = function (e) {
		for (var t = jat(e), r = {}, n = Object.keys(t), i = n.length, s = 0; s < i; s++) {
			var o = n[s],
				a = t[o]
			a.parent !== null && (r[o] = Xat(o, t))
		}
		return r
	}
})
var Spe = x((FTt, Ipe) => {
	"use strict"
	var MH = kH(),
		elt = wpe(),
		hy = {},
		tlt = Object.keys(MH)
	function rlt(e) {
		var t = function (r) {
			return r == null ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)), e(r))
		}
		return "conversion" in e && (t.conversion = e.conversion), t
	}
	function nlt(e) {
		var t = function (r) {
			if (r == null) return r
			arguments.length > 1 && (r = Array.prototype.slice.call(arguments))
			var n = e(r)
			if (typeof n == "object") for (var i = n.length, s = 0; s < i; s++) n[s] = Math.round(n[s])
			return n
		}
		return "conversion" in e && (t.conversion = e.conversion), t
	}
	tlt.forEach(function (e) {
		;(hy[e] = {}),
			Object.defineProperty(hy[e], "channels", { value: MH[e].channels }),
			Object.defineProperty(hy[e], "labels", { value: MH[e].labels })
		var t = elt(e),
			r = Object.keys(t)
		r.forEach(function (n) {
			var i = t[n]
			;(hy[e][n] = nlt(i)), (hy[e][n].raw = rlt(i))
		})
	})
	Ipe.exports = hy
})
var Tpe = x((QTt, Dpe) => {
	"use strict"
	var lx = mpe(),
		wa = Spe(),
		NH = [].slice,
		Bpe = ["keyword", "gray", "hex"],
		FH = {}
	Object.keys(wa).forEach(function (e) {
		FH[NH.call(wa[e].labels).sort().join("")] = e
	})
	var UR = {}
	function _s(e, t) {
		if (!(this instanceof _s)) return new _s(e, t)
		if ((t && t in Bpe && (t = null), t && !(t in wa))) throw new Error("Unknown model: " + t)
		var r, n
		if (e == null) (this.model = "rgb"), (this.color = [0, 0, 0]), (this.valpha = 1)
		else if (e instanceof _s) (this.model = e.model), (this.color = e.color.slice()), (this.valpha = e.valpha)
		else if (typeof e == "string") {
			var i = lx.get(e)
			if (i === null) throw new Error("Unable to parse color from string: " + e)
			;(this.model = i.model),
				(n = wa[this.model].channels),
				(this.color = i.value.slice(0, n)),
				(this.valpha = typeof i.value[n] == "number" ? i.value[n] : 1)
		} else if (e.length) {
			;(this.model = t || "rgb"), (n = wa[this.model].channels)
			var s = NH.call(e, 0, n)
			;(this.color = QH(s, n)), (this.valpha = typeof e[n] == "number" ? e[n] : 1)
		} else if (typeof e == "number")
			(e &= 16777215),
				(this.model = "rgb"),
				(this.color = [(e >> 16) & 255, (e >> 8) & 255, e & 255]),
				(this.valpha = 1)
		else {
			this.valpha = 1
			var o = Object.keys(e)
			"alpha" in e && (o.splice(o.indexOf("alpha"), 1), (this.valpha = typeof e.alpha == "number" ? e.alpha : 0))
			var a = o.sort().join("")
			if (!(a in FH)) throw new Error("Unable to parse color from object: " + JSON.stringify(e))
			this.model = FH[a]
			var l = wa[this.model].labels,
				c = []
			for (r = 0; r < l.length; r++) c.push(e[l[r]])
			this.color = QH(c)
		}
		if (UR[this.model])
			for (n = wa[this.model].channels, r = 0; r < n; r++) {
				var u = UR[this.model][r]
				u && (this.color[r] = u(this.color[r]))
			}
		;(this.valpha = Math.max(0, Math.min(1, this.valpha))), Object.freeze && Object.freeze(this)
	}
	_s.prototype = {
		toString: function () {
			return this.string()
		},
		toJSON: function () {
			return this[this.model]()
		},
		string: function (e) {
			var t = this.model in lx.to ? this : this.rgb()
			t = t.round(typeof e == "number" ? e : 1)
			var r = t.valpha === 1 ? t.color : t.color.concat(this.valpha)
			return lx.to[t.model](r)
		},
		percentString: function (e) {
			var t = this.rgb().round(typeof e == "number" ? e : 1),
				r = t.valpha === 1 ? t.color : t.color.concat(this.valpha)
			return lx.to.rgb.percent(r)
		},
		array: function () {
			return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha)
		},
		object: function () {
			for (var e = {}, t = wa[this.model].channels, r = wa[this.model].labels, n = 0; n < t; n++)
				e[r[n]] = this.color[n]
			return this.valpha !== 1 && (e.alpha = this.valpha), e
		},
		unitArray: function () {
			var e = this.rgb().color
			return (e[0] /= 255), (e[1] /= 255), (e[2] /= 255), this.valpha !== 1 && e.push(this.valpha), e
		},
		unitObject: function () {
			var e = this.rgb().object()
			return (e.r /= 255), (e.g /= 255), (e.b /= 255), this.valpha !== 1 && (e.alpha = this.valpha), e
		},
		round: function (e) {
			return (e = Math.max(e || 0, 0)), new _s(this.color.map(slt(e)).concat(this.valpha), this.model)
		},
		alpha: function (e) {
			return arguments.length ? new _s(this.color.concat(Math.max(0, Math.min(1, e))), this.model) : this.valpha
		},
		red: oi("rgb", 0, qi(255)),
		green: oi("rgb", 1, qi(255)),
		blue: oi("rgb", 2, qi(255)),
		hue: oi(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function (e) {
			return ((e % 360) + 360) % 360
		}),
		saturationl: oi("hsl", 1, qi(100)),
		lightness: oi("hsl", 2, qi(100)),
		saturationv: oi("hsv", 1, qi(100)),
		value: oi("hsv", 2, qi(100)),
		chroma: oi("hcg", 1, qi(100)),
		gray: oi("hcg", 2, qi(100)),
		white: oi("hwb", 1, qi(100)),
		wblack: oi("hwb", 2, qi(100)),
		cyan: oi("cmyk", 0, qi(100)),
		magenta: oi("cmyk", 1, qi(100)),
		yellow: oi("cmyk", 2, qi(100)),
		black: oi("cmyk", 3, qi(100)),
		x: oi("xyz", 0, qi(100)),
		y: oi("xyz", 1, qi(100)),
		z: oi("xyz", 2, qi(100)),
		l: oi("lab", 0, qi(100)),
		a: oi("lab", 1),
		b: oi("lab", 2),
		keyword: function (e) {
			return arguments.length ? new _s(e) : wa[this.model].keyword(this.color)
		},
		hex: function (e) {
			return arguments.length ? new _s(e) : lx.to.hex(this.rgb().round().color)
		},
		rgbNumber: function () {
			var e = this.rgb().color
			return ((e[0] & 255) << 16) | ((e[1] & 255) << 8) | (e[2] & 255)
		},
		luminosity: function () {
			for (var e = this.rgb().color, t = [], r = 0; r < e.length; r++) {
				var n = e[r] / 255
				t[r] = n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4)
			}
			return 0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]
		},
		contrast: function (e) {
			var t = this.luminosity(),
				r = e.luminosity()
			return t > r ? (t + 0.05) / (r + 0.05) : (r + 0.05) / (t + 0.05)
		},
		level: function (e) {
			var t = this.contrast(e)
			return t >= 7.1 ? "AAA" : t >= 4.5 ? "AA" : ""
		},
		isDark: function () {
			var e = this.rgb().color,
				t = (e[0] * 299 + e[1] * 587 + e[2] * 114) / 1e3
			return t < 128
		},
		isLight: function () {
			return !this.isDark()
		},
		negate: function () {
			for (var e = this.rgb(), t = 0; t < 3; t++) e.color[t] = 255 - e.color[t]
			return e
		},
		lighten: function (e) {
			var t = this.hsl()
			return (t.color[2] += t.color[2] * e), t
		},
		darken: function (e) {
			var t = this.hsl()
			return (t.color[2] -= t.color[2] * e), t
		},
		saturate: function (e) {
			var t = this.hsl()
			return (t.color[1] += t.color[1] * e), t
		},
		desaturate: function (e) {
			var t = this.hsl()
			return (t.color[1] -= t.color[1] * e), t
		},
		whiten: function (e) {
			var t = this.hwb()
			return (t.color[1] += t.color[1] * e), t
		},
		blacken: function (e) {
			var t = this.hwb()
			return (t.color[2] += t.color[2] * e), t
		},
		grayscale: function () {
			var e = this.rgb().color,
				t = e[0] * 0.3 + e[1] * 0.59 + e[2] * 0.11
			return _s.rgb(t, t, t)
		},
		fade: function (e) {
			return this.alpha(this.valpha - this.valpha * e)
		},
		opaquer: function (e) {
			return this.alpha(this.valpha + this.valpha * e)
		},
		rotate: function (e) {
			var t = this.hsl(),
				r = t.color[0]
			return (r = (r + e) % 360), (r = r < 0 ? 360 + r : r), (t.color[0] = r), t
		},
		mix: function (e, t) {
			if (!e || !e.rgb)
				throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof e)
			var r = e.rgb(),
				n = this.rgb(),
				i = t === void 0 ? 0.5 : t,
				s = 2 * i - 1,
				o = r.alpha() - n.alpha(),
				a = ((s * o === -1 ? s : (s + o) / (1 + s * o)) + 1) / 2,
				l = 1 - a
			return _s.rgb(
				a * r.red() + l * n.red(),
				a * r.green() + l * n.green(),
				a * r.blue() + l * n.blue(),
				r.alpha() * i + n.alpha() * (1 - i),
			)
		},
	}
	Object.keys(wa).forEach(function (e) {
		if (Bpe.indexOf(e) === -1) {
			var t = wa[e].channels
			;(_s.prototype[e] = function () {
				if (this.model === e) return new _s(this)
				if (arguments.length) return new _s(arguments, e)
				var r = typeof arguments[t] == "number" ? t : this.valpha
				return new _s(olt(wa[this.model][e].raw(this.color)).concat(r), e)
			}),
				(_s[e] = function (r) {
					return typeof r == "number" && (r = QH(NH.call(arguments), t)), new _s(r, e)
				})
		}
	})
	function ilt(e, t) {
		return Number(e.toFixed(t))
	}
	function slt(e) {
		return function (t) {
			return ilt(t, e)
		}
	}
	function oi(e, t, r) {
		return (
			(e = Array.isArray(e) ? e : [e]),
			e.forEach(function (n) {
				;(UR[n] || (UR[n] = []))[t] = r
			}),
			(e = e[0]),
			function (n) {
				var i
				return arguments.length
					? (r && (n = r(n)), (i = this[e]()), (i.color[t] = n), i)
					: ((i = this[e]().color[t]), r && (i = r(i)), i)
			}
		)
	}
	function qi(e) {
		return function (t) {
			return Math.max(0, Math.min(e, t))
		}
	}
	function olt(e) {
		return Array.isArray(e) ? e : [e]
	}
	function QH(e, t) {
		for (var r = 0; r < t; r++) typeof e[r] != "number" && (e[r] = 0)
		return e
	}
	Dpe.exports = _s
})
var kpe = x((NTt, Rpe) => {
	"use strict"
	Rpe.exports = function (t) {
		for (var r = 0, n = 0; r < t.length; n = t.charCodeAt(r++) + ((n << 5) - n));
		var i = Math.floor(Math.abs(((Math.sin(n) * 1e4) % 1) * 16777216)).toString(16)
		return "#" + Array(6 - i.length + 1).join("0") + i
	}
})
var Npe = x((PTt, Qpe) => {
	"use strict"
	var Mpe = Tpe(),
		Fpe = kpe()
	Qpe.exports = function (t, r) {
		var n = t.split(r || ":"),
			i = Fpe(n[0])
		if (!n.length) return i
		for (var s = 0, o = n.length - 1; s < o; s++)
			i = Mpe(i)
				.mix(Mpe(Fpe(n[s + 1])))
				.saturate(1)
				.hex()
		return i
	}
})
var Lpe = x((LTt, Ppe) => {
	"use strict"
	function mc(e, t) {
		if (t) return new mc(e).style(t)
		if (!(this instanceof mc)) return new mc(e)
		this.text = e
	}
	mc.prototype.prefix = "\x1B["
	mc.prototype.suffix = "m"
	mc.prototype.hex = function (t) {
		;(t = t[0] === "#" ? t.substring(1) : t),
			t.length === 3 &&
				((t = t.split("")),
				(t[5] = t[2]),
				(t[4] = t[2]),
				(t[3] = t[1]),
				(t[2] = t[1]),
				(t[1] = t[0]),
				(t = t.join("")))
		var r = t.substring(0, 2),
			n = t.substring(2, 4),
			i = t.substring(4, 6)
		return [parseInt(r, 16), parseInt(n, 16), parseInt(i, 16)]
	}
	mc.prototype.rgb = function (t, r, n) {
		var i = (t / 255) * 5,
			s = (r / 255) * 5,
			o = (n / 255) * 5
		return this.ansi(i, s, o)
	}
	mc.prototype.ansi = function (t, r, n) {
		var i = Math.round(t),
			s = Math.round(r),
			o = Math.round(n)
		return 16 + i * 36 + s * 6 + o
	}
	mc.prototype.reset = function () {
		return this.prefix + "39;49" + this.suffix
	}
	mc.prototype.style = function (t) {
		return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(t)) + this.suffix + this.text + this.reset()
	}
	Ppe.exports = mc
})
var Ope = x((UTt, Upe) => {
	"use strict"
	var alt = Npe(),
		llt = Lpe()
	Upe.exports = function (t, r) {
		var n = r.namespace,
			i = r.colors !== !1 ? llt(n + ":", alt(n)) : n + ":"
		return (t[0] = i + " " + t[0]), t
	}
})
var Vpe = x((OTt, qpe) => {
	"use strict"
	qpe.exports = function (t, r) {
		if (!r) return !1
		for (var n = r.split(/[\s,]+/), i = 0; i < n.length; i++) {
			if (((r = n[i].replace("*", ".*?")), r.charAt(0) === "-")) {
				if (new RegExp("^" + r.substr(1) + "$").test(t)) return !1
				continue
			}
			if (new RegExp("^" + r + "$").test(t)) return !0
		}
		return !1
	}
})
var Wpe = x((qTt, Hpe) => {
	"use strict"
	var clt = Vpe()
	Hpe.exports = function (t) {
		return function (n) {
			try {
				return clt(n, t())
			} catch {}
			return !1
		}
	}
})
var $pe = x((VTt, Gpe) => {
	"use strict"
	var ult = Wpe()
	Gpe.exports = ult(function () {
		return process.env.DEBUG || process.env.DIAGNOSTICS
	})
})
var Kpe = x((HTt, Ype) => {
	"use strict"
	Ype.exports = function (e, t) {
		try {
			Function.prototype.apply.call(console.log, console, t)
		} catch {}
	}
})
var zpe = x((WTt, Jpe) => {
	"use strict"
	var dlt = RH(),
		flt = require("tty").isatty(1),
		OR = dlt(function e(t, r) {
			return (
				(r = r || {}),
				(r.colors = "colors" in r ? r.colors : flt),
				(r.namespace = t),
				(r.prod = !1),
				(r.dev = !0),
				!e.enabled(t) && !(r.force || e.force) ? e.nope(r) : e.yep(r)
			)
		})
	OR.modify(Ope())
	OR.use($pe())
	OR.set(Kpe())
	Jpe.exports = OR
})
var cx = x((GTt, PH) => {
	"use strict"
	process.env.NODE_ENV === "production" ? (PH.exports = ope()) : (PH.exports = zpe())
})
var Zpe = x(($Tt, jpe) => {
	"use strict"
	var LH = require("fs"),
		{ StringDecoder: hlt } = require("string_decoder"),
		{ Stream: glt } = dy()
	function plt() {}
	jpe.exports = (e, t) => {
		let r = Buffer.alloc(65536),
			n = new hlt("utf8"),
			i = new glt(),
			s = "",
			o = 0,
			a = 0
		return (
			e.start === -1 && delete e.start,
			(i.readable = !0),
			(i.destroy = () => {
				;(i.destroyed = !0), i.emit("end"), i.emit("close")
			}),
			LH.open(e.file, "a+", "0644", (l, c) => {
				if (l) {
					t ? t(l) : i.emit("error", l), i.destroy()
					return
				}
				;(function u() {
					if (i.destroyed) {
						LH.close(c, plt)
						return
					}
					return LH.read(c, r, 0, r.length, o, (f, p) => {
						if (f) {
							t ? t(f) : i.emit("error", f), i.destroy()
							return
						}
						if (!p)
							return (
								s &&
									((e.start == null || a > e.start) && (t ? t(null, s) : i.emit("line", s)),
									a++,
									(s = "")),
								setTimeout(u, 1e3)
							)
						let g = n.write(r.slice(0, p))
						t || i.emit("data", g), (g = (s + g).split(/\n+/))
						let m = g.length - 1,
							y = 0
						for (; y < m; y++)
							(e.start == null || a > e.start) && (t ? t(null, g[y]) : i.emit("line", g[y])), a++
						return (s = g[m]), (o += p), u()
					})
				})()
			}),
			t ? i.destroy : i
		)
	}
})
var tAe = x((KTt, eAe) => {
	"use strict"
	var Wd = require("fs"),
		Hs = require("path"),
		Alt = $ge(),
		mlt = require("zlib"),
		{ MESSAGE: ylt } = Bi(),
		{ Stream: Clt, PassThrough: Xpe } = dy(),
		vlt = Dh(),
		yc = cx()("winston:file"),
		Elt = require("os"),
		blt = Zpe()
	eAe.exports = class extends vlt {
		constructor(t = {}) {
			super(t), (this.name = t.name || "file")
			function r(n, ...i) {
				i.slice(1).forEach((s) => {
					if (t[s]) throw new Error(`Cannot set ${s} and ${n} together`)
				})
			}
			if (
				((this._stream = new Xpe()),
				this._stream.setMaxListeners(30),
				(this._onError = this._onError.bind(this)),
				t.filename || t.dirname)
			)
				r("filename or dirname", "stream"),
					(this._basename = this.filename = t.filename ? Hs.basename(t.filename) : "winston.log"),
					(this.dirname = t.dirname || Hs.dirname(t.filename)),
					(this.options = t.options || { flags: "a" })
			else if (t.stream)
				console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream"),
					r("stream", "filename", "maxsize"),
					(this._dest = this._stream.pipe(this._setupStream(t.stream))),
					(this.dirname = Hs.dirname(this._dest.path))
			else throw new Error("Cannot log to file without filename or stream.")
			;(this.maxsize = t.maxsize || null),
				(this.rotationFormat = t.rotationFormat || !1),
				(this.zippedArchive = t.zippedArchive || !1),
				(this.maxFiles = t.maxFiles || null),
				(this.eol = typeof t.eol == "string" ? t.eol : Elt.EOL),
				(this.tailable = t.tailable || !1),
				(this.lazy = t.lazy || !1),
				(this._size = 0),
				(this._pendingSize = 0),
				(this._created = 0),
				(this._drain = !1),
				(this._opening = !1),
				(this._ending = !1),
				(this._fileExist = !1),
				this.dirname && this._createLogDirIfNotExist(this.dirname),
				this.lazy || this.open()
		}
		finishIfEnding() {
			this._ending &&
				(this._opening
					? this.once("open", () => {
							this._stream.once("finish", () => this.emit("finish")),
								setImmediate(() => this._stream.end())
						})
					: (this._stream.once("finish", () => this.emit("finish")), setImmediate(() => this._stream.end())))
		}
		log(t, r = () => {}) {
			if (this.silent) return r(), !0
			if (this._drain) {
				this._stream.once("drain", () => {
					;(this._drain = !1), this.log(t, r)
				})
				return
			}
			if (this._rotate) {
				this._stream.once("rotate", () => {
					;(this._rotate = !1), this.log(t, r)
				})
				return
			}
			if (this.lazy) {
				if (!this._fileExist) {
					this._opening || this.open(),
						this.once("open", () => {
							;(this._fileExist = !0), this.log(t, r)
						})
					return
				}
				if (this._needsNewFile(this._pendingSize)) {
					this._dest.once("close", () => {
						this._opening || this.open(),
							this.once("open", () => {
								this.log(t, r)
							})
					})
					return
				}
			}
			let n = `${t[ylt]}${this.eol}`,
				i = Buffer.byteLength(n)
			function s() {
				if (
					((this._size += i),
					(this._pendingSize -= i),
					yc("logged %s %s", this._size, n),
					this.emit("logged", t),
					!this._rotate && !this._opening && this._needsNewFile())
				) {
					if (this.lazy) {
						this._endStream(() => {
							this.emit("fileclosed")
						})
						return
					}
					;(this._rotate = !0), this._endStream(() => this._rotateFile())
				}
			}
			;(this._pendingSize += i),
				this._opening &&
					!this.rotatedWhileOpening &&
					this._needsNewFile(this._size + this._pendingSize) &&
					(this.rotatedWhileOpening = !0)
			let o = this._stream.write(n, s.bind(this))
			return (
				o
					? r()
					: ((this._drain = !0),
						this._stream.once("drain", () => {
							;(this._drain = !1), r()
						})),
				yc("written", o, this._drain),
				this.finishIfEnding(),
				o
			)
		}
		query(t, r) {
			typeof t == "function" && ((r = t), (t = {})), (t = f(t))
			let n = Hs.join(this.dirname, this.filename),
				i = "",
				s = [],
				o = 0,
				a = Wd.createReadStream(n, { encoding: "utf8" })
			a.on("error", (p) => {
				if ((a.readable && a.destroy(), !!r)) return p.code !== "ENOENT" ? r(p) : r(null, s)
			}),
				a.on("data", (p) => {
					p = (i + p).split(/\n+/)
					let g = p.length - 1,
						m = 0
					for (; m < g; m++) (!t.start || o >= t.start) && l(p[m]), o++
					i = p[g]
				}),
				a.on("close", () => {
					i && l(i, !0), t.order === "desc" && (s = s.reverse()), r && r(null, s)
				})
			function l(p, g) {
				try {
					let m = JSON.parse(p)
					u(m) && c(m)
				} catch (m) {
					g || a.emit("error", m)
				}
			}
			function c(p) {
				if (t.rows && s.length >= t.rows && t.order !== "desc") {
					a.readable && a.destroy()
					return
				}
				t.fields && (p = t.fields.reduce((g, m) => ((g[m] = p[m]), g), {})),
					t.order === "desc" && s.length >= t.rows && s.shift(),
					s.push(p)
			}
			function u(p) {
				if (!p || typeof p != "object") return
				let g = new Date(p.timestamp)
				if (!((t.from && g < t.from) || (t.until && g > t.until) || (t.level && t.level !== p.level))) return !0
			}
			function f(p) {
				return (
					(p = p || {}),
					(p.rows = p.rows || p.limit || 10),
					(p.start = p.start || 0),
					(p.until = p.until || new Date()),
					typeof p.until != "object" && (p.until = new Date(p.until)),
					(p.from = p.from || p.until - 24 * 60 * 60 * 1e3),
					typeof p.from != "object" && (p.from = new Date(p.from)),
					(p.order = p.order || "desc"),
					p
				)
			}
		}
		stream(t = {}) {
			let r = Hs.join(this.dirname, this.filename),
				n = new Clt(),
				i = { file: r, start: t.start }
			return (
				(n.destroy = blt(i, (s, o) => {
					if (s) return n.emit("error", s)
					try {
						n.emit("data", o), (o = JSON.parse(o)), n.emit("log", o)
					} catch (a) {
						n.emit("error", a)
					}
				})),
				n
			)
		}
		open() {
			this.filename &&
				(this._opening ||
					((this._opening = !0),
					this.stat((t, r) => {
						if (t) return this.emit("error", t)
						yc("stat done: %s { size: %s }", this.filename, r),
							(this._size = r),
							(this._dest = this._createStream(this._stream)),
							(this._opening = !1),
							this.once("open", () => {
								this._stream.eventNames().includes("rotate")
									? this._stream.emit("rotate")
									: (this._rotate = !1)
							})
					})))
		}
		stat(t) {
			let r = this._getFile(),
				n = Hs.join(this.dirname, r)
			Wd.stat(n, (i, s) => {
				if (i && i.code === "ENOENT") return yc("ENOENT\xA0ok", n), (this.filename = r), t(null, 0)
				if (i) return yc(`err ${i.code} ${n}`), t(i)
				if (!s || this._needsNewFile(s.size)) return this._incFile(() => this.stat(t))
				;(this.filename = r), t(null, s.size)
			})
		}
		close(t) {
			this._stream &&
				this._stream.end(() => {
					t && t(), this.emit("flush"), this.emit("closed")
				})
		}
		_needsNewFile(t) {
			return (t = t || this._size), this.maxsize && t >= this.maxsize
		}
		_onError(t) {
			this.emit("error", t)
		}
		_setupStream(t) {
			return t.on("error", this._onError), t
		}
		_cleanupStream(t) {
			return t.removeListener("error", this._onError), t.destroy(), t
		}
		_rotateFile() {
			this._incFile(() => this.open())
		}
		_endStream(t = () => {}) {
			this._dest
				? (this._stream.unpipe(this._dest),
					this._dest.end(() => {
						this._cleanupStream(this._dest), t()
					}))
				: t()
		}
		_createStream(t) {
			let r = Hs.join(this.dirname, this.filename)
			yc("create stream start", r, this.options)
			let n = Wd.createWriteStream(r, this.options)
				.on("error", (i) => yc(i))
				.on("close", () => yc("close", n.path, n.bytesWritten))
				.on("open", () => {
					yc("file open ok", r),
						this.emit("open", r),
						t.pipe(n),
						this.rotatedWhileOpening &&
							((this._stream = new Xpe()),
							this._stream.setMaxListeners(30),
							this._rotateFile(),
							(this.rotatedWhileOpening = !1),
							this._cleanupStream(n),
							t.end())
				})
			if ((yc("create stream ok", r), this.zippedArchive)) {
				let i = mlt.createGzip()
				return i.pipe(n), i
			}
			return n
		}
		_incFile(t) {
			yc("_incFile", this.filename)
			let r = Hs.extname(this._basename),
				n = Hs.basename(this._basename, r)
			this.tailable
				? this._checkMaxFilesTailable(r, n, t)
				: ((this._created += 1), this._checkMaxFilesIncrementing(r, n, t))
		}
		_getFile() {
			let t = Hs.extname(this._basename),
				r = Hs.basename(this._basename, t),
				n = this.rotationFormat ? this.rotationFormat() : this._created,
				i = !this.tailable && this._created ? `${r}${n}${t}` : `${r}${t}`
			return this.zippedArchive && !this.tailable ? `${i}.gz` : i
		}
		_checkMaxFilesIncrementing(t, r, n) {
			if (!this.maxFiles || this._created < this.maxFiles) return setImmediate(n)
			let i = this._created - this.maxFiles,
				s = i !== 0 ? i : "",
				o = this.zippedArchive ? ".gz" : "",
				a = `${r}${s}${t}${o}`,
				l = Hs.join(this.dirname, a)
			Wd.unlink(l, n)
		}
		_checkMaxFilesTailable(t, r, n) {
			let i = []
			if (!this.maxFiles) return
			let s = this.zippedArchive ? ".gz" : ""
			for (let o = this.maxFiles - 1; o > 1; o--)
				i.push(
					function (a, l) {
						let c = `${r}${a - 1}${t}${s}`,
							u = Hs.join(this.dirname, c)
						Wd.exists(u, (f) => {
							if (!f) return l(null)
							;(c = `${r}${a}${t}${s}`), Wd.rename(u, Hs.join(this.dirname, c), l)
						})
					}.bind(this, o),
				)
			Alt(i, () => {
				Wd.rename(Hs.join(this.dirname, `${r}${t}`), Hs.join(this.dirname, `${r}1${t}${s}`), n)
			})
		}
		_createLogDirIfNotExist(t) {
			Wd.existsSync(t) || Wd.mkdirSync(t, { recursive: !0 })
		}
	}
})
var nAe = x((zTt, rAe) => {
	"use strict"
	var xlt = require("http"),
		_lt = require("https"),
		{ Stream: wlt } = dy(),
		Ilt = Dh(),
		Slt = Wb()
	rAe.exports = class extends Ilt {
		constructor(t = {}) {
			super(t),
				(this.options = t),
				(this.name = t.name || "http"),
				(this.ssl = !!t.ssl),
				(this.host = t.host || "localhost"),
				(this.port = t.port),
				(this.auth = t.auth),
				(this.path = t.path || ""),
				(this.agent = t.agent),
				(this.headers = t.headers || {}),
				(this.headers["content-type"] = "application/json"),
				(this.batch = t.batch || !1),
				(this.batchInterval = t.batchInterval || 5e3),
				(this.batchCount = t.batchCount || 10),
				(this.batchOptions = []),
				(this.batchTimeoutID = -1),
				(this.batchCallback = {}),
				this.port || (this.port = this.ssl ? 443 : 80)
		}
		log(t, r) {
			this._request(t, null, null, (n, i) => {
				i && i.statusCode !== 200 && (n = new Error(`Invalid HTTP Status Code: ${i.statusCode}`)),
					n ? this.emit("warn", n) : this.emit("logged", t)
			}),
				r && setImmediate(r)
		}
		query(t, r) {
			typeof t == "function" && ((r = t), (t = {})), (t = { method: "query", params: this.normalizeQuery(t) })
			let n = t.params.auth || null
			delete t.params.auth
			let i = t.params.path || null
			delete t.params.path,
				this._request(t, n, i, (s, o, a) => {
					if ((o && o.statusCode !== 200 && (s = new Error(`Invalid HTTP Status Code: ${o.statusCode}`)), s))
						return r(s)
					if (typeof a == "string")
						try {
							a = JSON.parse(a)
						} catch (l) {
							return r(l)
						}
					r(null, a)
				})
		}
		stream(t = {}) {
			let r = new wlt()
			t = { method: "stream", params: t }
			let n = t.params.path || null
			delete t.params.path
			let i = t.params.auth || null
			delete t.params.auth
			let s = "",
				o = this._request(t, i, n)
			return (
				(r.destroy = () => o.destroy()),
				o.on("data", (a) => {
					a = (s + a).split(/\n+/)
					let l = a.length - 1,
						c = 0
					for (; c < l; c++)
						try {
							r.emit("log", JSON.parse(a[c]))
						} catch (u) {
							r.emit("error", u)
						}
					s = a[l]
				}),
				o.on("error", (a) => r.emit("error", a)),
				r
			)
		}
		_request(t, r, n, i) {
			;(t = t || {}),
				(r = r || this.auth),
				(n = n || this.path || ""),
				this.batch ? this._doBatch(t, i, r, n) : this._doRequest(t, i, r, n)
		}
		_doBatch(t, r, n, i) {
			if ((this.batchOptions.push(t), this.batchOptions.length === 1)) {
				let s = this
				;(this.batchCallback = r),
					(this.batchTimeoutID = setTimeout(function () {
						;(s.batchTimeoutID = -1), s._doBatchRequest(s.batchCallback, n, i)
					}, this.batchInterval))
			}
			this.batchOptions.length === this.batchCount && this._doBatchRequest(this.batchCallback, n, i)
		}
		_doBatchRequest(t, r, n) {
			this.batchTimeoutID > 0 && (clearTimeout(this.batchTimeoutID), (this.batchTimeoutID = -1))
			let i = this.batchOptions.slice()
			;(this.batchOptions = []), this._doRequest(i, t, r, n)
		}
		_doRequest(t, r, n, i) {
			let s = Object.assign({}, this.headers)
			n && n.bearer && (s.Authorization = `Bearer ${n.bearer}`)
			let o = (this.ssl ? _lt : xlt).request({
				...this.options,
				method: "POST",
				host: this.host,
				port: this.port,
				path: `/${i.replace(/^\//, "")}`,
				headers: s,
				auth: n && n.username && n.password ? `${n.username}:${n.password}` : "",
				agent: this.agent,
			})
			o.on("error", r),
				o.on("response", (a) => a.on("end", () => r(null, a)).resume()),
				o.end(Buffer.from(Slt(t, this.options.replacer), "utf8"))
		}
	}
})
var UH = x((jTt, iAe) => {
	"use strict"
	var xu = (e) => e !== null && typeof e == "object" && typeof e.pipe == "function"
	xu.writable = (e) =>
		xu(e) && e.writable !== !1 && typeof e._write == "function" && typeof e._writableState == "object"
	xu.readable = (e) =>
		xu(e) && e.readable !== !1 && typeof e._read == "function" && typeof e._readableState == "object"
	xu.duplex = (e) => xu.writable(e) && xu.readable(e)
	xu.transform = (e) => xu.duplex(e) && typeof e._transform == "function"
	iAe.exports = xu
})
var oAe = x((XTt, sAe) => {
	"use strict"
	var Blt = UH(),
		{ MESSAGE: Dlt } = Bi(),
		Tlt = require("os"),
		Rlt = Dh()
	sAe.exports = class extends Rlt {
		constructor(t = {}) {
			if ((super(t), !t.stream || !Blt(t.stream))) throw new Error("options.stream is required.")
			;(this._stream = t.stream),
				this._stream.setMaxListeners(1 / 0),
				(this.isObjectMode = t.stream._writableState.objectMode),
				(this.eol = typeof t.eol == "string" ? t.eol : Tlt.EOL)
		}
		log(t, r) {
			if ((setImmediate(() => this.emit("logged", t)), this.isObjectMode)) {
				this._stream.write(t), r && r()
				return
			}
			this._stream.write(`${t[Dlt]}${this.eol}`), r && r()
		}
	}
})
var aAe = x((ux) => {
	"use strict"
	Object.defineProperty(ux, "Console", {
		configurable: !0,
		enumerable: !0,
		get() {
			return uge()
		},
	})
	Object.defineProperty(ux, "File", {
		configurable: !0,
		enumerable: !0,
		get() {
			return tAe()
		},
	})
	Object.defineProperty(ux, "Http", {
		configurable: !0,
		enumerable: !0,
		get() {
			return nAe()
		},
	})
	Object.defineProperty(ux, "Stream", {
		configurable: !0,
		enumerable: !0,
		get() {
			return oAe()
		},
	})
})
var VR = x((dx) => {
	"use strict"
	var qR = O3(),
		{ configs: OH } = Bi()
	dx.cli = qR.levels(OH.cli)
	dx.npm = qR.levels(OH.npm)
	dx.syslog = qR.levels(OH.syslog)
	dx.addColors = qR.levels
})
var cAe = x((HR, lAe) => {
	"use strict"
	Object.defineProperty(HR, "__esModule", { value: !0 })
	var klt = mR(),
		Mlt = Wp(klt),
		Flt = SR(),
		Qlt = Wp(Flt),
		Nlt = bH(),
		Plt = Wp(Nlt),
		Llt = CH(),
		Ult = Wp(Llt),
		Olt = vH(),
		qlt = Wp(Olt),
		Vlt = Vp(),
		Hlt = Wp(Vlt),
		Wlt = uy(),
		Glt = Wp(Wlt)
	function Wp(e) {
		return e && e.__esModule ? e : { default: e }
	}
	function $lt(e, t, r) {
		r = (0, Ult.default)(r)
		var n = 0,
			i = 0,
			{ length: s } = e,
			o = !1
		s === 0 && r(null)
		function a(l, c) {
			l === !1 && (o = !0), o !== !0 && (l ? r(l) : (++i === s || c === Qlt.default) && r(null))
		}
		for (; n < s; n++) t(e[n], n, (0, qlt.default)(a))
	}
	function Ylt(e, t, r) {
		return (0, Plt.default)(e, 1 / 0, t, r)
	}
	function Klt(e, t, r) {
		var n = (0, Mlt.default)(e) ? $lt : Ylt
		return n(e, (0, Hlt.default)(t), r)
	}
	HR.default = (0, Glt.default)(Klt, 3)
	lAe.exports = HR.default
})
var dAe = x((WR, uAe) => {
	"use strict"
	Object.defineProperty(WR, "__esModule", { value: !0 })
	WR.default = Jlt
	function Jlt(e) {
		return (t, r, n) => e(t, n)
	}
	uAe.exports = WR.default
})
var YR = x(($R, fAe) => {
	"use strict"
	Object.defineProperty($R, "__esModule", { value: !0 })
	var zlt = cAe(),
		jlt = GR(zlt),
		Zlt = dAe(),
		Xlt = GR(Zlt),
		ect = Vp(),
		tct = GR(ect),
		rct = uy(),
		nct = GR(rct)
	function GR(e) {
		return e && e.__esModule ? e : { default: e }
	}
	function ict(e, t, r) {
		return (0, jlt.default)(e, (0, Xlt.default)((0, tct.default)(t)), r)
	}
	$R.default = (0, nct.default)(ict, 3)
	fAe.exports = $R.default
})
var gAe = x((rRt, hAe) => {
	"use strict"
	var sct = Object.prototype.toString
	hAe.exports = function (t) {
		if (typeof t.displayName == "string" && t.constructor.name) return t.displayName
		if (typeof t.name == "string" && t.name) return t.name
		if (typeof t == "object" && t.constructor && typeof t.constructor.name == "string") return t.constructor.name
		var r = t.toString(),
			n = sct.call(t).slice(8, -1)
		return n === "Function" ? (r = r.substring(r.indexOf("(") + 1, r.indexOf(")"))) : (r = n), r || "anonymous"
	}
})
var qH = x((nRt, pAe) => {
	"use strict"
	var oct = gAe()
	pAe.exports = function (t) {
		var r = 0,
			n
		function i() {
			return r || ((r = 1), (n = t.apply(this, arguments)), (t = null)), n
		}
		return (i.displayName = oct(t)), i
	}
})
var VH = x((hx) => {
	"use strict"
	hx.get = function (e) {
		var t = Error.stackTraceLimit
		Error.stackTraceLimit = 1 / 0
		var r = {},
			n = Error.prepareStackTrace
		;(Error.prepareStackTrace = function (s, o) {
			return o
		}),
			Error.captureStackTrace(r, e || hx.get)
		var i = r.stack
		return (Error.prepareStackTrace = n), (Error.stackTraceLimit = t), i
	}
	hx.parse = function (e) {
		if (!e.stack) return []
		var t = this,
			r = e.stack
				.split(
					`
`,
				)
				.slice(1)
		return r
			.map(function (n) {
				if (n.match(/^\s*[-]{4,}$/))
					return t._createParsedCallSite({
						fileName: n,
						lineNumber: null,
						functionName: null,
						typeName: null,
						methodName: null,
						columnNumber: null,
						native: null,
					})
				var i = n.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/)
				if (i) {
					var s = null,
						o = null,
						a = null,
						l = null,
						c = null,
						u = i[5] === "native"
					if (i[1]) {
						a = i[1]
						var f = a.lastIndexOf(".")
						if ((a[f - 1] == "." && f--, f > 0)) {
							;(s = a.substr(0, f)), (o = a.substr(f + 1))
							var p = s.indexOf(".Module")
							p > 0 && ((a = a.substr(p + 1)), (s = s.substr(0, p)))
						}
						l = null
					}
					o && ((l = s), (c = o)), o === "<anonymous>" && ((c = null), (a = null))
					var g = {
						fileName: i[2] || null,
						lineNumber: parseInt(i[3], 10) || null,
						functionName: a,
						typeName: l,
						methodName: c,
						columnNumber: parseInt(i[4], 10) || null,
						native: u,
					}
					return t._createParsedCallSite(g)
				}
			})
			.filter(function (n) {
				return !!n
			})
	}
	function fx(e) {
		for (var t in e) this[t] = e[t]
	}
	var act = [
			"this",
			"typeName",
			"functionName",
			"methodName",
			"fileName",
			"lineNumber",
			"columnNumber",
			"function",
			"evalOrigin",
		],
		lct = ["topLevel", "eval", "native", "constructor"]
	act.forEach(function (e) {
		;(fx.prototype[e] = null),
			(fx.prototype["get" + e[0].toUpperCase() + e.substr(1)] = function () {
				return this[e]
			})
	})
	lct.forEach(function (e) {
		;(fx.prototype[e] = !1),
			(fx.prototype["is" + e[0].toUpperCase() + e.substr(1)] = function () {
				return this[e]
			})
	})
	hx._createParsedCallSite = function (e) {
		return new fx(e)
	}
})
var HH = x((oRt, AAe) => {
	"use strict"
	var { Writable: cct } = dy()
	AAe.exports = class extends cct {
		constructor(t) {
			if ((super({ objectMode: !0 }), !t)) throw new Error("ExceptionStream requires a TransportStream instance.")
			;(this.handleExceptions = !0), (this.transport = t)
		}
		_write(t, r, n) {
			return t.exception ? this.transport.log(t, n) : (n(), !0)
		}
	}
})
var GH = x((lRt, CAe) => {
	"use strict"
	var mAe = require("os"),
		uct = YR(),
		WH = cx()("winston:exception"),
		dct = qH(),
		yAe = VH(),
		fct = HH()
	CAe.exports = class {
		constructor(t) {
			if (!t) throw new Error("Logger is required to handle exceptions")
			;(this.logger = t), (this.handlers = new Map())
		}
		handle(...t) {
			t.forEach((r) => {
				if (Array.isArray(r)) return r.forEach((n) => this._addHandler(n))
				this._addHandler(r)
			}),
				this.catcher ||
					((this.catcher = this._uncaughtException.bind(this)), process.on("uncaughtException", this.catcher))
		}
		unhandle() {
			this.catcher &&
				(process.removeListener("uncaughtException", this.catcher),
				(this.catcher = !1),
				Array.from(this.handlers.values()).forEach((t) => this.logger.unpipe(t)))
		}
		getAllInfo(t) {
			let r = null
			return (
				t && (r = typeof t == "string" ? t : t.message),
				{
					error: t,
					level: "error",
					message: [`uncaughtException: ${r || "(no error message)"}`, (t && t.stack) || "  No stack trace"]
						.join(`
`),
					stack: t && t.stack,
					exception: !0,
					date: new Date().toString(),
					process: this.getProcessInfo(),
					os: this.getOsInfo(),
					trace: this.getTrace(t),
				}
			)
		}
		getProcessInfo() {
			return {
				pid: process.pid,
				uid: process.getuid ? process.getuid() : null,
				gid: process.getgid ? process.getgid() : null,
				cwd: process.cwd(),
				execPath: process.execPath,
				version: process.version,
				argv: process.argv,
				memoryUsage: process.memoryUsage(),
			}
		}
		getOsInfo() {
			return { loadavg: mAe.loadavg(), uptime: mAe.uptime() }
		}
		getTrace(t) {
			return (t ? yAe.parse(t) : yAe.get()).map((n) => ({
				column: n.getColumnNumber(),
				file: n.getFileName(),
				function: n.getFunctionName(),
				line: n.getLineNumber(),
				method: n.getMethodName(),
				native: n.isNative(),
			}))
		}
		_addHandler(t) {
			if (!this.handlers.has(t)) {
				t.handleExceptions = !0
				let r = new fct(t)
				this.handlers.set(t, r), this.logger.pipe(r)
			}
		}
		_uncaughtException(t) {
			let r = this.getAllInfo(t),
				n = this._getExceptionHandlers(),
				i = typeof this.logger.exitOnError == "function" ? this.logger.exitOnError(t) : this.logger.exitOnError,
				s
			!n.length &&
				i &&
				(console.warn("winston: exitOnError cannot be true with no exception handlers."),
				console.warn("winston: not exiting process."),
				(i = !1))
			function o() {
				WH("doExit", i),
					WH("process._exiting", process._exiting),
					i && !process._exiting && (s && clearTimeout(s), process.exit(1))
			}
			if (!n || n.length === 0) return process.nextTick(o)
			uct(
				n,
				(a, l) => {
					let c = dct(l),
						u = a.transport || a
					function f(p) {
						return () => {
							WH(p), c()
						}
					}
					;(u._ending = !0), u.once("finish", f("finished")), u.once("error", f("error"))
				},
				() => i && o(),
			),
				this.logger.log(r),
				i && (s = setTimeout(o, 3e3))
		}
		_getExceptionHandlers() {
			return this.logger.transports.filter((t) => (t.transport || t).handleExceptions)
		}
	}
})
var YH = x((uRt, bAe) => {
	"use strict"
	var vAe = require("os"),
		hct = YR(),
		$H = cx()("winston:rejection"),
		gct = qH(),
		EAe = VH(),
		pct = HH()
	bAe.exports = class {
		constructor(t) {
			if (!t) throw new Error("Logger is required to handle rejections")
			;(this.logger = t), (this.handlers = new Map())
		}
		handle(...t) {
			t.forEach((r) => {
				if (Array.isArray(r)) return r.forEach((n) => this._addHandler(n))
				this._addHandler(r)
			}),
				this.catcher ||
					((this.catcher = this._unhandledRejection.bind(this)),
					process.on("unhandledRejection", this.catcher))
		}
		unhandle() {
			this.catcher &&
				(process.removeListener("unhandledRejection", this.catcher),
				(this.catcher = !1),
				Array.from(this.handlers.values()).forEach((t) => this.logger.unpipe(t)))
		}
		getAllInfo(t) {
			let r = null
			return (
				t && (r = typeof t == "string" ? t : t.message),
				{
					error: t,
					level: "error",
					message: [`unhandledRejection: ${r || "(no error message)"}`, (t && t.stack) || "  No stack trace"]
						.join(`
`),
					stack: t && t.stack,
					exception: !0,
					date: new Date().toString(),
					process: this.getProcessInfo(),
					os: this.getOsInfo(),
					trace: this.getTrace(t),
				}
			)
		}
		getProcessInfo() {
			return {
				pid: process.pid,
				uid: process.getuid ? process.getuid() : null,
				gid: process.getgid ? process.getgid() : null,
				cwd: process.cwd(),
				execPath: process.execPath,
				version: process.version,
				argv: process.argv,
				memoryUsage: process.memoryUsage(),
			}
		}
		getOsInfo() {
			return { loadavg: vAe.loadavg(), uptime: vAe.uptime() }
		}
		getTrace(t) {
			return (t ? EAe.parse(t) : EAe.get()).map((n) => ({
				column: n.getColumnNumber(),
				file: n.getFileName(),
				function: n.getFunctionName(),
				line: n.getLineNumber(),
				method: n.getMethodName(),
				native: n.isNative(),
			}))
		}
		_addHandler(t) {
			if (!this.handlers.has(t)) {
				t.handleRejections = !0
				let r = new pct(t)
				this.handlers.set(t, r), this.logger.pipe(r)
			}
		}
		_unhandledRejection(t) {
			let r = this.getAllInfo(t),
				n = this._getRejectionHandlers(),
				i = typeof this.logger.exitOnError == "function" ? this.logger.exitOnError(t) : this.logger.exitOnError,
				s
			!n.length &&
				i &&
				(console.warn("winston: exitOnError cannot be true with no rejection handlers."),
				console.warn("winston: not exiting process."),
				(i = !1))
			function o() {
				$H("doExit", i),
					$H("process._exiting", process._exiting),
					i && !process._exiting && (s && clearTimeout(s), process.exit(1))
			}
			if (!n || n.length === 0) return process.nextTick(o)
			hct(
				n,
				(a, l) => {
					let c = gct(l),
						u = a.transport || a
					function f(p) {
						return () => {
							$H(p), c()
						}
					}
					;(u._ending = !0), u.once("finish", f("finished")), u.once("error", f("error"))
				},
				() => i && o(),
			),
				this.logger.log(r),
				i && (s = setTimeout(o, 3e3))
		}
		_getRejectionHandlers() {
			return this.logger.transports.filter((t) => (t.transport || t).handleRejections)
		}
	}
})
var _Ae = x((dRt, xAe) => {
	"use strict"
	var KH = class {
		constructor(t) {
			let r = KR()
			if (typeof t != "object" || Array.isArray(t) || !(t instanceof r))
				throw new Error("Logger is required for profiling")
			;(this.logger = t), (this.start = Date.now())
		}
		done(...t) {
			typeof t[t.length - 1] == "function" &&
				(console.warn("Callback function no longer supported as of winston@3.0.0"), t.pop())
			let r = typeof t[t.length - 1] == "object" ? t.pop() : {}
			return (r.level = r.level || "info"), (r.durationMs = Date.now() - this.start), this.logger.write(r)
		}
	}
	xAe.exports = KH
})
var KR = x((fRt, BAe) => {
	"use strict"
	var { Stream: Act, Transform: mct } = dy(),
		wAe = YR(),
		{ LEVEL: _u, SPLAT: IAe } = Bi(),
		SAe = UH(),
		yct = GH(),
		Cct = YH(),
		vct = AH(),
		Ect = _Ae(),
		{ warn: bct } = q3(),
		xct = VR(),
		_ct = /%[scdjifoO%]/g,
		JR = class extends mct {
			constructor(t) {
				super({ objectMode: !0 }), this.configure(t)
			}
			child(t) {
				let r = this
				return Object.create(r, {
					write: {
						value: function (n) {
							let i = Object.assign({}, t, n)
							n instanceof Error && ((i.stack = n.stack), (i.message = n.message)), r.write(i)
						},
					},
				})
			}
			configure({
				silent: t,
				format: r,
				defaultMeta: n,
				levels: i,
				level: s = "info",
				exitOnError: o = !0,
				transports: a,
				colors: l,
				emitErrs: c,
				formatters: u,
				padLevels: f,
				rewriters: p,
				stripColors: g,
				exceptionHandlers: m,
				rejectionHandlers: y,
			} = {}) {
				if (
					(this.transports.length && this.clear(),
					(this.silent = t),
					(this.format = r || this.format || Q3()()),
					(this.defaultMeta = n || null),
					(this.levels = i || this.levels || xct.npm.levels),
					(this.level = s),
					this.exceptions && this.exceptions.unhandle(),
					this.rejections && this.rejections.unhandle(),
					(this.exceptions = new yct(this)),
					(this.rejections = new Cct(this)),
					(this.profilers = {}),
					(this.exitOnError = o),
					a && ((a = Array.isArray(a) ? a : [a]), a.forEach((C) => this.add(C))),
					l || c || u || f || p || g)
				)
					throw new Error(
						[
							"{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
							"Use a custom winston.format(function) instead.",
							"See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md",
						].join(`
`),
					)
				m && this.exceptions.handle(m), y && this.rejections.handle(y)
			}
			isLevelEnabled(t) {
				let r = JH(this.levels, t)
				if (r === null) return !1
				let n = JH(this.levels, this.level)
				return n === null
					? !1
					: !this.transports || this.transports.length === 0
						? n >= r
						: this.transports.findIndex((s) => {
								let o = JH(this.levels, s.level)
								return o === null && (o = n), o >= r
							}) !== -1
			}
			log(t, r, ...n) {
				if (arguments.length === 1) return (t[_u] = t.level), this._addDefaultMeta(t), this.write(t), this
				if (arguments.length === 2)
					return r && typeof r == "object"
						? ((r[_u] = r.level = t), this._addDefaultMeta(r), this.write(r), this)
						: ((r = { [_u]: t, level: t, message: r }), this._addDefaultMeta(r), this.write(r), this)
				let [i] = n
				if (typeof i == "object" && i !== null && !(r && r.match && r.match(_ct))) {
					let o = Object.assign({}, this.defaultMeta, i, {
						[_u]: t,
						[IAe]: n,
						level: t,
						message: r,
					})
					return (
						i.message && (o.message = `${o.message} ${i.message}`),
						i.stack && (o.stack = i.stack),
						this.write(o),
						this
					)
				}
				return (
					this.write(
						Object.assign({}, this.defaultMeta, {
							[_u]: t,
							[IAe]: n,
							level: t,
							message: r,
						}),
					),
					this
				)
			}
			_transform(t, r, n) {
				if (this.silent) return n()
				t[_u] || (t[_u] = t.level),
					!this.levels[t[_u]] &&
						this.levels[t[_u]] !== 0 &&
						console.error("[winston] Unknown logger level: %s", t[_u]),
					this._readableState.pipes ||
						console.error(
							"[winston] Attempt to write logs with no transports, which can increase memory usage: %j",
							t,
						)
				try {
					this.push(this.format.transform(t, this.format.options))
				} finally {
					;(this._writableState.sync = !1), n()
				}
			}
			_final(t) {
				let r = this.transports.slice()
				wAe(
					r,
					(n, i) => {
						if (!n || n.finished) return setImmediate(i)
						n.once("finish", i), n.end()
					},
					t,
				)
			}
			add(t) {
				let r = !SAe(t) || t.log.length > 2 ? new vct({ transport: t }) : t
				if (!r._writableState || !r._writableState.objectMode)
					throw new Error("Transports must WritableStreams in objectMode. Set { objectMode: true }.")
				return (
					this._onEvent("error", r),
					this._onEvent("warn", r),
					this.pipe(r),
					t.handleExceptions && this.exceptions.handle(),
					t.handleRejections && this.rejections.handle(),
					this
				)
			}
			remove(t) {
				if (!t) return this
				let r = t
				return (
					(!SAe(t) || t.log.length > 2) && (r = this.transports.filter((n) => n.transport === t)[0]),
					r && this.unpipe(r),
					this
				)
			}
			clear() {
				return this.unpipe(), this
			}
			close() {
				return this.exceptions.unhandle(), this.rejections.unhandle(), this.clear(), this.emit("close"), this
			}
			setLevels() {
				bct.deprecated("setLevels")
			}
			query(t, r) {
				typeof t == "function" && ((r = t), (t = {})), (t = t || {})
				let n = {},
					i = Object.assign({}, t.query || {})
				function s(a, l) {
					t.query && typeof a.formatQuery == "function" && (t.query = a.formatQuery(i)),
						a.query(t, (c, u) => {
							if (c) return l(c)
							typeof a.formatResults == "function" && (u = a.formatResults(u, t.format)), l(null, u)
						})
				}
				function o(a, l) {
					s(a, (c, u) => {
						l && ((u = c || u), u && (n[a.name] = u), l()), (l = null)
					})
				}
				wAe(
					this.transports.filter((a) => !!a.query),
					o,
					() => r(null, n),
				)
			}
			stream(t = {}) {
				let r = new Act(),
					n = []
				return (
					(r._streams = n),
					(r.destroy = () => {
						let i = n.length
						for (; i--; ) n[i].destroy()
					}),
					this.transports
						.filter((i) => !!i.stream)
						.forEach((i) => {
							let s = i.stream(t)
							s &&
								(n.push(s),
								s.on("log", (o) => {
									;(o.transport = o.transport || []), o.transport.push(i.name), r.emit("log", o)
								}),
								s.on("error", (o) => {
									;(o.transport = o.transport || []), o.transport.push(i.name), r.emit("error", o)
								}))
						}),
					r
				)
			}
			startTimer() {
				return new Ect(this)
			}
			profile(t, ...r) {
				let n = Date.now()
				if (this.profilers[t]) {
					let i = this.profilers[t]
					delete this.profilers[t],
						typeof r[r.length - 2] == "function" &&
							(console.warn("Callback function no longer supported as of winston@3.0.0"), r.pop())
					let s = typeof r[r.length - 1] == "object" ? r.pop() : {}
					return (
						(s.level = s.level || "info"),
						(s.durationMs = n - i),
						(s.message = s.message || t),
						this.write(s)
					)
				}
				return (this.profilers[t] = n), this
			}
			handleExceptions(...t) {
				console.warn("Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()"),
					this.exceptions.handle(...t)
			}
			unhandleExceptions(...t) {
				console.warn(
					"Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()",
				),
					this.exceptions.unhandle(...t)
			}
			cli() {
				throw new Error(
					[
						"Logger.cli() was removed in winston@3.0.0",
						"Use a custom winston.formats.cli() instead.",
						"See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md",
					].join(`
`),
				)
			}
			_onEvent(t, r) {
				function n(i) {
					t === "error" && !this.transports.includes(r) && this.add(r), this.emit(t, i, r)
				}
				r["__winston" + t] || ((r["__winston" + t] = n.bind(this)), r.on(t, r["__winston" + t]))
			}
			_addDefaultMeta(t) {
				this.defaultMeta && Object.assign(t, this.defaultMeta)
			}
		}
	function JH(e, t) {
		let r = e[t]
		return !r && r !== 0 ? null : r
	}
	Object.defineProperty(JR.prototype, "transports", {
		configurable: !1,
		enumerable: !0,
		get() {
			let { pipes: e } = this._readableState
			return Array.isArray(e) ? e : [e].filter(Boolean)
		},
	})
	BAe.exports = JR
})
var zH = x((hRt, DAe) => {
	"use strict"
	var { LEVEL: wct } = Bi(),
		Ict = VR(),
		Sct = KR(),
		Bct = cx()("winston:create-logger")
	function Dct(e) {
		return "is" + e.charAt(0).toUpperCase() + e.slice(1) + "Enabled"
	}
	DAe.exports = function (e = {}) {
		e.levels = e.levels || Ict.npm.levels
		class t extends Sct {
			constructor(i) {
				super(i)
			}
		}
		let r = new t(e)
		return (
			Object.keys(e.levels).forEach(function (n) {
				if ((Bct('Define prototype method for "%s"', n), n === "log")) {
					console.warn(
						'Level "log" not defined: conflicts with the method "log". Use a different level name.',
					)
					return
				}
				;(t.prototype[n] = function (...i) {
					let s = this || r
					if (i.length === 1) {
						let [o] = i,
							a = (o && o.message && o) || { message: o }
						return (a.level = a[wct] = n), s._addDefaultMeta(a), s.write(a), this || r
					}
					return i.length === 0 ? (s.log(n, ""), s) : s.log(n, ...i)
				}),
					(t.prototype[Dct(n)] = function () {
						return (this || r).isLevelEnabled(n)
					})
			}),
			r
		)
	}
})
var RAe = x((pRt, TAe) => {
	"use strict"
	var Tct = zH()
	TAe.exports = class {
		constructor(t = {}) {
			;(this.loggers = new Map()), (this.options = t)
		}
		add(t, r) {
			if (!this.loggers.has(t)) {
				r = Object.assign({}, r || this.options)
				let n = r.transports || this.options.transports
				n ? (r.transports = Array.isArray(n) ? n.slice() : [n]) : (r.transports = [])
				let i = Tct(r)
				i.on("close", () => this._delete(t)), this.loggers.set(t, i)
			}
			return this.loggers.get(t)
		}
		get(t, r) {
			return this.add(t, r)
		}
		has(t) {
			return !!this.loggers.has(t)
		}
		close(t) {
			if (t) return this._removeLogger(t)
			this.loggers.forEach((r, n) => this._removeLogger(n))
		}
		_removeLogger(t) {
			if (!this.loggers.has(t)) return
			this.loggers.get(t).close(), this._delete(t)
		}
		_delete(t) {
			this.loggers.delete(t)
		}
	}
})
var MAe = x((An) => {
	"use strict"
	var kAe = O3(),
		{ warn: gx } = q3()
	An.version = che().version
	An.transports = aAe()
	An.config = VR()
	An.addColors = kAe.levels
	An.format = kAe.format
	An.createLogger = zH()
	An.Logger = KR()
	An.ExceptionHandler = GH()
	An.RejectionHandler = YH()
	An.Container = RAe()
	An.Transport = Dh()
	An.loggers = new An.Container()
	var Gd = An.createLogger()
	Object.keys(An.config.npm.levels)
		.concat([
			"log",
			"query",
			"stream",
			"add",
			"remove",
			"clear",
			"profile",
			"startTimer",
			"handleExceptions",
			"unhandleExceptions",
			"handleRejections",
			"unhandleRejections",
			"configure",
			"child",
		])
		.forEach((e) => (An[e] = (...t) => Gd[e](...t)))
	Object.defineProperty(An, "level", {
		get() {
			return Gd.level
		},
		set(e) {
			Gd.level = e
		},
	})
	Object.defineProperty(An, "exceptions", {
		get() {
			return Gd.exceptions
		},
	})
	;["exitOnError"].forEach((e) => {
		Object.defineProperty(An, e, {
			get() {
				return Gd[e]
			},
			set(t) {
				Gd[e] = t
			},
		})
	})
	Object.defineProperty(An, "default", {
		get() {
			return {
				exceptionHandlers: Gd.exceptionHandlers,
				rejectionHandlers: Gd.rejectionHandlers,
				transports: Gd.transports,
			}
		},
	})
	gx.deprecated(An, "setLevels")
	gx.forFunctions(An, "useFormat", ["cli"])
	gx.forProperties(An, "useFormat", ["padLevels", "stripColors"])
	gx.forFunctions(An, "deprecated", ["addRewriter", "addFilter", "clone", "extend"])
	gx.forProperties(An, "deprecated", ["emitErrs", "levelLength"])
})
var NAe = x((DRt, Mct) => {
	Mct.exports = [
		{
			name: "C",
			vscode_name: "c",
			type: "programming",
			extensions: [".c", ".cats", ".h", ".idc", ".w"],
		},
		{
			name: "C++",
			vscode_name: "cpp",
			type: "programming",
			extensions: [
				".cpp",
				".c++",
				".cc",
				".cp",
				".cxx",
				".h",
				".h++",
				".hh",
				".hpp",
				".hxx",
				".inc",
				".inl",
				".ipp",
				".tcc",
				".tpp",
			],
		},
		{ name: "Go", vscode_name: "go", type: "programming", extensions: [".go"] },
		{
			name: "Java",
			vscode_name: "java",
			type: "programming",
			extensions: [".java"],
		},
		{
			name: "JavaScript",
			vscode_name: "javascript",
			type: "programming",
			extensions: [
				".js",
				"._js",
				".bones",
				".es",
				".es6",
				".frag",
				".gs",
				".jake",
				".jsb",
				".jscad",
				".jsfl",
				".jsm",
				".jss",
				".njs",
				".pac",
				".sjs",
				".ssjs",
				".sublime-build",
				".sublime-commands",
				".sublime-completions",
				".sublime-keymap",
				".sublime-macro",
				".sublime-menu",
				".sublime-mousemap",
				".sublime-project",
				".sublime-settings",
				".sublime-theme",
				".sublime-workspace",
				".sublime_metrics",
				".sublime_session",
				".xsjs",
				".xsjslib",
			],
		},
		{
			name: "Python",
			vscode_name: "python",
			type: "programming",
			extensions: [
				".py",
				".bzl",
				".cgi",
				".fcgi",
				".gyp",
				".lmi",
				".pyde",
				".pyp",
				".pyt",
				".pyw",
				".rpy",
				".tac",
				".wsgi",
				".xpy",
			],
		},
	]
})
var ZAe = x(($kt, jAe) => {
	"use strict"
	var zAe = "Expected a function",
		KAe = NaN,
		Vct = "[object Symbol]",
		Hct = /^\s+|\s+$/g,
		Wct = /^[-+]0x[0-9a-f]+$/i,
		Gct = /^0b[01]+$/i,
		$ct = /^0o[0-7]+$/i,
		Yct = parseInt,
		Kct = typeof global == "object" && global && global.Object === Object && global,
		Jct = typeof self == "object" && self && self.Object === Object && self,
		zct = Kct || Jct || Function("return this")(),
		jct = Object.prototype,
		Zct = jct.toString,
		Xct = Math.max,
		eut = Math.min,
		oW = function () {
			return zct.Date.now()
		}
	function tut(e, t, r) {
		var n,
			i,
			s,
			o,
			a,
			l,
			c = 0,
			u = !1,
			f = !1,
			p = !0
		if (typeof e != "function") throw new TypeError(zAe)
		;(t = JAe(t) || 0),
			pk(r) &&
				((u = !!r.leading),
				(f = "maxWait" in r),
				(s = f ? Xct(JAe(r.maxWait) || 0, t) : s),
				(p = "trailing" in r ? !!r.trailing : p))
		function g(Q) {
			var O = n,
				Y = i
			return (n = i = void 0), (c = Q), (o = e.apply(Y, O)), o
		}
		function m(Q) {
			return (c = Q), (a = setTimeout(v, t)), u ? g(Q) : o
		}
		function y(Q) {
			var O = Q - l,
				Y = Q - c,
				j = t - O
			return f ? eut(j, s - Y) : j
		}
		function C(Q) {
			var O = Q - l,
				Y = Q - c
			return l === void 0 || O >= t || O < 0 || (f && Y >= s)
		}
		function v() {
			var Q = oW()
			if (C(Q)) return b(Q)
			a = setTimeout(v, y(Q))
		}
		function b(Q) {
			return (a = void 0), p && n ? g(Q) : ((n = i = void 0), o)
		}
		function w() {
			a !== void 0 && clearTimeout(a), (c = 0), (n = l = i = a = void 0)
		}
		function B() {
			return a === void 0 ? o : b(oW())
		}
		function M() {
			var Q = oW(),
				O = C(Q)
			if (((n = arguments), (i = this), (l = Q), O)) {
				if (a === void 0) return m(l)
				if (f) return (a = setTimeout(v, t)), g(l)
			}
			return a === void 0 && (a = setTimeout(v, t)), o
		}
		return (M.cancel = w), (M.flush = B), M
	}
	function rut(e, t, r) {
		var n = !0,
			i = !0
		if (typeof e != "function") throw new TypeError(zAe)
		return (
			pk(r) && ((n = "leading" in r ? !!r.leading : n), (i = "trailing" in r ? !!r.trailing : i)),
			tut(e, t, { leading: n, maxWait: t, trailing: i })
		)
	}
	function pk(e) {
		var t = typeof e
		return !!e && (t == "object" || t == "function")
	}
	function nut(e) {
		return !!e && typeof e == "object"
	}
	function iut(e) {
		return typeof e == "symbol" || (nut(e) && Zct.call(e) == Vct)
	}
	function JAe(e) {
		if (typeof e == "number") return e
		if (iut(e)) return KAe
		if (pk(e)) {
			var t = typeof e.valueOf == "function" ? e.valueOf() : e
			e = pk(t) ? t + "" : t
		}
		if (typeof e != "string") return e === 0 ? e : +e
		e = e.replace(Hct, "")
		var r = Gct.test(e)
		return r || $ct.test(e) ? Yct(e.slice(2), r ? 2 : 8) : Wct.test(e) ? KAe : +e
	}
	jAe.exports = rut
})
var eme = x((Ykt, XAe) => {
	"use strict"
	var aW = class {
			constructor(t) {
				;(this.value = t), (this.next = void 0)
			}
		},
		lW = class {
			constructor() {
				this.clear()
			}
			enqueue(t) {
				let r = new aW(t)
				this._head ? ((this._tail.next = r), (this._tail = r)) : ((this._head = r), (this._tail = r)),
					this._size++
			}
			dequeue() {
				let t = this._head
				if (t) return (this._head = this._head.next), this._size--, t.value
			}
			clear() {
				;(this._head = void 0), (this._tail = void 0), (this._size = 0)
			}
			get size() {
				return this._size
			}
			*[Symbol.iterator]() {
				let t = this._head
				for (; t; ) yield t.value, (t = t.next)
			}
		}
	XAe.exports = lW
})
var rme = x((Kkt, tme) => {
	"use strict"
	var sut = eme(),
		out = (e) => {
			if (!((Number.isInteger(e) || e === 1 / 0) && e > 0))
				throw new TypeError("Expected `concurrency` to be a number from 1 and up")
			let t = new sut(),
				r = 0,
				n = () => {
					r--, t.size > 0 && t.dequeue()()
				},
				i = async (a, l, ...c) => {
					r++
					let u = (async () => a(...c))()
					l(u)
					try {
						await u
					} catch {}
					n()
				},
				s = (a, l, ...c) => {
					t.enqueue(i.bind(null, a, l, ...c)),
						(async () => (await Promise.resolve(), r < e && t.size > 0 && t.dequeue()()))()
				},
				o = (a, ...l) =>
					new Promise((c) => {
						s(a, c, ...l)
					})
			return (
				Object.defineProperties(o, {
					activeCount: { get: () => r },
					pendingCount: { get: () => t.size },
					clearQueue: {
						value: () => {
							t.clear()
						},
					},
				}),
				o
			)
		}
	tme.exports = out
})
var Nx = x((x1t, c0e) => {
	"use strict"
	var hdt = "2.0.0",
		gdt = Number.MAX_SAFE_INTEGER || 9007199254740991,
		pdt = 16,
		Adt = 250,
		mdt = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"]
	c0e.exports = {
		MAX_LENGTH: 256,
		MAX_SAFE_COMPONENT_LENGTH: pdt,
		MAX_SAFE_BUILD_LENGTH: Adt,
		MAX_SAFE_INTEGER: gdt,
		RELEASE_TYPES: mdt,
		SEMVER_SPEC_VERSION: hdt,
		FLAG_INCLUDE_PRERELEASE: 1,
		FLAG_LOOSE: 2,
	}
})
var Px = x((_1t, u0e) => {
	"use strict"
	var ydt =
		typeof process == "object" &&
		process.env &&
		process.env.NODE_DEBUG &&
		/\bsemver\b/i.test(process.env.NODE_DEBUG)
			? (...e) => console.error("SEMVER", ...e)
			: () => {}
	u0e.exports = ydt
})
var My = x((zd, d0e) => {
	"use strict"
	var { MAX_SAFE_COMPONENT_LENGTH: HW, MAX_SAFE_BUILD_LENGTH: Cdt, MAX_LENGTH: vdt } = Nx(),
		Edt = Px()
	zd = d0e.exports = {}
	var bdt = (zd.re = []),
		xdt = (zd.safeRe = []),
		Le = (zd.src = []),
		Ue = (zd.t = {}),
		_dt = 0,
		WW = "[a-zA-Z0-9-]",
		wdt = [
			["\\s", 1],
			["\\d", vdt],
			[WW, Cdt],
		],
		Idt = (e) => {
			for (let [t, r] of wdt) e = e.split(`${t}*`).join(`${t}{0,${r}}`).split(`${t}+`).join(`${t}{1,${r}}`)
			return e
		},
		Mt = (e, t, r) => {
			let n = Idt(t),
				i = _dt++
			Edt(e, i, t),
				(Ue[e] = i),
				(Le[i] = t),
				(bdt[i] = new RegExp(t, r ? "g" : void 0)),
				(xdt[i] = new RegExp(n, r ? "g" : void 0))
		}
	Mt("NUMERICIDENTIFIER", "0|[1-9]\\d*")
	Mt("NUMERICIDENTIFIERLOOSE", "\\d+")
	Mt("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${WW}*`)
	Mt("MAINVERSION", `(${Le[Ue.NUMERICIDENTIFIER]})\\.(${Le[Ue.NUMERICIDENTIFIER]})\\.(${Le[Ue.NUMERICIDENTIFIER]})`)
	Mt(
		"MAINVERSIONLOOSE",
		`(${Le[Ue.NUMERICIDENTIFIERLOOSE]})\\.(${Le[Ue.NUMERICIDENTIFIERLOOSE]})\\.(${Le[Ue.NUMERICIDENTIFIERLOOSE]})`,
	)
	Mt("PRERELEASEIDENTIFIER", `(?:${Le[Ue.NUMERICIDENTIFIER]}|${Le[Ue.NONNUMERICIDENTIFIER]})`)
	Mt("PRERELEASEIDENTIFIERLOOSE", `(?:${Le[Ue.NUMERICIDENTIFIERLOOSE]}|${Le[Ue.NONNUMERICIDENTIFIER]})`)
	Mt("PRERELEASE", `(?:-(${Le[Ue.PRERELEASEIDENTIFIER]}(?:\\.${Le[Ue.PRERELEASEIDENTIFIER]})*))`)
	Mt("PRERELEASELOOSE", `(?:-?(${Le[Ue.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${Le[Ue.PRERELEASEIDENTIFIERLOOSE]})*))`)
	Mt("BUILDIDENTIFIER", `${WW}+`)
	Mt("BUILD", `(?:\\+(${Le[Ue.BUILDIDENTIFIER]}(?:\\.${Le[Ue.BUILDIDENTIFIER]})*))`)
	Mt("FULLPLAIN", `v?${Le[Ue.MAINVERSION]}${Le[Ue.PRERELEASE]}?${Le[Ue.BUILD]}?`)
	Mt("FULL", `^${Le[Ue.FULLPLAIN]}$`)
	Mt("LOOSEPLAIN", `[v=\\s]*${Le[Ue.MAINVERSIONLOOSE]}${Le[Ue.PRERELEASELOOSE]}?${Le[Ue.BUILD]}?`)
	Mt("LOOSE", `^${Le[Ue.LOOSEPLAIN]}$`)
	Mt("GTLT", "((?:<|>)?=?)")
	Mt("XRANGEIDENTIFIERLOOSE", `${Le[Ue.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
	Mt("XRANGEIDENTIFIER", `${Le[Ue.NUMERICIDENTIFIER]}|x|X|\\*`)
	Mt(
		"XRANGEPLAIN",
		`[v=\\s]*(${Le[Ue.XRANGEIDENTIFIER]})(?:\\.(${
			Le[Ue.XRANGEIDENTIFIER]
		})(?:\\.(${Le[Ue.XRANGEIDENTIFIER]})(?:${Le[Ue.PRERELEASE]})?${Le[Ue.BUILD]}?)?)?`,
	)
	Mt(
		"XRANGEPLAINLOOSE",
		`[v=\\s]*(${Le[Ue.XRANGEIDENTIFIERLOOSE]})(?:\\.(${
			Le[Ue.XRANGEIDENTIFIERLOOSE]
		})(?:\\.(${Le[Ue.XRANGEIDENTIFIERLOOSE]})(?:${Le[Ue.PRERELEASELOOSE]})?${Le[Ue.BUILD]}?)?)?`,
	)
	Mt("XRANGE", `^${Le[Ue.GTLT]}\\s*${Le[Ue.XRANGEPLAIN]}$`)
	Mt("XRANGELOOSE", `^${Le[Ue.GTLT]}\\s*${Le[Ue.XRANGEPLAINLOOSE]}$`)
	Mt("COERCEPLAIN", `(^|[^\\d])(\\d{1,${HW}})(?:\\.(\\d{1,${HW}}))?(?:\\.(\\d{1,${HW}}))?`)
	Mt("COERCE", `${Le[Ue.COERCEPLAIN]}(?:$|[^\\d])`)
	Mt("COERCEFULL", Le[Ue.COERCEPLAIN] + `(?:${Le[Ue.PRERELEASE]})?(?:${Le[Ue.BUILD]})?(?:$|[^\\d])`)
	Mt("COERCERTL", Le[Ue.COERCE], !0)
	Mt("COERCERTLFULL", Le[Ue.COERCEFULL], !0)
	Mt("LONETILDE", "(?:~>?)")
	Mt("TILDETRIM", `(\\s*)${Le[Ue.LONETILDE]}\\s+`, !0)
	zd.tildeTrimReplace = "$1~"
	Mt("TILDE", `^${Le[Ue.LONETILDE]}${Le[Ue.XRANGEPLAIN]}$`)
	Mt("TILDELOOSE", `^${Le[Ue.LONETILDE]}${Le[Ue.XRANGEPLAINLOOSE]}$`)
	Mt("LONECARET", "(?:\\^)")
	Mt("CARETTRIM", `(\\s*)${Le[Ue.LONECARET]}\\s+`, !0)
	zd.caretTrimReplace = "$1^"
	Mt("CARET", `^${Le[Ue.LONECARET]}${Le[Ue.XRANGEPLAIN]}$`)
	Mt("CARETLOOSE", `^${Le[Ue.LONECARET]}${Le[Ue.XRANGEPLAINLOOSE]}$`)
	Mt("COMPARATORLOOSE", `^${Le[Ue.GTLT]}\\s*(${Le[Ue.LOOSEPLAIN]})$|^$`)
	Mt("COMPARATOR", `^${Le[Ue.GTLT]}\\s*(${Le[Ue.FULLPLAIN]})$|^$`)
	Mt("COMPARATORTRIM", `(\\s*)${Le[Ue.GTLT]}\\s*(${Le[Ue.LOOSEPLAIN]}|${Le[Ue.XRANGEPLAIN]})`, !0)
	zd.comparatorTrimReplace = "$1$2$3"
	Mt("HYPHENRANGE", `^\\s*(${Le[Ue.XRANGEPLAIN]})\\s+-\\s+(${Le[Ue.XRANGEPLAIN]})\\s*$`)
	Mt("HYPHENRANGELOOSE", `^\\s*(${Le[Ue.XRANGEPLAINLOOSE]})\\s+-\\s+(${Le[Ue.XRANGEPLAINLOOSE]})\\s*$`)
	Mt("STAR", "(<|>)?=?\\s*\\*")
	Mt("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$")
	Mt("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
})
var Fk = x((w1t, f0e) => {
	"use strict"
	var Sdt = Object.freeze({ loose: !0 }),
		Bdt = Object.freeze({}),
		Ddt = (e) => (e ? (typeof e != "object" ? Sdt : e) : Bdt)
	f0e.exports = Ddt
})
var GW = x((I1t, p0e) => {
	"use strict"
	var h0e = /^[0-9]+$/,
		g0e = (e, t) => {
			let r = h0e.test(e),
				n = h0e.test(t)
			return r && n && ((e = +e), (t = +t)), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1
		},
		Tdt = (e, t) => g0e(t, e)
	p0e.exports = { compareIdentifiers: g0e, rcompareIdentifiers: Tdt }
})
var Ws = x((S1t, C0e) => {
	"use strict"
	var Qk = Px(),
		{ MAX_LENGTH: A0e, MAX_SAFE_INTEGER: Nk } = Nx(),
		{ safeRe: m0e, t: y0e } = My(),
		Rdt = Fk(),
		{ compareIdentifiers: Fy } = GW(),
		$W = class e {
			constructor(t, r) {
				if (((r = Rdt(r)), t instanceof e)) {
					if (t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease) return t
					t = t.version
				} else if (typeof t != "string")
					throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`)
				if (t.length > A0e) throw new TypeError(`version is longer than ${A0e} characters`)
				Qk("SemVer", t, r),
					(this.options = r),
					(this.loose = !!r.loose),
					(this.includePrerelease = !!r.includePrerelease)
				let n = t.trim().match(r.loose ? m0e[y0e.LOOSE] : m0e[y0e.FULL])
				if (!n) throw new TypeError(`Invalid Version: ${t}`)
				if (
					((this.raw = t),
					(this.major = +n[1]),
					(this.minor = +n[2]),
					(this.patch = +n[3]),
					this.major > Nk || this.major < 0)
				)
					throw new TypeError("Invalid major version")
				if (this.minor > Nk || this.minor < 0) throw new TypeError("Invalid minor version")
				if (this.patch > Nk || this.patch < 0) throw new TypeError("Invalid patch version")
				n[4]
					? (this.prerelease = n[4].split(".").map((i) => {
							if (/^[0-9]+$/.test(i)) {
								let s = +i
								if (s >= 0 && s < Nk) return s
							}
							return i
						}))
					: (this.prerelease = []),
					(this.build = n[5] ? n[5].split(".") : []),
					this.format()
			}
			format() {
				return (
					(this.version = `${this.major}.${this.minor}.${this.patch}`),
					this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`),
					this.version
				)
			}
			toString() {
				return this.version
			}
			compare(t) {
				if ((Qk("SemVer.compare", this.version, this.options, t), !(t instanceof e))) {
					if (typeof t == "string" && t === this.version) return 0
					t = new e(t, this.options)
				}
				return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t)
			}
			compareMain(t) {
				return (
					t instanceof e || (t = new e(t, this.options)),
					Fy(this.major, t.major) || Fy(this.minor, t.minor) || Fy(this.patch, t.patch)
				)
			}
			comparePre(t) {
				if ((t instanceof e || (t = new e(t, this.options)), this.prerelease.length && !t.prerelease.length))
					return -1
				if (!this.prerelease.length && t.prerelease.length) return 1
				if (!this.prerelease.length && !t.prerelease.length) return 0
				let r = 0
				do {
					let n = this.prerelease[r],
						i = t.prerelease[r]
					if ((Qk("prerelease compare", r, n, i), n === void 0 && i === void 0)) return 0
					if (i === void 0) return 1
					if (n === void 0) return -1
					if (n === i) continue
					return Fy(n, i)
				} while (++r)
			}
			compareBuild(t) {
				t instanceof e || (t = new e(t, this.options))
				let r = 0
				do {
					let n = this.build[r],
						i = t.build[r]
					if ((Qk("build compare", r, n, i), n === void 0 && i === void 0)) return 0
					if (i === void 0) return 1
					if (n === void 0) return -1
					if (n === i) continue
					return Fy(n, i)
				} while (++r)
			}
			inc(t, r, n) {
				switch (t) {
					case "premajor":
						;(this.prerelease.length = 0),
							(this.patch = 0),
							(this.minor = 0),
							this.major++,
							this.inc("pre", r, n)
						break
					case "preminor":
						;(this.prerelease.length = 0), (this.patch = 0), this.minor++, this.inc("pre", r, n)
						break
					case "prepatch":
						;(this.prerelease.length = 0), this.inc("patch", r, n), this.inc("pre", r, n)
						break
					case "prerelease":
						this.prerelease.length === 0 && this.inc("patch", r, n), this.inc("pre", r, n)
						break
					case "major":
						;(this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++,
							(this.minor = 0),
							(this.patch = 0),
							(this.prerelease = [])
						break
					case "minor":
						;(this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
							(this.patch = 0),
							(this.prerelease = [])
						break
					case "patch":
						this.prerelease.length === 0 && this.patch++, (this.prerelease = [])
						break
					case "pre": {
						let i = Number(n) ? 1 : 0
						if (!r && n === !1) throw new Error("invalid increment argument: identifier is empty")
						if (this.prerelease.length === 0) this.prerelease = [i]
						else {
							let s = this.prerelease.length
							for (; --s >= 0; ) typeof this.prerelease[s] == "number" && (this.prerelease[s]++, (s = -2))
							if (s === -1) {
								if (r === this.prerelease.join(".") && n === !1)
									throw new Error("invalid increment argument: identifier already exists")
								this.prerelease.push(i)
							}
						}
						if (r) {
							let s = [r, i]
							n === !1 && (s = [r]),
								Fy(this.prerelease[0], r) === 0
									? isNaN(this.prerelease[1]) && (this.prerelease = s)
									: (this.prerelease = s)
						}
						break
					}
					default:
						throw new Error(`invalid increment argument: ${t}`)
				}
				return (this.raw = this.format()), this.build.length && (this.raw += `+${this.build.join(".")}`), this
			}
		}
	C0e.exports = $W
})
var jp = x((B1t, E0e) => {
	"use strict"
	var v0e = Ws(),
		kdt = (e, t, r = !1) => {
			if (e instanceof v0e) return e
			try {
				return new v0e(e, t)
			} catch (n) {
				if (!r) return null
				throw n
			}
		}
	E0e.exports = kdt
})
var x0e = x((D1t, b0e) => {
	"use strict"
	var Mdt = jp(),
		Fdt = (e, t) => {
			let r = Mdt(e, t)
			return r ? r.version : null
		}
	b0e.exports = Fdt
})
var w0e = x((T1t, _0e) => {
	"use strict"
	var Qdt = jp(),
		Ndt = (e, t) => {
			let r = Qdt(e.trim().replace(/^[=v]+/, ""), t)
			return r ? r.version : null
		}
	_0e.exports = Ndt
})
var B0e = x((R1t, S0e) => {
	"use strict"
	var I0e = Ws(),
		Pdt = (e, t, r, n, i) => {
			typeof r == "string" && ((i = n), (n = r), (r = void 0))
			try {
				return new I0e(e instanceof I0e ? e.version : e, r).inc(t, n, i).version
			} catch {
				return null
			}
		}
	S0e.exports = Pdt
})
var R0e = x((k1t, T0e) => {
	"use strict"
	var D0e = jp(),
		Ldt = (e, t) => {
			let r = D0e(e, null, !0),
				n = D0e(t, null, !0),
				i = r.compare(n)
			if (i === 0) return null
			let s = i > 0,
				o = s ? r : n,
				a = s ? n : r,
				l = !!o.prerelease.length
			if (!!a.prerelease.length && !l)
				return !a.patch && !a.minor ? "major" : o.patch ? "patch" : o.minor ? "minor" : "major"
			let u = l ? "pre" : ""
			return r.major !== n.major
				? u + "major"
				: r.minor !== n.minor
					? u + "minor"
					: r.patch !== n.patch
						? u + "patch"
						: "prerelease"
		}
	T0e.exports = Ldt
})
var M0e = x((M1t, k0e) => {
	"use strict"
	var Udt = Ws(),
		Odt = (e, t) => new Udt(e, t).major
	k0e.exports = Odt
})
var Q0e = x((F1t, F0e) => {
	"use strict"
	var qdt = Ws(),
		Vdt = (e, t) => new qdt(e, t).minor
	F0e.exports = Vdt
})
var P0e = x((Q1t, N0e) => {
	"use strict"
	var Hdt = Ws(),
		Wdt = (e, t) => new Hdt(e, t).patch
	N0e.exports = Wdt
})
var U0e = x((N1t, L0e) => {
	"use strict"
	var Gdt = jp(),
		$dt = (e, t) => {
			let r = Gdt(e, t)
			return r && r.prerelease.length ? r.prerelease : null
		}
	L0e.exports = $dt
})
var El = x((P1t, q0e) => {
	"use strict"
	var O0e = Ws(),
		Ydt = (e, t, r) => new O0e(e, r).compare(new O0e(t, r))
	q0e.exports = Ydt
})
var H0e = x((L1t, V0e) => {
	"use strict"
	var Kdt = El(),
		Jdt = (e, t, r) => Kdt(t, e, r)
	V0e.exports = Jdt
})
var G0e = x((U1t, W0e) => {
	"use strict"
	var zdt = El(),
		jdt = (e, t) => zdt(e, t, !0)
	W0e.exports = jdt
})
var Pk = x((O1t, Y0e) => {
	"use strict"
	var $0e = Ws(),
		Zdt = (e, t, r) => {
			let n = new $0e(e, r),
				i = new $0e(t, r)
			return n.compare(i) || n.compareBuild(i)
		}
	Y0e.exports = Zdt
})
var J0e = x((q1t, K0e) => {
	"use strict"
	var Xdt = Pk(),
		eft = (e, t) => e.sort((r, n) => Xdt(r, n, t))
	K0e.exports = eft
})
var j0e = x((V1t, z0e) => {
	"use strict"
	var tft = Pk(),
		rft = (e, t) => e.sort((r, n) => tft(n, r, t))
	z0e.exports = rft
})
var Lx = x((H1t, Z0e) => {
	"use strict"
	var nft = El(),
		ift = (e, t, r) => nft(e, t, r) > 0
	Z0e.exports = ift
})
var Lk = x((W1t, X0e) => {
	"use strict"
	var sft = El(),
		oft = (e, t, r) => sft(e, t, r) < 0
	X0e.exports = oft
})
var YW = x((G1t, eye) => {
	"use strict"
	var aft = El(),
		lft = (e, t, r) => aft(e, t, r) === 0
	eye.exports = lft
})
var KW = x(($1t, tye) => {
	"use strict"
	var cft = El(),
		uft = (e, t, r) => cft(e, t, r) !== 0
	tye.exports = uft
})
var Uk = x((Y1t, rye) => {
	"use strict"
	var dft = El(),
		fft = (e, t, r) => dft(e, t, r) >= 0
	rye.exports = fft
})
var Ok = x((K1t, nye) => {
	"use strict"
	var hft = El(),
		gft = (e, t, r) => hft(e, t, r) <= 0
	nye.exports = gft
})
var JW = x((J1t, iye) => {
	"use strict"
	var pft = YW(),
		Aft = KW(),
		mft = Lx(),
		yft = Uk(),
		Cft = Lk(),
		vft = Ok(),
		Eft = (e, t, r, n) => {
			switch (t) {
				case "===":
					return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r
				case "!==":
					return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r
				case "":
				case "=":
				case "==":
					return pft(e, r, n)
				case "!=":
					return Aft(e, r, n)
				case ">":
					return mft(e, r, n)
				case ">=":
					return yft(e, r, n)
				case "<":
					return Cft(e, r, n)
				case "<=":
					return vft(e, r, n)
				default:
					throw new TypeError(`Invalid operator: ${t}`)
			}
		}
	iye.exports = Eft
})
var oye = x((z1t, sye) => {
	"use strict"
	var bft = Ws(),
		xft = jp(),
		{ safeRe: qk, t: Vk } = My(),
		_ft = (e, t) => {
			if (e instanceof bft) return e
			if ((typeof e == "number" && (e = String(e)), typeof e != "string")) return null
			t = t || {}
			let r = null
			if (!t.rtl) r = e.match(t.includePrerelease ? qk[Vk.COERCEFULL] : qk[Vk.COERCE])
			else {
				let l = t.includePrerelease ? qk[Vk.COERCERTLFULL] : qk[Vk.COERCERTL],
					c
				for (; (c = l.exec(e)) && (!r || r.index + r[0].length !== e.length); )
					(!r || c.index + c[0].length !== r.index + r[0].length) && (r = c),
						(l.lastIndex = c.index + c[1].length + c[2].length)
				l.lastIndex = -1
			}
			if (r === null) return null
			let n = r[2],
				i = r[3] || "0",
				s = r[4] || "0",
				o = t.includePrerelease && r[5] ? `-${r[5]}` : "",
				a = t.includePrerelease && r[6] ? `+${r[6]}` : ""
			return xft(`${n}.${i}.${s}${o}${a}`, t)
		}
	sye.exports = _ft
})
var lye = x((j1t, aye) => {
	"use strict"
	var zW = class {
		constructor() {
			;(this.max = 1e3), (this.map = new Map())
		}
		get(t) {
			let r = this.map.get(t)
			if (r !== void 0) return this.map.delete(t), this.map.set(t, r), r
		}
		delete(t) {
			return this.map.delete(t)
		}
		set(t, r) {
			if (!this.delete(t) && r !== void 0) {
				if (this.map.size >= this.max) {
					let i = this.map.keys().next().value
					this.delete(i)
				}
				this.map.set(t, r)
			}
			return this
		}
	}
	aye.exports = zW
})
var bl = x((Z1t, fye) => {
	"use strict"
	var wft = /\s+/g,
		jW = class e {
			constructor(t, r) {
				if (((r = Sft(r)), t instanceof e))
					return t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease ? t : new e(t.raw, r)
				if (t instanceof ZW) return (this.raw = t.value), (this.set = [[t]]), (this.formatted = void 0), this
				if (
					((this.options = r),
					(this.loose = !!r.loose),
					(this.includePrerelease = !!r.includePrerelease),
					(this.raw = t.trim().replace(wft, " ")),
					(this.set = this.raw
						.split("||")
						.map((n) => this.parseRange(n.trim()))
						.filter((n) => n.length)),
					!this.set.length)
				)
					throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
				if (this.set.length > 1) {
					let n = this.set[0]
					if (((this.set = this.set.filter((i) => !uye(i[0]))), this.set.length === 0)) this.set = [n]
					else if (this.set.length > 1) {
						for (let i of this.set)
							if (i.length === 1 && Fft(i[0])) {
								this.set = [i]
								break
							}
					}
				}
				this.formatted = void 0
			}
			get range() {
				if (this.formatted === void 0) {
					this.formatted = ""
					for (let t = 0; t < this.set.length; t++) {
						t > 0 && (this.formatted += "||")
						let r = this.set[t]
						for (let n = 0; n < r.length; n++)
							n > 0 && (this.formatted += " "), (this.formatted += r[n].toString().trim())
					}
				}
				return this.formatted
			}
			format() {
				return this.range
			}
			toString() {
				return this.range
			}
			parseRange(t) {
				let n = ((this.options.includePrerelease && kft) | (this.options.loose && Mft)) + ":" + t,
					i = cye.get(n)
				if (i) return i
				let s = this.options.loose,
					o = s ? Yo[po.HYPHENRANGELOOSE] : Yo[po.HYPHENRANGE]
				;(t = t.replace(o, Wft(this.options.includePrerelease))),
					Sn("hyphen replace", t),
					(t = t.replace(Yo[po.COMPARATORTRIM], Dft)),
					Sn("comparator trim", t),
					(t = t.replace(Yo[po.TILDETRIM], Tft)),
					Sn("tilde trim", t),
					(t = t.replace(Yo[po.CARETTRIM], Rft)),
					Sn("caret trim", t)
				let a = t
					.split(" ")
					.map((f) => Qft(f, this.options))
					.join(" ")
					.split(/\s+/)
					.map((f) => Hft(f, this.options))
				s &&
					(a = a.filter(
						(f) => (Sn("loose invalid filter", f, this.options), !!f.match(Yo[po.COMPARATORLOOSE])),
					)),
					Sn("range list", a)
				let l = new Map(),
					c = a.map((f) => new ZW(f, this.options))
				for (let f of c) {
					if (uye(f)) return [f]
					l.set(f.value, f)
				}
				l.size > 1 && l.has("") && l.delete("")
				let u = [...l.values()]
				return cye.set(n, u), u
			}
			intersects(t, r) {
				if (!(t instanceof e)) throw new TypeError("a Range is required")
				return this.set.some(
					(n) =>
						dye(n, r) && t.set.some((i) => dye(i, r) && n.every((s) => i.every((o) => s.intersects(o, r)))),
				)
			}
			test(t) {
				if (!t) return !1
				if (typeof t == "string")
					try {
						t = new Bft(t, this.options)
					} catch {
						return !1
					}
				for (let r = 0; r < this.set.length; r++) if (Gft(this.set[r], t, this.options)) return !0
				return !1
			}
		}
	fye.exports = jW
	var Ift = lye(),
		cye = new Ift(),
		Sft = Fk(),
		ZW = Ux(),
		Sn = Px(),
		Bft = Ws(),
		{ safeRe: Yo, t: po, comparatorTrimReplace: Dft, tildeTrimReplace: Tft, caretTrimReplace: Rft } = My(),
		{ FLAG_INCLUDE_PRERELEASE: kft, FLAG_LOOSE: Mft } = Nx(),
		uye = (e) => e.value === "<0.0.0-0",
		Fft = (e) => e.value === "",
		dye = (e, t) => {
			let r = !0,
				n = e.slice(),
				i = n.pop()
			for (; r && n.length; ) (r = n.every((s) => i.intersects(s, t))), (i = n.pop())
			return r
		},
		Qft = (e, t) => (
			Sn("comp", e, t),
			(e = Lft(e, t)),
			Sn("caret", e),
			(e = Nft(e, t)),
			Sn("tildes", e),
			(e = Oft(e, t)),
			Sn("xrange", e),
			(e = Vft(e, t)),
			Sn("stars", e),
			e
		),
		Ao = (e) => !e || e.toLowerCase() === "x" || e === "*",
		Nft = (e, t) =>
			e
				.trim()
				.split(/\s+/)
				.map((r) => Pft(r, t))
				.join(" "),
		Pft = (e, t) => {
			let r = t.loose ? Yo[po.TILDELOOSE] : Yo[po.TILDE]
			return e.replace(r, (n, i, s, o, a) => {
				Sn("tilde", e, n, i, s, o, a)
				let l
				return (
					Ao(i)
						? (l = "")
						: Ao(s)
							? (l = `>=${i}.0.0 <${+i + 1}.0.0-0`)
							: Ao(o)
								? (l = `>=${i}.${s}.0 <${i}.${+s + 1}.0-0`)
								: a
									? (Sn("replaceTilde pr", a), (l = `>=${i}.${s}.${o}-${a} <${i}.${+s + 1}.0-0`))
									: (l = `>=${i}.${s}.${o} <${i}.${+s + 1}.0-0`),
					Sn("tilde return", l),
					l
				)
			})
		},
		Lft = (e, t) =>
			e
				.trim()
				.split(/\s+/)
				.map((r) => Uft(r, t))
				.join(" "),
		Uft = (e, t) => {
			Sn("caret", e, t)
			let r = t.loose ? Yo[po.CARETLOOSE] : Yo[po.CARET],
				n = t.includePrerelease ? "-0" : ""
			return e.replace(r, (i, s, o, a, l) => {
				Sn("caret", e, i, s, o, a, l)
				let c
				return (
					Ao(s)
						? (c = "")
						: Ao(o)
							? (c = `>=${s}.0.0${n} <${+s + 1}.0.0-0`)
							: Ao(a)
								? s === "0"
									? (c = `>=${s}.${o}.0${n} <${s}.${+o + 1}.0-0`)
									: (c = `>=${s}.${o}.0${n} <${+s + 1}.0.0-0`)
								: l
									? (Sn("replaceCaret pr", l),
										s === "0"
											? o === "0"
												? (c = `>=${s}.${o}.${a}-${l} <${s}.${o}.${+a + 1}-0`)
												: (c = `>=${s}.${o}.${a}-${l} <${s}.${+o + 1}.0-0`)
											: (c = `>=${s}.${o}.${a}-${l} <${+s + 1}.0.0-0`))
									: (Sn("no pr"),
										s === "0"
											? o === "0"
												? (c = `>=${s}.${o}.${a}${n} <${s}.${o}.${+a + 1}-0`)
												: (c = `>=${s}.${o}.${a}${n} <${s}.${+o + 1}.0-0`)
											: (c = `>=${s}.${o}.${a} <${+s + 1}.0.0-0`)),
					Sn("caret return", c),
					c
				)
			})
		},
		Oft = (e, t) => (
			Sn("replaceXRanges", e, t),
			e
				.split(/\s+/)
				.map((r) => qft(r, t))
				.join(" ")
		),
		qft = (e, t) => {
			e = e.trim()
			let r = t.loose ? Yo[po.XRANGELOOSE] : Yo[po.XRANGE]
			return e.replace(r, (n, i, s, o, a, l) => {
				Sn("xRange", e, n, i, s, o, a, l)
				let c = Ao(s),
					u = c || Ao(o),
					f = u || Ao(a),
					p = f
				return (
					i === "=" && p && (i = ""),
					(l = t.includePrerelease ? "-0" : ""),
					c
						? i === ">" || i === "<"
							? (n = "<0.0.0-0")
							: (n = "*")
						: i && p
							? (u && (o = 0),
								(a = 0),
								i === ">"
									? ((i = ">="), u ? ((s = +s + 1), (o = 0), (a = 0)) : ((o = +o + 1), (a = 0)))
									: i === "<=" && ((i = "<"), u ? (s = +s + 1) : (o = +o + 1)),
								i === "<" && (l = "-0"),
								(n = `${i + s}.${o}.${a}${l}`))
							: u
								? (n = `>=${s}.0.0${l} <${+s + 1}.0.0-0`)
								: f && (n = `>=${s}.${o}.0${l} <${s}.${+o + 1}.0-0`),
					Sn("xRange return", n),
					n
				)
			})
		},
		Vft = (e, t) => (Sn("replaceStars", e, t), e.trim().replace(Yo[po.STAR], "")),
		Hft = (e, t) => (Sn("replaceGTE0", e, t), e.trim().replace(Yo[t.includePrerelease ? po.GTE0PRE : po.GTE0], "")),
		Wft = (e) => (t, r, n, i, s, o, a, l, c, u, f, p) => (
			Ao(n)
				? (r = "")
				: Ao(i)
					? (r = `>=${n}.0.0${e ? "-0" : ""}`)
					: Ao(s)
						? (r = `>=${n}.${i}.0${e ? "-0" : ""}`)
						: o
							? (r = `>=${r}`)
							: (r = `>=${r}${e ? "-0" : ""}`),
			Ao(c)
				? (l = "")
				: Ao(u)
					? (l = `<${+c + 1}.0.0-0`)
					: Ao(f)
						? (l = `<${c}.${+u + 1}.0-0`)
						: p
							? (l = `<=${c}.${u}.${f}-${p}`)
							: e
								? (l = `<${c}.${u}.${+f + 1}-0`)
								: (l = `<=${l}`),
			`${r} ${l}`.trim()
		),
		Gft = (e, t, r) => {
			for (let n = 0; n < e.length; n++) if (!e[n].test(t)) return !1
			if (t.prerelease.length && !r.includePrerelease) {
				for (let n = 0; n < e.length; n++)
					if ((Sn(e[n].semver), e[n].semver !== ZW.ANY && e[n].semver.prerelease.length > 0)) {
						let i = e[n].semver
						if (i.major === t.major && i.minor === t.minor && i.patch === t.patch) return !0
					}
				return !1
			}
			return !0
		}
})
var Ux = x((X1t, yye) => {
	"use strict"
	var Ox = Symbol("SemVer ANY"),
		t4 = class e {
			static get ANY() {
				return Ox
			}
			constructor(t, r) {
				if (((r = hye(r)), t instanceof e)) {
					if (t.loose === !!r.loose) return t
					t = t.value
				}
				;(t = t.trim().split(/\s+/).join(" ")),
					e4("comparator", t, r),
					(this.options = r),
					(this.loose = !!r.loose),
					this.parse(t),
					this.semver === Ox ? (this.value = "") : (this.value = this.operator + this.semver.version),
					e4("comp", this)
			}
			parse(t) {
				let r = this.options.loose ? gye[pye.COMPARATORLOOSE] : gye[pye.COMPARATOR],
					n = t.match(r)
				if (!n) throw new TypeError(`Invalid comparator: ${t}`)
				;(this.operator = n[1] !== void 0 ? n[1] : ""),
					this.operator === "=" && (this.operator = ""),
					n[2] ? (this.semver = new Aye(n[2], this.options.loose)) : (this.semver = Ox)
			}
			toString() {
				return this.value
			}
			test(t) {
				if ((e4("Comparator.test", t, this.options.loose), this.semver === Ox || t === Ox)) return !0
				if (typeof t == "string")
					try {
						t = new Aye(t, this.options)
					} catch {
						return !1
					}
				return XW(t, this.operator, this.semver, this.options)
			}
			intersects(t, r) {
				if (!(t instanceof e)) throw new TypeError("a Comparator is required")
				return this.operator === ""
					? this.value === ""
						? !0
						: new mye(t.value, r).test(this.value)
					: t.operator === ""
						? t.value === ""
							? !0
							: new mye(this.value, r).test(t.semver)
						: ((r = hye(r)),
							(r.includePrerelease && (this.value === "<0.0.0-0" || t.value === "<0.0.0-0")) ||
							(!r.includePrerelease && (this.value.startsWith("<0.0.0") || t.value.startsWith("<0.0.0")))
								? !1
								: !!(
										(this.operator.startsWith(">") && t.operator.startsWith(">")) ||
										(this.operator.startsWith("<") && t.operator.startsWith("<")) ||
										(this.semver.version === t.semver.version &&
											this.operator.includes("=") &&
											t.operator.includes("=")) ||
										(XW(this.semver, "<", t.semver, r) &&
											this.operator.startsWith(">") &&
											t.operator.startsWith("<")) ||
										(XW(this.semver, ">", t.semver, r) &&
											this.operator.startsWith("<") &&
											t.operator.startsWith(">"))
									))
			}
		}
	yye.exports = t4
	var hye = Fk(),
		{ safeRe: gye, t: pye } = My(),
		XW = JW(),
		e4 = Px(),
		Aye = Ws(),
		mye = bl()
})
var qx = x((eQt, Cye) => {
	"use strict"
	var $ft = bl(),
		Yft = (e, t, r) => {
			try {
				t = new $ft(t, r)
			} catch {
				return !1
			}
			return t.test(e)
		}
	Cye.exports = Yft
})
var Eye = x((tQt, vye) => {
	"use strict"
	var Kft = bl(),
		Jft = (e, t) =>
			new Kft(e, t).set.map((r) =>
				r
					.map((n) => n.value)
					.join(" ")
					.trim()
					.split(" "),
			)
	vye.exports = Jft
})
var xye = x((rQt, bye) => {
	"use strict"
	var zft = Ws(),
		jft = bl(),
		Zft = (e, t, r) => {
			let n = null,
				i = null,
				s = null
			try {
				s = new jft(t, r)
			} catch {
				return null
			}
			return (
				e.forEach((o) => {
					s.test(o) && (!n || i.compare(o) === -1) && ((n = o), (i = new zft(n, r)))
				}),
				n
			)
		}
	bye.exports = Zft
})
var wye = x((nQt, _ye) => {
	"use strict"
	var Xft = Ws(),
		eht = bl(),
		tht = (e, t, r) => {
			let n = null,
				i = null,
				s = null
			try {
				s = new eht(t, r)
			} catch {
				return null
			}
			return (
				e.forEach((o) => {
					s.test(o) && (!n || i.compare(o) === 1) && ((n = o), (i = new Xft(n, r)))
				}),
				n
			)
		}
	_ye.exports = tht
})
var Bye = x((iQt, Sye) => {
	"use strict"
	var r4 = Ws(),
		rht = bl(),
		Iye = Lx(),
		nht = (e, t) => {
			e = new rht(e, t)
			let r = new r4("0.0.0")
			if (e.test(r) || ((r = new r4("0.0.0-0")), e.test(r))) return r
			r = null
			for (let n = 0; n < e.set.length; ++n) {
				let i = e.set[n],
					s = null
				i.forEach((o) => {
					let a = new r4(o.semver.version)
					switch (o.operator) {
						case ">":
							a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), (a.raw = a.format())
						case "":
						case ">=":
							;(!s || Iye(a, s)) && (s = a)
							break
						case "<":
						case "<=":
							break
						default:
							throw new Error(`Unexpected operation: ${o.operator}`)
					}
				}),
					s && (!r || Iye(r, s)) && (r = s)
			}
			return r && e.test(r) ? r : null
		}
	Sye.exports = nht
})
var Tye = x((sQt, Dye) => {
	"use strict"
	var iht = bl(),
		sht = (e, t) => {
			try {
				return new iht(e, t).range || "*"
			} catch {
				return null
			}
		}
	Dye.exports = sht
})
var Hk = x((oQt, Fye) => {
	"use strict"
	var oht = Ws(),
		Mye = Ux(),
		{ ANY: aht } = Mye,
		lht = bl(),
		cht = qx(),
		Rye = Lx(),
		kye = Lk(),
		uht = Ok(),
		dht = Uk(),
		fht = (e, t, r, n) => {
			;(e = new oht(e, n)), (t = new lht(t, n))
			let i, s, o, a, l
			switch (r) {
				case ">":
					;(i = Rye), (s = uht), (o = kye), (a = ">"), (l = ">=")
					break
				case "<":
					;(i = kye), (s = dht), (o = Rye), (a = "<"), (l = "<=")
					break
				default:
					throw new TypeError('Must provide a hilo val of "<" or ">"')
			}
			if (cht(e, t, n)) return !1
			for (let c = 0; c < t.set.length; ++c) {
				let u = t.set[c],
					f = null,
					p = null
				if (
					(u.forEach((g) => {
						g.semver === aht && (g = new Mye(">=0.0.0")),
							(f = f || g),
							(p = p || g),
							i(g.semver, f.semver, n) ? (f = g) : o(g.semver, p.semver, n) && (p = g)
					}),
					f.operator === a || f.operator === l || ((!p.operator || p.operator === a) && s(e, p.semver)))
				)
					return !1
				if (p.operator === l && o(e, p.semver)) return !1
			}
			return !0
		}
	Fye.exports = fht
})
var Nye = x((aQt, Qye) => {
	"use strict"
	var hht = Hk(),
		ght = (e, t, r) => hht(e, t, ">", r)
	Qye.exports = ght
})
var Lye = x((lQt, Pye) => {
	"use strict"
	var pht = Hk(),
		Aht = (e, t, r) => pht(e, t, "<", r)
	Pye.exports = Aht
})
var qye = x((cQt, Oye) => {
	"use strict"
	var Uye = bl(),
		mht = (e, t, r) => ((e = new Uye(e, r)), (t = new Uye(t, r)), e.intersects(t, r))
	Oye.exports = mht
})
var Hye = x((uQt, Vye) => {
	"use strict"
	var yht = qx(),
		Cht = El()
	Vye.exports = (e, t, r) => {
		let n = [],
			i = null,
			s = null,
			o = e.sort((u, f) => Cht(u, f, r))
		for (let u of o) yht(u, t, r) ? ((s = u), i || (i = u)) : (s && n.push([i, s]), (s = null), (i = null))
		i && n.push([i, null])
		let a = []
		for (let [u, f] of n)
			u === f
				? a.push(u)
				: !f && u === o[0]
					? a.push("*")
					: f
						? u === o[0]
							? a.push(`<=${f}`)
							: a.push(`${u} - ${f}`)
						: a.push(`>=${u}`)
		let l = a.join(" || "),
			c = typeof t.raw == "string" ? t.raw : String(t)
		return l.length < c.length ? l : t
	}
})
var Jye = x((dQt, Kye) => {
	"use strict"
	var Wye = bl(),
		i4 = Ux(),
		{ ANY: n4 } = i4,
		Vx = qx(),
		s4 = El(),
		vht = (e, t, r = {}) => {
			if (e === t) return !0
			;(e = new Wye(e, r)), (t = new Wye(t, r))
			let n = !1
			e: for (let i of e.set) {
				for (let s of t.set) {
					let o = bht(i, s, r)
					if (((n = n || o !== null), o)) continue e
				}
				if (n) return !1
			}
			return !0
		},
		Eht = [new i4(">=0.0.0-0")],
		Gye = [new i4(">=0.0.0")],
		bht = (e, t, r) => {
			if (e === t) return !0
			if (e.length === 1 && e[0].semver === n4) {
				if (t.length === 1 && t[0].semver === n4) return !0
				r.includePrerelease ? (e = Eht) : (e = Gye)
			}
			if (t.length === 1 && t[0].semver === n4) {
				if (r.includePrerelease) return !0
				t = Gye
			}
			let n = new Set(),
				i,
				s
			for (let g of e)
				g.operator === ">" || g.operator === ">="
					? (i = $ye(i, g, r))
					: g.operator === "<" || g.operator === "<="
						? (s = Yye(s, g, r))
						: n.add(g.semver)
			if (n.size > 1) return null
			let o
			if (i && s) {
				if (((o = s4(i.semver, s.semver, r)), o > 0)) return null
				if (o === 0 && (i.operator !== ">=" || s.operator !== "<=")) return null
			}
			for (let g of n) {
				if ((i && !Vx(g, String(i), r)) || (s && !Vx(g, String(s), r))) return null
				for (let m of t) if (!Vx(g, String(m), r)) return !1
				return !0
			}
			let a,
				l,
				c,
				u,
				f = s && !r.includePrerelease && s.semver.prerelease.length ? s.semver : !1,
				p = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1
			f && f.prerelease.length === 1 && s.operator === "<" && f.prerelease[0] === 0 && (f = !1)
			for (let g of t) {
				if (
					((u = u || g.operator === ">" || g.operator === ">="),
					(c = c || g.operator === "<" || g.operator === "<="),
					i)
				) {
					if (
						(p &&
							g.semver.prerelease &&
							g.semver.prerelease.length &&
							g.semver.major === p.major &&
							g.semver.minor === p.minor &&
							g.semver.patch === p.patch &&
							(p = !1),
						g.operator === ">" || g.operator === ">=")
					) {
						if (((a = $ye(i, g, r)), a === g && a !== i)) return !1
					} else if (i.operator === ">=" && !Vx(i.semver, String(g), r)) return !1
				}
				if (s) {
					if (
						(f &&
							g.semver.prerelease &&
							g.semver.prerelease.length &&
							g.semver.major === f.major &&
							g.semver.minor === f.minor &&
							g.semver.patch === f.patch &&
							(f = !1),
						g.operator === "<" || g.operator === "<=")
					) {
						if (((l = Yye(s, g, r)), l === g && l !== s)) return !1
					} else if (s.operator === "<=" && !Vx(s.semver, String(g), r)) return !1
				}
				if (!g.operator && (s || i) && o !== 0) return !1
			}
			return !((i && c && !s && o !== 0) || (s && u && !i && o !== 0) || p || f)
		},
		$ye = (e, t, r) => {
			if (!e) return t
			let n = s4(e.semver, t.semver, r)
			return n > 0 ? e : n < 0 || (t.operator === ">" && e.operator === ">=") ? t : e
		},
		Yye = (e, t, r) => {
			if (!e) return t
			let n = s4(e.semver, t.semver, r)
			return n < 0 ? e : n > 0 || (t.operator === "<" && e.operator === "<=") ? t : e
		}
	Kye.exports = vht
})
var Xye = x((fQt, Zye) => {
	"use strict"
	var o4 = My(),
		zye = Nx(),
		xht = Ws(),
		jye = GW(),
		_ht = jp(),
		wht = x0e(),
		Iht = w0e(),
		Sht = B0e(),
		Bht = R0e(),
		Dht = M0e(),
		Tht = Q0e(),
		Rht = P0e(),
		kht = U0e(),
		Mht = El(),
		Fht = H0e(),
		Qht = G0e(),
		Nht = Pk(),
		Pht = J0e(),
		Lht = j0e(),
		Uht = Lx(),
		Oht = Lk(),
		qht = YW(),
		Vht = KW(),
		Hht = Uk(),
		Wht = Ok(),
		Ght = JW(),
		$ht = oye(),
		Yht = Ux(),
		Kht = bl(),
		Jht = qx(),
		zht = Eye(),
		jht = xye(),
		Zht = wye(),
		Xht = Bye(),
		egt = Tye(),
		tgt = Hk(),
		rgt = Nye(),
		ngt = Lye(),
		igt = qye(),
		sgt = Hye(),
		ogt = Jye()
	Zye.exports = {
		parse: _ht,
		valid: wht,
		clean: Iht,
		inc: Sht,
		diff: Bht,
		major: Dht,
		minor: Tht,
		patch: Rht,
		prerelease: kht,
		compare: Mht,
		rcompare: Fht,
		compareLoose: Qht,
		compareBuild: Nht,
		sort: Pht,
		rsort: Lht,
		gt: Uht,
		lt: Oht,
		eq: qht,
		neq: Vht,
		gte: Hht,
		lte: Wht,
		cmp: Ght,
		coerce: $ht,
		Comparator: Yht,
		Range: Kht,
		satisfies: Jht,
		toComparators: zht,
		maxSatisfying: jht,
		minSatisfying: Zht,
		minVersion: Xht,
		validRange: egt,
		outside: tgt,
		gtr: rgt,
		ltr: ngt,
		intersects: igt,
		simplifyRange: sgt,
		subset: ogt,
		SemVer: xht,
		re: o4.re,
		src: o4.src,
		tokens: o4.t,
		SEMVER_SPEC_VERSION: zye.SEMVER_SPEC_VERSION,
		RELEASE_TYPES: zye.RELEASE_TYPES,
		compareIdentifiers: jye.compareIdentifiers,
		rcompareIdentifiers: jye.rcompareIdentifiers,
	}
})
var _4 = x((zNt, ACe) => {
	"use strict"
	function hgt(e) {
		;(r.debug = r),
			(r.default = r),
			(r.coerce = l),
			(r.disable = o),
			(r.enable = i),
			(r.enabled = a),
			(r.humanize = jT()),
			(r.destroy = c),
			Object.keys(e).forEach((u) => {
				r[u] = e[u]
			}),
			(r.names = []),
			(r.skips = []),
			(r.formatters = {})
		function t(u) {
			let f = 0
			for (let p = 0; p < u.length; p++) (f = (f << 5) - f + u.charCodeAt(p)), (f |= 0)
			return r.colors[Math.abs(f) % r.colors.length]
		}
		r.selectColor = t
		function r(u) {
			let f,
				p = null,
				g,
				m
			function y(...C) {
				if (!y.enabled) return
				let v = y,
					b = Number(new Date()),
					w = b - (f || b)
				;(v.diff = w),
					(v.prev = f),
					(v.curr = b),
					(f = b),
					(C[0] = r.coerce(C[0])),
					typeof C[0] != "string" && C.unshift("%O")
				let B = 0
				;(C[0] = C[0].replace(/%([a-zA-Z%])/g, (Q, O) => {
					if (Q === "%%") return "%"
					B++
					let Y = r.formatters[O]
					if (typeof Y == "function") {
						let j = C[B]
						;(Q = Y.call(v, j)), C.splice(B, 1), B--
					}
					return Q
				})),
					r.formatArgs.call(v, C),
					(v.log || r.log).apply(v, C)
			}
			return (
				(y.namespace = u),
				(y.useColors = r.useColors()),
				(y.color = r.selectColor(u)),
				(y.extend = n),
				(y.destroy = r.destroy),
				Object.defineProperty(y, "enabled", {
					enumerable: !0,
					configurable: !1,
					get: () => (p !== null ? p : (g !== r.namespaces && ((g = r.namespaces), (m = r.enabled(u))), m)),
					set: (C) => {
						p = C
					},
				}),
				typeof r.init == "function" && r.init(y),
				y
			)
		}
		function n(u, f) {
			let p = r(this.namespace + (typeof f > "u" ? ":" : f) + u)
			return (p.log = this.log), p
		}
		function i(u) {
			r.save(u), (r.namespaces = u), (r.names = []), (r.skips = [])
			let f = (typeof u == "string" ? u : "").trim().replace(" ", ",").split(",").filter(Boolean)
			for (let p of f) p[0] === "-" ? r.skips.push(p.slice(1)) : r.names.push(p)
		}
		function s(u, f) {
			let p = 0,
				g = 0,
				m = -1,
				y = 0
			for (; p < u.length; )
				if (g < f.length && (f[g] === u[p] || f[g] === "*")) f[g] === "*" ? ((m = g), (y = p), g++) : (p++, g++)
				else if (m !== -1) (g = m + 1), y++, (p = y)
				else return !1
			for (; g < f.length && f[g] === "*"; ) g++
			return g === f.length
		}
		function o() {
			let u = [...r.names, ...r.skips.map((f) => "-" + f)].join(",")
			return r.enable(""), u
		}
		function a(u) {
			for (let f of r.skips) if (s(u, f)) return !1
			for (let f of r.names) if (s(u, f)) return !0
			return !1
		}
		function l(u) {
			return u instanceof Error ? u.stack || u.message : u
		}
		function c() {
			console.warn(
				"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
			)
		}
		return r.enable(r.load()), r
	}
	ACe.exports = hgt
})
var mCe = x((Ta, CM) => {
	"use strict"
	Ta.formatArgs = pgt
	Ta.save = Agt
	Ta.load = mgt
	Ta.useColors = ggt
	Ta.storage = ygt()
	Ta.destroy = (() => {
		let e = !1
		return () => {
			e ||
				((e = !0),
				console.warn(
					"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
				))
		}
	})()
	Ta.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33",
	]
	function ggt() {
		if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
			return !0
		if (
			typeof navigator < "u" &&
			navigator.userAgent &&
			navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
		)
			return !1
		let e
		return (
			(typeof document < "u" &&
				document.documentElement &&
				document.documentElement.style &&
				document.documentElement.style.WebkitAppearance) ||
			(typeof window < "u" &&
				window.console &&
				(window.console.firebug || (window.console.exception && window.console.table))) ||
			(typeof navigator < "u" &&
				navigator.userAgent &&
				(e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
				parseInt(e[1], 10) >= 31) ||
			(typeof navigator < "u" &&
				navigator.userAgent &&
				navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
		)
	}
	function pgt(e) {
		if (
			((e[0] =
				(this.useColors ? "%c" : "") +
				this.namespace +
				(this.useColors ? " %c" : " ") +
				e[0] +
				(this.useColors ? "%c " : " ") +
				"+" +
				CM.exports.humanize(this.diff)),
			!this.useColors)
		)
			return
		let t = "color: " + this.color
		e.splice(1, 0, t, "color: inherit")
		let r = 0,
			n = 0
		e[0].replace(/%[a-zA-Z%]/g, (i) => {
			i !== "%%" && (r++, i === "%c" && (n = r))
		}),
			e.splice(n, 0, t)
	}
	Ta.log = console.debug || console.log || (() => {})
	function Agt(e) {
		try {
			e ? Ta.storage.setItem("debug", e) : Ta.storage.removeItem("debug")
		} catch {}
	}
	function mgt() {
		let e
		try {
			e = Ta.storage.getItem("debug")
		} catch {}
		return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e
	}
	function ygt() {
		try {
			return localStorage
		} catch {}
	}
	CM.exports = _4()(Ta)
	var { formatters: Cgt } = CM.exports
	Cgt.j = function (e) {
		try {
			return JSON.stringify(e)
		} catch (t) {
			return "[UnexpectedJSONParseError]: " + t.message
		}
	}
})
var S4 = {}
z2(S4, { createSupportsColor: () => I4, default: () => _gt })
function xl(e, t = globalThis.Deno ? globalThis.Deno.args : EM.default.argv) {
	let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--",
		n = t.indexOf(r + e),
		i = t.indexOf("--")
	return n !== -1 && (i === -1 || n < i)
}
function vgt() {
	if ("FORCE_COLOR" in Yn)
		return Yn.FORCE_COLOR === "true"
			? 1
			: Yn.FORCE_COLOR === "false"
				? 0
				: Yn.FORCE_COLOR.length === 0
					? 1
					: Math.min(Number.parseInt(Yn.FORCE_COLOR, 10), 3)
}
function Egt(e) {
	return e === 0 ? !1 : { level: e, hasBasic: !0, has256: e >= 2, has16m: e >= 3 }
}
function bgt(e, { streamIsTTY: t, sniffFlags: r = !0 } = {}) {
	let n = vgt()
	n !== void 0 && (vM = n)
	let i = r ? vM : n
	if (i === 0) return 0
	if (r) {
		if (xl("color=16m") || xl("color=full") || xl("color=truecolor")) return 3
		if (xl("color=256")) return 2
	}
	if ("TF_BUILD" in Yn && "AGENT_NAME" in Yn) return 1
	if (e && !t && i === void 0) return 0
	let s = i || 0
	if (Yn.TERM === "dumb") return s
	if (EM.default.platform === "win32") {
		let o = yCe.default.release().split(".")
		return Number(o[0]) >= 10 && Number(o[2]) >= 10586 ? (Number(o[2]) >= 14931 ? 3 : 2) : 1
	}
	if ("CI" in Yn)
		return "GITHUB_ACTIONS" in Yn || "GITEA_ACTIONS" in Yn
			? 3
			: ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((o) => o in Yn) ||
				  Yn.CI_NAME === "codeship"
				? 1
				: s
	if ("TEAMCITY_VERSION" in Yn) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Yn.TEAMCITY_VERSION) ? 1 : 0
	if (Yn.COLORTERM === "truecolor" || Yn.TERM === "xterm-kitty") return 3
	if ("TERM_PROGRAM" in Yn) {
		let o = Number.parseInt((Yn.TERM_PROGRAM_VERSION || "").split(".")[0], 10)
		switch (Yn.TERM_PROGRAM) {
			case "iTerm.app":
				return o >= 3 ? 3 : 2
			case "Apple_Terminal":
				return 2
		}
	}
	return /-256(color)?$/i.test(Yn.TERM)
		? 2
		: /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Yn.TERM) || "COLORTERM" in Yn
			? 1
			: s
}
function I4(e, t = {}) {
	let r = bgt(e, { streamIsTTY: e && e.isTTY, ...t })
	return Egt(r)
}
var EM,
	yCe,
	w4,
	Yn,
	vM,
	xgt,
	_gt,
	B4 = oke(() => {
		"use strict"
		;(EM = W(require("process"))), (yCe = W(require("os"))), (w4 = W(require("tty")))
		;({ env: Yn } = EM.default)
		xl("no-color") || xl("no-colors") || xl("color=false") || xl("color=never")
			? (vM = 0)
			: (xl("color") || xl("colors") || xl("color=true") || xl("color=always")) && (vM = 1)
		;(xgt = {
			stdout: I4({ isTTY: w4.default.isatty(1) }),
			stderr: I4({ isTTY: w4.default.isatty(2) }),
		}),
			(_gt = xgt)
	})
var vCe = x((ts, xM) => {
	"use strict"
	var wgt = require("tty"),
		bM = require("util")
	ts.init = kgt
	ts.log = Dgt
	ts.formatArgs = Sgt
	ts.save = Tgt
	ts.load = Rgt
	ts.useColors = Igt
	ts.destroy = bM.deprecate(
		() => {},
		"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
	)
	ts.colors = [6, 2, 3, 4, 5, 1]
	try {
		let e = (B4(), j2(S4))
		e &&
			(e.stderr || e).level >= 2 &&
			(ts.colors = [
				20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79,
				80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167,
				168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,
				207, 208, 209, 214, 215, 220, 221,
			])
	} catch {}
	ts.inspectOpts = Object.keys(process.env)
		.filter((e) => /^debug_/i.test(e))
		.reduce((e, t) => {
			let r = t
					.substring(6)
					.toLowerCase()
					.replace(/_([a-z])/g, (i, s) => s.toUpperCase()),
				n = process.env[t]
			return (
				/^(yes|on|true|enabled)$/i.test(n)
					? (n = !0)
					: /^(no|off|false|disabled)$/i.test(n)
						? (n = !1)
						: n === "null"
							? (n = null)
							: (n = Number(n)),
				(e[r] = n),
				e
			)
		}, {})
	function Igt() {
		return "colors" in ts.inspectOpts ? !!ts.inspectOpts.colors : wgt.isatty(process.stderr.fd)
	}
	function Sgt(e) {
		let { namespace: t, useColors: r } = this
		if (r) {
			let n = this.color,
				i = "\x1B[3" + (n < 8 ? n : "8;5;" + n),
				s = `  ${i};1m${t} \x1B[0m`
			;(e[0] =
				s +
				e[0]
					.split(
						`
`,
					)
					.join(
						`
` + s,
					)),
				e.push(i + "m+" + xM.exports.humanize(this.diff) + "\x1B[0m")
		} else e[0] = Bgt() + t + " " + e[0]
	}
	function Bgt() {
		return ts.inspectOpts.hideDate ? "" : new Date().toISOString() + " "
	}
	function Dgt(...e) {
		return process.stderr.write(
			bM.formatWithOptions(ts.inspectOpts, ...e) +
				`
`,
		)
	}
	function Tgt(e) {
		e ? (process.env.DEBUG = e) : delete process.env.DEBUG
	}
	function Rgt() {
		return process.env.DEBUG
	}
	function kgt(e) {
		e.inspectOpts = {}
		let t = Object.keys(ts.inspectOpts)
		for (let r = 0; r < t.length; r++) e.inspectOpts[t[r]] = ts.inspectOpts[t[r]]
	}
	xM.exports = _4()(ts)
	var { formatters: CCe } = xM.exports
	CCe.o = function (e) {
		return (
			(this.inspectOpts.colors = this.useColors),
			bM
				.inspect(e, this.inspectOpts)
				.split(
					`
`,
				)
				.map((t) => t.trim())
				.join(" ")
		)
	}
	CCe.O = function (e) {
		return (this.inspectOpts.colors = this.useColors), bM.inspect(e, this.inspectOpts)
	}
})
var ECe = x((jNt, D4) => {
	"use strict"
	typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs
		? (D4.exports = mCe())
		: (D4.exports = vCe())
})
var bCe = x((Ra) => {
	"use strict"
	var Mgt =
		(Ra && Ra.__importDefault) ||
		function (e) {
			return e && e.__esModule ? e : { default: e }
		}
	Object.defineProperty(Ra, "__esModule", { value: !0 })
	var Fgt = require("fs"),
		Qgt = Mgt(ECe()),
		Uy = Qgt.default("@kwsites/file-exists")
	function Ngt(e, t, r) {
		Uy("checking %s", e)
		try {
			let n = Fgt.statSync(e)
			return n.isFile() && t
				? (Uy("[OK] path represents a file"), !0)
				: n.isDirectory() && r
					? (Uy("[OK] path represents a directory"), !0)
					: (Uy("[FAIL] path represents something other than a file or directory"), !1)
		} catch (n) {
			if (n.code === "ENOENT") return Uy("[FAIL] path is not accessible: %o", n), !1
			throw (Uy("[FATAL] %o", n), n)
		}
	}
	function Pgt(e, t = Ra.READABLE) {
		return Ngt(e, (t & Ra.FILE) > 0, (t & Ra.FOLDER) > 0)
	}
	Ra.exists = Pgt
	Ra.FILE = 1
	Ra.FOLDER = 2
	Ra.READABLE = Ra.FILE + Ra.FOLDER
})
var xCe = x((_M) => {
	"use strict"
	function Lgt(e) {
		for (var t in e) _M.hasOwnProperty(t) || (_M[t] = e[t])
	}
	Object.defineProperty(_M, "__esModule", { value: !0 })
	Lgt(bCe())
})
var T4 = x((e2t, _Ce) => {
	"use strict"
	function Ugt(e) {
		;(r.debug = r),
			(r.default = r),
			(r.coerce = l),
			(r.disable = s),
			(r.enable = i),
			(r.enabled = o),
			(r.humanize = jT()),
			(r.destroy = c),
			Object.keys(e).forEach((u) => {
				r[u] = e[u]
			}),
			(r.names = []),
			(r.skips = []),
			(r.formatters = {})
		function t(u) {
			let f = 0
			for (let p = 0; p < u.length; p++) (f = (f << 5) - f + u.charCodeAt(p)), (f |= 0)
			return r.colors[Math.abs(f) % r.colors.length]
		}
		r.selectColor = t
		function r(u) {
			let f,
				p = null,
				g,
				m
			function y(...C) {
				if (!y.enabled) return
				let v = y,
					b = Number(new Date()),
					w = b - (f || b)
				;(v.diff = w),
					(v.prev = f),
					(v.curr = b),
					(f = b),
					(C[0] = r.coerce(C[0])),
					typeof C[0] != "string" && C.unshift("%O")
				let B = 0
				;(C[0] = C[0].replace(/%([a-zA-Z%])/g, (Q, O) => {
					if (Q === "%%") return "%"
					B++
					let Y = r.formatters[O]
					if (typeof Y == "function") {
						let j = C[B]
						;(Q = Y.call(v, j)), C.splice(B, 1), B--
					}
					return Q
				})),
					r.formatArgs.call(v, C),
					(v.log || r.log).apply(v, C)
			}
			return (
				(y.namespace = u),
				(y.useColors = r.useColors()),
				(y.color = r.selectColor(u)),
				(y.extend = n),
				(y.destroy = r.destroy),
				Object.defineProperty(y, "enabled", {
					enumerable: !0,
					configurable: !1,
					get: () => (p !== null ? p : (g !== r.namespaces && ((g = r.namespaces), (m = r.enabled(u))), m)),
					set: (C) => {
						p = C
					},
				}),
				typeof r.init == "function" && r.init(y),
				y
			)
		}
		function n(u, f) {
			let p = r(this.namespace + (typeof f > "u" ? ":" : f) + u)
			return (p.log = this.log), p
		}
		function i(u) {
			r.save(u), (r.namespaces = u), (r.names = []), (r.skips = [])
			let f,
				p = (typeof u == "string" ? u : "").split(/[\s,]+/),
				g = p.length
			for (f = 0; f < g; f++)
				p[f] &&
					((u = p[f].replace(/\*/g, ".*?")),
					u[0] === "-"
						? r.skips.push(new RegExp("^" + u.slice(1) + "$"))
						: r.names.push(new RegExp("^" + u + "$")))
		}
		function s() {
			let u = [...r.names.map(a), ...r.skips.map(a).map((f) => "-" + f)].join(",")
			return r.enable(""), u
		}
		function o(u) {
			if (u[u.length - 1] === "*") return !0
			let f, p
			for (f = 0, p = r.skips.length; f < p; f++) if (r.skips[f].test(u)) return !1
			for (f = 0, p = r.names.length; f < p; f++) if (r.names[f].test(u)) return !0
			return !1
		}
		function a(u) {
			return u
				.toString()
				.substring(2, u.toString().length - 2)
				.replace(/\.\*\?$/, "*")
		}
		function l(u) {
			return u instanceof Error ? u.stack || u.message : u
		}
		function c() {
			console.warn(
				"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
			)
		}
		return r.enable(r.load()), r
	}
	_Ce.exports = Ugt
})
var wCe = x((ka, wM) => {
	"use strict"
	ka.formatArgs = qgt
	ka.save = Vgt
	ka.load = Hgt
	ka.useColors = Ogt
	ka.storage = Wgt()
	ka.destroy = (() => {
		let e = !1
		return () => {
			e ||
				((e = !0),
				console.warn(
					"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
				))
		}
	})()
	ka.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33",
	]
	function Ogt() {
		if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
			return !0
		if (
			typeof navigator < "u" &&
			navigator.userAgent &&
			navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
		)
			return !1
		let e
		return (
			(typeof document < "u" &&
				document.documentElement &&
				document.documentElement.style &&
				document.documentElement.style.WebkitAppearance) ||
			(typeof window < "u" &&
				window.console &&
				(window.console.firebug || (window.console.exception && window.console.table))) ||
			(typeof navigator < "u" &&
				navigator.userAgent &&
				(e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
				parseInt(e[1], 10) >= 31) ||
			(typeof navigator < "u" &&
				navigator.userAgent &&
				navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
		)
	}
	function qgt(e) {
		if (
			((e[0] =
				(this.useColors ? "%c" : "") +
				this.namespace +
				(this.useColors ? " %c" : " ") +
				e[0] +
				(this.useColors ? "%c " : " ") +
				"+" +
				wM.exports.humanize(this.diff)),
			!this.useColors)
		)
			return
		let t = "color: " + this.color
		e.splice(1, 0, t, "color: inherit")
		let r = 0,
			n = 0
		e[0].replace(/%[a-zA-Z%]/g, (i) => {
			i !== "%%" && (r++, i === "%c" && (n = r))
		}),
			e.splice(n, 0, t)
	}
	ka.log = console.debug || console.log || (() => {})
	function Vgt(e) {
		try {
			e ? ka.storage.setItem("debug", e) : ka.storage.removeItem("debug")
		} catch {}
	}
	function Hgt() {
		let e
		try {
			e = ka.storage.getItem("debug")
		} catch {}
		return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e
	}
	function Wgt() {
		try {
			return localStorage
		} catch {}
	}
	wM.exports = T4()(ka)
	var { formatters: Ggt } = wM.exports
	Ggt.j = function (e) {
		try {
			return JSON.stringify(e)
		} catch (t) {
			return "[UnexpectedJSONParseError]: " + t.message
		}
	}
})
var SCe = x((rs, SM) => {
	"use strict"
	var $gt = require("tty"),
		IM = require("util")
	rs.init = Xgt
	rs.log = zgt
	rs.formatArgs = Kgt
	rs.save = jgt
	rs.load = Zgt
	rs.useColors = Ygt
	rs.destroy = IM.deprecate(
		() => {},
		"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
	)
	rs.colors = [6, 2, 3, 4, 5, 1]
	try {
		let e = (B4(), j2(S4))
		e &&
			(e.stderr || e).level >= 2 &&
			(rs.colors = [
				20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79,
				80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167,
				168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,
				207, 208, 209, 214, 215, 220, 221,
			])
	} catch {}
	rs.inspectOpts = Object.keys(process.env)
		.filter((e) => /^debug_/i.test(e))
		.reduce((e, t) => {
			let r = t
					.substring(6)
					.toLowerCase()
					.replace(/_([a-z])/g, (i, s) => s.toUpperCase()),
				n = process.env[t]
			return (
				/^(yes|on|true|enabled)$/i.test(n)
					? (n = !0)
					: /^(no|off|false|disabled)$/i.test(n)
						? (n = !1)
						: n === "null"
							? (n = null)
							: (n = Number(n)),
				(e[r] = n),
				e
			)
		}, {})
	function Ygt() {
		return "colors" in rs.inspectOpts ? !!rs.inspectOpts.colors : $gt.isatty(process.stderr.fd)
	}
	function Kgt(e) {
		let { namespace: t, useColors: r } = this
		if (r) {
			let n = this.color,
				i = "\x1B[3" + (n < 8 ? n : "8;5;" + n),
				s = `  ${i};1m${t} \x1B[0m`
			;(e[0] =
				s +
				e[0]
					.split(
						`
`,
					)
					.join(
						`
` + s,
					)),
				e.push(i + "m+" + SM.exports.humanize(this.diff) + "\x1B[0m")
		} else e[0] = Jgt() + t + " " + e[0]
	}
	function Jgt() {
		return rs.inspectOpts.hideDate ? "" : new Date().toISOString() + " "
	}
	function zgt(...e) {
		return process.stderr.write(
			IM.formatWithOptions(rs.inspectOpts, ...e) +
				`
`,
		)
	}
	function jgt(e) {
		e ? (process.env.DEBUG = e) : delete process.env.DEBUG
	}
	function Zgt() {
		return process.env.DEBUG
	}
	function Xgt(e) {
		e.inspectOpts = {}
		let t = Object.keys(rs.inspectOpts)
		for (let r = 0; r < t.length; r++) e.inspectOpts[t[r]] = rs.inspectOpts[t[r]]
	}
	SM.exports = T4()(rs)
	var { formatters: ICe } = SM.exports
	ICe.o = function (e) {
		return (
			(this.inspectOpts.colors = this.useColors),
			IM.inspect(e, this.inspectOpts)
				.split(
					`
`,
				)
				.map((t) => t.trim())
				.join(" ")
		)
	}
	ICe.O = function (e) {
		return (this.inspectOpts.colors = this.useColors), IM.inspect(e, this.inspectOpts)
	}
})
var BCe = x((t2t, R4) => {
	"use strict"
	typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs
		? (R4.exports = wCe())
		: (R4.exports = SCe())
})
var M4 = x((eA) => {
	"use strict"
	Object.defineProperty(eA, "__esModule", { value: !0 })
	eA.createDeferred = eA.deferred = void 0
	function k4() {
		let e,
			t,
			r = "pending"
		return {
			promise: new Promise((i, s) => {
				;(e = i), (t = s)
			}),
			done(i) {
				r === "pending" && ((r = "resolved"), e(i))
			},
			fail(i) {
				r === "pending" && ((r = "rejected"), t(i))
			},
			get fulfilled() {
				return r !== "pending"
			},
			get status() {
				return r
			},
		}
	}
	eA.deferred = k4
	eA.createDeferred = k4
	eA.default = k4
})
var Hbe = x((Aqt, TF) => {
	"use strict"
	TF.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/
	TF.exports.ID_Start =
		/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/
	TF.exports.ID_Continue =
		/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
})
var MG = x((mqt, Wbe) => {
	"use strict"
	var kG = Hbe()
	Wbe.exports = {
		isSpaceSeparator(e) {
			return typeof e == "string" && kG.Space_Separator.test(e)
		},
		isIdStartChar(e) {
			return (
				typeof e == "string" &&
				((e >= "a" && e <= "z") || (e >= "A" && e <= "Z") || e === "$" || e === "_" || kG.ID_Start.test(e))
			)
		},
		isIdContinueChar(e) {
			return (
				typeof e == "string" &&
				((e >= "a" && e <= "z") ||
					(e >= "A" && e <= "Z") ||
					(e >= "0" && e <= "9") ||
					e === "$" ||
					e === "_" ||
					e === "\u200C" ||
					e === "\u200D" ||
					kG.ID_Continue.test(e))
			)
		},
		isDigit(e) {
			return typeof e == "string" && /[0-9]/.test(e)
		},
		isHexDigit(e) {
			return typeof e == "string" && /[0-9A-Fa-f]/.test(e)
		},
	}
})
var Jbe = x((yqt, Kbe) => {
	"use strict"
	var ns = MG(),
		QG,
		vo,
		af,
		kF,
		Kh,
		Rc,
		is,
		LG,
		p_
	Kbe.exports = function (t, r) {
		;(QG = String(t)),
			(vo = "start"),
			(af = []),
			(kF = 0),
			(Kh = 1),
			(Rc = 0),
			(is = void 0),
			(LG = void 0),
			(p_ = void 0)
		do (is = x0t()), I0t[vo]()
		while (is.type !== "eof")
		return typeof r == "function" ? NG({ "": p_ }, "", r) : p_
	}
	function NG(e, t, r) {
		let n = e[t]
		if (n != null && typeof n == "object")
			if (Array.isArray(n))
				for (let i = 0; i < n.length; i++) {
					let s = String(i),
						o = NG(n, s, r)
					o === void 0
						? delete n[s]
						: Object.defineProperty(n, s, {
								value: o,
								writable: !0,
								enumerable: !0,
								configurable: !0,
							})
				}
			else
				for (let i in n) {
					let s = NG(n, i, r)
					s === void 0
						? delete n[i]
						: Object.defineProperty(n, i, {
								value: s,
								writable: !0,
								enumerable: !0,
								configurable: !0,
							})
				}
		return r.call(e, t, n)
	}
	var Kt, Qt, g_, of, pr
	function x0t() {
		for (Kt = "default", Qt = "", g_ = !1, of = 1; ; ) {
			pr = lf()
			let e = $be[Kt]()
			if (e) return e
		}
	}
	function lf() {
		if (QG[kF]) return String.fromCodePoint(QG.codePointAt(kF))
	}
	function he() {
		let e = lf()
		return (
			e ===
			`
`
				? (Kh++, (Rc = 0))
				: e
					? (Rc += e.length)
					: Rc++,
			e && (kF += e.length),
			e
		)
	}
	var $be = {
		default() {
			switch (pr) {
				case "	":
				case "\v":
				case "\f":
				case " ":
				case "\xA0":
				case "\uFEFF":
				case `
`:
				case "\r":
				case "\u2028":
				case "\u2029":
					he()
					return
				case "/":
					he(), (Kt = "comment")
					return
				case void 0:
					return he(), Dn("eof")
			}
			if (ns.isSpaceSeparator(pr)) {
				he()
				return
			}
			return $be[vo]()
		},
		comment() {
			switch (pr) {
				case "*":
					he(), (Kt = "multiLineComment")
					return
				case "/":
					he(), (Kt = "singleLineComment")
					return
			}
			throw Tn(he())
		},
		multiLineComment() {
			switch (pr) {
				case "*":
					he(), (Kt = "multiLineCommentAsterisk")
					return
				case void 0:
					throw Tn(he())
			}
			he()
		},
		multiLineCommentAsterisk() {
			switch (pr) {
				case "*":
					he()
					return
				case "/":
					he(), (Kt = "default")
					return
				case void 0:
					throw Tn(he())
			}
			he(), (Kt = "multiLineComment")
		},
		singleLineComment() {
			switch (pr) {
				case `
`:
				case "\r":
				case "\u2028":
				case "\u2029":
					he(), (Kt = "default")
					return
				case void 0:
					return he(), Dn("eof")
			}
			he()
		},
		value() {
			switch (pr) {
				case "{":
				case "[":
					return Dn("punctuator", he())
				case "n":
					return he(), fA("ull"), Dn("null", null)
				case "t":
					return he(), fA("rue"), Dn("boolean", !0)
				case "f":
					return he(), fA("alse"), Dn("boolean", !1)
				case "-":
				case "+":
					he() === "-" && (of = -1), (Kt = "sign")
					return
				case ".":
					;(Qt = he()), (Kt = "decimalPointLeading")
					return
				case "0":
					;(Qt = he()), (Kt = "zero")
					return
				case "1":
				case "2":
				case "3":
				case "4":
				case "5":
				case "6":
				case "7":
				case "8":
				case "9":
					;(Qt = he()), (Kt = "decimalInteger")
					return
				case "I":
					return he(), fA("nfinity"), Dn("numeric", 1 / 0)
				case "N":
					return he(), fA("aN"), Dn("numeric", NaN)
				case '"':
				case "'":
					;(g_ = he() === '"'), (Qt = ""), (Kt = "string")
					return
			}
			throw Tn(he())
		},
		identifierNameStartEscape() {
			if (pr !== "u") throw Tn(he())
			he()
			let e = PG()
			switch (e) {
				case "$":
				case "_":
					break
				default:
					if (!ns.isIdStartChar(e)) throw Gbe()
					break
			}
			;(Qt += e), (Kt = "identifierName")
		},
		identifierName() {
			switch (pr) {
				case "$":
				case "_":
				case "\u200C":
				case "\u200D":
					Qt += he()
					return
				case "\\":
					he(), (Kt = "identifierNameEscape")
					return
			}
			if (ns.isIdContinueChar(pr)) {
				Qt += he()
				return
			}
			return Dn("identifier", Qt)
		},
		identifierNameEscape() {
			if (pr !== "u") throw Tn(he())
			he()
			let e = PG()
			switch (e) {
				case "$":
				case "_":
				case "\u200C":
				case "\u200D":
					break
				default:
					if (!ns.isIdContinueChar(e)) throw Gbe()
					break
			}
			;(Qt += e), (Kt = "identifierName")
		},
		sign() {
			switch (pr) {
				case ".":
					;(Qt = he()), (Kt = "decimalPointLeading")
					return
				case "0":
					;(Qt = he()), (Kt = "zero")
					return
				case "1":
				case "2":
				case "3":
				case "4":
				case "5":
				case "6":
				case "7":
				case "8":
				case "9":
					;(Qt = he()), (Kt = "decimalInteger")
					return
				case "I":
					return he(), fA("nfinity"), Dn("numeric", of * (1 / 0))
				case "N":
					return he(), fA("aN"), Dn("numeric", NaN)
			}
			throw Tn(he())
		},
		zero() {
			switch (pr) {
				case ".":
					;(Qt += he()), (Kt = "decimalPoint")
					return
				case "e":
				case "E":
					;(Qt += he()), (Kt = "decimalExponent")
					return
				case "x":
				case "X":
					;(Qt += he()), (Kt = "hexadecimal")
					return
			}
			return Dn("numeric", of * 0)
		},
		decimalInteger() {
			switch (pr) {
				case ".":
					;(Qt += he()), (Kt = "decimalPoint")
					return
				case "e":
				case "E":
					;(Qt += he()), (Kt = "decimalExponent")
					return
			}
			if (ns.isDigit(pr)) {
				Qt += he()
				return
			}
			return Dn("numeric", of * Number(Qt))
		},
		decimalPointLeading() {
			if (ns.isDigit(pr)) {
				;(Qt += he()), (Kt = "decimalFraction")
				return
			}
			throw Tn(he())
		},
		decimalPoint() {
			switch (pr) {
				case "e":
				case "E":
					;(Qt += he()), (Kt = "decimalExponent")
					return
			}
			if (ns.isDigit(pr)) {
				;(Qt += he()), (Kt = "decimalFraction")
				return
			}
			return Dn("numeric", of * Number(Qt))
		},
		decimalFraction() {
			switch (pr) {
				case "e":
				case "E":
					;(Qt += he()), (Kt = "decimalExponent")
					return
			}
			if (ns.isDigit(pr)) {
				Qt += he()
				return
			}
			return Dn("numeric", of * Number(Qt))
		},
		decimalExponent() {
			switch (pr) {
				case "+":
				case "-":
					;(Qt += he()), (Kt = "decimalExponentSign")
					return
			}
			if (ns.isDigit(pr)) {
				;(Qt += he()), (Kt = "decimalExponentInteger")
				return
			}
			throw Tn(he())
		},
		decimalExponentSign() {
			if (ns.isDigit(pr)) {
				;(Qt += he()), (Kt = "decimalExponentInteger")
				return
			}
			throw Tn(he())
		},
		decimalExponentInteger() {
			if (ns.isDigit(pr)) {
				Qt += he()
				return
			}
			return Dn("numeric", of * Number(Qt))
		},
		hexadecimal() {
			if (ns.isHexDigit(pr)) {
				;(Qt += he()), (Kt = "hexadecimalInteger")
				return
			}
			throw Tn(he())
		},
		hexadecimalInteger() {
			if (ns.isHexDigit(pr)) {
				Qt += he()
				return
			}
			return Dn("numeric", of * Number(Qt))
		},
		string() {
			switch (pr) {
				case "\\":
					he(), (Qt += _0t())
					return
				case '"':
					if (g_) return he(), Dn("string", Qt)
					Qt += he()
					return
				case "'":
					if (!g_) return he(), Dn("string", Qt)
					Qt += he()
					return
				case `
`:
				case "\r":
					throw Tn(he())
				case "\u2028":
				case "\u2029":
					S0t(pr)
					break
				case void 0:
					throw Tn(he())
			}
			Qt += he()
		},
		start() {
			switch (pr) {
				case "{":
				case "[":
					return Dn("punctuator", he())
			}
			Kt = "value"
		},
		beforePropertyName() {
			switch (pr) {
				case "$":
				case "_":
					;(Qt = he()), (Kt = "identifierName")
					return
				case "\\":
					he(), (Kt = "identifierNameStartEscape")
					return
				case "}":
					return Dn("punctuator", he())
				case '"':
				case "'":
					;(g_ = he() === '"'), (Kt = "string")
					return
			}
			if (ns.isIdStartChar(pr)) {
				;(Qt += he()), (Kt = "identifierName")
				return
			}
			throw Tn(he())
		},
		afterPropertyName() {
			if (pr === ":") return Dn("punctuator", he())
			throw Tn(he())
		},
		beforePropertyValue() {
			Kt = "value"
		},
		afterPropertyValue() {
			switch (pr) {
				case ",":
				case "}":
					return Dn("punctuator", he())
			}
			throw Tn(he())
		},
		beforeArrayValue() {
			if (pr === "]") return Dn("punctuator", he())
			Kt = "value"
		},
		afterArrayValue() {
			switch (pr) {
				case ",":
				case "]":
					return Dn("punctuator", he())
			}
			throw Tn(he())
		},
		end() {
			throw Tn(he())
		},
	}
	function Dn(e, t) {
		return { type: e, value: t, line: Kh, column: Rc }
	}
	function fA(e) {
		for (let t of e) {
			if (lf() !== t) throw Tn(he())
			he()
		}
	}
	function _0t() {
		switch (lf()) {
			case "b":
				return he(), "\b"
			case "f":
				return he(), "\f"
			case "n":
				return (
					he(),
					`
`
				)
			case "r":
				return he(), "\r"
			case "t":
				return he(), "	"
			case "v":
				return he(), "\v"
			case "0":
				if ((he(), ns.isDigit(lf()))) throw Tn(he())
				return "\0"
			case "x":
				return he(), w0t()
			case "u":
				return he(), PG()
			case `
`:
			case "\u2028":
			case "\u2029":
				return he(), ""
			case "\r":
				return (
					he(),
					lf() ===
						`
` && he(),
					""
				)
			case "1":
			case "2":
			case "3":
			case "4":
			case "5":
			case "6":
			case "7":
			case "8":
			case "9":
				throw Tn(he())
			case void 0:
				throw Tn(he())
		}
		return he()
	}
	function w0t() {
		let e = "",
			t = lf()
		if (!ns.isHexDigit(t) || ((e += he()), (t = lf()), !ns.isHexDigit(t))) throw Tn(he())
		return (e += he()), String.fromCodePoint(parseInt(e, 16))
	}
	function PG() {
		let e = "",
			t = 4
		for (; t-- > 0; ) {
			let r = lf()
			if (!ns.isHexDigit(r)) throw Tn(he())
			e += he()
		}
		return String.fromCodePoint(parseInt(e, 16))
	}
	var I0t = {
		start() {
			if (is.type === "eof") throw hA()
			FG()
		},
		beforePropertyName() {
			switch (is.type) {
				case "identifier":
				case "string":
					;(LG = is.value), (vo = "afterPropertyName")
					return
				case "punctuator":
					RF()
					return
				case "eof":
					throw hA()
			}
		},
		afterPropertyName() {
			if (is.type === "eof") throw hA()
			vo = "beforePropertyValue"
		},
		beforePropertyValue() {
			if (is.type === "eof") throw hA()
			FG()
		},
		beforeArrayValue() {
			if (is.type === "eof") throw hA()
			if (is.type === "punctuator" && is.value === "]") {
				RF()
				return
			}
			FG()
		},
		afterPropertyValue() {
			if (is.type === "eof") throw hA()
			switch (is.value) {
				case ",":
					vo = "beforePropertyName"
					return
				case "}":
					RF()
			}
		},
		afterArrayValue() {
			if (is.type === "eof") throw hA()
			switch (is.value) {
				case ",":
					vo = "beforeArrayValue"
					return
				case "]":
					RF()
			}
		},
		end() {},
	}
	function FG() {
		let e
		switch (is.type) {
			case "punctuator":
				switch (is.value) {
					case "{":
						e = {}
						break
					case "[":
						e = []
						break
				}
				break
			case "null":
			case "boolean":
			case "numeric":
			case "string":
				e = is.value
				break
		}
		if (p_ === void 0) p_ = e
		else {
			let t = af[af.length - 1]
			Array.isArray(t)
				? t.push(e)
				: Object.defineProperty(t, LG, {
						value: e,
						writable: !0,
						enumerable: !0,
						configurable: !0,
					})
		}
		if (e !== null && typeof e == "object")
			af.push(e), Array.isArray(e) ? (vo = "beforeArrayValue") : (vo = "beforePropertyName")
		else {
			let t = af[af.length - 1]
			t == null ? (vo = "end") : Array.isArray(t) ? (vo = "afterArrayValue") : (vo = "afterPropertyValue")
		}
	}
	function RF() {
		af.pop()
		let e = af[af.length - 1]
		e == null ? (vo = "end") : Array.isArray(e) ? (vo = "afterArrayValue") : (vo = "afterPropertyValue")
	}
	function Tn(e) {
		return MF(
			e === void 0
				? `JSON5: invalid end of input at ${Kh}:${Rc}`
				: `JSON5: invalid character '${Ybe(e)}' at ${Kh}:${Rc}`,
		)
	}
	function hA() {
		return MF(`JSON5: invalid end of input at ${Kh}:${Rc}`)
	}
	function Gbe() {
		return (Rc -= 5), MF(`JSON5: invalid identifier character at ${Kh}:${Rc}`)
	}
	function S0t(e) {
		console.warn(`JSON5: '${Ybe(e)}' in strings is not valid ECMAScript; consider escaping`)
	}
	function Ybe(e) {
		let t = {
			"'": "\\'",
			'"': '\\"',
			"\\": "\\\\",
			"\b": "\\b",
			"\f": "\\f",
			"\n": "\\n",
			"\r": "\\r",
			"	": "\\t",
			"\v": "\\v",
			"\0": "\\0",
			"\u2028": "\\u2028",
			"\u2029": "\\u2029",
		}
		if (t[e]) return t[e]
		if (e < " ") {
			let r = e.charCodeAt(0).toString(16)
			return "\\x" + ("00" + r).substring(r.length)
		}
		return e
	}
	function MF(e) {
		let t = new SyntaxError(e)
		return (t.lineNumber = Kh), (t.columnNumber = Rc), t
	}
})
var jbe = x((Cqt, zbe) => {
	"use strict"
	var UG = MG()
	zbe.exports = function (t, r, n) {
		let i = [],
			s = "",
			o,
			a,
			l = "",
			c
		if (
			(r != null && typeof r == "object" && !Array.isArray(r) && ((n = r.space), (c = r.quote), (r = r.replacer)),
			typeof r == "function")
		)
			a = r
		else if (Array.isArray(r)) {
			o = []
			for (let y of r) {
				let C
				typeof y == "string"
					? (C = y)
					: (typeof y == "number" || y instanceof String || y instanceof Number) && (C = String(y)),
					C !== void 0 && o.indexOf(C) < 0 && o.push(C)
			}
		}
		return (
			n instanceof Number ? (n = Number(n)) : n instanceof String && (n = String(n)),
			typeof n == "number"
				? n > 0 && ((n = Math.min(10, Math.floor(n))), (l = "          ".substr(0, n)))
				: typeof n == "string" && (l = n.substr(0, 10)),
			u("", { "": t })
		)
		function u(y, C) {
			let v = C[y]
			switch (
				(v != null &&
					(typeof v.toJSON5 == "function"
						? (v = v.toJSON5(y))
						: typeof v.toJSON == "function" && (v = v.toJSON(y))),
				a && (v = a.call(C, y, v)),
				v instanceof Number
					? (v = Number(v))
					: v instanceof String
						? (v = String(v))
						: v instanceof Boolean && (v = v.valueOf()),
				v)
			) {
				case null:
					return "null"
				case !0:
					return "true"
				case !1:
					return "false"
			}
			if (typeof v == "string") return f(v, !1)
			if (typeof v == "number") return String(v)
			if (typeof v == "object") return Array.isArray(v) ? m(v) : p(v)
		}
		function f(y) {
			let C = { "'": 0.1, '"': 0.2 },
				v = {
					"'": "\\'",
					'"': '\\"',
					"\\": "\\\\",
					"\b": "\\b",
					"\f": "\\f",
					"\n": "\\n",
					"\r": "\\r",
					"	": "\\t",
					"\v": "\\v",
					"\0": "\\0",
					"\u2028": "\\u2028",
					"\u2029": "\\u2029",
				},
				b = ""
			for (let B = 0; B < y.length; B++) {
				let M = y[B]
				switch (M) {
					case "'":
					case '"':
						C[M]++, (b += M)
						continue
					case "\0":
						if (UG.isDigit(y[B + 1])) {
							b += "\\x00"
							continue
						}
				}
				if (v[M]) {
					b += v[M]
					continue
				}
				if (M < " ") {
					let Q = M.charCodeAt(0).toString(16)
					b += "\\x" + ("00" + Q).substring(Q.length)
					continue
				}
				b += M
			}
			let w = c || Object.keys(C).reduce((B, M) => (C[B] < C[M] ? B : M))
			return (b = b.replace(new RegExp(w, "g"), v[w])), w + b + w
		}
		function p(y) {
			if (i.indexOf(y) >= 0) throw TypeError("Converting circular structure to JSON5")
			i.push(y)
			let C = s
			s = s + l
			let v = o || Object.keys(y),
				b = []
			for (let B of v) {
				let M = u(B, y)
				if (M !== void 0) {
					let Q = g(B) + ":"
					l !== "" && (Q += " "), (Q += M), b.push(Q)
				}
			}
			let w
			if (b.length === 0) w = "{}"
			else {
				let B
				if (l === "") (B = b.join(",")), (w = "{" + B + "}")
				else {
					let M =
						`,
` + s
					;(B = b.join(M)),
						(w =
							`{
` +
							s +
							B +
							`,
` +
							C +
							"}")
				}
			}
			return i.pop(), (s = C), w
		}
		function g(y) {
			if (y.length === 0) return f(y, !0)
			let C = String.fromCodePoint(y.codePointAt(0))
			if (!UG.isIdStartChar(C)) return f(y, !0)
			for (let v = C.length; v < y.length; v++)
				if (!UG.isIdContinueChar(String.fromCodePoint(y.codePointAt(v)))) return f(y, !0)
			return y
		}
		function m(y) {
			if (i.indexOf(y) >= 0) throw TypeError("Converting circular structure to JSON5")
			i.push(y)
			let C = s
			s = s + l
			let v = []
			for (let w = 0; w < y.length; w++) {
				let B = u(String(w), y)
				v.push(B !== void 0 ? B : "null")
			}
			let b
			if (v.length === 0) b = "[]"
			else if (l === "") b = "[" + v.join(",") + "]"
			else {
				let w =
						`,
` + s,
					B = v.join(w)
				b =
					`[
` +
					s +
					B +
					`,
` +
					C +
					"]"
			}
			return i.pop(), (s = C), b
		}
	}
})
var OG = x((vqt, Zbe) => {
	"use strict"
	var B0t = Jbe(),
		D0t = jbe(),
		T0t = { parse: B0t, stringify: D0t }
	Zbe.exports = T0t
})
var E8 = x((pKt, $_e) => {
	"use strict"
	function zn(e, r) {
		var r = r || {}
		;(this._capacity = r.capacity),
			(this._head = 0),
			(this._tail = 0),
			Array.isArray(e) ? this._fromArray(e) : ((this._capacityMask = 3), (this._list = new Array(4)))
	}
	zn.prototype.peekAt = function (t) {
		var r = t
		if (r === (r | 0)) {
			var n = this.size()
			if (!(r >= n || r < -n))
				return r < 0 && (r += n), (r = (this._head + r) & this._capacityMask), this._list[r]
		}
	}
	zn.prototype.get = function (t) {
		return this.peekAt(t)
	}
	zn.prototype.peek = function () {
		if (this._head !== this._tail) return this._list[this._head]
	}
	zn.prototype.peekFront = function () {
		return this.peek()
	}
	zn.prototype.peekBack = function () {
		return this.peekAt(-1)
	}
	Object.defineProperty(zn.prototype, "length", {
		get: function () {
			return this.size()
		},
	})
	zn.prototype.size = function () {
		return this._head === this._tail
			? 0
			: this._head < this._tail
				? this._tail - this._head
				: this._capacityMask + 1 - (this._head - this._tail)
	}
	zn.prototype.unshift = function (t) {
		if (arguments.length === 0) return this.size()
		var r = this._list.length
		return (
			(this._head = (this._head - 1 + r) & this._capacityMask),
			(this._list[this._head] = t),
			this._tail === this._head && this._growArray(),
			this._capacity && this.size() > this._capacity && this.pop(),
			this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail)
		)
	}
	zn.prototype.shift = function () {
		var t = this._head
		if (t !== this._tail) {
			var r = this._list[t]
			return (
				(this._list[t] = void 0),
				(this._head = (t + 1) & this._capacityMask),
				t < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2 && this._shrinkArray(),
				r
			)
		}
	}
	zn.prototype.push = function (t) {
		if (arguments.length === 0) return this.size()
		var r = this._tail
		return (
			(this._list[r] = t),
			(this._tail = (r + 1) & this._capacityMask),
			this._tail === this._head && this._growArray(),
			this._capacity && this.size() > this._capacity && this.shift(),
			this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail)
		)
	}
	zn.prototype.pop = function () {
		var t = this._tail
		if (t !== this._head) {
			var r = this._list.length
			this._tail = (t - 1 + r) & this._capacityMask
			var n = this._list[this._tail]
			return (
				(this._list[this._tail] = void 0), this._head < 2 && t > 1e4 && t <= r >>> 2 && this._shrinkArray(), n
			)
		}
	}
	zn.prototype.removeOne = function (t) {
		var r = t
		if (r === (r | 0) && this._head !== this._tail) {
			var n = this.size(),
				i = this._list.length
			if (!(r >= n || r < -n)) {
				r < 0 && (r += n), (r = (this._head + r) & this._capacityMask)
				var s = this._list[r],
					o
				if (t < n / 2) {
					for (o = t; o > 0; o--) this._list[r] = this._list[(r = (r - 1 + i) & this._capacityMask)]
					;(this._list[r] = void 0), (this._head = (this._head + 1 + i) & this._capacityMask)
				} else {
					for (o = n - 1 - t; o > 0; o--) this._list[r] = this._list[(r = (r + 1 + i) & this._capacityMask)]
					;(this._list[r] = void 0), (this._tail = (this._tail - 1 + i) & this._capacityMask)
				}
				return s
			}
		}
	}
	zn.prototype.remove = function (t, r) {
		var n = t,
			i,
			s = r
		if (n === (n | 0) && this._head !== this._tail) {
			var o = this.size(),
				a = this._list.length
			if (!(n >= o || n < -o || r < 1)) {
				if ((n < 0 && (n += o), r === 1 || !r)) return (i = new Array(1)), (i[0] = this.removeOne(n)), i
				if (n === 0 && n + r >= o) return (i = this.toArray()), this.clear(), i
				n + r > o && (r = o - n)
				var l
				for (i = new Array(r), l = 0; l < r; l++) i[l] = this._list[(this._head + n + l) & this._capacityMask]
				if (((n = (this._head + n) & this._capacityMask), t + r === o)) {
					for (this._tail = (this._tail - r + a) & this._capacityMask, l = r; l > 0; l--)
						this._list[(n = (n + 1 + a) & this._capacityMask)] = void 0
					return i
				}
				if (t === 0) {
					for (this._head = (this._head + r + a) & this._capacityMask, l = r - 1; l > 0; l--)
						this._list[(n = (n + 1 + a) & this._capacityMask)] = void 0
					return i
				}
				if (n < o / 2) {
					for (this._head = (this._head + t + r + a) & this._capacityMask, l = t; l > 0; l--)
						this.unshift(this._list[(n = (n - 1 + a) & this._capacityMask)])
					for (n = (this._head - 1 + a) & this._capacityMask; s > 0; )
						(this._list[(n = (n - 1 + a) & this._capacityMask)] = void 0), s--
					t < 0 && (this._tail = n)
				} else {
					for (this._tail = n, n = (n + r + a) & this._capacityMask, l = o - (r + t); l > 0; l--)
						this.push(this._list[n++])
					for (n = this._tail; s > 0; ) (this._list[(n = (n + 1 + a) & this._capacityMask)] = void 0), s--
				}
				return this._head < 2 && this._tail > 1e4 && this._tail <= a >>> 2 && this._shrinkArray(), i
			}
		}
	}
	zn.prototype.splice = function (t, r) {
		var n = t
		if (n === (n | 0)) {
			var i = this.size()
			if ((n < 0 && (n += i), !(n > i)))
				if (arguments.length > 2) {
					var s,
						o,
						a,
						l = arguments.length,
						c = this._list.length,
						u = 2
					if (!i || n < i / 2) {
						for (o = new Array(n), s = 0; s < n; s++)
							o[s] = this._list[(this._head + s) & this._capacityMask]
						for (
							r === 0
								? ((a = []), n > 0 && (this._head = (this._head + n + c) & this._capacityMask))
								: ((a = this.remove(n, r)), (this._head = (this._head + n + c) & this._capacityMask));
							l > u;

						)
							this.unshift(arguments[--l])
						for (s = n; s > 0; s--) this.unshift(o[s - 1])
					} else {
						o = new Array(i - (n + r))
						var f = o.length
						for (s = 0; s < f; s++) o[s] = this._list[(this._head + n + r + s) & this._capacityMask]
						for (
							r === 0
								? ((a = []), n != i && (this._tail = (this._head + n + c) & this._capacityMask))
								: ((a = this.remove(n, r)), (this._tail = (this._tail - f + c) & this._capacityMask));
							u < l;

						)
							this.push(arguments[u++])
						for (s = 0; s < f; s++) this.push(o[s])
					}
					return a
				} else return this.remove(n, r)
		}
	}
	zn.prototype.clear = function () {
		;(this._list = new Array(this._list.length)), (this._head = 0), (this._tail = 0)
	}
	zn.prototype.isEmpty = function () {
		return this._head === this._tail
	}
	zn.prototype.toArray = function () {
		return this._copyArray(!1)
	}
	zn.prototype._fromArray = function (t) {
		var r = t.length,
			n = this._nextPowerOf2(r)
		;(this._list = new Array(n)), (this._capacityMask = n - 1), (this._tail = r)
		for (var i = 0; i < r; i++) this._list[i] = t[i]
	}
	zn.prototype._copyArray = function (t, r) {
		var n = this._list,
			i = n.length,
			s = this.length
		if (((r = r | s), r == s && this._head < this._tail)) return this._list.slice(this._head, this._tail)
		var o = new Array(r),
			a = 0,
			l
		if (t || this._head > this._tail) {
			for (l = this._head; l < i; l++) o[a++] = n[l]
			for (l = 0; l < this._tail; l++) o[a++] = n[l]
		} else for (l = this._head; l < this._tail; l++) o[a++] = n[l]
		return o
	}
	zn.prototype._growArray = function () {
		if (this._head != 0) {
			var t = this._copyArray(!0, this._list.length << 1)
			;(this._tail = this._list.length), (this._head = 0), (this._list = t)
		} else (this._tail = this._list.length), (this._list.length <<= 1)
		this._capacityMask = (this._capacityMask << 1) | 1
	}
	zn.prototype._shrinkArray = function () {
		;(this._list.length >>>= 1), (this._capacityMask >>>= 1)
	}
	zn.prototype._nextPowerOf2 = function (t) {
		var r = Math.log(t) / Math.log(2),
			n = 1 << (r + 1)
		return Math.max(n, 4)
	}
	$_e.exports = zn
})
var nwe = x((QKt, rwe) => {
	"use strict"
	function K_e(e) {
		return Array.isArray(e) ? e : [e]
	}
	var Z_e = "",
		J_e = " ",
		x8 = "\\",
		Byt = /^\s+$/,
		Dyt = /(?:[^\\]|^)\\$/,
		Tyt = /^\\!/,
		Ryt = /^\\#/,
		kyt = /\r?\n/g,
		Myt = /^\.*\/|^\.+$/,
		_8 = "/",
		X_e = "node-ignore"
	typeof Symbol < "u" && (X_e = Symbol.for("node-ignore"))
	var z_e = X_e,
		Fyt = (e, t, r) => Object.defineProperty(e, t, { value: r }),
		Qyt = /([0-z])-([0-z])/g,
		ewe = () => !1,
		Nyt = (e) => e.replace(Qyt, (t, r, n) => (r.charCodeAt(0) <= n.charCodeAt(0) ? t : Z_e)),
		Pyt = (e) => {
			let { length: t } = e
			return e.slice(0, t - (t % 2))
		},
		Lyt = [
			[/\\?\s+$/, (e) => (e.indexOf("\\") === 0 ? J_e : Z_e)],
			[/\\\s/g, () => J_e],
			[/[\\$.|*+(){^]/g, (e) => `\\${e}`],
			[/(?!\\)\?/g, () => "[^/]"],
			[/^\//, () => "^"],
			[/\//g, () => "\\/"],
			[/^\^*\\\*\\\*\\\//, () => "^(?:.*\\/)?"],
			[
				/^(?=[^^])/,
				function () {
					return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)"
				},
			],
			[/\\\/\\\*\\\*(?=\\\/|$)/g, (e, t, r) => (t + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+")],
			[
				/(^|[^\\]+)(\\\*)+(?=.+)/g,
				(e, t, r) => {
					let n = r.replace(/\\\*/g, "[^\\/]*")
					return t + n
				},
			],
			[/\\\\\\(?=[$.|*+(){^])/g, () => x8],
			[/\\\\/g, () => x8],
			[
				/(\\)?\[([^\]/]*?)(\\*)($|\])/g,
				(e, t, r, n, i) =>
					t === x8 ? `\\[${r}${Pyt(n)}${i}` : i === "]" && n.length % 2 === 0 ? `[${Nyt(r)}${n}]` : "[]",
			],
			[/(?:[^*])$/, (e) => (/\/$/.test(e) ? `${e}$` : `${e}(?=$|\\/$)`)],
			[/(\^|\\\/)?\\\*$/, (e, t) => `${t ? `${t}[^/]+` : "[^/]*"}(?=$|\\/$)`],
		],
		j_e = Object.create(null),
		Uyt = (e, t) => {
			let r = j_e[e]
			return (
				r || ((r = Lyt.reduce((n, i) => n.replace(i[0], i[1].bind(e)), e)), (j_e[e] = r)),
				t ? new RegExp(r, "i") : new RegExp(r)
			)
		},
		S8 = (e) => typeof e == "string",
		Oyt = (e) => e && S8(e) && !Byt.test(e) && !Dyt.test(e) && e.indexOf("#") !== 0,
		qyt = (e) => e.split(kyt),
		w8 = class {
			constructor(t, r, n, i) {
				;(this.origin = t), (this.pattern = r), (this.negative = n), (this.regex = i)
			}
		},
		Vyt = (e, t) => {
			let r = e,
				n = !1
			e.indexOf("!") === 0 && ((n = !0), (e = e.substr(1))), (e = e.replace(Tyt, "!").replace(Ryt, "#"))
			let i = Uyt(e, t)
			return new w8(r, e, n, i)
		},
		Hyt = (e, t) => {
			throw new t(e)
		},
		gf = (e, t, r) =>
			S8(e)
				? e
					? gf.isNotRelative(e)
						? r(`path should be a \`path.relative()\`d string, but got "${t}"`, RangeError)
						: !0
					: r("path must not be empty", TypeError)
				: r(`path must be a string, but got \`${t}\``, TypeError),
		twe = (e) => Myt.test(e)
	gf.isNotRelative = twe
	gf.convert = (e) => e
	var I8 = class {
			constructor({ ignorecase: t = !0, ignoreCase: r = t, allowRelativePaths: n = !1 } = {}) {
				Fyt(this, z_e, !0),
					(this._rules = []),
					(this._ignoreCase = r),
					(this._allowRelativePaths = n),
					this._initCache()
			}
			_initCache() {
				;(this._ignoreCache = Object.create(null)), (this._testCache = Object.create(null))
			}
			_addPattern(t) {
				if (t && t[z_e]) {
					;(this._rules = this._rules.concat(t._rules)), (this._added = !0)
					return
				}
				if (Oyt(t)) {
					let r = Vyt(t, this._ignoreCase)
					;(this._added = !0), this._rules.push(r)
				}
			}
			add(t) {
				return (
					(this._added = !1),
					K_e(S8(t) ? qyt(t) : t).forEach(this._addPattern, this),
					this._added && this._initCache(),
					this
				)
			}
			addPattern(t) {
				return this.add(t)
			}
			_testOne(t, r) {
				let n = !1,
					i = !1
				return (
					this._rules.forEach((s) => {
						let { negative: o } = s
						if ((i === o && n !== i) || (o && !n && !i && !r)) return
						s.regex.test(t) && ((n = !o), (i = o))
					}),
					{ ignored: n, unignored: i }
				)
			}
			_test(t, r, n, i) {
				let s = t && gf.convert(t)
				return gf(s, t, this._allowRelativePaths ? ewe : Hyt), this._t(s, r, n, i)
			}
			_t(t, r, n, i) {
				if (t in r) return r[t]
				if ((i || (i = t.split(_8)), i.pop(), !i.length)) return (r[t] = this._testOne(t, n))
				let s = this._t(i.join(_8) + _8, r, n, i)
				if (s.ignored) return (r[t] = s)
				let o = this._testOne(t, n)
				return (r[t] = {
					ignored: o.ignored,
					unignored: s.unignored || o.unignored,
				})
			}
			ignores(t) {
				return this._test(t, this._ignoreCache, !1).ignored
			}
			createFilter() {
				return (t) => !this.ignores(t)
			}
			filter(t) {
				return K_e(t).filter(this.createFilter())
			}
			test(t) {
				return this._test(t, this._testCache, !0)
			}
		},
		$Q = (e) => new I8(e),
		Wyt = (e) => gf(e && gf.convert(e), e, ewe)
	$Q.isPathValid = Wyt
	$Q.default = $Q
	rwe.exports = $Q
	if (typeof process < "u" && ((process.env && process.env.IGNORE_TEST_WIN32) || process.platform === "win32")) {
		let e = (r) => (/^\\\\\?\\/.test(r) || /["<>|\u0000-\u001F]+/u.test(r) ? r : r.replace(/\\/g, "/"))
		gf.convert = e
		let t = /^[a-z]:\//i
		gf.isNotRelative = (r) => t.test(r) || twe(r)
	}
})
var xCt = {}
z2(xCt, {
	AugmentExtension: () => AA,
	_exportedForTesting: () => bCt,
	activate: () => ECt,
	getSessionId: () => Rwe,
})
module.exports = j2(xCt)
var bv
function g$(e) {
	if (bv) {
		bv.warn("Attempting to initialize logger when one is already configured. Keeping existing logger.")
		return
	}
	bv = e
}
function dn(e) {
	if (!bv) throw new Error("Logger not initialized. Call setLogger() before using getLogger().")
	return bv.child({ prefix: e })
}
var xv = class {
		static _instance = void 0
		static setPluginFileStore(t) {
			if (this._instance !== void 0) {
				dn("PluginFileStore").warn(
					"Attempting to initialize client workspaces when one is already configured. Keeping existing client workspaces.",
				)
				return
			}
			this._instance = t
		}
		static getPluginFileStore() {
			if (this._instance === void 0) throw new Error("ClientWorkspaces not set")
			return this._instance
		}
		static reset() {
			this._instance = void 0
		}
	},
	p$ = (e) => xv.setPluginFileStore(e),
	lI = () => xv.getPluginFileStore(),
	A$ = () => xv.reset()
var cI = class e {
		_logger = dn("AgentShardStorage")
		static storagePathKeyPrefix = "agent-edit-shard-storage"
		static manifestKey = "manifest"
		static serializedStoreKey = "serialized-store"
		async save(t) {
			await this._saveJson(this._getStoragePath(hd.serializedStore, e.serializedStoreKey), t)
		}
		async load() {
			return this._loadJson(this._getStoragePath(hd.serializedStore, e.serializedStoreKey))
		}
		async _saveJson(t, r) {
			let n = Buffer.from(JSON.stringify(r), "utf8")
			await lI().saveAsset(t, new Uint8Array(n))
		}
		async _loadJson(t) {
			let r = await lI().loadAsset(t)
			if (!(!r || r.length === 0)) return JSON.parse(Buffer.from(r).toString("utf8"))
		}
		_getStoragePath(t, r) {
			return `agent-edits/${t}/${e.storagePathKeyPrefix}-${r}.json`
		}
		async saveShard(t, r) {
			await this._saveJson(this._getStoragePath(hd.shards, t), r)
		}
		async loadShard(t) {
			return this._loadJson(this._getStoragePath(hd.shards, t))
		}
		async deleteShard(t) {
			await lI().deleteAsset(this._getStoragePath(hd.shards, t))
		}
		async saveManifest(t) {
			await this._saveJson(this._getStoragePath(hd.manifest, e.manifestKey), t)
		}
		async loadManifest() {
			return this._loadJson(this._getStoragePath(hd.manifest, e.manifestKey))
		}
	},
	hd
;(function (e) {
	;(e.shards = "shards"), (e.manifest = "manifest"), (e.serializedStore = "serialized-store")
})(hd || (hd = {}))
var _v = require("path")
function $t(e, t, r = !1) {
	let n = (0, _v.join)(e, t)
	return r && !n.endsWith(_v.sep) && (n += _v.sep), n
}
var Je = class e {
	rootPath
	relPath
	constructor(t, r) {
		;(this.rootPath = t), (this.relPath = r)
	}
	static from(t) {
		return new e(t.rootPath, t.relPath)
	}
	get absPath() {
		return $t(this.rootPath, this.relPath)
	}
	equals(t) {
		return e.equals(this, t)
	}
	static equals(t, r) {
		if (t === r) return !0
		if (t == null || r == null) return !1
		let n = m$(t) ? $t(t.rootPath, t.relPath) : t.fsPath,
			i = m$(r) ? $t(r.rootPath, r.relPath) : r.fsPath
		return n === i
	}
}
function m$(e) {
	return e != null && typeof e == "object" && ("rootPath" in e || "relPath" in e)
}
var xg = class {
	_disposables = []
	add(t) {
		if (t === void 0) throw new Error("Attempt to add undefined disposable to DisposableCollection")
		return this._disposables.push(t), t
	}
	addAll(...t) {
		t.forEach((r) => this.add(r))
	}
	adopt(t) {
		this._disposables.push(...t._disposables), (t._disposables.length = 0)
	}
	dispose() {
		for (let t of this._disposables) t.dispose()
		this._disposables.length = 0
	}
}
var JA = class {
	_disposables = new xg()
	_priorityDisposables = new xg()
	constructor(t = new xg(), r = new xg()) {
		this._disposables.adopt(t), this._priorityDisposables.adopt(r)
	}
	addDisposable(t, r = !1) {
		return r ? this._priorityDisposables.add(t) : this._disposables.add(t)
	}
	addDisposables(...t) {
		this._disposables.addAll(...t)
	}
	dispose() {
		this._priorityDisposables.dispose(), this._disposables.dispose()
	}
}
var hi = class e extends JA {
	filePath
	_originalCode
	_modifiedCode
	_opts
	static EMPTY_PATH_NAME = { rootPath: "", relPath: "" }
	_originalListeners
	_modifiedListeners
	_isUntitled
	constructor(t, r, n, i) {
		super(),
			(this.filePath = t),
			(this._originalCode = r),
			(this._modifiedCode = n),
			(this._opts = i),
			(this._isUntitled = this._opts.isUntitled ?? (() => !1)),
			(this._originalListeners = new Set()),
			(this._modifiedListeners = new Set()),
			this.addDisposable({ dispose: () => this._originalListeners.clear() }),
			this.addDisposable({ dispose: () => this._modifiedListeners.clear() }),
			this._opts?.logger?.debug(this.toString("constructor", !0))
	}
	toString(t, r = !1) {
		let n = this.isUntitled ? " (untitled)" : "",
			i = this._originalCode !== this._modifiedCode,
			s = this._originalCode
				? this._originalCode.split(`
`).length
				: 0,
			o = this._modifiedCode
				? this._modifiedCode.split(`
`).length
				: 0
		return r
			? [
					`[${t}] DiffViewDocument`,
					"----------------------------------------",
					`Path      : ${this.filePath.absPath}${n}`,
					`Original  : ${s} lines`,
					`Modified  : ${o} lines`,
					"----------------------------------------",
				].join(`
`)
			: [
					`[${t}] DiffViewDocument`,
					"----------------------------------------",
					`Path      : ${this.filePath.absPath}${n}`,
					`Status    : ${i ? "Modified" : "Unchanged"}`,
					`Orig Size : ${this._originalCode.length} chars`,
					`Mod Size  : ${this._modifiedCode.length} chars`,
					"",
					"Original Code:",
					this._originalCode || "(empty)",
					"",
					"Modified Code:",
					this._modifiedCode || "(empty)",
					"----------------------------------------",
				].join(`
`)
	}
	static empty() {
		return new e(Je.from(e.EMPTY_PATH_NAME), "", "", {})
	}
	get isEmptyDocument() {
		return this.filePath.equals(e.EMPTY_PATH_NAME)
	}
	get absPath() {
		return this.filePath.absPath
	}
	get originalCode() {
		return this.isEmptyDocument || this._originalCode === "" ? "" : this._originalCode
	}
	get modifiedCode() {
		return this.isEmptyDocument || this._modifiedCode === "" ? "" : this._modifiedCode
	}
	get isUntitled() {
		return this._isUntitled(this.filePath)
	}
	onOriginalUpdated = (t) => (this._originalListeners.add(t), { dispose: () => this._originalListeners.delete(t) })
	onModifiedUpdated = (t) => (this._modifiedListeners.add(t), { dispose: () => this._modifiedListeners.delete(t) })
	updateOriginal = (t) =>
		this.originalCode === t ? !1 : ((this._originalCode = t), this._originalListeners.forEach((r) => r(this)), !0)
	updateBuffer = (t) =>
		this.modifiedCode === t ? !1 : ((this._modifiedCode = t), this._modifiedListeners.forEach((r) => r(this)), !0)
	updateCodeVersions = (t, r) => {
		let n = !1
		return t !== void 0 && (n = this.updateOriginal(t) || n), r !== void 0 && (n = this.updateBuffer(r) || n), n
	}
}
function y$(e) {
	return typeof e != "string"
		? { isValid: !1, reason: "Shard ID must be a string" }
		: e.length === 0
			? { isValid: !1, reason: "Shard ID cannot be empty" }
			: { isValid: !0 }
}
function uI(e) {
	if (typeof e.version != "number" || typeof e.lastUpdated != "number")
		return {
			isValid: !1,
			reason: "Invalid manifest version or lastUpdated timestamp",
		}
	if (!e.shards || typeof e.shards != "object") return { isValid: !1, reason: "Missing or invalid shards object" }
	for (let [t, r] of Object.entries(e.shards)) {
		let n = y$(t)
		if (!n.isValid) return n
		if (!r || typeof r != "object") return { isValid: !1, reason: `Invalid metadata object for shard ${t}` }
		if (typeof r.size != "number") return { isValid: !1, reason: `Invalid size field for shard ${t}` }
		if (typeof r.checkpointCount != "number")
			return {
				isValid: !1,
				reason: `Invalid checkpointCount field for shard ${t}`,
			}
		if (typeof r.lastModified != "number")
			return {
				isValid: !1,
				reason: `Invalid lastModified field for shard ${t}`,
			}
		if (!Array.isArray(r.checkpointDocumentIds))
			return {
				isValid: !1,
				reason: `Invalid checkpointDocumentIds array for shard ${t}`,
			}
		for (let i of r.checkpointDocumentIds)
			if (typeof i != "string" || i.length === 0)
				return {
					isValid: !1,
					reason: `Invalid checkpoint document ID in shard ${t}: ${i}`,
				}
	}
	return { isValid: !0 }
}
function C$(e) {
	let t = y$(e.id)
	if (!t.isValid) return t
	let r = uI({
		version: 1,
		lastUpdated: Date.now(),
		shards: { [e.id]: e.metadata },
	})
	if (!r.isValid) return r
	if (typeof e.checkpoints != "object" || !e.checkpoints)
		return { isValid: !1, reason: "Missing or invalid checkpoints object" }
	for (let [s, o] of Object.entries(e.checkpoints)) {
		if (typeof s != "string" || s.length === 0) return { isValid: !1, reason: `Invalid checkpoint ID: ${s}` }
		if (!Array.isArray(o))
			return {
				isValid: !1,
				reason: `Checkpoints for ID ${s} must be an array`,
			}
		for (let a of o)
			if (
				typeof a != "object" ||
				!a ||
				typeof a.sourceToolCallRequestId != "string" ||
				typeof a.timestamp != "number" ||
				typeof a.document != "object" ||
				!a.document ||
				typeof a.document.originalCode != "string" ||
				typeof a.document.modifiedCode != "string" ||
				typeof a.document.path != "object" ||
				!a.document.path ||
				typeof a.document.path.rootPath != "string" ||
				typeof a.document.path.relPath != "string"
			)
				return {
					isValid: !1,
					reason: `Invalid checkpoint structure in ID ${s}`,
				}
	}
	let n = new Set(Object.keys(e.checkpoints)),
		i = new Set(e.metadata.checkpointDocumentIds)
	if (n.size !== i.size)
		return {
			isValid: !1,
			reason: "Mismatch between checkpoint IDs in metadata and actual checkpoints",
		}
	for (let s of n)
		if (!i.has(s))
			return {
				isValid: !1,
				reason: "Mismatch between checkpoint IDs in metadata and actual checkpoints",
			}
	return { isValid: !0 }
}
function Z2(e, t, r = !0) {
	let { minTimestamp: n, maxTimestamp: i, minIdx: s, maxIdx: o } = t
	return e.filter((a, l) => {
		let c = (n === void 0 || a.timestamp >= n) && (i === void 0 || a.timestamp < i),
			u = (s === void 0 || l >= s) && (o === void 0 || l < o),
			f = n !== void 0 || i !== void 0,
			p = s !== void 0 || o !== void 0
		if (!(f || p)) return r
		let m = (!f || c) && (!p || u)
		return r ? m : !m
	})
}
var Df = class extends Error {
	constructor(t) {
		super(t), (this.name = "SerializationError")
	}
}
function ake(e) {
	return {
		path: { rootPath: e.filePath.rootPath, relPath: e.filePath.relPath },
		originalCode: e.originalCode,
		modifiedCode: e.modifiedCode,
	}
}
function lke(e) {
	return new hi(Je.from(e.path), e.originalCode, e.modifiedCode, {})
}
function cke(e) {
	return {
		sourceToolCallRequestId: e.sourceToolCallRequestId,
		timestamp: e.timestamp,
		document: ake(e.document),
		conversationId: e.conversationId,
	}
}
function uke(e) {
	return {
		sourceToolCallRequestId: e.sourceToolCallRequestId,
		timestamp: e.timestamp,
		document: lke(e.document),
		conversationId: e.conversationId,
	}
}
function v$(e) {
	try {
		let t = { id: e.id, checkpoints: {}, metadata: e.getMetadata() }
		for (let r of e.checkpointDocumentIds) {
			let n = e.getCheckpointsById(r)
			n && (t.checkpoints[r] = n.map(cke))
		}
		return t
	} catch (t) {
		throw new Df(`Failed to serialize shard: ${t instanceof Error ? t.message : String(t)}`)
	}
}
function E$(e, t, r) {
	try {
		if (!fke(t)) throw new Df("Invalid shard data structure")
		if (t.id !== e) throw new Df(`Shard ID mismatch: expected ${e}, got ${t.id}`)
		if (!C$(t).isValid) throw new Df("Shard validation failed")
		let n = new _g(e, r)
		for (let i of Object.entries(t.checkpoints))
			for (let s of i[1]) {
				let o = Je.from(s.document.path),
					a = { conversationId: s.conversationId, path: o }
				n.addCheckpoint(a, uke(s))
			}
		return n
	} catch (n) {
		throw n instanceof Df ? n : new Df(`Failed to deserialize shard: ${n instanceof Error ? n.message : String(n)}`)
	}
}
function dke(e) {
	if (typeof e != "object" || !e) return !1
	let t = e
	return (
		typeof t.path == "object" &&
		!!t.path &&
		typeof t.path.rootPath == "string" &&
		typeof t.path.relPath == "string" &&
		typeof t.originalCode == "string" &&
		typeof t.modifiedCode == "string"
	)
}
function fke(e) {
	if (typeof e != "object" || !e) return !1
	let t = e
	if (
		typeof t.id != "string" ||
		typeof t.checkpoints != "object" ||
		!t.checkpoints ||
		typeof t.metadata != "object" ||
		!t.metadata
	)
		return !1
	let r = t.metadata
	if (
		!Array.isArray(r.checkpointDocumentIds) ||
		typeof r.size != "number" ||
		typeof r.checkpointCount != "number" ||
		typeof r.lastModified != "number"
	)
		return !1
	let n = t.checkpoints,
		i = r.checkpointDocumentIds
	return Object.entries(n).every(([s, o]) =>
		!Array.isArray(o) || !i.includes(s)
			? !1
			: o.every((a) => {
					if (typeof a != "object" || !a) return !1
					let l = a
					return (
						typeof l.sourceToolCallRequestId == "string" &&
						typeof l.timestamp == "number" &&
						typeof l.conversationId == "string" &&
						dke(l.document)
					)
				}),
	)
}
var _g = class {
	_id
	_checkpointDocumentIdFn
	_checkpoints = new Map()
	_lastModified = Date.now()
	constructor(t, r) {
		;(this._id = t), (this._checkpointDocumentIdFn = r)
	}
	static fromSerialized(t, r, n) {
		if (r.id !== t) throw new Error(`Shard ID mismatch: expected ${t}, got ${r.id}`)
		return E$(t, r, n)
	}
	get id() {
		return this._id
	}
	get size() {
		return Array.from(this._checkpoints.values()).reduce(
			(t, r) =>
				t +
				r.reduce(
					(n, i) => n + (i.document.originalCode?.length || 0) + (i.document.modifiedCode?.length || 0),
					0,
				),
			0,
		)
	}
	get checkpointCount() {
		return Array.from(this._checkpoints.values()).reduce((t, r) => t + r.length, 0)
	}
	get lastModified() {
		return this._lastModified
	}
	get checkpointDocumentIds() {
		return Array.from(this._checkpoints.keys())
	}
	getCheckpointsById(t) {
		return this._checkpoints.get(t)
	}
	serialize() {
		return v$(this)
	}
	getMetadata() {
		return {
			checkpointDocumentIds: this.checkpointDocumentIds,
			size: this.size,
			checkpointCount: this.checkpointCount,
			lastModified: this._lastModified,
		}
	}
	hasKey(t) {
		return this._checkpoints.has(this._checkpointDocumentIdFn(t))
	}
	getAllCheckpoints() {
		return Array.from(this._checkpoints.values()).flat()
	}
	getAllCheckpointsSorted() {
		return this.getAllCheckpoints().sort((t, r) => t.timestamp - r.timestamp)
	}
	get orderedCheckpointsByTime() {
		return this.getAllCheckpointsSorted()
	}
	get totalCheckpointCount() {
		return this.checkpointCount
	}
	getCheckpointNumberForToolCall(t) {
		let r = this.orderedCheckpointsByTime.findIndex((n) => n.sourceToolCallRequestId === t)
		return r === -1 ? void 0 : r
	}
	getCheckpointBySourceId(t) {
		return this.getAllCheckpoints().find((r) => r.sourceToolCallRequestId === t)
	}
	getCheckpoints(t, r) {
		let n = this._checkpoints.get(this._checkpointDocumentIdFn(t))
		if (!n?.length) return
		if (!r) return n
		let i = Z2(n, r)
		return i.length > 0 ? i : []
	}
	getLatestCheckpoint(t) {
		let r = this._checkpoints.get(this._checkpointDocumentIdFn(t))
		return r?.[r.length - 1]
	}
	addCheckpoint(t, r) {
		let n = this._checkpointDocumentIdFn(t),
			s = [...(this._checkpoints.get(n) || []), r].sort((o, a) => o.timestamp - a.timestamp)
		this._checkpoints.set(n, s), (this._lastModified = Date.now())
	}
	updateCheckpoint(t, r) {
		let n = this._checkpointDocumentIdFn(t),
			i = this._checkpoints.get(n) || [],
			s = i.findIndex((o) => o.sourceToolCallRequestId === r.sourceToolCallRequestId)
		s !== -1 && ((i[s] = r), this._checkpoints.set(n, i), (this._lastModified = Date.now()))
	}
	getAllTrackedConversationIds() {
		let t = new Set()
		for (let r of this.getAllCheckpoints()) t.add(r.conversationId)
		return Array.from(t)
	}
	getAllTrackedFilePaths(t) {
		let r = new Map()
		for (let n of this.getAllCheckpoints())
			n.conversationId === t && r.set(n.document.filePath.absPath, n.document.filePath)
		return Array.from(r.values())
	}
	removeCheckpoint(t, r) {
		let n = this._checkpointDocumentIdFn(t),
			i = this._checkpoints.get(n)
		if (!i?.length) return !1
		if (!r) return this._checkpoints.delete(n), (this._lastModified = Date.now()), !0
		let s = Z2(i, r, !1)
		return s.length === i.length
			? !1
			: (s.length === 0 ? this._checkpoints.delete(n) : this._checkpoints.set(n, s),
				(this._lastModified = Date.now()),
				!0)
	}
	clear() {
		this._checkpoints.clear(), (this._lastModified = Date.now())
	}
}
var wv = class {
		static _instance = void 0
		static setClientWorkspaces(t) {
			if (this._instance !== void 0) {
				dn("ClientWorkspaces").warn(
					"Attempting to initialize client workspaces when one is already configured. Keeping existing client workspaces.",
				)
				return
			}
			this._instance = t
		}
		static getClientWorkspaces() {
			if (this._instance === void 0) throw new Error("ClientWorkspaces not set")
			return this._instance
		}
		static reset() {
			this._instance = void 0
		}
	},
	b$ = (e) => wv.setClientWorkspaces(e),
	Do = () => wv.getClientWorkspaces(),
	x$ = () => wv.reset()
var X$ = W(ZA()),
	dI = class {
		_storage
		_shardFunction
		_options
		_shardCache = new Map()
		_manifest = { version: 1, lastUpdated: Date.now(), shards: {} }
		_accessOrder = []
		_checkpointDocumentIdFn
		_flushManifest
		constructor(t, r, n = {}) {
			;(this._storage = t),
				(this._shardFunction = r),
				(this._options = n),
				(this._checkpointDocumentIdFn = (i) => `${i.conversationId}:${i.path.absPath}`),
				(this._flushManifest = (0, X$.default)(
					async () => {
						await this._storage.saveManifest(this._manifest)
					},
					this._options.manifestUpdateThrottleMs ?? 1e3,
					{ leading: !0, trailing: !0 },
				))
		}
		get manifest() {
			return this._manifest
		}
		initialize = async () => {
			let t = await this._storage.loadManifest()
			t && uI(t).isValid
				? (this._manifest = t)
				: ((this._manifest = {
						version: 1,
						lastUpdated: Date.now(),
						shards: {},
					}),
					await this._storage.saveManifest(this._manifest))
		}
		_getShardId(t) {
			let r = this._checkpointDocumentIdFn(t)
			for (let [n, i] of Object.entries(this._manifest.shards)) if (i.checkpointDocumentIds.includes(r)) return n
			return this._shardFunction(t, {
				manifestSnapshot: this._manifest,
				pathStats: { checkpointCount: 0, estimatedSize: 0 },
			})
		}
		_updateAccessTime(t) {
			let r = this._accessOrder.indexOf(t)
			r > -1 && this._accessOrder.splice(r, 1), this._accessOrder.push(t)
		}
		async _loadShard(t) {
			let r = this._shardCache.get(t)
			if (r) return this._updateAccessTime(t), r
			let n = await this._storage.loadShard(t)
			r = n ? _g.fromSerialized(t, n, this._checkpointDocumentIdFn) : new _g(t, this._checkpointDocumentIdFn)
			for (let s of r.getAllTrackedConversationIds())
				for (let o of r.getAllTrackedFilePaths(s)) {
					let a = r.getLatestCheckpoint({ conversationId: s, path: o })
					if (!a) continue
					let l = (await Do().readFile(o.absPath)).contents
					if (l && l !== a.document.modifiedCode) {
						let c = new hi(o, a.document.modifiedCode, l, {})
						r.addCheckpoint(
							{ conversationId: s, path: o },
							{
								sourceToolCallRequestId: crypto.randomUUID(),
								timestamp: Date.now(),
								document: c,
								conversationId: s,
							},
						)
					}
				}
			let i = this._options.maxCachedShards ?? 10
			for (; this._shardCache.size >= i && this._accessOrder.length > 0; ) {
				let s = this._accessOrder.shift()
				if (s) {
					let o = this._shardCache.get(s)
					o && (await this._storage.saveShard(s, o.serialize()), this._shardCache.delete(s))
				}
			}
			return this._shardCache.set(t, r), this._updateAccessTime(t), r
		}
		async _updateManifest(t, r) {
			;(this._manifest.shards[t] = r.getMetadata()),
				(this._manifest.lastUpdated = Date.now()),
				await this._flushManifest()
		}
		getShard = async (t) => {
			let r = this._getShardId(t)
			return await this.getShardById(r)
		}
		getShardById = async (t) => await this._loadShard(t)
		getCheckpoints = async (t, r) => {
			let n = this._getShardId(t)
			return (await this._loadShard(n)).getCheckpoints(t, r) || []
		}
		getLatestCheckpoint = async (t) => {
			let r = this._getShardId(t)
			return (await this._loadShard(r)).getLatestCheckpoint(t)
		}
		addCheckpoint = async (t, r) => {
			let n = this._getShardId(t),
				i = await this._loadShard(n)
			i.addCheckpoint(t, r), await this._storage.saveShard(n, i.serialize()), await this._updateManifest(n, i)
		}
		updateCheckpoint = async (t, r) => {
			let n = this._getShardId(t),
				i = await this._loadShard(n)
			i.updateCheckpoint(t, r), await this._updateManifest(n, i)
		}
		removeCheckpoint = async (t, r) => {
			let n = this._getShardId(t),
				i = await this._loadShard(n),
				s = i.removeCheckpoint(t, r)
			return (
				s &&
					(i.checkpointCount === 0
						? (this._shardCache.delete(n),
							delete this._manifest.shards[n],
							await this._storage.deleteShard(n))
						: (await this._storage.saveShard(n, i.serialize()), await this._updateManifest(n, i))),
				s
			)
		}
		clearShard = async (t) => {
			let r = await this._loadShard(t)
			r.clear(), await this._storage.saveShard(t, r.serialize()), await this._updateManifest(t, r)
		}
		clear = async () => {
			for (let [t, r] of this._shardCache) r.clear(), await this._storage.saveShard(t, r.serialize())
			this._shardCache.clear(),
				(this._accessOrder.length = 0),
				(this._manifest = { version: 1, lastUpdated: Date.now(), shards: {} }),
				await this._storage.saveManifest(this._manifest)
		}
	}
var hs = []
for (let e = 0; e < 256; ++e) hs.push((e + 256).toString(16).slice(1))
function eY(e, t = 0) {
	return (
		hs[e[t + 0]] +
		hs[e[t + 1]] +
		hs[e[t + 2]] +
		hs[e[t + 3]] +
		"-" +
		hs[e[t + 4]] +
		hs[e[t + 5]] +
		"-" +
		hs[e[t + 6]] +
		hs[e[t + 7]] +
		"-" +
		hs[e[t + 8]] +
		hs[e[t + 9]] +
		"-" +
		hs[e[t + 10]] +
		hs[e[t + 11]] +
		hs[e[t + 12]] +
		hs[e[t + 13]] +
		hs[e[t + 14]] +
		hs[e[t + 15]]
	).toLowerCase()
}
var tY = require("crypto"),
	hI = new Uint8Array(256),
	fI = hI.length
function tP() {
	return fI > hI.length - 16 && ((0, tY.randomFillSync)(hI), (fI = 0)), hI.slice(fI, (fI += 16))
}
var rY = require("crypto"),
	rP = { randomUUID: rY.randomUUID }
function sMe(e, t, r) {
	if (rP.randomUUID && !t && !e) return rP.randomUUID()
	e = e || {}
	let n = e.random ?? e.rng?.() ?? tP()
	if (n.length < 16) throw new Error("Random bytes length must be >= 16")
	if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), t)) {
		if (((r = r || 0), r < 0 || r + 16 > t.length))
			throw new RangeError(`UUID byte range ${r}:${r + 15} is out of buffer bounds`)
		for (let i = 0; i < 16; ++i) t[r + i] = n[i]
		return t
	}
	return eY(n)
}
var nP = sMe
function pd() {
	return nP()
}
function Yl() {}
Yl.prototype = {
	diff: function (t, r) {
		var n,
			i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
			s = i.callback
		typeof i == "function" && ((s = i), (i = {}))
		var o = this
		function a(B) {
			return (
				(B = o.postProcess(B, i)),
				s
					? (setTimeout(function () {
							s(B)
						}, 0),
						!0)
					: B
			)
		}
		;(t = this.castInput(t, i)),
			(r = this.castInput(r, i)),
			(t = this.removeEmpty(this.tokenize(t, i))),
			(r = this.removeEmpty(this.tokenize(r, i)))
		var l = r.length,
			c = t.length,
			u = 1,
			f = l + c
		i.maxEditLength != null && (f = Math.min(f, i.maxEditLength))
		var p = (n = i.timeout) !== null && n !== void 0 ? n : 1 / 0,
			g = Date.now() + p,
			m = [{ oldPos: -1, lastComponent: void 0 }],
			y = this.extractCommon(m[0], r, t, 0, i)
		if (m[0].oldPos + 1 >= c && y + 1 >= l) return a(nY(o, m[0].lastComponent, r, t, o.useLongestToken))
		var C = -1 / 0,
			v = 1 / 0
		function b() {
			for (var B = Math.max(C, -u); B <= Math.min(v, u); B += 2) {
				var M = void 0,
					Q = m[B - 1],
					O = m[B + 1]
				Q && (m[B - 1] = void 0)
				var Y = !1
				if (O) {
					var j = O.oldPos - B
					Y = O && 0 <= j && j < l
				}
				var ne = Q && Q.oldPos + 1 < c
				if (!Y && !ne) {
					m[B] = void 0
					continue
				}
				if (
					(!ne || (Y && Q.oldPos < O.oldPos)
						? (M = o.addToPath(O, !0, !1, 0, i))
						: (M = o.addToPath(Q, !1, !0, 1, i)),
					(y = o.extractCommon(M, r, t, B, i)),
					M.oldPos + 1 >= c && y + 1 >= l)
				)
					return a(nY(o, M.lastComponent, r, t, o.useLongestToken))
				;(m[B] = M), M.oldPos + 1 >= c && (v = Math.min(v, B - 1)), y + 1 >= l && (C = Math.max(C, B + 1))
			}
			u++
		}
		if (s)
			(function B() {
				setTimeout(function () {
					if (u > f || Date.now() > g) return s()
					b() || B()
				}, 0)
			})()
		else
			for (; u <= f && Date.now() <= g; ) {
				var w = b()
				if (w) return w
			}
	},
	addToPath: function (t, r, n, i, s) {
		var o = t.lastComponent
		return o && !s.oneChangePerToken && o.added === r && o.removed === n
			? {
					oldPos: t.oldPos + i,
					lastComponent: {
						count: o.count + 1,
						added: r,
						removed: n,
						previousComponent: o.previousComponent,
					},
				}
			: {
					oldPos: t.oldPos + i,
					lastComponent: {
						count: 1,
						added: r,
						removed: n,
						previousComponent: o,
					},
				}
	},
	extractCommon: function (t, r, n, i, s) {
		for (
			var o = r.length, a = n.length, l = t.oldPos, c = l - i, u = 0;
			c + 1 < o && l + 1 < a && this.equals(n[l + 1], r[c + 1], s);

		)
			c++,
				l++,
				u++,
				s.oneChangePerToken &&
					(t.lastComponent = {
						count: 1,
						previousComponent: t.lastComponent,
						added: !1,
						removed: !1,
					})
		return (
			u &&
				!s.oneChangePerToken &&
				(t.lastComponent = {
					count: u,
					previousComponent: t.lastComponent,
					added: !1,
					removed: !1,
				}),
			(t.oldPos = l),
			c
		)
	},
	equals: function (t, r, n) {
		return n.comparator ? n.comparator(t, r) : t === r || (n.ignoreCase && t.toLowerCase() === r.toLowerCase())
	},
	removeEmpty: function (t) {
		for (var r = [], n = 0; n < t.length; n++) t[n] && r.push(t[n])
		return r
	},
	castInput: function (t) {
		return t
	},
	tokenize: function (t) {
		return Array.from(t)
	},
	join: function (t) {
		return t.join("")
	},
	postProcess: function (t) {
		return t
	},
}
function nY(e, t, r, n, i) {
	for (var s = [], o; t; ) s.push(t), (o = t.previousComponent), delete t.previousComponent, (t = o)
	s.reverse()
	for (var a = 0, l = s.length, c = 0, u = 0; a < l; a++) {
		var f = s[a]
		if (f.removed) (f.value = e.join(n.slice(u, u + f.count))), (u += f.count)
		else {
			if (!f.added && i) {
				var p = r.slice(c, c + f.count)
				;(p = p.map(function (g, m) {
					var y = n[u + m]
					return y.length > g.length ? y : g
				})),
					(f.value = e.join(p))
			} else f.value = e.join(r.slice(c, c + f.count))
			;(c += f.count), f.added || (u += f.count)
		}
	}
	return s
}
var Bvt = new Yl()
function iY(e, t) {
	var r
	for (r = 0; r < e.length && r < t.length; r++) if (e[r] != t[r]) return e.slice(0, r)
	return e.slice(0, r)
}
function sY(e, t) {
	var r
	if (!e || !t || e[e.length - 1] != t[t.length - 1]) return ""
	for (r = 0; r < e.length && r < t.length; r++)
		if (e[e.length - (r + 1)] != t[t.length - (r + 1)]) return e.slice(-r)
	return e.slice(-r)
}
function sP(e, t, r) {
	if (e.slice(0, t.length) != t)
		throw Error(
			"string "
				.concat(JSON.stringify(e), " doesn't start with prefix ")
				.concat(JSON.stringify(t), "; this is a bug"),
		)
	return r + e.slice(t.length)
}
function oP(e, t, r) {
	if (!t) return e + r
	if (e.slice(-t.length) != t)
		throw Error(
			"string "
				.concat(JSON.stringify(e), " doesn't end with suffix ")
				.concat(JSON.stringify(t), "; this is a bug"),
		)
	return e.slice(0, -t.length) + r
}
function Bv(e, t) {
	return sP(e, t, "")
}
function gI(e, t) {
	return oP(e, t, "")
}
function oY(e, t) {
	return t.slice(0, oMe(e, t))
}
function oMe(e, t) {
	var r = 0
	e.length > t.length && (r = e.length - t.length)
	var n = t.length
	e.length < t.length && (n = e.length)
	var i = Array(n),
		s = 0
	i[0] = 0
	for (var o = 1; o < n; o++) {
		for (t[o] == t[s] ? (i[o] = i[s]) : (i[o] = s); s > 0 && t[o] != t[s]; ) s = i[s]
		t[o] == t[s] && s++
	}
	s = 0
	for (var a = r; a < e.length; a++) {
		for (; s > 0 && e[a] != t[s]; ) s = i[s]
		e[a] == t[s] && s++
	}
	return s
}
var pI =
		"a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}",
	aMe = new RegExp("[".concat(pI, "]+|\\s+|[^").concat(pI, "]"), "ug"),
	yI = new Yl()
yI.equals = function (e, t, r) {
	return r.ignoreCase && ((e = e.toLowerCase()), (t = t.toLowerCase())), e.trim() === t.trim()
}
yI.tokenize = function (e) {
	var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
		r
	if (t.intlSegmenter) {
		if (t.intlSegmenter.resolvedOptions().granularity != "word")
			throw new Error('The segmenter passed must have a granularity of "word"')
		r = Array.from(t.intlSegmenter.segment(e), function (s) {
			return s.segment
		})
	} else r = e.match(aMe) || []
	var n = [],
		i = null
	return (
		r.forEach(function (s) {
			;/\s/.test(s)
				? i == null
					? n.push(s)
					: n.push(n.pop() + s)
				: /\s/.test(i)
					? n[n.length - 1] == i
						? n.push(n.pop() + s)
						: n.push(i + s)
					: n.push(s),
				(i = s)
		}),
		n
	)
}
yI.join = function (e) {
	return e
		.map(function (t, r) {
			return r == 0 ? t : t.replace(/^\s+/, "")
		})
		.join("")
}
yI.postProcess = function (e, t) {
	if (!e || t.oneChangePerToken) return e
	var r = null,
		n = null,
		i = null
	return (
		e.forEach(function (s) {
			s.added ? (n = s) : s.removed ? (i = s) : ((n || i) && aY(r, i, n, s), (r = s), (n = null), (i = null))
		}),
		(n || i) && aY(r, i, n, null),
		e
	)
}
function aY(e, t, r, n) {
	if (t && r) {
		var i = t.value.match(/^\s*/)[0],
			s = t.value.match(/\s*$/)[0],
			o = r.value.match(/^\s*/)[0],
			a = r.value.match(/\s*$/)[0]
		if (e) {
			var l = iY(i, o)
			;(e.value = oP(e.value, o, l)), (t.value = Bv(t.value, l)), (r.value = Bv(r.value, l))
		}
		if (n) {
			var c = sY(s, a)
			;(n.value = sP(n.value, a, c)), (t.value = gI(t.value, c)), (r.value = gI(r.value, c))
		}
	} else if (r) e && (r.value = r.value.replace(/^\s*/, "")), n && (n.value = n.value.replace(/^\s*/, ""))
	else if (e && n) {
		var u = n.value.match(/^\s*/)[0],
			f = t.value.match(/^\s*/)[0],
			p = t.value.match(/\s*$/)[0],
			g = iY(u, f)
		t.value = Bv(t.value, g)
		var m = sY(Bv(u, g), p)
		;(t.value = gI(t.value, m)),
			(n.value = sP(n.value, u, m)),
			(e.value = oP(e.value, u, u.slice(0, u.length - m.length)))
	} else if (n) {
		var y = n.value.match(/^\s*/)[0],
			C = t.value.match(/\s*$/)[0],
			v = oY(C, y)
		t.value = gI(t.value, v)
	} else if (e) {
		var b = e.value.match(/\s*$/)[0],
			w = t.value.match(/^\s*/)[0],
			B = oY(b, w)
		t.value = Bv(t.value, B)
	}
}
var lMe = new Yl()
lMe.tokenize = function (e) {
	var t = new RegExp("(\\r?\\n)|[".concat(pI, "]+|[^\\S\\n\\r]+|[^").concat(pI, "]"), "ug")
	return e.match(t) || []
}
var CI = new Yl()
CI.tokenize = function (e, t) {
	t.stripTrailingCr &&
		(e = e.replace(
			/\r\n/g,
			`
`,
		))
	var r = [],
		n = e.split(/(\n|\r\n)/)
	n[n.length - 1] || n.pop()
	for (var i = 0; i < n.length; i++) {
		var s = n[i]
		i % 2 && !t.newlineIsToken ? (r[r.length - 1] += s) : r.push(s)
	}
	return r
}
CI.equals = function (e, t, r) {
	return (
		r.ignoreWhitespace
			? ((!r.newlineIsToken ||
					!e.includes(`
`)) &&
					(e = e.trim()),
				(!r.newlineIsToken ||
					!t.includes(`
`)) &&
					(t = t.trim()))
			: r.ignoreNewlineAtEof &&
				!r.newlineIsToken &&
				(e.endsWith(`
`) && (e = e.slice(0, -1)),
				t.endsWith(`
`) && (t = t.slice(0, -1))),
		Yl.prototype.equals.call(this, e, t, r)
	)
}
function XA(e, t, r) {
	return CI.diff(e, t, r)
}
var cMe = new Yl()
cMe.tokenize = function (e) {
	return e.split(/(\S.+?[.!?])(?=\s+|$)/)
}
var uMe = new Yl()
uMe.tokenize = function (e) {
	return e.split(/([{}:;,]|\s+)/)
}
function lY(e, t) {
	var r = Object.keys(e)
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e)
		t &&
			(n = n.filter(function (i) {
				return Object.getOwnPropertyDescriptor(e, i).enumerable
			})),
			r.push.apply(r, n)
	}
	return r
}
function AI(e) {
	for (var t = 1; t < arguments.length; t++) {
		var r = arguments[t] != null ? arguments[t] : {}
		t % 2
			? lY(Object(r), !0).forEach(function (n) {
					hMe(e, n, r[n])
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
				: lY(Object(r)).forEach(function (n) {
						Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n))
					})
	}
	return e
}
function dMe(e, t) {
	if (typeof e != "object" || !e) return e
	var r = e[Symbol.toPrimitive]
	if (r !== void 0) {
		var n = r.call(e, t || "default")
		if (typeof n != "object") return n
		throw new TypeError("@@toPrimitive must return a primitive value.")
	}
	return (t === "string" ? String : Number)(e)
}
function fMe(e) {
	var t = dMe(e, "string")
	return typeof t == "symbol" ? t : t + ""
}
function aP(e) {
	"@babel/helpers - typeof"
	return (
		(aP =
			typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
				? function (t) {
						return typeof t
					}
				: function (t) {
						return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype
							? "symbol"
							: typeof t
					}),
		aP(e)
	)
}
function hMe(e, t, r) {
	return (
		(t = fMe(t)),
		t in e
			? Object.defineProperty(e, t, {
					value: r,
					enumerable: !0,
					configurable: !0,
					writable: !0,
				})
			: (e[t] = r),
		e
	)
}
function iP(e) {
	return gMe(e) || pMe(e) || AMe(e) || mMe()
}
function gMe(e) {
	if (Array.isArray(e)) return lP(e)
}
function pMe(e) {
	if ((typeof Symbol < "u" && e[Symbol.iterator] != null) || e["@@iterator"] != null) return Array.from(e)
}
function AMe(e, t) {
	if (e) {
		if (typeof e == "string") return lP(e, t)
		var r = Object.prototype.toString.call(e).slice(8, -1)
		if ((r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set"))
			return Array.from(e)
		if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return lP(e, t)
	}
}
function lP(e, t) {
	;(t == null || t > e.length) && (t = e.length)
	for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r]
	return n
}
function mMe() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var Dv = new Yl()
Dv.useLongestToken = !0
Dv.tokenize = CI.tokenize
Dv.castInput = function (e, t) {
	var r = t.undefinedReplacement,
		n = t.stringifyReplacer,
		i =
			n === void 0
				? function (s, o) {
						return typeof o > "u" ? r : o
					}
				: n
	return typeof e == "string" ? e : JSON.stringify(cP(e, null, null, i), i, "  ")
}
Dv.equals = function (e, t, r) {
	return Yl.prototype.equals.call(Dv, e.replace(/,([\r\n])/g, "$1"), t.replace(/,([\r\n])/g, "$1"), r)
}
function cP(e, t, r, n, i) {
	;(t = t || []), (r = r || []), n && (e = n(i, e))
	var s
	for (s = 0; s < t.length; s += 1) if (t[s] === e) return r[s]
	var o
	if (Object.prototype.toString.call(e) === "[object Array]") {
		for (t.push(e), o = new Array(e.length), r.push(o), s = 0; s < e.length; s += 1) o[s] = cP(e[s], t, r, n, i)
		return t.pop(), r.pop(), o
	}
	if ((e && e.toJSON && (e = e.toJSON()), aP(e) === "object" && e !== null)) {
		t.push(e), (o = {}), r.push(o)
		var a = [],
			l
		for (l in e) Object.prototype.hasOwnProperty.call(e, l) && a.push(l)
		for (a.sort(), s = 0; s < a.length; s += 1) (l = a[s]), (o[l] = cP(e[l], t, r, n, l))
		t.pop(), r.pop()
	} else o = e
	return o
}
var uP = new Yl()
uP.tokenize = function (e) {
	return e.slice()
}
uP.join = uP.removeEmpty = function (e) {
	return e
}
function mI(e, t, r, n, i, s, o) {
	if (
		(o || (o = {}),
		typeof o == "function" && (o = { callback: o }),
		typeof o.context > "u" && (o.context = 4),
		o.newlineIsToken)
	)
		throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions")
	if (o.callback) {
		var a = o,
			l = a.callback
		XA(
			r,
			n,
			AI(
				AI({}, o),
				{},
				{
					callback: function (f) {
						var p = c(f)
						l(p)
					},
				},
			),
		)
	} else return c(XA(r, n, o))
	function c(u) {
		if (!u) return
		u.push({ value: "", lines: [] })
		function f(Y) {
			return Y.map(function (j) {
				return " " + j
			})
		}
		for (
			var p = [],
				g = 0,
				m = 0,
				y = [],
				C = 1,
				v = 1,
				b = function () {
					var j = u[w],
						ne = j.lines || yMe(j.value)
					if (((j.lines = ne), j.added || j.removed)) {
						var q
						if (!g) {
							var me = u[w - 1]
							;(g = C),
								(m = v),
								me &&
									((y = o.context > 0 ? f(me.lines.slice(-o.context)) : []),
									(g -= y.length),
									(m -= y.length))
						}
						;(q = y).push.apply(
							q,
							iP(
								ne.map(function (se) {
									return (j.added ? "+" : "-") + se
								}),
							),
						),
							j.added ? (v += ne.length) : (C += ne.length)
					} else {
						if (g)
							if (ne.length <= o.context * 2 && w < u.length - 2) {
								var Qe
								;(Qe = y).push.apply(Qe, iP(f(ne)))
							} else {
								var N,
									re = Math.min(ne.length, o.context)
								;(N = y).push.apply(N, iP(f(ne.slice(0, re))))
								var K = {
									oldStart: g,
									oldLines: C - g + re,
									newStart: m,
									newLines: v - m + re,
									lines: y,
								}
								p.push(K), (g = 0), (m = 0), (y = [])
							}
						;(C += ne.length), (v += ne.length)
					}
				},
				w = 0;
			w < u.length;
			w++
		)
			b()
		for (var B = 0, M = p; B < M.length; B++)
			for (var Q = M[B], O = 0; O < Q.lines.length; O++)
				Q.lines[O].endsWith(`
`)
					? (Q.lines[O] = Q.lines[O].slice(0, -1))
					: (Q.lines.splice(O + 1, 0, "\\ No newline at end of file"), O++)
		return {
			oldFileName: e,
			newFileName: t,
			oldHeader: i,
			newHeader: s,
			hunks: p,
		}
	}
}
function dP(e) {
	if (Array.isArray(e))
		return e.map(dP).join(`
`)
	var t = []
	e.oldFileName == e.newFileName && t.push("Index: " + e.oldFileName),
		t.push("==================================================================="),
		t.push("--- " + e.oldFileName + (typeof e.oldHeader > "u" ? "" : "	" + e.oldHeader)),
		t.push("+++ " + e.newFileName + (typeof e.newHeader > "u" ? "" : "	" + e.newHeader))
	for (var r = 0; r < e.hunks.length; r++) {
		var n = e.hunks[r]
		n.oldLines === 0 && (n.oldStart -= 1),
			n.newLines === 0 && (n.newStart -= 1),
			t.push("@@ -" + n.oldStart + "," + n.oldLines + " +" + n.newStart + "," + n.newLines + " @@"),
			t.push.apply(t, n.lines)
	}
	return (
		t.join(`
`) +
		`
`
	)
}
function vI(e, t, r, n, i, s, o) {
	var a
	if ((typeof o == "function" && (o = { callback: o }), (a = o) !== null && a !== void 0 && a.callback)) {
		var c = o,
			u = c.callback
		mI(
			e,
			t,
			r,
			n,
			i,
			s,
			AI(
				AI({}, o),
				{},
				{
					callback: function (p) {
						p ? u(dP(p)) : u()
					},
				},
			),
		)
	} else {
		var l = mI(e, t, r, n, i, s, o)
		return l ? dP(l) : void 0
	}
}
function yMe(e) {
	var t = e.endsWith(`
`),
		r = e
			.split(
				`
`,
			)
			.map(function (n) {
				return (
					n +
					`
`
				)
			})
	return t ? r.pop() : r.push(r.pop().slice(0, -1)), r
}
var EI = class extends JA {
	_storage
	_getMemoriesAbsPath
	_onDocumentChange
	shardManager
	_shardFunction = (t) => `shard-${t.conversationId}`
	_currentConversationId
	_logger = dn("AggregateCheckpointManager")
	_agentEditListHasUpdatesCallbacks = new Set()
	constructor(t, r, n) {
		super(),
			(this._storage = t),
			(this._getMemoriesAbsPath = r),
			(this._onDocumentChange = n),
			(this.shardManager = new dI(this._storage, this._shardFunction)),
			this.addDisposable(
				this._onDocumentChange((i) => {
					this._handleDocumentChange(i)
				}),
			),
			this.addDisposable({
				dispose: () => {
					this._agentEditListHasUpdatesCallbacks.clear()
				},
			})
	}
	get currentConversationId() {
		return this._currentConversationId
	}
	setCurrentConversation(t) {
		this._currentConversationId = t
	}
	getAgentMemoriesAbsPath = () => this._getMemoriesAbsPath()
	onAgentEditListHasUpdates = (t) => (
		this._agentEditListHasUpdatesCallbacks.add(t),
		{
			dispose: () => {
				this._agentEditListHasUpdatesCallbacks.delete(t)
			},
		}
	)
	_notifyAgentEditListHasUpdates = () => {
		this._agentEditListHasUpdatesCallbacks.forEach((t) => t())
	}
	_getAllTrackedFiles = async (t) => {
		await this.shardManager.initialize()
		let r = this._shardFunction({ conversationId: t })
		return (await this.shardManager.getShardById(r)).getAllTrackedFilePaths(t)
	}
	_checkpointFileState = async (t, r) => {
		let n = (await Do().readFile(r.absPath)).contents
		if (n === void 0) return
		let i = {
				sourceToolCallRequestId: pd(),
				timestamp: Date.now(),
				document: new hi(r, n, n, { logger: this._logger }),
				conversationId: t,
			},
			s = { conversationId: t, path: r }
		return (
			await this.shardManager.addCheckpoint(s, i),
			this._notifyAgentEditListHasUpdates(),
			i.sourceToolCallRequestId
		)
	}
	_trackFile = async (t, r) => {
		await this.shardManager.initialize()
		let n = { conversationId: t, path: r }
		if ((await this.shardManager.getCheckpoints(n)).length > 0) {
			this._logger.debug(`File already tracked: ${r.absPath}`)
			return
		}
		this._logger.debug(`Tracking file: ${r.absPath}`), await this._checkpointFileState(t, r)
	}
	storeCurrentFileStateAsCheckpoint = async (t, r) => (
		await this.shardManager.initialize(), await this._checkpointFileState(t, r)
	)
	addCheckpoint = async (t, r) => {
		await this.shardManager.initialize(),
			await this._trackFile(t.conversationId, r.document.filePath),
			await this.shardManager.addCheckpoint(t, r),
			this._notifyAgentEditListHasUpdates(),
			await Do().writeFile(r.document.filePath, r.document.modifiedCode)
	}
	_getFileStateAtTimestamp = async (t, r, n) => {
		let i = { conversationId: t, path: r },
			o = (await this.shardManager.getCheckpoints(i, { maxTimestamp: n })).at(-1)
		return o
			? o.document.modifiedCode
			: (await this.shardManager.getCheckpoints(i, { minTimestamp: n })).at(0)?.document.originalCode
	}
	_handleDocumentChange = async (t) => {
		let r = Je.from(t.document.qualifiedPathName)
		if (r === void 0 || this._currentConversationId === void 0) return
		let n = t.document.getText?.() ?? ""
		await this.updateLatestCheckpoint(r, n)
	}
	updateLatestCheckpoint = async (t, r, n) => {
		if (this._currentConversationId === void 0) return
		let i = { conversationId: this._currentConversationId, path: t },
			o = (await this.shardManager.getCheckpoints(i)).at(-1)
		if (o === void 0) return
		let a = { ...o, document: new hi(t, o.document.originalCode, r, {}) }
		await this.shardManager.updateCheckpoint(i, a),
			this._notifyAgentEditListHasUpdates(),
			(n?.saveToWorkspace ?? !1) && (await Do().writeFile(t, r))
	}
	getAggregateCheckpointForFile = async (t, r) => {
		await this.shardManager.initialize()
		let n = this._currentConversationId
		if (n === void 0)
			return {
				fromTimestamp: 0,
				toTimestamp: 1 / 0,
				conversationId: "",
				files: [],
			}
		let i = r.minTimestamp ?? 0,
			s = r.maxTimestamp ?? 1 / 0,
			o = await this._getFileStateAtTimestamp(n, t, i),
			a = await this._getFileStateAtTimestamp(n, t, s),
			l = new hi(t, o ?? "", a ?? "", {})
		return {
			fromTimestamp: i,
			toTimestamp: s,
			conversationId: n,
			files: [{ changesSummary: fP(l), changeDocument: l }],
		}
	}
	getCheckpointByRequestId = async (t) => {
		await this.shardManager.initialize()
		let r = this._currentConversationId
		if (r === void 0) return
		let n = this._shardFunction({ conversationId: r }),
			s = (await this.shardManager.getShardById(n)).getCheckpointBySourceId(t)
		if (s !== void 0)
			return {
				fromTimestamp: s.timestamp,
				toTimestamp: s.timestamp,
				conversationId: r,
				files: [{ changesSummary: fP(s.document), changeDocument: s.document }],
			}
	}
	getAggregateCheckpoint = async (t) => {
		await this.shardManager.initialize()
		let r = t.minTimestamp ?? 0,
			n = t.maxTimestamp ?? 1 / 0,
			i = this._currentConversationId
		if (i === void 0)
			return {
				fromTimestamp: 0,
				toTimestamp: 1 / 0,
				conversationId: "",
				files: [],
			}
		let s = await this._getAllTrackedFiles(i),
			o = await Promise.all(
				s.map(async (a) => {
					let l = await this._getFileStateAtTimestamp(i, a, r),
						c = await this._getFileStateAtTimestamp(i, a, n)
					return new hi(a, l ?? "", c ?? "", {})
				}),
			)
		return {
			fromTimestamp: r,
			toTimestamp: n,
			conversationId: i,
			files: o.map((a) => ({ changesSummary: fP(a), changeDocument: a })),
		}
	}
	clearConversationCheckpoints = async (t) => {
		await this.shardManager.initialize(),
			await this.shardManager.clearShard(this._shardFunction({ conversationId: t }))
	}
	revertDocumentToTimestamp = async (t, r) => {
		await this.shardManager.initialize()
		let n = this._currentConversationId
		if (n === void 0) return
		let i = await this._getFileStateAtTimestamp(n, t, r)
		if (i === void 0) return
		let s = await this._getFileStateAtTimestamp(n, t, Number.MAX_SAFE_INTEGER)
		await this.addCheckpoint(
			{ conversationId: n, path: t },
			{
				sourceToolCallRequestId: pd(),
				timestamp: Date.now(),
				document: new hi(t, s ?? "", i, {}),
				conversationId: n,
			},
		)
	}
	revertToTimestamp = async (t) => {
		if ((await this.shardManager.initialize(), this._currentConversationId === void 0)) return
		let n = await this.getAggregateCheckpoint({
			minTimestamp: t,
			maxTimestamp: void 0,
		})
		await Promise.all(
			n.files.map(async (i) => {
				await this.revertDocumentToTimestamp(i.changeDocument.filePath, t)
			}),
		)
	}
}
function fP(e) {
	let t = XA(e.originalCode, e.modifiedCode),
		r = t.filter((i) => i.added).reduce((i, s) => i + (s.count ?? 0), 0),
		n = t.filter((i) => i.removed).reduce((i, s) => i + (s.count ?? 0), 0)
	return { totalAddedLines: r, totalRemovedLines: n, changes: t }
}
var Tv = class {
		static _instance = void 0
		static setAPIClient(t) {
			if (this._instance !== void 0) {
				dn("APICLient").warn(
					"Attempting to initialize API clientwhen one is already configured. Keeping existing client workspaces.",
				)
				return
			}
			this._instance = t
		}
		static getAPIClient() {
			if (this._instance === void 0) throw new Error("API Client not set")
			return this._instance
		}
		static reset() {
			this._instance = void 0
		}
	},
	cY = (e) => Tv.setAPIClient(e),
	Rf = () => Tv.getAPIClient(),
	uY = () => Tv.reset()
var Rv = class {
		static _instance = void 0
		static setWebviewMessagingClient(t) {
			if (this._instance !== void 0) {
				dn("WebviewMessages").warn(
					"Attempting to initialize webview messages when one is already configured. Keeping existing webview message client.",
				)
				return
			}
			this._instance = t
		}
		static getWebviewMessagingClient() {
			if (this._instance === void 0) throw new Error("Webview messaging client not set")
			return this._instance
		}
		static reset() {
			this._instance = void 0
		}
	},
	dY = (e) => Rv.setWebviewMessagingClient(e),
	CMe = () => Rv.getWebviewMessagingClient(),
	fY = () => Rv.reset()
function hY(e, t) {
	CMe().onMessage(e, t)
}
var He
;(function (e) {
	;(e[(e.ok = 0)] = "ok"),
		(e[(e.cancelled = 1)] = "cancelled"),
		(e[(e.unknown = 2)] = "unknown"),
		(e[(e.unavailable = 3)] = "unavailable"),
		(e[(e.unimplemented = 4)] = "unimplemented"),
		(e[(e.invalidArgument = 5)] = "invalidArgument"),
		(e[(e.resourceExhausted = 6)] = "resourceExhausted"),
		(e[(e.unauthenticated = 7)] = "unauthenticated"),
		(e[(e.permissionDenied = 8)] = "permissionDenied"),
		(e[(e.deadlineExceeded = 9)] = "deadlineExceeded"),
		(e[(e.augmentTooLarge = 10)] = "augmentTooLarge")
})(He || (He = {}))
var kr = class e extends Error {
	status
	constructor(t, r) {
		super(r), (this.status = t)
	}
	static transientIssue(t) {
		return new e(He.unavailable, t)
	}
	static fromResponse(t) {
		return new e(vMe(t.status), `HTTP error: ${t.status} ${t.statusText}`)
	}
	static isAPIErrorWithStatus(t, r) {
		return t instanceof e ? t.status === r : !1
	}
	static isRetriableAPIError(t) {
		return t instanceof e ? EMe.has(t.status) : !1
	}
}
function vMe(e) {
	switch (e) {
		case 200:
			return He.ok
		case 400:
			return He.invalidArgument
		case 401:
			return He.unauthenticated
		case 403:
			return He.permissionDenied
		case 404:
			return He.unimplemented
		case 413:
			return He.augmentTooLarge
		case 429:
			return He.resourceExhausted
		case 499:
			return He.cancelled
		case 504:
			return He.deadlineExceeded
	}
	return e >= 500 && e < 600 ? He.unavailable : He.unknown
}
var EMe = new Set([He.unavailable, He.cancelled])
var Gc = class {
	_maxItems
	_insertCount = 0
	_emptySlots
	_items
	constructor(t) {
		;(this._maxItems = t), (this._items = new Array(t)), (this._emptySlots = t)
	}
	get empty() {
		return this.length === 0
	}
	get length() {
		return this._maxItems - this._emptySlots
	}
	addItem(t) {
		;(this._items[this._insertCount % this._maxItems] = t),
			(this._emptySlots = Math.max(this._emptySlots - 1, 0)),
			this._insertCount++
	}
	shiftLeft(t) {
		this._emptySlots = Math.min(this._emptySlots + t, this._maxItems)
	}
	shiftRight(t) {
		;(this._insertCount -= Math.min(t, this.length)),
			(this._emptySlots = Math.min(this._emptySlots + t, this._maxItems))
	}
	at(t) {
		if (t < 0) return t < -this.length ? void 0 : this._items[(this._insertCount + t) % this._maxItems]
		if (!(t >= this.length)) return this._items[(this._insertCount + this._emptySlots + t) % this._maxItems]
	}
	_normalizeSliceIdx(t) {
		return t >= 0 ? Math.min(t, this.length) : Math.max(this.length + t, 0)
	}
	_translateIdx(t) {
		return (this._insertCount + this._emptySlots + t) % this._maxItems
	}
	slice(t, r) {
		let n = this._normalizeSliceIdx(t ?? 0),
			i = this._normalizeSliceIdx(r ?? this.length)
		if (n > i) return []
		let s = i - n,
			o = this._translateIdx(n)
		return o + s <= this._maxItems
			? this._items.slice(o, o + s)
			: this._items.slice(o).concat(this._items.slice(0, (o + s) % this._maxItems))
	}
	*[Symbol.iterator]() {
		for (let t = 0; t < this.length; t++) yield this.at(t)
	}
	clear() {
		this._emptySlots = this._maxItems
	}
}
var bMe = { initialMS: 100, mult: 2, maxMS: 3e4 }
function Kl(e) {
	return e === 0
		? Promise.resolve()
		: new Promise((t) => {
				setTimeout(t, e)
			})
}
/**
 * Retry a function until it succeeds or the max time has been reached.
 *
 * When an error is thrown, the function will be retried after a certain amount of
 * time. The amount of time to wait is determined by the
 * `initialMS` and `mult` properties of the `options` object. For example, if
 * `initialMS` is 100 and `mult` is 2, the first retry will happen after 100ms,
 * the second after 200ms, the third after 400ms, etc.
 *
 * If the function succeeds, the returned promise will resolve with the result of
 * the successful call. If the max time is reached, the returned promise will
 * reject with the last error that occurred.
 *
 * @param {function} fn - the function to retry
 * @param {object} logger - the logger to use for logging info messages
 * @param {object} options - the options for retrying
 * @param {number} [options.initialMS=100] - the initial amount of time to wait
 * @param {number} [options.mult=2] - the multiplier for the amount of time to wait
 * @param {number} [options.maxMS=30000] - the max amount of time to wait
 */
async function xi(e, t, r = bMe) {
	let n = 0,
		i = r.maxTotalMs !== void 0 ? Date.now() : void 0,
		s = r.canRetry ? r.canRetry : (o) => kr.isRetriableAPIError(o)
	for (let o = 0; ; o++)
		try {
			let a = await e()
			return o > 0 && t.info(`Operation succeeded after ${o} transient failures`), a
		} catch (a) {
			if (!s(a)) throw a
			let l = o + 1
			if (
				(r.maxTries !== void 0 && l >= r.maxTries) ||
				(n === 0 ? (n = r.initialMS) : (n = Math.min(n * r.mult, r.maxMS)),
				t.info(`Operation failed with error ${a}, retrying in ${n} ms; retries = ${o}`),
				r.maxTotalMs !== void 0 && i !== void 0 && Date.now() - i + n > r.maxTotalMs)
			)
				throw a
			await Kl(n)
		}
}
var Zn = class {
	_uploadMsec
	_uploadBatchSize
	_logger
	_store
	_uploadIntervalId = void 0
	_currentUploadPromise
	constructor(t, r, n, i) {
		;(this._uploadMsec = n), (this._uploadBatchSize = i), (this._store = new Gc(r)), (this._logger = dn(t))
	}
	report(t) {
		this._store.addItem(t)
	}
	get uploadEnabled() {
		return this._uploadIntervalId !== void 0
	}
	enableUpload() {
		this.uploadEnabled ||
			(this._uploadIntervalId = setInterval(() => {
				this._currentUploadPromise === void 0 &&
					(async () => {
						try {
							;(this._currentUploadPromise = this._doUpload()), await this._currentUploadPromise
						} finally {
							this._currentUploadPromise = void 0
						}
					})()
			}, this._uploadMsec))
	}
	/**
	 * Perform the actual upload of metrics.
	 *
	 * This method is called by the interval that is set up when `enableUpload` is
	 * called. It will take all the metrics in the store and split them into
	 * batches of the specified size. Each batch is then uploaded to the server
	 * using the `performUpload` method. If any of the uploads fail, the method will
	 * retry the upload up to the maximum number of times specified by the
	 * `maxTries` option.
	 *
	 * @private
	 */
	async _doUpload() {
		if (this._store.length === 0) return
		let t = this._store.slice()
		this._store.clear()
		for (let r = 0; r < t.length; r += this._uploadBatchSize) {
			let n = t.slice(r, r + this._uploadBatchSize)
			await xi(async () => {
				if (this.uploadEnabled)
					try {
						return this._logger.debug(`Uploading ${n.length} metric(s)`), await this.performUpload(n)
					} catch (i) {
						throw (
							(this._logger.error(`Error uploading metrics: ${i} ${i instanceof Error ? i.stack : ""}`),
							i)
						)
					}
			}, this._logger)
		}
	}
	disableUpload() {
		clearInterval(this._uploadIntervalId), (this._uploadIntervalId = void 0)
	}
	dispose() {
		this.disableUpload()
	}
}
function kn(e) {
	let t = Math.floor(e / 1e3),
		r = (e % 1e3) * 1e6
	return [t, r]
}
var bI = class e extends Zn {
	featureFlagManager
	static defaultMaxRecords = 1e4
	static defaultBatchSize = 1e3
	static defaultUploadMsec = 1e4
	constructor(t, r, n, i) {
		super("AgentSessionEventReporter", r ?? e.defaultMaxRecords, n ?? e.defaultUploadMsec, i ?? e.defaultBatchSize),
			(this.featureFlagManager = t)
	}
	formatTracingData(t) {
		return {
			flags: t.flags,
			nums: t.nums,
			string_stats: t.string_stats,
			request_ids: t.request_ids,
		}
	}
	reportEvent(t) {
		let [r, n] = kn(Date.now()),
			i,
			s = this.featureFlagManager.flags.memoriesParams.enable_memories_tracing
		if (
			(t.eventData?.agentReversionData && (i = { agent_reversion_data: {} }),
			t.eventData?.agentInterruptionData &&
				(i = {
					agent_interruption_data: {
						request_id: t.eventData.agentInterruptionData.requestId,
						curr_conversation_length: t.eventData.agentInterruptionData.currConversationLength,
					},
				}),
			t.eventData?.rememberToolCallData)
		) {
			if (!s) return
			i = {
				remember_tool_call_data: {
					caller: t.eventData.rememberToolCallData.caller,
					is_complex_new_memory: t.eventData.rememberToolCallData.is_complex_new_memory,
					tracing_data: this.formatTracingData(t.eventData.rememberToolCallData.tracingData),
				},
			}
		}
		if (t.eventData?.initialOrientationData) {
			if (!s) return
			i = {
				initial_orientation_data: {
					caller: t.eventData.initialOrientationData.caller,
					tracing_data: this.formatTracingData(t.eventData.initialOrientationData.tracingData),
				},
			}
		}
		if (t.eventData?.classifyAndDistillData) {
			if (!s) return
			i = {
				classify_and_distill_data: {
					tracing_data: this.formatTracingData(t.eventData.classifyAndDistillData.tracingData),
				},
			}
		}
		if (t.eventData?.flushMemoriesData) {
			if (!s) return
			i = {
				flush_memories_data: {
					tracing_data: this.formatTracingData(t.eventData.flushMemoriesData.tracingData),
				},
			}
		}
		t.eventData?.memoriesFileOpenData &&
			(i = {
				memories_file_open_data: {
					memories_path_undefined: t.eventData.memoriesFileOpenData.memoriesPathUndefined,
				},
			}),
			this.report({
				event_time_sec: r,
				event_time_nsec: n,
				event_name: t.eventName,
				conversation_id: t.conversationId,
				event_data: i,
			})
	}
	performUpload(t) {
		return Rf().logAgentSessionEvent(t)
	}
}
var xI = class e extends Zn {
	static defaultMaxRecords = 1e4
	static defaultBatchSize = 1e3
	static defaultUploadMsec = 1e4
	constructor(t, r, n) {
		super(
			"ToolUseRequestEventReporter",
			t ?? e.defaultMaxRecords,
			r ?? e.defaultUploadMsec,
			n ?? e.defaultBatchSize,
		)
	}
	reportEvent(t, r, n, i, s, o, a, l, c, u) {
		let [f, p] = kn(Date.now())
		this.report({
			requestId: t,
			toolName: r,
			toolUseId: n,
			toolInput: i,
			toolOutputIsError: s,
			toolRunDurationMs: o,
			isMcpTool: a,
			conversationId: l,
			chatHistoryLength: c,
			eventTimeSec: f,
			eventTimeNsec: p,
			toolRequestId: u,
		})
	}
	performUpload(t) {
		return Rf().logToolUseRequestEvent(t)
	}
}
var $c
;(function (e) {
	;(e[(e.TEXT = 0)] = "TEXT"),
		(e[(e.TOOL_RESULT = 1)] = "TOOL_RESULT"),
		(e[(e.IMAGE = 2)] = "IMAGE"),
		(e[(e.IMAGE_ID = 3)] = "IMAGE_ID"),
		(e[(e.IDE_STATE = 4)] = "IDE_STATE")
})($c || ($c = {}))
var _I
;(function (e) {
	;(e[(e.IMAGE_FORMAT_UNSPECIFIED = 0)] = "IMAGE_FORMAT_UNSPECIFIED"),
		(e[(e.PNG = 1)] = "PNG"),
		(e[(e.JPEG = 2)] = "JPEG")
})(_I || (_I = {}))
var Jl
;(function (e) {
	;(e[(e.RAW_RESPONSE = 0)] = "RAW_RESPONSE"),
		(e[(e.SUGGESTED_QUESTIONS = 1)] = "SUGGESTED_QUESTIONS"),
		(e[(e.MAIN_TEXT_FINISHED = 2)] = "MAIN_TEXT_FINISHED"),
		(e[(e.TOOL_USE = 5)] = "TOOL_USE"),
		(e[(e.AGENT_MEMORY = 6)] = "AGENT_MEMORY")
})(Jl || (Jl = {}))
var Mn
;(function (e) {
	;(e.chat = "CHAT"), (e.agent = "AGENT")
})(Mn || (Mn = {}))
var vr
;(function (e) {
	e.assertEqual = (i) => i
	function t(i) {}
	e.assertIs = t
	function r(i) {
		throw new Error()
	}
	;(e.assertNever = r),
		(e.arrayToEnum = (i) => {
			let s = {}
			for (let o of i) s[o] = o
			return s
		}),
		(e.getValidEnumValues = (i) => {
			let s = e.objectKeys(i).filter((a) => typeof i[i[a]] != "number"),
				o = {}
			for (let a of s) o[a] = i[a]
			return e.objectValues(o)
		}),
		(e.objectValues = (i) =>
			e.objectKeys(i).map(function (s) {
				return i[s]
			})),
		(e.objectKeys =
			typeof Object.keys == "function"
				? (i) => Object.keys(i)
				: (i) => {
						let s = []
						for (let o in i) Object.prototype.hasOwnProperty.call(i, o) && s.push(o)
						return s
					}),
		(e.find = (i, s) => {
			for (let o of i) if (s(o)) return o
		}),
		(e.isInteger =
			typeof Number.isInteger == "function"
				? (i) => Number.isInteger(i)
				: (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i)
	function n(i, s = " | ") {
		return i.map((o) => (typeof o == "string" ? `'${o}'` : o)).join(s)
	}
	;(e.joinValues = n), (e.jsonStringifyReplacer = (i, s) => (typeof s == "bigint" ? s.toString() : s))
})(vr || (vr = {}))
var gP
;(function (e) {
	e.mergeShapes = (t, r) => ({ ...t, ...r })
})(gP || (gP = {}))
var Pe = vr.arrayToEnum([
		"string",
		"nan",
		"number",
		"integer",
		"float",
		"boolean",
		"date",
		"bigint",
		"symbol",
		"function",
		"undefined",
		"null",
		"array",
		"object",
		"unknown",
		"promise",
		"void",
		"never",
		"map",
		"set",
	]),
	md = (e) => {
		switch (typeof e) {
			case "undefined":
				return Pe.undefined
			case "string":
				return Pe.string
			case "number":
				return isNaN(e) ? Pe.nan : Pe.number
			case "boolean":
				return Pe.boolean
			case "function":
				return Pe.function
			case "bigint":
				return Pe.bigint
			case "symbol":
				return Pe.symbol
			case "object":
				return Array.isArray(e)
					? Pe.array
					: e === null
						? Pe.null
						: e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function"
							? Pe.promise
							: typeof Map < "u" && e instanceof Map
								? Pe.map
								: typeof Set < "u" && e instanceof Set
									? Pe.set
									: typeof Date < "u" && e instanceof Date
										? Pe.date
										: Pe.object
			default:
				return Pe.unknown
		}
	},
	ve = vr.arrayToEnum([
		"invalid_type",
		"invalid_literal",
		"custom",
		"invalid_union",
		"invalid_union_discriminator",
		"invalid_enum_value",
		"unrecognized_keys",
		"invalid_arguments",
		"invalid_return_type",
		"invalid_date",
		"invalid_string",
		"too_small",
		"too_big",
		"invalid_intersection_types",
		"not_multiple_of",
		"not_finite",
	]),
	xMe = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"),
	ua = class e extends Error {
		get errors() {
			return this.issues
		}
		constructor(t) {
			super(),
				(this.issues = []),
				(this.addIssue = (n) => {
					this.issues = [...this.issues, n]
				}),
				(this.addIssues = (n = []) => {
					this.issues = [...this.issues, ...n]
				})
			let r = new.target.prototype
			Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : (this.__proto__ = r),
				(this.name = "ZodError"),
				(this.issues = t)
		}
		format(t) {
			let r =
					t ||
					function (s) {
						return s.message
					},
				n = { _errors: [] },
				i = (s) => {
					for (let o of s.issues)
						if (o.code === "invalid_union") o.unionErrors.map(i)
						else if (o.code === "invalid_return_type") i(o.returnTypeError)
						else if (o.code === "invalid_arguments") i(o.argumentsError)
						else if (o.path.length === 0) n._errors.push(r(o))
						else {
							let a = n,
								l = 0
							for (; l < o.path.length; ) {
								let c = o.path[l]
								l === o.path.length - 1
									? ((a[c] = a[c] || { _errors: [] }), a[c]._errors.push(r(o)))
									: (a[c] = a[c] || { _errors: [] }),
									(a = a[c]),
									l++
							}
						}
				}
			return i(this), n
		}
		static assert(t) {
			if (!(t instanceof e)) throw new Error(`Not a ZodError: ${t}`)
		}
		toString() {
			return this.message
		}
		get message() {
			return JSON.stringify(this.issues, vr.jsonStringifyReplacer, 2)
		}
		get isEmpty() {
			return this.issues.length === 0
		}
		flatten(t = (r) => r.message) {
			let r = {},
				n = []
			for (let i of this.issues)
				i.path.length > 0 ? ((r[i.path[0]] = r[i.path[0]] || []), r[i.path[0]].push(t(i))) : n.push(t(i))
			return { formErrors: n, fieldErrors: r }
		}
		get formErrors() {
			return this.flatten()
		}
	}
ua.create = (e) => new ua(e)
var rm = (e, t) => {
		let r
		switch (e.code) {
			case ve.invalid_type:
				e.received === Pe.undefined ? (r = "Required") : (r = `Expected ${e.expected}, received ${e.received}`)
				break
			case ve.invalid_literal:
				r = `Invalid literal value, expected ${JSON.stringify(e.expected, vr.jsonStringifyReplacer)}`
				break
			case ve.unrecognized_keys:
				r = `Unrecognized key(s) in object: ${vr.joinValues(e.keys, ", ")}`
				break
			case ve.invalid_union:
				r = "Invalid input"
				break
			case ve.invalid_union_discriminator:
				r = `Invalid discriminator value. Expected ${vr.joinValues(e.options)}`
				break
			case ve.invalid_enum_value:
				r = `Invalid enum value. Expected ${vr.joinValues(e.options)}, received '${e.received}'`
				break
			case ve.invalid_arguments:
				r = "Invalid function arguments"
				break
			case ve.invalid_return_type:
				r = "Invalid function return type"
				break
			case ve.invalid_date:
				r = "Invalid date"
				break
			case ve.invalid_string:
				typeof e.validation == "object"
					? "includes" in e.validation
						? ((r = `Invalid input: must include "${e.validation.includes}"`),
							typeof e.validation.position == "number" &&
								(r = `${r} at one or more positions greater than or equal to ${e.validation.position}`))
						: "startsWith" in e.validation
							? (r = `Invalid input: must start with "${e.validation.startsWith}"`)
							: "endsWith" in e.validation
								? (r = `Invalid input: must end with "${e.validation.endsWith}"`)
								: vr.assertNever(e.validation)
					: e.validation !== "regex"
						? (r = `Invalid ${e.validation}`)
						: (r = "Invalid")
				break
			case ve.too_small:
				e.type === "array"
					? (r = `Array must contain ${
							e.exact ? "exactly" : e.inclusive ? "at least" : "more than"
						} ${e.minimum} element(s)`)
					: e.type === "string"
						? (r = `String must contain ${
								e.exact ? "exactly" : e.inclusive ? "at least" : "over"
							} ${e.minimum} character(s)`)
						: e.type === "number"
							? (r = `Number must be ${
									e.exact
										? "exactly equal to "
										: e.inclusive
											? "greater than or equal to "
											: "greater than "
								}${e.minimum}`)
							: e.type === "date"
								? (r = `Date must be ${
										e.exact
											? "exactly equal to "
											: e.inclusive
												? "greater than or equal to "
												: "greater than "
									}${new Date(Number(e.minimum))}`)
								: (r = "Invalid input")
				break
			case ve.too_big:
				e.type === "array"
					? (r = `Array must contain ${
							e.exact ? "exactly" : e.inclusive ? "at most" : "less than"
						} ${e.maximum} element(s)`)
					: e.type === "string"
						? (r = `String must contain ${
								e.exact ? "exactly" : e.inclusive ? "at most" : "under"
							} ${e.maximum} character(s)`)
						: e.type === "number"
							? (r = `Number must be ${
									e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"
								} ${e.maximum}`)
							: e.type === "bigint"
								? (r = `BigInt must be ${
										e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"
									} ${e.maximum}`)
								: e.type === "date"
									? (r = `Date must be ${
											e.exact
												? "exactly"
												: e.inclusive
													? "smaller than or equal to"
													: "smaller than"
										} ${new Date(Number(e.maximum))}`)
									: (r = "Invalid input")
				break
			case ve.custom:
				r = "Invalid input"
				break
			case ve.invalid_intersection_types:
				r = "Intersection results could not be merged"
				break
			case ve.not_multiple_of:
				r = `Number must be a multiple of ${e.multipleOf}`
				break
			case ve.not_finite:
				r = "Number must be finite"
				break
			default:
				;(r = t.defaultError), vr.assertNever(e)
		}
		return { message: r }
	},
	AY = rm
function _Me(e) {
	AY = e
}
function wI() {
	return AY
}
var II = (e) => {
		let { data: t, path: r, errorMaps: n, issueData: i } = e,
			s = [...r, ...(i.path || [])],
			o = { ...i, path: s }
		if (i.message !== void 0) return { ...i, path: s, message: i.message }
		let a = "",
			l = n
				.filter((c) => !!c)
				.slice()
				.reverse()
		for (let c of l) a = c(o, { data: t, defaultError: a }).message
		return { ...i, path: s, message: a }
	},
	wMe = []
function Re(e, t) {
	let r = wI(),
		n = II({
			issueData: t,
			data: e.data,
			path: e.path,
			errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, r, r === rm ? void 0 : rm].filter((i) => !!i),
		})
	e.common.issues.push(n)
}
var Ms = class e {
		constructor() {
			this.value = "valid"
		}
		dirty() {
			this.value === "valid" && (this.value = "dirty")
		}
		abort() {
			this.value !== "aborted" && (this.value = "aborted")
		}
		static mergeArray(t, r) {
			let n = []
			for (let i of r) {
				if (i.status === "aborted") return vt
				i.status === "dirty" && t.dirty(), n.push(i.value)
			}
			return { status: t.value, value: n }
		}
		static async mergeObjectAsync(t, r) {
			let n = []
			for (let i of r) {
				let s = await i.key,
					o = await i.value
				n.push({ key: s, value: o })
			}
			return e.mergeObjectSync(t, n)
		}
		static mergeObjectSync(t, r) {
			let n = {}
			for (let i of r) {
				let { key: s, value: o } = i
				if (s.status === "aborted" || o.status === "aborted") return vt
				s.status === "dirty" && t.dirty(),
					o.status === "dirty" && t.dirty(),
					s.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (n[s.value] = o.value)
			}
			return { status: t.value, value: n }
		}
	},
	vt = Object.freeze({ status: "aborted" }),
	tm = (e) => ({ status: "dirty", value: e }),
	ro = (e) => ({ status: "valid", value: e }),
	pP = (e) => e.status === "aborted",
	AP = (e) => e.status === "dirty",
	wg = (e) => e.status === "valid",
	Fv = (e) => typeof Promise < "u" && e instanceof Promise
function SI(e, t, r, n) {
	if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter")
	if (typeof t == "function" ? e !== t || !n : !t.has(e))
		throw new TypeError("Cannot read private member from an object whose class did not declare it")
	return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e)
}
function mY(e, t, r, n, i) {
	if (n === "m") throw new TypeError("Private method is not writable")
	if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter")
	if (typeof t == "function" ? e !== t || !i : !t.has(e))
		throw new TypeError("Cannot write private member to an object whose class did not declare it")
	return n === "a" ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
}
var $e
;(function (e) {
	;(e.errToObj = (t) => (typeof t == "string" ? { message: t } : t || {})),
		(e.toString = (t) => (typeof t == "string" ? t : t?.message))
})($e || ($e = {}))
var kv,
	Mv,
	za = class {
		constructor(t, r, n, i) {
			;(this._cachedPath = []), (this.parent = t), (this.data = r), (this._path = n), (this._key = i)
		}
		get path() {
			return (
				this._cachedPath.length ||
					(this._key instanceof Array
						? this._cachedPath.push(...this._path, ...this._key)
						: this._cachedPath.push(...this._path, this._key)),
				this._cachedPath
			)
		}
	},
	gY = (e, t) => {
		if (wg(t)) return { success: !0, data: t.value }
		if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.")
		return {
			success: !1,
			get error() {
				if (this._error) return this._error
				let r = new ua(e.common.issues)
				return (this._error = r), this._error
			},
		}
	}
function Nt(e) {
	if (!e) return {}
	let { errorMap: t, invalid_type_error: r, required_error: n, description: i } = e
	if (t && (r || n))
		throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`)
	return t
		? { errorMap: t, description: i }
		: {
				errorMap: (o, a) => {
					var l, c
					let { message: u } = e
					return o.code === "invalid_enum_value"
						? { message: u ?? a.defaultError }
						: typeof a.data > "u"
							? {
									message: (l = u ?? n) !== null && l !== void 0 ? l : a.defaultError,
								}
							: o.code !== "invalid_type"
								? { message: a.defaultError }
								: {
										message: (c = u ?? r) !== null && c !== void 0 ? c : a.defaultError,
									}
				},
				description: i,
			}
}
var Pt = class {
		get description() {
			return this._def.description
		}
		_getType(t) {
			return md(t.data)
		}
		_getOrReturnCtx(t, r) {
			return (
				r || {
					common: t.parent.common,
					data: t.data,
					parsedType: md(t.data),
					schemaErrorMap: this._def.errorMap,
					path: t.path,
					parent: t.parent,
				}
			)
		}
		_processInputParams(t) {
			return {
				status: new Ms(),
				ctx: {
					common: t.parent.common,
					data: t.data,
					parsedType: md(t.data),
					schemaErrorMap: this._def.errorMap,
					path: t.path,
					parent: t.parent,
				},
			}
		}
		_parseSync(t) {
			let r = this._parse(t)
			if (Fv(r)) throw new Error("Synchronous parse encountered promise.")
			return r
		}
		_parseAsync(t) {
			let r = this._parse(t)
			return Promise.resolve(r)
		}
		parse(t, r) {
			let n = this.safeParse(t, r)
			if (n.success) return n.data
			throw n.error
		}
		safeParse(t, r) {
			var n
			let i = {
					common: {
						issues: [],
						async: (n = r?.async) !== null && n !== void 0 ? n : !1,
						contextualErrorMap: r?.errorMap,
					},
					path: r?.path || [],
					schemaErrorMap: this._def.errorMap,
					parent: null,
					data: t,
					parsedType: md(t),
				},
				s = this._parseSync({ data: t, path: i.path, parent: i })
			return gY(i, s)
		}
		"~validate"(t) {
			var r, n
			let i = {
				common: { issues: [], async: !!this["~standard"].async },
				path: [],
				schemaErrorMap: this._def.errorMap,
				parent: null,
				data: t,
				parsedType: md(t),
			}
			if (!this["~standard"].async)
				try {
					let s = this._parseSync({ data: t, path: [], parent: i })
					return wg(s) ? { value: s.value } : { issues: i.common.issues }
				} catch (s) {
					!(
						(n = (r = s?.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null ||
						n === void 0
					) &&
						n.includes("encountered") &&
						(this["~standard"].async = !0),
						(i.common = { issues: [], async: !0 })
				}
			return this._parseAsync({ data: t, path: [], parent: i }).then((s) =>
				wg(s) ? { value: s.value } : { issues: i.common.issues },
			)
		}
		async parseAsync(t, r) {
			let n = await this.safeParseAsync(t, r)
			if (n.success) return n.data
			throw n.error
		}
		async safeParseAsync(t, r) {
			let n = {
					common: { issues: [], contextualErrorMap: r?.errorMap, async: !0 },
					path: r?.path || [],
					schemaErrorMap: this._def.errorMap,
					parent: null,
					data: t,
					parsedType: md(t),
				},
				i = this._parse({ data: t, path: n.path, parent: n }),
				s = await (Fv(i) ? i : Promise.resolve(i))
			return gY(n, s)
		}
		refine(t, r) {
			let n = (i) => (typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(i) : r)
			return this._refinement((i, s) => {
				let o = t(i),
					a = () => s.addIssue({ code: ve.custom, ...n(i) })
				return typeof Promise < "u" && o instanceof Promise
					? o.then((l) => (l ? !0 : (a(), !1)))
					: o
						? !0
						: (a(), !1)
			})
		}
		refinement(t, r) {
			return this._refinement((n, i) => (t(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1)))
		}
		_refinement(t) {
			return new da({
				schema: this,
				typeName: At.ZodEffects,
				effect: { type: "refinement", refinement: t },
			})
		}
		superRefine(t) {
			return this._refinement(t)
		}
		constructor(t) {
			;(this.spa = this.safeParseAsync),
				(this._def = t),
				(this.parse = this.parse.bind(this)),
				(this.safeParse = this.safeParse.bind(this)),
				(this.parseAsync = this.parseAsync.bind(this)),
				(this.safeParseAsync = this.safeParseAsync.bind(this)),
				(this.spa = this.spa.bind(this)),
				(this.refine = this.refine.bind(this)),
				(this.refinement = this.refinement.bind(this)),
				(this.superRefine = this.superRefine.bind(this)),
				(this.optional = this.optional.bind(this)),
				(this.nullable = this.nullable.bind(this)),
				(this.nullish = this.nullish.bind(this)),
				(this.array = this.array.bind(this)),
				(this.promise = this.promise.bind(this)),
				(this.or = this.or.bind(this)),
				(this.and = this.and.bind(this)),
				(this.transform = this.transform.bind(this)),
				(this.brand = this.brand.bind(this)),
				(this.default = this.default.bind(this)),
				(this.catch = this.catch.bind(this)),
				(this.describe = this.describe.bind(this)),
				(this.pipe = this.pipe.bind(this)),
				(this.readonly = this.readonly.bind(this)),
				(this.isNullable = this.isNullable.bind(this)),
				(this.isOptional = this.isOptional.bind(this)),
				(this["~standard"] = {
					version: 1,
					vendor: "zod",
					validate: (r) => this["~validate"](r),
				})
		}
		optional() {
			return Ja.create(this, this._def)
		}
		nullable() {
			return Kc.create(this, this._def)
		}
		nullish() {
			return this.nullable().optional()
		}
		array() {
			return Cd.create(this)
		}
		promise() {
			return Ff.create(this, this._def)
		}
		or(t) {
			return kg.create([this, t], this._def)
		}
		and(t) {
			return Mg.create(this, t, this._def)
		}
		transform(t) {
			return new da({
				...Nt(this._def),
				schema: this,
				typeName: At.ZodEffects,
				effect: { type: "transform", transform: t },
			})
		}
		default(t) {
			let r = typeof t == "function" ? t : () => t
			return new Lg({
				...Nt(this._def),
				innerType: this,
				defaultValue: r,
				typeName: At.ZodDefault,
			})
		}
		brand() {
			return new Qv({ typeName: At.ZodBranded, type: this, ...Nt(this._def) })
		}
		catch(t) {
			let r = typeof t == "function" ? t : () => t
			return new Ug({
				...Nt(this._def),
				innerType: this,
				catchValue: r,
				typeName: At.ZodCatch,
			})
		}
		describe(t) {
			let r = this.constructor
			return new r({ ...this._def, description: t })
		}
		pipe(t) {
			return Nv.create(this, t)
		}
		readonly() {
			return Og.create(this)
		}
		isOptional() {
			return this.safeParse(void 0).success
		}
		isNullable() {
			return this.safeParse(null).success
		}
	},
	IMe = /^c[^\s-]{8,}$/i,
	SMe = /^[0-9a-z]+$/,
	BMe = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
	DMe = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
	TMe = /^[a-z0-9_-]{21}$/i,
	RMe = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
	kMe =
		/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
	MMe = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
	FMe = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
	hP,
	QMe =
		/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
	NMe =
		/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
	PMe =
		/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
	LMe =
		/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
	UMe = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
	OMe = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
	yY =
		"((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
	qMe = new RegExp(`^${yY}$`)
function CY(e) {
	let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d"
	return e.precision ? (t = `${t}\\.\\d{${e.precision}}`) : e.precision == null && (t = `${t}(\\.\\d+)?`), t
}
function VMe(e) {
	return new RegExp(`^${CY(e)}$`)
}
function vY(e) {
	let t = `${yY}T${CY(e)}`,
		r = []
	return (
		r.push(e.local ? "Z?" : "Z"),
		e.offset && r.push("([+-]\\d{2}:?\\d{2})"),
		(t = `${t}(${r.join("|")})`),
		new RegExp(`^${t}$`)
	)
}
function HMe(e, t) {
	return !!(((t === "v4" || !t) && QMe.test(e)) || ((t === "v6" || !t) && PMe.test(e)))
}
function WMe(e, t) {
	if (!RMe.test(e)) return !1
	try {
		let [r] = e.split("."),
			n = r
				.replace(/-/g, "+")
				.replace(/_/g, "/")
				.padEnd(r.length + ((4 - (r.length % 4)) % 4), "="),
			i = JSON.parse(atob(n))
		return !(typeof i != "object" || i === null || !i.typ || !i.alg || (t && i.alg !== t))
	} catch {
		return !1
	}
}
function GMe(e, t) {
	return !!(((t === "v4" || !t) && NMe.test(e)) || ((t === "v6" || !t) && LMe.test(e)))
}
var kf = class e extends Pt {
	_parse(t) {
		if ((this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Pe.string)) {
			let s = this._getOrReturnCtx(t)
			return (
				Re(s, {
					code: ve.invalid_type,
					expected: Pe.string,
					received: s.parsedType,
				}),
				vt
			)
		}
		let n = new Ms(),
			i
		for (let s of this._def.checks)
			if (s.kind === "min")
				t.data.length < s.value &&
					((i = this._getOrReturnCtx(t, i)),
					Re(i, {
						code: ve.too_small,
						minimum: s.value,
						type: "string",
						inclusive: !0,
						exact: !1,
						message: s.message,
					}),
					n.dirty())
			else if (s.kind === "max")
				t.data.length > s.value &&
					((i = this._getOrReturnCtx(t, i)),
					Re(i, {
						code: ve.too_big,
						maximum: s.value,
						type: "string",
						inclusive: !0,
						exact: !1,
						message: s.message,
					}),
					n.dirty())
			else if (s.kind === "length") {
				let o = t.data.length > s.value,
					a = t.data.length < s.value
				;(o || a) &&
					((i = this._getOrReturnCtx(t, i)),
					o
						? Re(i, {
								code: ve.too_big,
								maximum: s.value,
								type: "string",
								inclusive: !0,
								exact: !0,
								message: s.message,
							})
						: a &&
							Re(i, {
								code: ve.too_small,
								minimum: s.value,
								type: "string",
								inclusive: !0,
								exact: !0,
								message: s.message,
							}),
					n.dirty())
			} else if (s.kind === "email")
				MMe.test(t.data) ||
					((i = this._getOrReturnCtx(t, i)),
					Re(i, {
						validation: "email",
						code: ve.invalid_string,
						message: s.message,
					}),
					n.dirty())
			else if (s.kind === "emoji")
				hP || (hP = new RegExp(FMe, "u")),
					hP.test(t.data) ||
						((i = this._getOrReturnCtx(t, i)),
						Re(i, {
							validation: "emoji",
							code: ve.invalid_string,
							message: s.message,
						}),
						n.dirty())
			else if (s.kind === "uuid")
				DMe.test(t.data) ||
					((i = this._getOrReturnCtx(t, i)),
					Re(i, {
						validation: "uuid",
						code: ve.invalid_string,
						message: s.message,
					}),
					n.dirty())
			else if (s.kind === "nanoid")
				TMe.test(t.data) ||
					((i = this._getOrReturnCtx(t, i)),
					Re(i, {
						validation: "nanoid",
						code: ve.invalid_string,
						message: s.message,
					}),
					n.dirty())
			else if (s.kind === "cuid")
				IMe.test(t.data) ||
					((i = this._getOrReturnCtx(t, i)),
					Re(i, {
						validation: "cuid",
						code: ve.invalid_string,
						message: s.message,
					}),
					n.dirty())
			else if (s.kind === "cuid2")
				SMe.test(t.data) ||
					((i = this._getOrReturnCtx(t, i)),
					Re(i, {
						validation: "cuid2",
						code: ve.invalid_string,
						message: s.message,
					}),
					n.dirty())
			else if (s.kind === "ulid")
				BMe.test(t.data) ||
					((i = this._getOrReturnCtx(t, i)),
					Re(i, {
						validation: "ulid",
						code: ve.invalid_string,
						message: s.message,
					}),
					n.dirty())
			else if (s.kind === "url")
				try {
					new URL(t.data)
				} catch {
					;(i = this._getOrReturnCtx(t, i)),
						Re(i, {
							validation: "url",
							code: ve.invalid_string,
							message: s.message,
						}),
						n.dirty()
				}
			else
				s.kind === "regex"
					? ((s.regex.lastIndex = 0),
						s.regex.test(t.data) ||
							((i = this._getOrReturnCtx(t, i)),
							Re(i, {
								validation: "regex",
								code: ve.invalid_string,
								message: s.message,
							}),
							n.dirty()))
					: s.kind === "trim"
						? (t.data = t.data.trim())
						: s.kind === "includes"
							? t.data.includes(s.value, s.position) ||
								((i = this._getOrReturnCtx(t, i)),
								Re(i, {
									code: ve.invalid_string,
									validation: { includes: s.value, position: s.position },
									message: s.message,
								}),
								n.dirty())
							: s.kind === "toLowerCase"
								? (t.data = t.data.toLowerCase())
								: s.kind === "toUpperCase"
									? (t.data = t.data.toUpperCase())
									: s.kind === "startsWith"
										? t.data.startsWith(s.value) ||
											((i = this._getOrReturnCtx(t, i)),
											Re(i, {
												code: ve.invalid_string,
												validation: { startsWith: s.value },
												message: s.message,
											}),
											n.dirty())
										: s.kind === "endsWith"
											? t.data.endsWith(s.value) ||
												((i = this._getOrReturnCtx(t, i)),
												Re(i, {
													code: ve.invalid_string,
													validation: { endsWith: s.value },
													message: s.message,
												}),
												n.dirty())
											: s.kind === "datetime"
												? vY(s).test(t.data) ||
													((i = this._getOrReturnCtx(t, i)),
													Re(i, {
														code: ve.invalid_string,
														validation: "datetime",
														message: s.message,
													}),
													n.dirty())
												: s.kind === "date"
													? qMe.test(t.data) ||
														((i = this._getOrReturnCtx(t, i)),
														Re(i, {
															code: ve.invalid_string,
															validation: "date",
															message: s.message,
														}),
														n.dirty())
													: s.kind === "time"
														? VMe(s).test(t.data) ||
															((i = this._getOrReturnCtx(t, i)),
															Re(i, {
																code: ve.invalid_string,
																validation: "time",
																message: s.message,
															}),
															n.dirty())
														: s.kind === "duration"
															? kMe.test(t.data) ||
																((i = this._getOrReturnCtx(t, i)),
																Re(i, {
																	validation: "duration",
																	code: ve.invalid_string,
																	message: s.message,
																}),
																n.dirty())
															: s.kind === "ip"
																? HMe(t.data, s.version) ||
																	((i = this._getOrReturnCtx(t, i)),
																	Re(i, {
																		validation: "ip",
																		code: ve.invalid_string,
																		message: s.message,
																	}),
																	n.dirty())
																: s.kind === "jwt"
																	? WMe(t.data, s.alg) ||
																		((i = this._getOrReturnCtx(t, i)),
																		Re(i, {
																			validation: "jwt",
																			code: ve.invalid_string,
																			message: s.message,
																		}),
																		n.dirty())
																	: s.kind === "cidr"
																		? GMe(t.data, s.version) ||
																			((i = this._getOrReturnCtx(t, i)),
																			Re(i, {
																				validation: "cidr",
																				code: ve.invalid_string,
																				message: s.message,
																			}),
																			n.dirty())
																		: s.kind === "base64"
																			? UMe.test(t.data) ||
																				((i = this._getOrReturnCtx(t, i)),
																				Re(i, {
																					validation: "base64",
																					code: ve.invalid_string,
																					message: s.message,
																				}),
																				n.dirty())
																			: s.kind === "base64url"
																				? OMe.test(t.data) ||
																					((i = this._getOrReturnCtx(t, i)),
																					Re(i, {
																						validation: "base64url",
																						code: ve.invalid_string,
																						message: s.message,
																					}),
																					n.dirty())
																				: vr.assertNever(s)
		return { status: n.value, value: t.data }
	}
	_regex(t, r, n) {
		return this.refinement((i) => t.test(i), {
			validation: r,
			code: ve.invalid_string,
			...$e.errToObj(n),
		})
	}
	_addCheck(t) {
		return new e({ ...this._def, checks: [...this._def.checks, t] })
	}
	email(t) {
		return this._addCheck({ kind: "email", ...$e.errToObj(t) })
	}
	url(t) {
		return this._addCheck({ kind: "url", ...$e.errToObj(t) })
	}
	emoji(t) {
		return this._addCheck({ kind: "emoji", ...$e.errToObj(t) })
	}
	uuid(t) {
		return this._addCheck({ kind: "uuid", ...$e.errToObj(t) })
	}
	nanoid(t) {
		return this._addCheck({ kind: "nanoid", ...$e.errToObj(t) })
	}
	cuid(t) {
		return this._addCheck({ kind: "cuid", ...$e.errToObj(t) })
	}
	cuid2(t) {
		return this._addCheck({ kind: "cuid2", ...$e.errToObj(t) })
	}
	ulid(t) {
		return this._addCheck({ kind: "ulid", ...$e.errToObj(t) })
	}
	base64(t) {
		return this._addCheck({ kind: "base64", ...$e.errToObj(t) })
	}
	base64url(t) {
		return this._addCheck({ kind: "base64url", ...$e.errToObj(t) })
	}
	jwt(t) {
		return this._addCheck({ kind: "jwt", ...$e.errToObj(t) })
	}
	ip(t) {
		return this._addCheck({ kind: "ip", ...$e.errToObj(t) })
	}
	cidr(t) {
		return this._addCheck({ kind: "cidr", ...$e.errToObj(t) })
	}
	datetime(t) {
		var r, n
		return typeof t == "string"
			? this._addCheck({
					kind: "datetime",
					precision: null,
					offset: !1,
					local: !1,
					message: t,
				})
			: this._addCheck({
					kind: "datetime",
					precision: typeof t?.precision > "u" ? null : t?.precision,
					offset: (r = t?.offset) !== null && r !== void 0 ? r : !1,
					local: (n = t?.local) !== null && n !== void 0 ? n : !1,
					...$e.errToObj(t?.message),
				})
	}
	date(t) {
		return this._addCheck({ kind: "date", message: t })
	}
	time(t) {
		return typeof t == "string"
			? this._addCheck({ kind: "time", precision: null, message: t })
			: this._addCheck({
					kind: "time",
					precision: typeof t?.precision > "u" ? null : t?.precision,
					...$e.errToObj(t?.message),
				})
	}
	duration(t) {
		return this._addCheck({ kind: "duration", ...$e.errToObj(t) })
	}
	regex(t, r) {
		return this._addCheck({ kind: "regex", regex: t, ...$e.errToObj(r) })
	}
	includes(t, r) {
		return this._addCheck({
			kind: "includes",
			value: t,
			position: r?.position,
			...$e.errToObj(r?.message),
		})
	}
	startsWith(t, r) {
		return this._addCheck({ kind: "startsWith", value: t, ...$e.errToObj(r) })
	}
	endsWith(t, r) {
		return this._addCheck({ kind: "endsWith", value: t, ...$e.errToObj(r) })
	}
	min(t, r) {
		return this._addCheck({ kind: "min", value: t, ...$e.errToObj(r) })
	}
	max(t, r) {
		return this._addCheck({ kind: "max", value: t, ...$e.errToObj(r) })
	}
	length(t, r) {
		return this._addCheck({ kind: "length", value: t, ...$e.errToObj(r) })
	}
	nonempty(t) {
		return this.min(1, $e.errToObj(t))
	}
	trim() {
		return new e({
			...this._def,
			checks: [...this._def.checks, { kind: "trim" }],
		})
	}
	toLowerCase() {
		return new e({
			...this._def,
			checks: [...this._def.checks, { kind: "toLowerCase" }],
		})
	}
	toUpperCase() {
		return new e({
			...this._def,
			checks: [...this._def.checks, { kind: "toUpperCase" }],
		})
	}
	get isDatetime() {
		return !!this._def.checks.find((t) => t.kind === "datetime")
	}
	get isDate() {
		return !!this._def.checks.find((t) => t.kind === "date")
	}
	get isTime() {
		return !!this._def.checks.find((t) => t.kind === "time")
	}
	get isDuration() {
		return !!this._def.checks.find((t) => t.kind === "duration")
	}
	get isEmail() {
		return !!this._def.checks.find((t) => t.kind === "email")
	}
	get isURL() {
		return !!this._def.checks.find((t) => t.kind === "url")
	}
	get isEmoji() {
		return !!this._def.checks.find((t) => t.kind === "emoji")
	}
	get isUUID() {
		return !!this._def.checks.find((t) => t.kind === "uuid")
	}
	get isNANOID() {
		return !!this._def.checks.find((t) => t.kind === "nanoid")
	}
	get isCUID() {
		return !!this._def.checks.find((t) => t.kind === "cuid")
	}
	get isCUID2() {
		return !!this._def.checks.find((t) => t.kind === "cuid2")
	}
	get isULID() {
		return !!this._def.checks.find((t) => t.kind === "ulid")
	}
	get isIP() {
		return !!this._def.checks.find((t) => t.kind === "ip")
	}
	get isCIDR() {
		return !!this._def.checks.find((t) => t.kind === "cidr")
	}
	get isBase64() {
		return !!this._def.checks.find((t) => t.kind === "base64")
	}
	get isBase64url() {
		return !!this._def.checks.find((t) => t.kind === "base64url")
	}
	get minLength() {
		let t = null
		for (let r of this._def.checks) r.kind === "min" && (t === null || r.value > t) && (t = r.value)
		return t
	}
	get maxLength() {
		let t = null
		for (let r of this._def.checks) r.kind === "max" && (t === null || r.value < t) && (t = r.value)
		return t
	}
}
kf.create = (e) => {
	var t
	return new kf({
		checks: [],
		typeName: At.ZodString,
		coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
		...Nt(e),
	})
}
function $Me(e, t) {
	let r = (e.toString().split(".")[1] || "").length,
		n = (t.toString().split(".")[1] || "").length,
		i = r > n ? r : n,
		s = parseInt(e.toFixed(i).replace(".", "")),
		o = parseInt(t.toFixed(i).replace(".", ""))
	return (s % o) / Math.pow(10, i)
}
var Ig = class e extends Pt {
	constructor() {
		super(...arguments), (this.min = this.gte), (this.max = this.lte), (this.step = this.multipleOf)
	}
	_parse(t) {
		if ((this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Pe.number)) {
			let s = this._getOrReturnCtx(t)
			return (
				Re(s, {
					code: ve.invalid_type,
					expected: Pe.number,
					received: s.parsedType,
				}),
				vt
			)
		}
		let n,
			i = new Ms()
		for (let s of this._def.checks)
			s.kind === "int"
				? vr.isInteger(t.data) ||
					((n = this._getOrReturnCtx(t, n)),
					Re(n, {
						code: ve.invalid_type,
						expected: "integer",
						received: "float",
						message: s.message,
					}),
					i.dirty())
				: s.kind === "min"
					? (s.inclusive ? t.data < s.value : t.data <= s.value) &&
						((n = this._getOrReturnCtx(t, n)),
						Re(n, {
							code: ve.too_small,
							minimum: s.value,
							type: "number",
							inclusive: s.inclusive,
							exact: !1,
							message: s.message,
						}),
						i.dirty())
					: s.kind === "max"
						? (s.inclusive ? t.data > s.value : t.data >= s.value) &&
							((n = this._getOrReturnCtx(t, n)),
							Re(n, {
								code: ve.too_big,
								maximum: s.value,
								type: "number",
								inclusive: s.inclusive,
								exact: !1,
								message: s.message,
							}),
							i.dirty())
						: s.kind === "multipleOf"
							? $Me(t.data, s.value) !== 0 &&
								((n = this._getOrReturnCtx(t, n)),
								Re(n, {
									code: ve.not_multiple_of,
									multipleOf: s.value,
									message: s.message,
								}),
								i.dirty())
							: s.kind === "finite"
								? Number.isFinite(t.data) ||
									((n = this._getOrReturnCtx(t, n)),
									Re(n, { code: ve.not_finite, message: s.message }),
									i.dirty())
								: vr.assertNever(s)
		return { status: i.value, value: t.data }
	}
	gte(t, r) {
		return this.setLimit("min", t, !0, $e.toString(r))
	}
	gt(t, r) {
		return this.setLimit("min", t, !1, $e.toString(r))
	}
	lte(t, r) {
		return this.setLimit("max", t, !0, $e.toString(r))
	}
	lt(t, r) {
		return this.setLimit("max", t, !1, $e.toString(r))
	}
	setLimit(t, r, n, i) {
		return new e({
			...this._def,
			checks: [...this._def.checks, { kind: t, value: r, inclusive: n, message: $e.toString(i) }],
		})
	}
	_addCheck(t) {
		return new e({ ...this._def, checks: [...this._def.checks, t] })
	}
	int(t) {
		return this._addCheck({ kind: "int", message: $e.toString(t) })
	}
	positive(t) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: !1,
			message: $e.toString(t),
		})
	}
	negative(t) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: !1,
			message: $e.toString(t),
		})
	}
	nonpositive(t) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: !0,
			message: $e.toString(t),
		})
	}
	nonnegative(t) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: !0,
			message: $e.toString(t),
		})
	}
	multipleOf(t, r) {
		return this._addCheck({
			kind: "multipleOf",
			value: t,
			message: $e.toString(r),
		})
	}
	finite(t) {
		return this._addCheck({ kind: "finite", message: $e.toString(t) })
	}
	safe(t) {
		return this._addCheck({
			kind: "min",
			inclusive: !0,
			value: Number.MIN_SAFE_INTEGER,
			message: $e.toString(t),
		})._addCheck({
			kind: "max",
			inclusive: !0,
			value: Number.MAX_SAFE_INTEGER,
			message: $e.toString(t),
		})
	}
	get minValue() {
		let t = null
		for (let r of this._def.checks) r.kind === "min" && (t === null || r.value > t) && (t = r.value)
		return t
	}
	get maxValue() {
		let t = null
		for (let r of this._def.checks) r.kind === "max" && (t === null || r.value < t) && (t = r.value)
		return t
	}
	get isInt() {
		return !!this._def.checks.find((t) => t.kind === "int" || (t.kind === "multipleOf" && vr.isInteger(t.value)))
	}
	get isFinite() {
		let t = null,
			r = null
		for (let n of this._def.checks) {
			if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf") return !0
			n.kind === "min"
				? (r === null || n.value > r) && (r = n.value)
				: n.kind === "max" && (t === null || n.value < t) && (t = n.value)
		}
		return Number.isFinite(r) && Number.isFinite(t)
	}
}
Ig.create = (e) =>
	new Ig({
		checks: [],
		typeName: At.ZodNumber,
		coerce: e?.coerce || !1,
		...Nt(e),
	})
var Sg = class e extends Pt {
	constructor() {
		super(...arguments), (this.min = this.gte), (this.max = this.lte)
	}
	_parse(t) {
		if (this._def.coerce)
			try {
				t.data = BigInt(t.data)
			} catch {
				return this._getInvalidInput(t)
			}
		if (this._getType(t) !== Pe.bigint) return this._getInvalidInput(t)
		let n,
			i = new Ms()
		for (let s of this._def.checks)
			s.kind === "min"
				? (s.inclusive ? t.data < s.value : t.data <= s.value) &&
					((n = this._getOrReturnCtx(t, n)),
					Re(n, {
						code: ve.too_small,
						type: "bigint",
						minimum: s.value,
						inclusive: s.inclusive,
						message: s.message,
					}),
					i.dirty())
				: s.kind === "max"
					? (s.inclusive ? t.data > s.value : t.data >= s.value) &&
						((n = this._getOrReturnCtx(t, n)),
						Re(n, {
							code: ve.too_big,
							type: "bigint",
							maximum: s.value,
							inclusive: s.inclusive,
							message: s.message,
						}),
						i.dirty())
					: s.kind === "multipleOf"
						? t.data % s.value !== BigInt(0) &&
							((n = this._getOrReturnCtx(t, n)),
							Re(n, {
								code: ve.not_multiple_of,
								multipleOf: s.value,
								message: s.message,
							}),
							i.dirty())
						: vr.assertNever(s)
		return { status: i.value, value: t.data }
	}
	_getInvalidInput(t) {
		let r = this._getOrReturnCtx(t)
		return (
			Re(r, {
				code: ve.invalid_type,
				expected: Pe.bigint,
				received: r.parsedType,
			}),
			vt
		)
	}
	gte(t, r) {
		return this.setLimit("min", t, !0, $e.toString(r))
	}
	gt(t, r) {
		return this.setLimit("min", t, !1, $e.toString(r))
	}
	lte(t, r) {
		return this.setLimit("max", t, !0, $e.toString(r))
	}
	lt(t, r) {
		return this.setLimit("max", t, !1, $e.toString(r))
	}
	setLimit(t, r, n, i) {
		return new e({
			...this._def,
			checks: [...this._def.checks, { kind: t, value: r, inclusive: n, message: $e.toString(i) }],
		})
	}
	_addCheck(t) {
		return new e({ ...this._def, checks: [...this._def.checks, t] })
	}
	positive(t) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: !1,
			message: $e.toString(t),
		})
	}
	negative(t) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: !1,
			message: $e.toString(t),
		})
	}
	nonpositive(t) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: !0,
			message: $e.toString(t),
		})
	}
	nonnegative(t) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: !0,
			message: $e.toString(t),
		})
	}
	multipleOf(t, r) {
		return this._addCheck({
			kind: "multipleOf",
			value: t,
			message: $e.toString(r),
		})
	}
	get minValue() {
		let t = null
		for (let r of this._def.checks) r.kind === "min" && (t === null || r.value > t) && (t = r.value)
		return t
	}
	get maxValue() {
		let t = null
		for (let r of this._def.checks) r.kind === "max" && (t === null || r.value < t) && (t = r.value)
		return t
	}
}
Sg.create = (e) => {
	var t
	return new Sg({
		checks: [],
		typeName: At.ZodBigInt,
		coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
		...Nt(e),
	})
}
var Bg = class extends Pt {
	_parse(t) {
		if ((this._def.coerce && (t.data = !!t.data), this._getType(t) !== Pe.boolean)) {
			let n = this._getOrReturnCtx(t)
			return (
				Re(n, {
					code: ve.invalid_type,
					expected: Pe.boolean,
					received: n.parsedType,
				}),
				vt
			)
		}
		return ro(t.data)
	}
}
Bg.create = (e) => new Bg({ typeName: At.ZodBoolean, coerce: e?.coerce || !1, ...Nt(e) })
var Dg = class e extends Pt {
	_parse(t) {
		if ((this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Pe.date)) {
			let s = this._getOrReturnCtx(t)
			return (
				Re(s, {
					code: ve.invalid_type,
					expected: Pe.date,
					received: s.parsedType,
				}),
				vt
			)
		}
		if (isNaN(t.data.getTime())) {
			let s = this._getOrReturnCtx(t)
			return Re(s, { code: ve.invalid_date }), vt
		}
		let n = new Ms(),
			i
		for (let s of this._def.checks)
			s.kind === "min"
				? t.data.getTime() < s.value &&
					((i = this._getOrReturnCtx(t, i)),
					Re(i, {
						code: ve.too_small,
						message: s.message,
						inclusive: !0,
						exact: !1,
						minimum: s.value,
						type: "date",
					}),
					n.dirty())
				: s.kind === "max"
					? t.data.getTime() > s.value &&
						((i = this._getOrReturnCtx(t, i)),
						Re(i, {
							code: ve.too_big,
							message: s.message,
							inclusive: !0,
							exact: !1,
							maximum: s.value,
							type: "date",
						}),
						n.dirty())
					: vr.assertNever(s)
		return { status: n.value, value: new Date(t.data.getTime()) }
	}
	_addCheck(t) {
		return new e({ ...this._def, checks: [...this._def.checks, t] })
	}
	min(t, r) {
		return this._addCheck({
			kind: "min",
			value: t.getTime(),
			message: $e.toString(r),
		})
	}
	max(t, r) {
		return this._addCheck({
			kind: "max",
			value: t.getTime(),
			message: $e.toString(r),
		})
	}
	get minDate() {
		let t = null
		for (let r of this._def.checks) r.kind === "min" && (t === null || r.value > t) && (t = r.value)
		return t != null ? new Date(t) : null
	}
	get maxDate() {
		let t = null
		for (let r of this._def.checks) r.kind === "max" && (t === null || r.value < t) && (t = r.value)
		return t != null ? new Date(t) : null
	}
}
Dg.create = (e) =>
	new Dg({
		checks: [],
		coerce: e?.coerce || !1,
		typeName: At.ZodDate,
		...Nt(e),
	})
var nm = class extends Pt {
	_parse(t) {
		if (this._getType(t) !== Pe.symbol) {
			let n = this._getOrReturnCtx(t)
			return (
				Re(n, {
					code: ve.invalid_type,
					expected: Pe.symbol,
					received: n.parsedType,
				}),
				vt
			)
		}
		return ro(t.data)
	}
}
nm.create = (e) => new nm({ typeName: At.ZodSymbol, ...Nt(e) })
var Tg = class extends Pt {
	_parse(t) {
		if (this._getType(t) !== Pe.undefined) {
			let n = this._getOrReturnCtx(t)
			return (
				Re(n, {
					code: ve.invalid_type,
					expected: Pe.undefined,
					received: n.parsedType,
				}),
				vt
			)
		}
		return ro(t.data)
	}
}
Tg.create = (e) => new Tg({ typeName: At.ZodUndefined, ...Nt(e) })
var Rg = class extends Pt {
	_parse(t) {
		if (this._getType(t) !== Pe.null) {
			let n = this._getOrReturnCtx(t)
			return (
				Re(n, {
					code: ve.invalid_type,
					expected: Pe.null,
					received: n.parsedType,
				}),
				vt
			)
		}
		return ro(t.data)
	}
}
Rg.create = (e) => new Rg({ typeName: At.ZodNull, ...Nt(e) })
var Mf = class extends Pt {
	constructor() {
		super(...arguments), (this._any = !0)
	}
	_parse(t) {
		return ro(t.data)
	}
}
Mf.create = (e) => new Mf({ typeName: At.ZodAny, ...Nt(e) })
var yd = class extends Pt {
	constructor() {
		super(...arguments), (this._unknown = !0)
	}
	_parse(t) {
		return ro(t.data)
	}
}
yd.create = (e) => new yd({ typeName: At.ZodUnknown, ...Nt(e) })
var zl = class extends Pt {
	_parse(t) {
		let r = this._getOrReturnCtx(t)
		return (
			Re(r, {
				code: ve.invalid_type,
				expected: Pe.never,
				received: r.parsedType,
			}),
			vt
		)
	}
}
zl.create = (e) => new zl({ typeName: At.ZodNever, ...Nt(e) })
var im = class extends Pt {
	_parse(t) {
		if (this._getType(t) !== Pe.undefined) {
			let n = this._getOrReturnCtx(t)
			return (
				Re(n, {
					code: ve.invalid_type,
					expected: Pe.void,
					received: n.parsedType,
				}),
				vt
			)
		}
		return ro(t.data)
	}
}
im.create = (e) => new im({ typeName: At.ZodVoid, ...Nt(e) })
var Cd = class e extends Pt {
	_parse(t) {
		let { ctx: r, status: n } = this._processInputParams(t),
			i = this._def
		if (r.parsedType !== Pe.array)
			return (
				Re(r, {
					code: ve.invalid_type,
					expected: Pe.array,
					received: r.parsedType,
				}),
				vt
			)
		if (i.exactLength !== null) {
			let o = r.data.length > i.exactLength.value,
				a = r.data.length < i.exactLength.value
			;(o || a) &&
				(Re(r, {
					code: o ? ve.too_big : ve.too_small,
					minimum: a ? i.exactLength.value : void 0,
					maximum: o ? i.exactLength.value : void 0,
					type: "array",
					inclusive: !0,
					exact: !0,
					message: i.exactLength.message,
				}),
				n.dirty())
		}
		if (
			(i.minLength !== null &&
				r.data.length < i.minLength.value &&
				(Re(r, {
					code: ve.too_small,
					minimum: i.minLength.value,
					type: "array",
					inclusive: !0,
					exact: !1,
					message: i.minLength.message,
				}),
				n.dirty()),
			i.maxLength !== null &&
				r.data.length > i.maxLength.value &&
				(Re(r, {
					code: ve.too_big,
					maximum: i.maxLength.value,
					type: "array",
					inclusive: !0,
					exact: !1,
					message: i.maxLength.message,
				}),
				n.dirty()),
			r.common.async)
		)
			return Promise.all([...r.data].map((o, a) => i.type._parseAsync(new za(r, o, r.path, a)))).then((o) =>
				Ms.mergeArray(n, o),
			)
		let s = [...r.data].map((o, a) => i.type._parseSync(new za(r, o, r.path, a)))
		return Ms.mergeArray(n, s)
	}
	get element() {
		return this._def.type
	}
	min(t, r) {
		return new e({
			...this._def,
			minLength: { value: t, message: $e.toString(r) },
		})
	}
	max(t, r) {
		return new e({
			...this._def,
			maxLength: { value: t, message: $e.toString(r) },
		})
	}
	length(t, r) {
		return new e({
			...this._def,
			exactLength: { value: t, message: $e.toString(r) },
		})
	}
	nonempty(t) {
		return this.min(1, t)
	}
}
Cd.create = (e, t) =>
	new Cd({
		type: e,
		minLength: null,
		maxLength: null,
		exactLength: null,
		typeName: At.ZodArray,
		...Nt(t),
	})
function em(e) {
	if (e instanceof To) {
		let t = {}
		for (let r in e.shape) {
			let n = e.shape[r]
			t[r] = Ja.create(em(n))
		}
		return new To({ ...e._def, shape: () => t })
	} else
		return e instanceof Cd
			? new Cd({ ...e._def, type: em(e.element) })
			: e instanceof Ja
				? Ja.create(em(e.unwrap()))
				: e instanceof Kc
					? Kc.create(em(e.unwrap()))
					: e instanceof Yc
						? Yc.create(e.items.map((t) => em(t)))
						: e
}
var To = class e extends Pt {
	constructor() {
		super(...arguments), (this._cached = null), (this.nonstrict = this.passthrough), (this.augment = this.extend)
	}
	_getCached() {
		if (this._cached !== null) return this._cached
		let t = this._def.shape(),
			r = vr.objectKeys(t)
		return (this._cached = { shape: t, keys: r })
	}
	_parse(t) {
		if (this._getType(t) !== Pe.object) {
			let c = this._getOrReturnCtx(t)
			return (
				Re(c, {
					code: ve.invalid_type,
					expected: Pe.object,
					received: c.parsedType,
				}),
				vt
			)
		}
		let { status: n, ctx: i } = this._processInputParams(t),
			{ shape: s, keys: o } = this._getCached(),
			a = []
		if (!(this._def.catchall instanceof zl && this._def.unknownKeys === "strip"))
			for (let c in i.data) o.includes(c) || a.push(c)
		let l = []
		for (let c of o) {
			let u = s[c],
				f = i.data[c]
			l.push({
				key: { status: "valid", value: c },
				value: u._parse(new za(i, f, i.path, c)),
				alwaysSet: c in i.data,
			})
		}
		if (this._def.catchall instanceof zl) {
			let c = this._def.unknownKeys
			if (c === "passthrough")
				for (let u of a)
					l.push({
						key: { status: "valid", value: u },
						value: { status: "valid", value: i.data[u] },
					})
			else if (c === "strict") a.length > 0 && (Re(i, { code: ve.unrecognized_keys, keys: a }), n.dirty())
			else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.")
		} else {
			let c = this._def.catchall
			for (let u of a) {
				let f = i.data[u]
				l.push({
					key: { status: "valid", value: u },
					value: c._parse(new za(i, f, i.path, u)),
					alwaysSet: u in i.data,
				})
			}
		}
		return i.common.async
			? Promise.resolve()
					.then(async () => {
						let c = []
						for (let u of l) {
							let f = await u.key,
								p = await u.value
							c.push({ key: f, value: p, alwaysSet: u.alwaysSet })
						}
						return c
					})
					.then((c) => Ms.mergeObjectSync(n, c))
			: Ms.mergeObjectSync(n, l)
	}
	get shape() {
		return this._def.shape()
	}
	strict(t) {
		return (
			$e.errToObj,
			new e({
				...this._def,
				unknownKeys: "strict",
				...(t !== void 0
					? {
							errorMap: (r, n) => {
								var i, s, o, a
								let l =
									(o =
										(s = (i = this._def).errorMap) === null || s === void 0
											? void 0
											: s.call(i, r, n).message) !== null && o !== void 0
										? o
										: n.defaultError
								return r.code === "unrecognized_keys"
									? {
											message: (a = $e.errToObj(t).message) !== null && a !== void 0 ? a : l,
										}
									: { message: l }
							},
						}
					: {}),
			})
		)
	}
	strip() {
		return new e({ ...this._def, unknownKeys: "strip" })
	}
	passthrough() {
		return new e({ ...this._def, unknownKeys: "passthrough" })
	}
	extend(t) {
		return new e({
			...this._def,
			shape: () => ({ ...this._def.shape(), ...t }),
		})
	}
	merge(t) {
		return new e({
			unknownKeys: t._def.unknownKeys,
			catchall: t._def.catchall,
			shape: () => ({ ...this._def.shape(), ...t._def.shape() }),
			typeName: At.ZodObject,
		})
	}
	setKey(t, r) {
		return this.augment({ [t]: r })
	}
	catchall(t) {
		return new e({ ...this._def, catchall: t })
	}
	pick(t) {
		let r = {}
		return (
			vr.objectKeys(t).forEach((n) => {
				t[n] && this.shape[n] && (r[n] = this.shape[n])
			}),
			new e({ ...this._def, shape: () => r })
		)
	}
	omit(t) {
		let r = {}
		return (
			vr.objectKeys(this.shape).forEach((n) => {
				t[n] || (r[n] = this.shape[n])
			}),
			new e({ ...this._def, shape: () => r })
		)
	}
	deepPartial() {
		return em(this)
	}
	partial(t) {
		let r = {}
		return (
			vr.objectKeys(this.shape).forEach((n) => {
				let i = this.shape[n]
				t && !t[n] ? (r[n] = i) : (r[n] = i.optional())
			}),
			new e({ ...this._def, shape: () => r })
		)
	}
	required(t) {
		let r = {}
		return (
			vr.objectKeys(this.shape).forEach((n) => {
				if (t && !t[n]) r[n] = this.shape[n]
				else {
					let s = this.shape[n]
					for (; s instanceof Ja; ) s = s._def.innerType
					r[n] = s
				}
			}),
			new e({ ...this._def, shape: () => r })
		)
	}
	keyof() {
		return EY(vr.objectKeys(this.shape))
	}
}
To.create = (e, t) =>
	new To({
		shape: () => e,
		unknownKeys: "strip",
		catchall: zl.create(),
		typeName: At.ZodObject,
		...Nt(t),
	})
To.strictCreate = (e, t) =>
	new To({
		shape: () => e,
		unknownKeys: "strict",
		catchall: zl.create(),
		typeName: At.ZodObject,
		...Nt(t),
	})
To.lazycreate = (e, t) =>
	new To({
		shape: e,
		unknownKeys: "strip",
		catchall: zl.create(),
		typeName: At.ZodObject,
		...Nt(t),
	})
var kg = class extends Pt {
	_parse(t) {
		let { ctx: r } = this._processInputParams(t),
			n = this._def.options
		function i(s) {
			for (let a of s) if (a.result.status === "valid") return a.result
			for (let a of s)
				if (a.result.status === "dirty") return r.common.issues.push(...a.ctx.common.issues), a.result
			let o = s.map((a) => new ua(a.ctx.common.issues))
			return Re(r, { code: ve.invalid_union, unionErrors: o }), vt
		}
		if (r.common.async)
			return Promise.all(
				n.map(async (s) => {
					let o = { ...r, common: { ...r.common, issues: [] }, parent: null }
					return {
						result: await s._parseAsync({
							data: r.data,
							path: r.path,
							parent: o,
						}),
						ctx: o,
					}
				}),
			).then(i)
		{
			let s,
				o = []
			for (let l of n) {
				let c = { ...r, common: { ...r.common, issues: [] }, parent: null },
					u = l._parseSync({ data: r.data, path: r.path, parent: c })
				if (u.status === "valid") return u
				u.status === "dirty" && !s && (s = { result: u, ctx: c }),
					c.common.issues.length && o.push(c.common.issues)
			}
			if (s) return r.common.issues.push(...s.ctx.common.issues), s.result
			let a = o.map((l) => new ua(l))
			return Re(r, { code: ve.invalid_union, unionErrors: a }), vt
		}
	}
	get options() {
		return this._def.options
	}
}
kg.create = (e, t) => new kg({ options: e, typeName: At.ZodUnion, ...Nt(t) })
var Ad = (e) =>
		e instanceof Fg
			? Ad(e.schema)
			: e instanceof da
				? Ad(e.innerType())
				: e instanceof Qg
					? [e.value]
					: e instanceof Ng
						? e.options
						: e instanceof Pg
							? vr.objectValues(e.enum)
							: e instanceof Lg
								? Ad(e._def.innerType)
								: e instanceof Tg
									? [void 0]
									: e instanceof Rg
										? [null]
										: e instanceof Ja
											? [void 0, ...Ad(e.unwrap())]
											: e instanceof Kc
												? [null, ...Ad(e.unwrap())]
												: e instanceof Qv || e instanceof Og
													? Ad(e.unwrap())
													: e instanceof Ug
														? Ad(e._def.innerType)
														: [],
	BI = class e extends Pt {
		_parse(t) {
			let { ctx: r } = this._processInputParams(t)
			if (r.parsedType !== Pe.object)
				return (
					Re(r, {
						code: ve.invalid_type,
						expected: Pe.object,
						received: r.parsedType,
					}),
					vt
				)
			let n = this.discriminator,
				i = r.data[n],
				s = this.optionsMap.get(i)
			return s
				? r.common.async
					? s._parseAsync({ data: r.data, path: r.path, parent: r })
					: s._parseSync({ data: r.data, path: r.path, parent: r })
				: (Re(r, {
						code: ve.invalid_union_discriminator,
						options: Array.from(this.optionsMap.keys()),
						path: [n],
					}),
					vt)
		}
		get discriminator() {
			return this._def.discriminator
		}
		get options() {
			return this._def.options
		}
		get optionsMap() {
			return this._def.optionsMap
		}
		static create(t, r, n) {
			let i = new Map()
			for (let s of r) {
				let o = Ad(s.shape[t])
				if (!o.length)
					throw new Error(
						`A discriminator value for key \`${t}\` could not be extracted from all schema options`,
					)
				for (let a of o) {
					if (i.has(a))
						throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`)
					i.set(a, s)
				}
			}
			return new e({
				typeName: At.ZodDiscriminatedUnion,
				discriminator: t,
				options: r,
				optionsMap: i,
				...Nt(n),
			})
		}
	}
function mP(e, t) {
	let r = md(e),
		n = md(t)
	if (e === t) return { valid: !0, data: e }
	if (r === Pe.object && n === Pe.object) {
		let i = vr.objectKeys(t),
			s = vr.objectKeys(e).filter((a) => i.indexOf(a) !== -1),
			o = { ...e, ...t }
		for (let a of s) {
			let l = mP(e[a], t[a])
			if (!l.valid) return { valid: !1 }
			o[a] = l.data
		}
		return { valid: !0, data: o }
	} else if (r === Pe.array && n === Pe.array) {
		if (e.length !== t.length) return { valid: !1 }
		let i = []
		for (let s = 0; s < e.length; s++) {
			let o = e[s],
				a = t[s],
				l = mP(o, a)
			if (!l.valid) return { valid: !1 }
			i.push(l.data)
		}
		return { valid: !0, data: i }
	} else return r === Pe.date && n === Pe.date && +e == +t ? { valid: !0, data: e } : { valid: !1 }
}
var Mg = class extends Pt {
	_parse(t) {
		let { status: r, ctx: n } = this._processInputParams(t),
			i = (s, o) => {
				if (pP(s) || pP(o)) return vt
				let a = mP(s.value, o.value)
				return a.valid
					? ((AP(s) || AP(o)) && r.dirty(), { status: r.value, value: a.data })
					: (Re(n, { code: ve.invalid_intersection_types }), vt)
			}
		return n.common.async
			? Promise.all([
					this._def.left._parseAsync({ data: n.data, path: n.path, parent: n }),
					this._def.right._parseAsync({
						data: n.data,
						path: n.path,
						parent: n,
					}),
				]).then(([s, o]) => i(s, o))
			: i(
					this._def.left._parseSync({ data: n.data, path: n.path, parent: n }),
					this._def.right._parseSync({ data: n.data, path: n.path, parent: n }),
				)
	}
}
Mg.create = (e, t, r) => new Mg({ left: e, right: t, typeName: At.ZodIntersection, ...Nt(r) })
var Yc = class e extends Pt {
	_parse(t) {
		let { status: r, ctx: n } = this._processInputParams(t)
		if (n.parsedType !== Pe.array)
			return (
				Re(n, {
					code: ve.invalid_type,
					expected: Pe.array,
					received: n.parsedType,
				}),
				vt
			)
		if (n.data.length < this._def.items.length)
			return (
				Re(n, {
					code: ve.too_small,
					minimum: this._def.items.length,
					inclusive: !0,
					exact: !1,
					type: "array",
				}),
				vt
			)
		!this._def.rest &&
			n.data.length > this._def.items.length &&
			(Re(n, {
				code: ve.too_big,
				maximum: this._def.items.length,
				inclusive: !0,
				exact: !1,
				type: "array",
			}),
			r.dirty())
		let s = [...n.data]
			.map((o, a) => {
				let l = this._def.items[a] || this._def.rest
				return l ? l._parse(new za(n, o, n.path, a)) : null
			})
			.filter((o) => !!o)
		return n.common.async ? Promise.all(s).then((o) => Ms.mergeArray(r, o)) : Ms.mergeArray(r, s)
	}
	get items() {
		return this._def.items
	}
	rest(t) {
		return new e({ ...this._def, rest: t })
	}
}
Yc.create = (e, t) => {
	if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])")
	return new Yc({ items: e, typeName: At.ZodTuple, rest: null, ...Nt(t) })
}
var DI = class e extends Pt {
		get keySchema() {
			return this._def.keyType
		}
		get valueSchema() {
			return this._def.valueType
		}
		_parse(t) {
			let { status: r, ctx: n } = this._processInputParams(t)
			if (n.parsedType !== Pe.object)
				return (
					Re(n, {
						code: ve.invalid_type,
						expected: Pe.object,
						received: n.parsedType,
					}),
					vt
				)
			let i = [],
				s = this._def.keyType,
				o = this._def.valueType
			for (let a in n.data)
				i.push({
					key: s._parse(new za(n, a, n.path, a)),
					value: o._parse(new za(n, n.data[a], n.path, a)),
					alwaysSet: a in n.data,
				})
			return n.common.async ? Ms.mergeObjectAsync(r, i) : Ms.mergeObjectSync(r, i)
		}
		get element() {
			return this._def.valueType
		}
		static create(t, r, n) {
			return r instanceof Pt
				? new e({ keyType: t, valueType: r, typeName: At.ZodRecord, ...Nt(n) })
				: new e({
						keyType: kf.create(),
						valueType: t,
						typeName: At.ZodRecord,
						...Nt(r),
					})
		}
	},
	sm = class extends Pt {
		get keySchema() {
			return this._def.keyType
		}
		get valueSchema() {
			return this._def.valueType
		}
		_parse(t) {
			let { status: r, ctx: n } = this._processInputParams(t)
			if (n.parsedType !== Pe.map)
				return (
					Re(n, {
						code: ve.invalid_type,
						expected: Pe.map,
						received: n.parsedType,
					}),
					vt
				)
			let i = this._def.keyType,
				s = this._def.valueType,
				o = [...n.data.entries()].map(([a, l], c) => ({
					key: i._parse(new za(n, a, n.path, [c, "key"])),
					value: s._parse(new za(n, l, n.path, [c, "value"])),
				}))
			if (n.common.async) {
				let a = new Map()
				return Promise.resolve().then(async () => {
					for (let l of o) {
						let c = await l.key,
							u = await l.value
						if (c.status === "aborted" || u.status === "aborted") return vt
						;(c.status === "dirty" || u.status === "dirty") && r.dirty(), a.set(c.value, u.value)
					}
					return { status: r.value, value: a }
				})
			} else {
				let a = new Map()
				for (let l of o) {
					let c = l.key,
						u = l.value
					if (c.status === "aborted" || u.status === "aborted") return vt
					;(c.status === "dirty" || u.status === "dirty") && r.dirty(), a.set(c.value, u.value)
				}
				return { status: r.value, value: a }
			}
		}
	}
sm.create = (e, t, r) => new sm({ valueType: t, keyType: e, typeName: At.ZodMap, ...Nt(r) })
var om = class e extends Pt {
	_parse(t) {
		let { status: r, ctx: n } = this._processInputParams(t)
		if (n.parsedType !== Pe.set)
			return (
				Re(n, {
					code: ve.invalid_type,
					expected: Pe.set,
					received: n.parsedType,
				}),
				vt
			)
		let i = this._def
		i.minSize !== null &&
			n.data.size < i.minSize.value &&
			(Re(n, {
				code: ve.too_small,
				minimum: i.minSize.value,
				type: "set",
				inclusive: !0,
				exact: !1,
				message: i.minSize.message,
			}),
			r.dirty()),
			i.maxSize !== null &&
				n.data.size > i.maxSize.value &&
				(Re(n, {
					code: ve.too_big,
					maximum: i.maxSize.value,
					type: "set",
					inclusive: !0,
					exact: !1,
					message: i.maxSize.message,
				}),
				r.dirty())
		let s = this._def.valueType
		function o(l) {
			let c = new Set()
			for (let u of l) {
				if (u.status === "aborted") return vt
				u.status === "dirty" && r.dirty(), c.add(u.value)
			}
			return { status: r.value, value: c }
		}
		let a = [...n.data.values()].map((l, c) => s._parse(new za(n, l, n.path, c)))
		return n.common.async ? Promise.all(a).then((l) => o(l)) : o(a)
	}
	min(t, r) {
		return new e({
			...this._def,
			minSize: { value: t, message: $e.toString(r) },
		})
	}
	max(t, r) {
		return new e({
			...this._def,
			maxSize: { value: t, message: $e.toString(r) },
		})
	}
	size(t, r) {
		return this.min(t, r).max(t, r)
	}
	nonempty(t) {
		return this.min(1, t)
	}
}
om.create = (e, t) =>
	new om({
		valueType: e,
		minSize: null,
		maxSize: null,
		typeName: At.ZodSet,
		...Nt(t),
	})
var TI = class e extends Pt {
		constructor() {
			super(...arguments), (this.validate = this.implement)
		}
		_parse(t) {
			let { ctx: r } = this._processInputParams(t)
			if (r.parsedType !== Pe.function)
				return (
					Re(r, {
						code: ve.invalid_type,
						expected: Pe.function,
						received: r.parsedType,
					}),
					vt
				)
			function n(a, l) {
				return II({
					data: a,
					path: r.path,
					errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, wI(), rm].filter((c) => !!c),
					issueData: { code: ve.invalid_arguments, argumentsError: l },
				})
			}
			function i(a, l) {
				return II({
					data: a,
					path: r.path,
					errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, wI(), rm].filter((c) => !!c),
					issueData: { code: ve.invalid_return_type, returnTypeError: l },
				})
			}
			let s = { errorMap: r.common.contextualErrorMap },
				o = r.data
			if (this._def.returns instanceof Ff) {
				let a = this
				return ro(async function (...l) {
					let c = new ua([]),
						u = await a._def.args.parseAsync(l, s).catch((g) => {
							throw (c.addIssue(n(l, g)), c)
						}),
						f = await Reflect.apply(o, this, u)
					return await a._def.returns._def.type.parseAsync(f, s).catch((g) => {
						throw (c.addIssue(i(f, g)), c)
					})
				})
			} else {
				let a = this
				return ro(function (...l) {
					let c = a._def.args.safeParse(l, s)
					if (!c.success) throw new ua([n(l, c.error)])
					let u = Reflect.apply(o, this, c.data),
						f = a._def.returns.safeParse(u, s)
					if (!f.success) throw new ua([i(u, f.error)])
					return f.data
				})
			}
		}
		parameters() {
			return this._def.args
		}
		returnType() {
			return this._def.returns
		}
		args(...t) {
			return new e({ ...this._def, args: Yc.create(t).rest(yd.create()) })
		}
		returns(t) {
			return new e({ ...this._def, returns: t })
		}
		implement(t) {
			return this.parse(t)
		}
		strictImplement(t) {
			return this.parse(t)
		}
		static create(t, r, n) {
			return new e({
				args: t || Yc.create([]).rest(yd.create()),
				returns: r || yd.create(),
				typeName: At.ZodFunction,
				...Nt(n),
			})
		}
	},
	Fg = class extends Pt {
		get schema() {
			return this._def.getter()
		}
		_parse(t) {
			let { ctx: r } = this._processInputParams(t)
			return this._def.getter()._parse({ data: r.data, path: r.path, parent: r })
		}
	}
Fg.create = (e, t) => new Fg({ getter: e, typeName: At.ZodLazy, ...Nt(t) })
var Qg = class extends Pt {
	_parse(t) {
		if (t.data !== this._def.value) {
			let r = this._getOrReturnCtx(t)
			return (
				Re(r, {
					received: r.data,
					code: ve.invalid_literal,
					expected: this._def.value,
				}),
				vt
			)
		}
		return { status: "valid", value: t.data }
	}
	get value() {
		return this._def.value
	}
}
Qg.create = (e, t) => new Qg({ value: e, typeName: At.ZodLiteral, ...Nt(t) })
function EY(e, t) {
	return new Ng({ values: e, typeName: At.ZodEnum, ...Nt(t) })
}
var Ng = class e extends Pt {
	constructor() {
		super(...arguments), kv.set(this, void 0)
	}
	_parse(t) {
		if (typeof t.data != "string") {
			let r = this._getOrReturnCtx(t),
				n = this._def.values
			return (
				Re(r, {
					expected: vr.joinValues(n),
					received: r.parsedType,
					code: ve.invalid_type,
				}),
				vt
			)
		}
		if ((SI(this, kv, "f") || mY(this, kv, new Set(this._def.values), "f"), !SI(this, kv, "f").has(t.data))) {
			let r = this._getOrReturnCtx(t),
				n = this._def.values
			return Re(r, { received: r.data, code: ve.invalid_enum_value, options: n }), vt
		}
		return ro(t.data)
	}
	get options() {
		return this._def.values
	}
	get enum() {
		let t = {}
		for (let r of this._def.values) t[r] = r
		return t
	}
	get Values() {
		let t = {}
		for (let r of this._def.values) t[r] = r
		return t
	}
	get Enum() {
		let t = {}
		for (let r of this._def.values) t[r] = r
		return t
	}
	extract(t, r = this._def) {
		return e.create(t, { ...this._def, ...r })
	}
	exclude(t, r = this._def) {
		return e.create(
			this.options.filter((n) => !t.includes(n)),
			{ ...this._def, ...r },
		)
	}
}
kv = new WeakMap()
Ng.create = EY
var Pg = class extends Pt {
	constructor() {
		super(...arguments), Mv.set(this, void 0)
	}
	_parse(t) {
		let r = vr.getValidEnumValues(this._def.values),
			n = this._getOrReturnCtx(t)
		if (n.parsedType !== Pe.string && n.parsedType !== Pe.number) {
			let i = vr.objectValues(r)
			return (
				Re(n, {
					expected: vr.joinValues(i),
					received: n.parsedType,
					code: ve.invalid_type,
				}),
				vt
			)
		}
		if (
			(SI(this, Mv, "f") || mY(this, Mv, new Set(vr.getValidEnumValues(this._def.values)), "f"),
			!SI(this, Mv, "f").has(t.data))
		) {
			let i = vr.objectValues(r)
			return Re(n, { received: n.data, code: ve.invalid_enum_value, options: i }), vt
		}
		return ro(t.data)
	}
	get enum() {
		return this._def.values
	}
}
Mv = new WeakMap()
Pg.create = (e, t) => new Pg({ values: e, typeName: At.ZodNativeEnum, ...Nt(t) })
var Ff = class extends Pt {
	unwrap() {
		return this._def.type
	}
	_parse(t) {
		let { ctx: r } = this._processInputParams(t)
		if (r.parsedType !== Pe.promise && r.common.async === !1)
			return (
				Re(r, {
					code: ve.invalid_type,
					expected: Pe.promise,
					received: r.parsedType,
				}),
				vt
			)
		let n = r.parsedType === Pe.promise ? r.data : Promise.resolve(r.data)
		return ro(
			n.then((i) =>
				this._def.type.parseAsync(i, {
					path: r.path,
					errorMap: r.common.contextualErrorMap,
				}),
			),
		)
	}
}
Ff.create = (e, t) => new Ff({ type: e, typeName: At.ZodPromise, ...Nt(t) })
var da = class extends Pt {
	innerType() {
		return this._def.schema
	}
	sourceType() {
		return this._def.schema._def.typeName === At.ZodEffects ? this._def.schema.sourceType() : this._def.schema
	}
	_parse(t) {
		let { status: r, ctx: n } = this._processInputParams(t),
			i = this._def.effect || null,
			s = {
				addIssue: (o) => {
					Re(n, o), o.fatal ? r.abort() : r.dirty()
				},
				get path() {
					return n.path
				},
			}
		if (((s.addIssue = s.addIssue.bind(s)), i.type === "preprocess")) {
			let o = i.transform(n.data, s)
			if (n.common.async)
				return Promise.resolve(o).then(async (a) => {
					if (r.value === "aborted") return vt
					let l = await this._def.schema._parseAsync({
						data: a,
						path: n.path,
						parent: n,
					})
					return l.status === "aborted" ? vt : l.status === "dirty" || r.value === "dirty" ? tm(l.value) : l
				})
			{
				if (r.value === "aborted") return vt
				let a = this._def.schema._parseSync({
					data: o,
					path: n.path,
					parent: n,
				})
				return a.status === "aborted" ? vt : a.status === "dirty" || r.value === "dirty" ? tm(a.value) : a
			}
		}
		if (i.type === "refinement") {
			let o = (a) => {
				let l = i.refinement(a, s)
				if (n.common.async) return Promise.resolve(l)
				if (l instanceof Promise)
					throw new Error(
						"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
					)
				return a
			}
			if (n.common.async === !1) {
				let a = this._def.schema._parseSync({
					data: n.data,
					path: n.path,
					parent: n,
				})
				return a.status === "aborted"
					? vt
					: (a.status === "dirty" && r.dirty(), o(a.value), { status: r.value, value: a.value })
			} else
				return this._def.schema
					._parseAsync({ data: n.data, path: n.path, parent: n })
					.then((a) =>
						a.status === "aborted"
							? vt
							: (a.status === "dirty" && r.dirty(),
								o(a.value).then(() => ({ status: r.value, value: a.value }))),
					)
		}
		if (i.type === "transform")
			if (n.common.async === !1) {
				let o = this._def.schema._parseSync({
					data: n.data,
					path: n.path,
					parent: n,
				})
				if (!wg(o)) return o
				let a = i.transform(o.value, s)
				if (a instanceof Promise)
					throw new Error(
						"Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.",
					)
				return { status: r.value, value: a }
			} else
				return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) =>
					wg(o)
						? Promise.resolve(i.transform(o.value, s)).then((a) => ({
								status: r.value,
								value: a,
							}))
						: o,
				)
		vr.assertNever(i)
	}
}
da.create = (e, t, r) => new da({ schema: e, typeName: At.ZodEffects, effect: t, ...Nt(r) })
da.createWithPreprocess = (e, t, r) =>
	new da({
		schema: t,
		effect: { type: "preprocess", transform: e },
		typeName: At.ZodEffects,
		...Nt(r),
	})
var Ja = class extends Pt {
	_parse(t) {
		return this._getType(t) === Pe.undefined ? ro(void 0) : this._def.innerType._parse(t)
	}
	unwrap() {
		return this._def.innerType
	}
}
Ja.create = (e, t) => new Ja({ innerType: e, typeName: At.ZodOptional, ...Nt(t) })
var Kc = class extends Pt {
	_parse(t) {
		return this._getType(t) === Pe.null ? ro(null) : this._def.innerType._parse(t)
	}
	unwrap() {
		return this._def.innerType
	}
}
Kc.create = (e, t) => new Kc({ innerType: e, typeName: At.ZodNullable, ...Nt(t) })
var Lg = class extends Pt {
	_parse(t) {
		let { ctx: r } = this._processInputParams(t),
			n = r.data
		return (
			r.parsedType === Pe.undefined && (n = this._def.defaultValue()),
			this._def.innerType._parse({ data: n, path: r.path, parent: r })
		)
	}
	removeDefault() {
		return this._def.innerType
	}
}
Lg.create = (e, t) =>
	new Lg({
		innerType: e,
		typeName: At.ZodDefault,
		defaultValue: typeof t.default == "function" ? t.default : () => t.default,
		...Nt(t),
	})
var Ug = class extends Pt {
	_parse(t) {
		let { ctx: r } = this._processInputParams(t),
			n = { ...r, common: { ...r.common, issues: [] } },
			i = this._def.innerType._parse({
				data: n.data,
				path: n.path,
				parent: { ...n },
			})
		return Fv(i)
			? i.then((s) => ({
					status: "valid",
					value:
						s.status === "valid"
							? s.value
							: this._def.catchValue({
									get error() {
										return new ua(n.common.issues)
									},
									input: n.data,
								}),
				}))
			: {
					status: "valid",
					value:
						i.status === "valid"
							? i.value
							: this._def.catchValue({
									get error() {
										return new ua(n.common.issues)
									},
									input: n.data,
								}),
				}
	}
	removeCatch() {
		return this._def.innerType
	}
}
Ug.create = (e, t) =>
	new Ug({
		innerType: e,
		typeName: At.ZodCatch,
		catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
		...Nt(t),
	})
var am = class extends Pt {
	_parse(t) {
		if (this._getType(t) !== Pe.nan) {
			let n = this._getOrReturnCtx(t)
			return (
				Re(n, {
					code: ve.invalid_type,
					expected: Pe.nan,
					received: n.parsedType,
				}),
				vt
			)
		}
		return { status: "valid", value: t.data }
	}
}
am.create = (e) => new am({ typeName: At.ZodNaN, ...Nt(e) })
var YMe = Symbol("zod_brand"),
	Qv = class extends Pt {
		_parse(t) {
			let { ctx: r } = this._processInputParams(t),
				n = r.data
			return this._def.type._parse({ data: n, path: r.path, parent: r })
		}
		unwrap() {
			return this._def.type
		}
	},
	Nv = class e extends Pt {
		_parse(t) {
			let { status: r, ctx: n } = this._processInputParams(t)
			if (n.common.async)
				return (async () => {
					let s = await this._def.in._parseAsync({
						data: n.data,
						path: n.path,
						parent: n,
					})
					return s.status === "aborted"
						? vt
						: s.status === "dirty"
							? (r.dirty(), tm(s.value))
							: this._def.out._parseAsync({
									data: s.value,
									path: n.path,
									parent: n,
								})
				})()
			{
				let i = this._def.in._parseSync({
					data: n.data,
					path: n.path,
					parent: n,
				})
				return i.status === "aborted"
					? vt
					: i.status === "dirty"
						? (r.dirty(), { status: "dirty", value: i.value })
						: this._def.out._parseSync({
								data: i.value,
								path: n.path,
								parent: n,
							})
			}
		}
		static create(t, r) {
			return new e({ in: t, out: r, typeName: At.ZodPipeline })
		}
	},
	Og = class extends Pt {
		_parse(t) {
			let r = this._def.innerType._parse(t),
				n = (i) => (wg(i) && (i.value = Object.freeze(i.value)), i)
			return Fv(r) ? r.then((i) => n(i)) : n(r)
		}
		unwrap() {
			return this._def.innerType
		}
	}
Og.create = (e, t) => new Og({ innerType: e, typeName: At.ZodReadonly, ...Nt(t) })
function bY(e, t = {}, r) {
	return e
		? Mf.create().superRefine((n, i) => {
				var s, o
				if (!e(n)) {
					let a = typeof t == "function" ? t(n) : typeof t == "string" ? { message: t } : t,
						l = (o = (s = a.fatal) !== null && s !== void 0 ? s : r) !== null && o !== void 0 ? o : !0,
						c = typeof a == "string" ? { message: a } : a
					i.addIssue({ code: "custom", ...c, fatal: l })
				}
			})
		: Mf.create()
}
var KMe = { object: To.lazycreate },
	At
;(function (e) {
	;(e.ZodString = "ZodString"),
		(e.ZodNumber = "ZodNumber"),
		(e.ZodNaN = "ZodNaN"),
		(e.ZodBigInt = "ZodBigInt"),
		(e.ZodBoolean = "ZodBoolean"),
		(e.ZodDate = "ZodDate"),
		(e.ZodSymbol = "ZodSymbol"),
		(e.ZodUndefined = "ZodUndefined"),
		(e.ZodNull = "ZodNull"),
		(e.ZodAny = "ZodAny"),
		(e.ZodUnknown = "ZodUnknown"),
		(e.ZodNever = "ZodNever"),
		(e.ZodVoid = "ZodVoid"),
		(e.ZodArray = "ZodArray"),
		(e.ZodObject = "ZodObject"),
		(e.ZodUnion = "ZodUnion"),
		(e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
		(e.ZodIntersection = "ZodIntersection"),
		(e.ZodTuple = "ZodTuple"),
		(e.ZodRecord = "ZodRecord"),
		(e.ZodMap = "ZodMap"),
		(e.ZodSet = "ZodSet"),
		(e.ZodFunction = "ZodFunction"),
		(e.ZodLazy = "ZodLazy"),
		(e.ZodLiteral = "ZodLiteral"),
		(e.ZodEnum = "ZodEnum"),
		(e.ZodEffects = "ZodEffects"),
		(e.ZodNativeEnum = "ZodNativeEnum"),
		(e.ZodOptional = "ZodOptional"),
		(e.ZodNullable = "ZodNullable"),
		(e.ZodDefault = "ZodDefault"),
		(e.ZodCatch = "ZodCatch"),
		(e.ZodPromise = "ZodPromise"),
		(e.ZodBranded = "ZodBranded"),
		(e.ZodPipeline = "ZodPipeline"),
		(e.ZodReadonly = "ZodReadonly")
})(At || (At = {}))
var JMe = (e, t = { message: `Input not instance of ${e.name}` }) => bY((r) => r instanceof e, t),
	xY = kf.create,
	_Y = Ig.create,
	zMe = am.create,
	jMe = Sg.create,
	wY = Bg.create,
	ZMe = Dg.create,
	XMe = nm.create,
	eFe = Tg.create,
	tFe = Rg.create,
	rFe = Mf.create,
	nFe = yd.create,
	iFe = zl.create,
	sFe = im.create,
	oFe = Cd.create,
	aFe = To.create,
	lFe = To.strictCreate,
	cFe = kg.create,
	uFe = BI.create,
	dFe = Mg.create,
	fFe = Yc.create,
	hFe = DI.create,
	gFe = sm.create,
	pFe = om.create,
	AFe = TI.create,
	mFe = Fg.create,
	yFe = Qg.create,
	CFe = Ng.create,
	vFe = Pg.create,
	EFe = Ff.create,
	pY = da.create,
	bFe = Ja.create,
	xFe = Kc.create,
	_Fe = da.createWithPreprocess,
	wFe = Nv.create,
	IFe = () => xY().optional(),
	SFe = () => _Y().optional(),
	BFe = () => wY().optional(),
	DFe = {
		string: (e) => kf.create({ ...e, coerce: !0 }),
		number: (e) => Ig.create({ ...e, coerce: !0 }),
		boolean: (e) => Bg.create({ ...e, coerce: !0 }),
		bigint: (e) => Sg.create({ ...e, coerce: !0 }),
		date: (e) => Dg.create({ ...e, coerce: !0 }),
	},
	TFe = vt,
	R = Object.freeze({
		__proto__: null,
		defaultErrorMap: rm,
		setErrorMap: _Me,
		getErrorMap: wI,
		makeIssue: II,
		EMPTY_PATH: wMe,
		addIssueToContext: Re,
		ParseStatus: Ms,
		INVALID: vt,
		DIRTY: tm,
		OK: ro,
		isAborted: pP,
		isDirty: AP,
		isValid: wg,
		isAsync: Fv,
		get util() {
			return vr
		},
		get objectUtil() {
			return gP
		},
		ZodParsedType: Pe,
		getParsedType: md,
		ZodType: Pt,
		datetimeRegex: vY,
		ZodString: kf,
		ZodNumber: Ig,
		ZodBigInt: Sg,
		ZodBoolean: Bg,
		ZodDate: Dg,
		ZodSymbol: nm,
		ZodUndefined: Tg,
		ZodNull: Rg,
		ZodAny: Mf,
		ZodUnknown: yd,
		ZodNever: zl,
		ZodVoid: im,
		ZodArray: Cd,
		ZodObject: To,
		ZodUnion: kg,
		ZodDiscriminatedUnion: BI,
		ZodIntersection: Mg,
		ZodTuple: Yc,
		ZodRecord: DI,
		ZodMap: sm,
		ZodSet: om,
		ZodFunction: TI,
		ZodLazy: Fg,
		ZodLiteral: Qg,
		ZodEnum: Ng,
		ZodNativeEnum: Pg,
		ZodPromise: Ff,
		ZodEffects: da,
		ZodTransformer: da,
		ZodOptional: Ja,
		ZodNullable: Kc,
		ZodDefault: Lg,
		ZodCatch: Ug,
		ZodNaN: am,
		BRAND: YMe,
		ZodBranded: Qv,
		ZodPipeline: Nv,
		ZodReadonly: Og,
		custom: bY,
		Schema: Pt,
		ZodSchema: Pt,
		late: KMe,
		get ZodFirstPartyTypeKind() {
			return At
		},
		coerce: DFe,
		any: rFe,
		array: oFe,
		bigint: jMe,
		boolean: wY,
		date: ZMe,
		discriminatedUnion: uFe,
		effect: pY,
		enum: CFe,
		function: AFe,
		instanceof: JMe,
		intersection: dFe,
		lazy: mFe,
		literal: yFe,
		map: gFe,
		nan: zMe,
		nativeEnum: vFe,
		never: iFe,
		null: tFe,
		nullable: xFe,
		number: _Y,
		object: aFe,
		oboolean: BFe,
		onumber: SFe,
		optional: bFe,
		ostring: IFe,
		pipeline: wFe,
		preprocess: _Fe,
		promise: EFe,
		record: hFe,
		set: pFe,
		strictObject: lFe,
		string: xY,
		symbol: XMe,
		transformer: pY,
		tuple: fFe,
		undefined: eFe,
		union: cFe,
		unknown: nFe,
		void: sFe,
		NEVER: TFe,
		ZodIssueCode: ve,
		quotelessJson: xMe,
		ZodError: ua,
	})
var yP = "2024-11-05",
	IY = [yP, "2024-10-07"],
	RI = "2.0",
	SY = R.union([R.string(), R.number().int()]),
	BY = R.string(),
	jl = R.object({
		_meta: R.optional(R.object({ progressToken: R.optional(SY) }).passthrough()),
	}).passthrough(),
	fa = R.object({ method: R.string(), params: R.optional(jl) }),
	Pv = R.object({
		_meta: R.optional(R.object({}).passthrough()),
	}).passthrough(),
	Jc = R.object({ method: R.string(), params: R.optional(Pv) }),
	Zl = R.object({
		_meta: R.optional(R.object({}).passthrough()),
	}).passthrough(),
	kI = R.union([R.string(), R.number().int()]),
	RFe = R.object({ jsonrpc: R.literal(RI), id: kI })
		.merge(fa)
		.strict(),
	kFe = R.object({ jsonrpc: R.literal(RI) })
		.merge(Jc)
		.strict(),
	MFe = R.object({ jsonrpc: R.literal(RI), id: kI, result: Zl }).strict(),
	qg
;(function (e) {
	;(e[(e.ConnectionClosed = -1)] = "ConnectionClosed"),
		(e[(e.RequestTimeout = -2)] = "RequestTimeout"),
		(e[(e.ParseError = -32700)] = "ParseError"),
		(e[(e.InvalidRequest = -32600)] = "InvalidRequest"),
		(e[(e.MethodNotFound = -32601)] = "MethodNotFound"),
		(e[(e.InvalidParams = -32602)] = "InvalidParams"),
		(e[(e.InternalError = -32603)] = "InternalError")
})(qg || (qg = {}))
var FFe = R.object({
		jsonrpc: R.literal(RI),
		id: kI,
		error: R.object({
			code: R.number().int(),
			message: R.string(),
			data: R.optional(R.unknown()),
		}),
	}).strict(),
	DY = R.union([RFe, kFe, MFe, FFe]),
	Vg = Zl.strict(),
	MI = Jc.extend({
		method: R.literal("notifications/cancelled"),
		params: Pv.extend({ requestId: kI, reason: R.string().optional() }),
	}),
	TY = R.object({ name: R.string(), version: R.string() }).passthrough(),
	QFe = R.object({
		experimental: R.optional(R.object({}).passthrough()),
		sampling: R.optional(R.object({}).passthrough()),
		roots: R.optional(R.object({ listChanged: R.optional(R.boolean()) }).passthrough()),
	}).passthrough(),
	NFe = fa.extend({
		method: R.literal("initialize"),
		params: jl.extend({
			protocolVersion: R.string(),
			capabilities: QFe,
			clientInfo: TY,
		}),
	}),
	PFe = R.object({
		experimental: R.optional(R.object({}).passthrough()),
		logging: R.optional(R.object({}).passthrough()),
		prompts: R.optional(R.object({ listChanged: R.optional(R.boolean()) }).passthrough()),
		resources: R.optional(
			R.object({
				subscribe: R.optional(R.boolean()),
				listChanged: R.optional(R.boolean()),
			}).passthrough(),
		),
		tools: R.optional(R.object({ listChanged: R.optional(R.boolean()) }).passthrough()),
	}).passthrough(),
	CP = Zl.extend({
		protocolVersion: R.string(),
		capabilities: PFe,
		serverInfo: TY,
	}),
	LFe = Jc.extend({ method: R.literal("notifications/initialized") }),
	FI = fa.extend({ method: R.literal("ping") }),
	UFe = R.object({
		progress: R.number(),
		total: R.optional(R.number()),
	}).passthrough(),
	QI = Jc.extend({
		method: R.literal("notifications/progress"),
		params: Pv.merge(UFe).extend({ progressToken: SY }),
	}),
	NI = fa.extend({ params: jl.extend({ cursor: R.optional(BY) }).optional() }),
	PI = Zl.extend({ nextCursor: R.optional(BY) }),
	RY = R.object({
		uri: R.string(),
		mimeType: R.optional(R.string()),
	}).passthrough(),
	kY = RY.extend({ text: R.string() }),
	MY = RY.extend({ blob: R.string().base64() }),
	OFe = R.object({
		uri: R.string(),
		name: R.string(),
		description: R.optional(R.string()),
		mimeType: R.optional(R.string()),
	}).passthrough(),
	qFe = R.object({
		uriTemplate: R.string(),
		name: R.string(),
		description: R.optional(R.string()),
		mimeType: R.optional(R.string()),
	}).passthrough(),
	VFe = NI.extend({ method: R.literal("resources/list") }),
	vP = PI.extend({ resources: R.array(OFe) }),
	HFe = NI.extend({ method: R.literal("resources/templates/list") }),
	EP = PI.extend({ resourceTemplates: R.array(qFe) }),
	WFe = fa.extend({
		method: R.literal("resources/read"),
		params: jl.extend({ uri: R.string() }),
	}),
	bP = Zl.extend({ contents: R.array(R.union([kY, MY])) }),
	GFe = Jc.extend({
		method: R.literal("notifications/resources/list_changed"),
	}),
	$Fe = fa.extend({
		method: R.literal("resources/subscribe"),
		params: jl.extend({ uri: R.string() }),
	}),
	YFe = fa.extend({
		method: R.literal("resources/unsubscribe"),
		params: jl.extend({ uri: R.string() }),
	}),
	KFe = Jc.extend({
		method: R.literal("notifications/resources/updated"),
		params: Pv.extend({ uri: R.string() }),
	}),
	JFe = R.object({
		name: R.string(),
		description: R.optional(R.string()),
		required: R.optional(R.boolean()),
	}).passthrough(),
	zFe = R.object({
		name: R.string(),
		description: R.optional(R.string()),
		arguments: R.optional(R.array(JFe)),
	}).passthrough(),
	jFe = NI.extend({ method: R.literal("prompts/list") }),
	xP = PI.extend({ prompts: R.array(zFe) }),
	ZFe = fa.extend({
		method: R.literal("prompts/get"),
		params: jl.extend({
			name: R.string(),
			arguments: R.optional(R.record(R.string())),
		}),
	}),
	LI = R.object({ type: R.literal("text"), text: R.string() }).passthrough(),
	UI = R.object({
		type: R.literal("image"),
		data: R.string().base64(),
		mimeType: R.string(),
	}).passthrough(),
	FY = R.object({
		type: R.literal("resource"),
		resource: R.union([kY, MY]),
	}).passthrough(),
	XFe = R.object({
		role: R.enum(["user", "assistant"]),
		content: R.union([LI, UI, FY]),
	}).passthrough(),
	_P = Zl.extend({
		description: R.optional(R.string()),
		messages: R.array(XFe),
	}),
	e1e = Jc.extend({ method: R.literal("notifications/prompts/list_changed") }),
	t1e = R.object({
		name: R.string(),
		description: R.optional(R.string()),
		inputSchema: R.object({
			type: R.literal("object"),
			properties: R.optional(R.object({}).passthrough()),
		}).passthrough(),
	}).passthrough(),
	r1e = NI.extend({ method: R.literal("tools/list") }),
	wP = PI.extend({ tools: R.array(t1e) }),
	cm = Zl.extend({
		content: R.array(R.union([LI, UI, FY])),
		isError: R.boolean().default(!1).optional(),
	}),
	dEt = cm.or(Zl.extend({ toolResult: R.unknown() })),
	n1e = fa.extend({
		method: R.literal("tools/call"),
		params: jl.extend({
			name: R.string(),
			arguments: R.optional(R.record(R.unknown())),
		}),
	}),
	i1e = Jc.extend({ method: R.literal("notifications/tools/list_changed") }),
	QY = R.enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]),
	s1e = fa.extend({
		method: R.literal("logging/setLevel"),
		params: jl.extend({ level: QY }),
	}),
	o1e = Jc.extend({
		method: R.literal("notifications/message"),
		params: Pv.extend({
			level: QY,
			logger: R.optional(R.string()),
			data: R.unknown(),
		}),
	}),
	a1e = R.object({ name: R.string().optional() }).passthrough(),
	l1e = R.object({
		hints: R.optional(R.array(a1e)),
		costPriority: R.optional(R.number().min(0).max(1)),
		speedPriority: R.optional(R.number().min(0).max(1)),
		intelligencePriority: R.optional(R.number().min(0).max(1)),
	}).passthrough(),
	c1e = R.object({
		role: R.enum(["user", "assistant"]),
		content: R.union([LI, UI]),
	}).passthrough(),
	u1e = fa.extend({
		method: R.literal("sampling/createMessage"),
		params: jl.extend({
			messages: R.array(c1e),
			systemPrompt: R.optional(R.string()),
			includeContext: R.optional(R.enum(["none", "thisServer", "allServers"])),
			temperature: R.optional(R.number()),
			maxTokens: R.number().int(),
			stopSequences: R.optional(R.array(R.string())),
			metadata: R.optional(R.object({}).passthrough()),
			modelPreferences: R.optional(l1e),
		}),
	}),
	d1e = Zl.extend({
		model: R.string(),
		stopReason: R.optional(R.enum(["endTurn", "stopSequence", "maxTokens"]).or(R.string())),
		role: R.enum(["user", "assistant"]),
		content: R.discriminatedUnion("type", [LI, UI]),
	}),
	f1e = R.object({
		type: R.literal("ref/resource"),
		uri: R.string(),
	}).passthrough(),
	h1e = R.object({
		type: R.literal("ref/prompt"),
		name: R.string(),
	}).passthrough(),
	g1e = fa.extend({
		method: R.literal("completion/complete"),
		params: jl.extend({
			ref: R.union([h1e, f1e]),
			argument: R.object({ name: R.string(), value: R.string() }).passthrough(),
		}),
	}),
	IP = Zl.extend({
		completion: R.object({
			values: R.array(R.string()).max(100),
			total: R.optional(R.number().int()),
			hasMore: R.optional(R.boolean()),
		}).passthrough(),
	}),
	p1e = R.object({
		uri: R.string().startsWith("file://"),
		name: R.optional(R.string()),
	}).passthrough(),
	A1e = fa.extend({ method: R.literal("roots/list") }),
	m1e = Zl.extend({ roots: R.array(p1e) }),
	y1e = Jc.extend({ method: R.literal("notifications/roots/list_changed") }),
	fEt = R.union([FI, NFe, g1e, s1e, ZFe, jFe, VFe, HFe, WFe, $Fe, YFe, n1e, r1e]),
	hEt = R.union([MI, QI, LFe, y1e]),
	gEt = R.union([Vg, d1e, m1e]),
	pEt = R.union([FI, u1e, A1e]),
	AEt = R.union([MI, QI, o1e, KFe, GFe, i1e, e1e]),
	mEt = R.union([Vg, CP, IP, _P, xP, vP, EP, bP, cm, wP]),
	lm = class extends Error {
		code
		data
		constructor(t, r, n) {
			super(`MCP error ${t}: ${r}`), (this.code = t), (this.data = n)
		}
	}
var C1e = 6e4,
	OI = class {
		_options
		_transport
		_requestMessageId = 0
		_requestHandlers = new Map()
		_requestHandlerAbortControllers = new Map()
		_notificationHandlers = new Map()
		_responseHandlers = new Map()
		_progressHandlers = new Map()
		onclose
		onerror
		fallbackRequestHandler
		fallbackNotificationHandler
		constructor(t) {
			;(this._options = t),
				this.setNotificationHandler(MI, (r) => {
					this._requestHandlerAbortControllers.get(r.params.requestId)?.abort(r.params.reason)
				}),
				this.setNotificationHandler(QI, (r) => {
					this._onprogress(r)
				}),
				this.setRequestHandler(FI, (r) => ({}))
		}
		async connect(t) {
			;(this._transport = t),
				(this._transport.onclose = () => {
					this._onclose()
				}),
				(this._transport.onerror = (r) => {
					this._onerror(r)
				}),
				(this._transport.onmessage = (r) => {
					"method" in r ? ("id" in r ? this._onrequest(r) : this._onnotification(r)) : this._onresponse(r)
				}),
				await this._transport.start()
		}
		_onclose() {
			let t = this._responseHandlers
			;(this._responseHandlers = new Map()),
				this._progressHandlers.clear(),
				(this._transport = void 0),
				this.onclose?.()
			let r = new lm(qg.ConnectionClosed, "Connection closed")
			for (let n of t.values()) n(r)
		}
		_onerror(t) {
			this.onerror?.(t)
		}
		_onnotification(t) {
			let r = this._notificationHandlers.get(t.method) ?? this.fallbackNotificationHandler
			r !== void 0 &&
				Promise.resolve()
					.then(() => r(t))
					.catch((n) => this._onerror(new Error(`Uncaught error in notification handler: ${n}`)))
		}
		_onrequest(t) {
			let r = this._requestHandlers.get(t.method) ?? this.fallbackRequestHandler
			if (r === void 0) {
				this._transport
					?.send({
						jsonrpc: "2.0",
						id: t.id,
						error: { code: qg.MethodNotFound, message: "Method not found" },
					})
					.catch((i) => this._onerror(new Error(`Failed to send an error response: ${i}`)))
				return
			}
			let n = new AbortController()
			this._requestHandlerAbortControllers.set(t.id, n),
				Promise.resolve()
					.then(() => r(t, { signal: n.signal }))
					.then(
						(i) => {
							if (!n.signal.aborted)
								return this._transport?.send({
									result: i,
									jsonrpc: "2.0",
									id: t.id,
								})
						},
						(i) => {
							if (!n.signal.aborted)
								return this._transport?.send({
									jsonrpc: "2.0",
									id: t.id,
									error: {
										code: Number.isSafeInteger(i.code) ? i.code : qg.InternalError,
										message: i.message ?? "Internal error",
									},
								})
						},
					)
					.catch((i) => this._onerror(new Error(`Failed to send response: ${i}`)))
					.finally(() => {
						this._requestHandlerAbortControllers.delete(t.id)
					})
		}
		_onprogress(t) {
			let { progressToken: r, ...n } = t.params,
				i = this._progressHandlers.get(Number(r))
			if (i === void 0) {
				this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(t)}`))
				return
			}
			i(n)
		}
		_onresponse(t) {
			let r = t.id,
				n = this._responseHandlers.get(Number(r))
			if (n === void 0) {
				this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(t)}`))
				return
			}
			if ((this._responseHandlers.delete(Number(r)), this._progressHandlers.delete(Number(r)), "result" in t))
				n(t)
			else {
				let i = new lm(t.error.code, t.error.message, t.error.data)
				n(i)
			}
		}
		get transport() {
			return this._transport
		}
		async close() {
			await this._transport?.close()
		}
		request(t, r, n) {
			return new Promise((i, s) => {
				if (!this._transport) {
					s(new Error("Not connected"))
					return
				}
				this._options?.enforceStrictCapabilities === !0 && this.assertCapabilityForMethod(t.method),
					n?.signal?.throwIfAborted()
				let o = this._requestMessageId++,
					a = { ...t, jsonrpc: "2.0", id: o }
				n?.onprogress &&
					(this._progressHandlers.set(o, n.onprogress),
					(a.params = { ...t.params, _meta: { progressToken: o } }))
				let l
				this._responseHandlers.set(o, (f) => {
					if ((l !== void 0 && clearTimeout(l), !n?.signal?.aborted)) {
						if (f instanceof Error) return s(f)
						try {
							let p = r.parse(f.result)
							i(p)
						} catch (p) {
							s(p)
						}
					}
				})
				let c = (f) => {
					this._responseHandlers.delete(o),
						this._progressHandlers.delete(o),
						this._transport
							?.send({
								jsonrpc: "2.0",
								method: "notifications/cancelled",
								params: { requestId: o, reason: String(f) },
							})
							.catch((p) => this._onerror(new Error(`Failed to send cancellation: ${p}`))),
						s(f)
				}
				n?.signal?.addEventListener("abort", () => {
					l !== void 0 && clearTimeout(l), c(n?.signal?.reason)
				})
				let u = n?.timeout ?? C1e
				;(l = setTimeout(() => c(new lm(qg.RequestTimeout, "Request timed out", { timeout: u })), u)),
					this._transport.send(a).catch((f) => {
						l !== void 0 && clearTimeout(l), s(f)
					})
			})
		}
		async notification(t) {
			if (!this._transport) throw new Error("Not connected")
			this.assertNotificationCapability(t.method)
			let r = { ...t, jsonrpc: "2.0" }
			await this._transport.send(r)
		}
		setRequestHandler(t, r) {
			let n = t.shape.method.value
			this.assertRequestHandlerCapability(n),
				this._requestHandlers.set(n, (i, s) => Promise.resolve(r(t.parse(i), s)))
		}
		removeRequestHandler(t) {
			this._requestHandlers.delete(t)
		}
		setNotificationHandler(t, r) {
			this._notificationHandlers.set(t.shape.method.value, (n) => Promise.resolve(r(t.parse(n))))
		}
		removeNotificationHandler(t) {
			this._notificationHandlers.delete(t)
		}
	}
var qI = class extends OI {
	_clientInfo
	_serverCapabilities
	_serverVersion
	_capabilities
	constructor(t, r) {
		super(r), (this._clientInfo = t), (this._capabilities = r.capabilities)
	}
	assertCapability(t, r) {
		if (!this._serverCapabilities?.[t]) throw new Error(`Server does not support ${t} (required for ${r})`)
	}
	async connect(t) {
		await super.connect(t)
		try {
			let r = await this.request(
				{
					method: "initialize",
					params: {
						protocolVersion: yP,
						capabilities: this._capabilities,
						clientInfo: this._clientInfo,
					},
				},
				CP,
			)
			if (r === void 0) throw new Error(`Server sent invalid initialize result: ${r}`)
			if (!IY.includes(r.protocolVersion))
				throw new Error(`Server's protocol version is not supported: ${r.protocolVersion}`)
			;(this._serverCapabilities = r.capabilities),
				(this._serverVersion = r.serverInfo),
				await this.notification({ method: "notifications/initialized" })
		} catch (r) {
			throw (this.close(), r)
		}
	}
	getServerCapabilities() {
		return this._serverCapabilities
	}
	getServerVersion() {
		return this._serverVersion
	}
	assertCapabilityForMethod(t) {
		switch (t) {
			case "logging/setLevel":
				if (!this._serverCapabilities?.logging)
					throw new Error(`Server does not support logging (required for ${t})`)
				break
			case "prompts/get":
			case "prompts/list":
				if (!this._serverCapabilities?.prompts)
					throw new Error(`Server does not support prompts (required for ${t})`)
				break
			case "resources/list":
			case "resources/templates/list":
			case "resources/read":
			case "resources/subscribe":
			case "resources/unsubscribe":
				if (!this._serverCapabilities?.resources)
					throw new Error(`Server does not support resources (required for ${t})`)
				if (t === "resources/subscribe" && !this._serverCapabilities.resources.subscribe)
					throw new Error(`Server does not support resource subscriptions (required for ${t})`)
				break
			case "tools/call":
			case "tools/list":
				if (!this._serverCapabilities?.tools)
					throw new Error(`Server does not support tools (required for ${t})`)
				break
			case "completion/complete":
				if (!this._serverCapabilities?.prompts)
					throw new Error(`Server does not support prompts (required for ${t})`)
				break
			case "initialize":
				break
			case "ping":
				break
		}
	}
	assertNotificationCapability(t) {
		switch (t) {
			case "notifications/roots/list_changed":
				if (!this._capabilities.roots?.listChanged)
					throw new Error(`Client does not support roots list changed notifications (required for ${t})`)
				break
			case "notifications/initialized":
				break
			case "notifications/cancelled":
				break
			case "notifications/progress":
				break
		}
	}
	assertRequestHandlerCapability(t) {
		switch (t) {
			case "sampling/createMessage":
				if (!this._capabilities.sampling)
					throw new Error(`Client does not support sampling capability (required for ${t})`)
				break
			case "roots/list":
				if (!this._capabilities.roots)
					throw new Error(`Client does not support roots capability (required for ${t})`)
				break
			case "ping":
				break
		}
	}
	async ping(t) {
		return this.request({ method: "ping" }, Vg, t)
	}
	async complete(t, r) {
		return this.request({ method: "completion/complete", params: t }, IP, r)
	}
	async setLoggingLevel(t, r) {
		return this.request({ method: "logging/setLevel", params: { level: t } }, Vg, r)
	}
	async getPrompt(t, r) {
		return this.request({ method: "prompts/get", params: t }, _P, r)
	}
	async listPrompts(t, r) {
		return this.request({ method: "prompts/list", params: t }, xP, r)
	}
	async listResources(t, r) {
		return this.request({ method: "resources/list", params: t }, vP, r)
	}
	async listResourceTemplates(t, r) {
		return this.request({ method: "resources/templates/list", params: t }, EP, r)
	}
	async readResource(t, r) {
		return this.request({ method: "resources/read", params: t }, bP, r)
	}
	async subscribeResource(t, r) {
		return this.request({ method: "resources/subscribe", params: t }, Vg, r)
	}
	async unsubscribeResource(t, r) {
		return this.request({ method: "resources/unsubscribe", params: t }, Vg, r)
	}
	async callTool(t, r = cm, n) {
		return this.request({ method: "tools/call", params: t }, r, n)
	}
	async listTools(t, r) {
		return this.request({ method: "tools/list", params: t }, wP, r)
	}
	async sendRootsListChanged() {
		return this.notification({ method: "notifications/roots/list_changed" })
	}
}
var PY = require("child_process"),
	Lv = W(require("process"))
var VI = class {
	_buffer
	append(t) {
		this._buffer = this._buffer ? Buffer.concat([this._buffer, t]) : t
	}
	readMessage() {
		if (!this._buffer) return null
		let t = this._buffer.indexOf(`
`)
		if (t === -1) return null
		let r = this._buffer.toString("utf8", 0, t)
		return (this._buffer = this._buffer.subarray(t + 1)), v1e(r)
	}
	clear() {
		this._buffer = void 0
	}
}
function v1e(e) {
	return DY.parse(JSON.parse(e))
}
function NY(e) {
	return (
		JSON.stringify(e) +
		`
`
	)
}
var E1e =
	Lv.default.platform === "win32"
		? [
				"APPDATA",
				"HOMEDRIVE",
				"HOMEPATH",
				"LOCALAPPDATA",
				"PATH",
				"PROCESSOR_ARCHITECTURE",
				"SYSTEMDRIVE",
				"SYSTEMROOT",
				"TEMP",
				"USERNAME",
				"USERPROFILE",
			]
		: ["HOME", "LOGNAME", "PATH", "SHELL", "TERM", "USER"]
function SP() {
	let e = {}
	for (let t of E1e) {
		let r = Lv.default.env[t]
		r !== void 0 && (r.startsWith("()") || (e[t] = r))
	}
	return e
}
var HI = class {
	_process
	_abortController = new AbortController()
	_readBuffer = new VI()
	_serverParams
	onclose
	onerror
	onmessage
	constructor(t) {
		this._serverParams = t
	}
	async start() {
		if (this._process)
			throw new Error(
				"StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.",
			)
		return new Promise((t, r) => {
			;(this._process = (0, PY.spawn)(this._serverParams.command, this._serverParams.args ?? [], {
				env: this._serverParams.env ?? SP(),
				stdio: ["pipe", "pipe", this._serverParams.stderr ?? "inherit"],
				shell: !1,
				signal: this._abortController.signal,
				windowsHide: Lv.default.platform === "win32" && b1e(),
			})),
				this._process.on("error", (n) => {
					if (n.name === "AbortError") {
						this.onclose?.()
						return
					}
					r(n), this.onerror?.(n)
				}),
				this._process.on("spawn", () => {
					t()
				}),
				this._process.on("close", (n) => {
					;(this._process = void 0), this.onclose?.()
				}),
				this._process.stdin?.on("error", (n) => {
					this.onerror?.(n)
				}),
				this._process.stdout?.on("data", (n) => {
					this._readBuffer.append(n), this.processReadBuffer()
				}),
				this._process.stdout?.on("error", (n) => {
					this.onerror?.(n)
				})
		})
	}
	get stderr() {
		return this._process?.stderr ?? null
	}
	processReadBuffer() {
		for (;;)
			try {
				let t = this._readBuffer.readMessage()
				if (t === null) break
				this.onmessage?.(t)
			} catch (t) {
				this.onerror?.(t)
			}
	}
	async close() {
		this._abortController.abort(), (this._process = void 0), this._readBuffer.clear()
	}
	send(t) {
		return new Promise((r) => {
			if (!this._process?.stdin) throw new Error("Not connected")
			let n = NY(t)
			this._process.stdin.write(n) ? r() : this._process.stdin.once("drain", r)
		})
	}
}
function b1e() {
	return "type" in Lv.default
}
var LY = W(gs())
var On
;(function (e) {
	;(e.readFile = "read-file"),
		(e.saveFile = "save-file"),
		(e.editFile = "edit-file"),
		(e.remember = "remember"),
		(e.clarify = "clarify"),
		(e.onboardingSubAgent = "onboarding-sub-agent"),
		(e.launchProcess = "launch-process"),
		(e.killProcess = "kill-process"),
		(e.readProcess = "read-process"),
		(e.writeProcess = "write-process"),
		(e.listProcesses = "list-processes"),
		(e.waitProcess = "wait-process"),
		(e.openBrowser = "open-browser")
})(On || (On = {}))
var Ro
;(function (e) {
	;(e.remoteToolHost = "remoteToolHost"),
		(e.localToolHost = "localToolHost"),
		(e.sidecarToolHost = "sidecarToolHost"),
		(e.mcpHost = "mcpHost")
})(Ro || (Ro = {}))
var xt
;(function (e) {
	;(e[(e.Unsafe = 0)] = "Unsafe"), (e[(e.Safe = 1)] = "Safe"), (e[(e.Check = 2)] = "Check")
})(xt || (xt = {}))
var rn = class {
		name
		toolSafety
		constructor(t, r) {
			;(this.name = t), (this.toolSafety = r)
		}
		version = 1
	},
	Li
;(function (e) {
	;(e[(e.Unknown = 0)] = "Unknown"),
		(e[(e.WebSearch = 1)] = "WebSearch"),
		(e[(e.GitHubApi = 8)] = "GitHubApi"),
		(e[(e.Linear = 12)] = "Linear"),
		(e[(e.Jira = 13)] = "Jira"),
		(e[(e.Confluence = 14)] = "Confluence"),
		(e[(e.Notion = 15)] = "Notion"),
		(e[(e.Supabase = 16)] = "Supabase")
})(Li || (Li = {}))
var dm
;(function (e) {
	;(e[(e.UnknownStatus = 0)] = "UnknownStatus"),
		(e[(e.Available = 1)] = "Available"),
		(e[(e.UserConfigRequired = 2)] = "UserConfigRequired")
})(dm || (dm = {}))
var Ov = class e {
	_config
	_onStartupError
	_client = void 0
	_initializingPromise
	_closingPromise = void 0
	_cancelledByUser = !1
	_toolDefinitions = void 0
	_runningTool = void 0
	_serverName
	_stdErrGenerator = void 0
	static maxTimeoutMs = 2147483647
	constructor(t, r = void 0, n) {
		;(this._config = t),
			(this._onStartupError = n),
			(this._client = new qI({ name: "augment-mcp-client", version: "1.0.0" }, { capabilities: {} })),
			this.validateConfig(t),
			(this._serverName =
				t.name && t.name.length > 0 ? this.sanitizeServerName(t.name) : this.extractServerName(t.command)),
			(this._initializingPromise = (async () => {
				if ((await r, this._closingPromise !== void 0)) throw new Error("Client is closing")
				if (this._client === void 0) throw new Error("Client is undefined")
				let i = this._config.command,
					s = this._config.args || []
				this._config.useShellInterpolation &&
					(process.platform === "win32"
						? ((s = ["/c", i]), (i = "cmd.exe"))
						: ((s = ["-c", i]), (i = "/bin/sh")))
				let o = new BP({
					command: i,
					args: s,
					env: { ...SP(), ...this._config.env },
					stderr: "pipe",
				})
				;(this._stdErrGenerator = o), await this._client.connect(o)
				let a = await this._client.listTools()
				this._toolDefinitions =
					a?.tools.map((l) => {
						let c = this.createNamespacedToolName(l.name)
						return {
							definition: {
								name: c,
								description: l.description ?? "",
								input_schema_json: JSON.stringify(l.inputSchema),
								tool_safety: xt.Unsafe,
							},
							identifier: { hostName: Ro.mcpHost, toolId: c },
							isConfigured: !0,
							enabled: !0,
							toolSafety: xt.Unsafe,
						}
					}) ?? []
			})()
				.catch((i) => {
					let s
					this._client !== void 0 &&
						this._stdErrGenerator !== void 0 &&
						(s = this._stdErrGenerator.capturedStderr),
						this._onStartupError({
							command: this._config.command,
							args: this._config.args,
							error: i instanceof Error ? i.message : String(i),
							...(s !== void 0 && { stderr: s }),
						})
				})
				.finally(() => {
					this._stdErrGenerator?.stopCapturing()
				}))
	}
	isRequestActive(t, r) {
		return this._runningTool?.requestId === t && this._runningTool?.toolUseId === r
	}
	close(t = !1) {
		return (
			this._closingPromise === void 0 &&
				((this._cancelledByUser = t),
				(this._closingPromise = (async () => {
					await (await this.getClient()).close()
				})())),
			this._closingPromise
		)
	}
	closeAllToolProcesses() {
		return Promise.resolve()
	}
	async getToolDefinitions() {
		return await this.getClient(), this._toolDefinitions === void 0 ? [] : this._toolDefinitions
	}
	getAllToolDefinitions(t = !0) {
		return this.getToolDefinitions()
	}
	getTool(t) {}
	getName() {
		return Ro.mcpHost
	}
	async callTool(t, r, n, i, s) {
		let o = await this.getClient()
		if (this._closingPromise !== void 0) return { isError: !0, text: "MCP client is closing" }
		this._runningTool = { requestId: t, toolUseId: r }
		let a = this.extractOriginalToolName(n),
			l
		try {
			let f
			this._config.timeoutMs && (f = { timeout: this._config.timeoutMs }),
				(l = await o.callTool({ name: a, arguments: i }, cm, f))
		} catch (f) {
			if (this._cancelledByUser) return { isError: !0, text: "Cancelled by user." }
			throw f
		} finally {
			this._runningTool = void 0
		}
		let c = typeof l.isError == "boolean" ? l.isError : !1
		if (!Array.isArray(l.content)) throw new Error("Unexpected result format: content is not an array")
		let u = l.content.map((f) => (!("text" in f) || typeof f.text != "string" ? "" : f.text)).join("")
		return { isError: c, text: c && u.length === 0 ? "No result" : u }
	}
	async checkToolCallSafe(t, r) {
		return Promise.resolve(!1)
	}
	async getClient() {
		if ((await this._initializingPromise, this._client === void 0)) throw new Error("Client is undefined")
		return this._client
	}
	validateConfig(t) {
		if (t?.timeoutMs !== void 0 && t?.timeoutMs > e.maxTimeoutMs)
			throw new Error(`Timeout is too large: ${t.timeoutMs}, max is ${e.maxTimeoutMs}.`)
	}
	sanitizeServerName(t) {
		return t.replace(/[^a-zA-Z0-9_-]/g, "_")
	}
	extractServerName(t) {
		let n = t.split(/\s+/)[0].split(/[/\\]/).pop() || "mcp"
		return this.sanitizeServerName(n)
	}
	createNamespacedToolName(t) {
		return (0, LY.truncate)(`${t}_${this._serverName}`, {
			length: 64,
			omission: "",
		})
	}
	extractOriginalToolName(t) {
		let r = `${this._serverName}_`
		return t.startsWith(r) ? t.substring(r.length) : t
	}
	factory(t) {
		return new e(this._config, t, this._onStartupError)
	}
}
var BP = class extends HI {
	_capturedStdErr = []
	_capturing = !0
	async start() {
		await super.start()
		let t = this.stderr
		t &&
			t.on("data", (r) => {
				this._capturing && this._capturedStdErr.push(r.toString())
			})
	}
	get capturedStderr() {
		return this._capturedStdErr.join("")
	}
	stopCapturing() {
		this._capturing = !1
	}
}
function UY(e) {
	return Object.keys(e)
		.map((t) => Number.parseInt(t, 10))
		.filter((t) => !Number.isNaN(t))
}
var OY = require("child_process"),
	qY = require("util")
async function fm(e, t) {
	let r = (0, qY.promisify)(OY.exec)
	try {
		let { stdout: n } = await r(e, t)
		return n.trim()
	} catch {
		return
	}
}
var WI = class {
	toolId = Li.GitHubApi
	constructor() {}
	async transform(t) {
		let r = await this.getGitInfo()
		return r
			? {
					...t,
					description:
						t.description +
						`

` +
						r,
				}
			: t
	}
	async getGitInfo() {
		let t = await Do().getCwd()
		if (!t) return
		let r = { timeout: 1e3, cwd: t }
		try {
			let n = await fm("git rev-parse --show-toplevel", r)
			if (!n) return
			let i = { timeout: 1e3, cwd: n },
				[s, o, a, l] = await Promise.all([
					fm("git config --get remote.origin.url", i),
					fm("git rev-parse --abbrev-ref HEAD", i),
					fm("git rev-parse --abbrev-ref origin/HEAD", i),
					fm("git config --get user.email", i),
				]),
				c = a?.split("/").pop(),
				u = ["Local Git Repository Information:"]
			return (
				n && u.push(`- Repository Root: ${n}`),
				s && u.push(`- Remote URL: ${s}`),
				o && u.push(`- Current Branch: ${o}`),
				c && u.push(`- Default Branch: ${c}`),
				l && u.push(`- Git User Email: ${l}`),
				u.push("REPOSITORY SCOPE:"),
				u.push(
					"All queries MUST be limited to this repository only, unless explicitly requested otherwise. Always indicate in text outside of the tool use that you are limiting to this repo if you are doing so.",
				),
				u.join(`
`) +
					`
`
			)
		} catch {
			return
		}
	}
}
var GI = class e {
		_remoteInfoSource
		_abortController = void 0
		_toolMap = new Map()
		_logger = dn("RemoteToolHost")
		_transformationMap
		_cachedToolDefinitions = null
		_lastCacheUpdateTime = 0
		_cacheExpirationMs = 60 * 60 * 1e3
		constructor(t) {
			this._remoteInfoSource = t
			let r = new WI()
			this._transformationMap = new Map([[r.toolId, r]])
		}
		async getToolDefinitions(t = !0) {
			let r = (await this._getToolDefinitions(t)).filter((n) => n.isConfigured)
			return (
				this._toolMap.clear(),
				r.forEach((n) => {
					this._toolMap.set(n.identifier.toolId, n)
				}),
				r
			)
		}
		async getAllToolDefinitions(t = !0) {
			return await this._getToolDefinitions(t)
		}
		getTool(t) {}
		getName() {
			return Ro.remoteToolHost
		}
		async _getToolDefinitions(t = !0) {
			if (
				t &&
				this._cachedToolDefinitions !== null &&
				Date.now() - this._lastCacheUpdateTime < this._cacheExpirationMs
			)
				return this._cachedToolDefinitions
			this._logger.debug("Fetching remote tool definitions from backend")
			try {
				let r = UY(Li),
					n = await this._remoteInfoSource.retrieveRemoteTools(r),
					i = n.filter((c) => c.availabilityStatus === dm.UserConfigRequired).map((c) => c.remoteToolId),
					s = await this._remoteInfoSource.filterToolsWithExtraInput(i),
					o = (c) =>
						c.availabilityStatus === dm.Available
							? !0
							: c.availabilityStatus === dm.UserConfigRequired
								? s.has(c.remoteToolId)
								: !1,
					l = (
						await Promise.all(
							n.map(async (c) => {
								let u = this._transformationMap.get(c.remoteToolId)
								if (u) {
									this._logger.debug(`Applying transformation for ${c.remoteToolId}`)
									let f = await u.transform(c.toolDefinition)
									return { ...c, toolDefinition: f }
								}
								return c
							}),
						)
					).map((c) => ({
						definition: c.toolDefinition,
						identifier: { hostName: Ro.remoteToolHost, toolId: c.remoteToolId },
						isConfigured: o(c),
						enabled: !0,
						toolSafety: c.toolSafety,
						oauthUrl: c.oauthUrl,
					}))
				return (this._cachedToolDefinitions = l), (this._lastCacheUpdateTime = Date.now()), l
			} catch (r) {
				return (
					this._logger.error("Failed to list remote tools", r),
					this._cachedToolDefinitions !== null
						? (this._logger.info("Using expired cache due to error fetching remote tools"),
							this._cachedToolDefinitions)
						: []
				)
			}
		}
		findToolIdByName(t) {
			for (let [r, n] of this._toolMap.entries()) if (n.definition.name.toString() === t) return r
			return Li.Unknown
		}
		async callTool(t, r, n, i, s) {
			try {
				let o = (this._abortController = new AbortController()),
					a = this.findToolIdByName(n)
				if (!this._toolMap.get(a))
					return this._logger.error(`Tool not found: ${n}`), { text: `Tool ${n} not found.`, isError: !0 }
				let c = pd(),
					u = await this._remoteInfoSource.runRemoteTool(c, n, JSON.stringify(i), a, o.signal)
				return (
					u.status !== qv.ExecutionSuccess &&
						this._logger.error(`Failed to run remote tool ${n}: ${qv[u.status]}`),
					{
						text: u.toolOutput,
						isError: u.status !== qv.ExecutionSuccess,
						requestId: c,
					}
				)
			} catch (o) {
				return {
					text: `Failed to run remote tool ${n} - ${o instanceof Error ? o.message : o}`,
					isError: !0,
				}
			} finally {
				this._abortController = void 0
			}
		}
		checkToolCallSafe(t, r) {
			let n = this.findToolIdByName(t),
				i = this._toolMap.get(n)
			return i?.toolSafety === xt.Check
				? (this._logger.info(`Checking tool safety for ${t}`),
					this._remoteInfoSource.checkToolSafety(n, JSON.stringify(r)))
				: Promise.resolve(i?.toolSafety === xt.Safe)
		}
		isRequestActive(t, r) {
			return this._abortController !== void 0
		}
		close(t = !1) {
			return this._abortController?.abort(), Promise.resolve()
		}
		closeAllToolProcesses() {
			return Promise.resolve()
		}
		factory(t) {
			return new e(this._remoteInfoSource)
		}
	},
	qv
;(function (e) {
	;(e[(e.ExecutionUnknownStatus = 0)] = "ExecutionUnknownStatus"),
		(e[(e.ExecutionSuccess = 1)] = "ExecutionSuccess"),
		(e[(e.NotFound = 2)] = "NotFound"),
		(e[(e.InvalidInput = 3)] = "InvalidInput"),
		(e[(e.ExecutionError = 4)] = "ExecutionError"),
		(e[(e.NotAvailable = 5)] = "NotAvailable"),
		(e[(e.AuthenticationError = 6)] = "AuthenticationError")
})(qv || (qv = {}))
var hm = class {
	_tools
	hostName
	_runningTool = void 0
	_abortController = void 0
	constructor(t, r) {
		;(this._tools = t), (this.hostName = r)
	}
	getToolDefinitions() {
		return Promise.resolve(
			this._tools.map((t) => ({
				definition: {
					name: t.name,
					description: t.description,
					input_schema_json: t.inputSchemaJson,
					tool_safety: t.toolSafety,
				},
				identifier: { hostName: this.hostName, toolId: t.name },
				isConfigured: !0,
				enabled: !0,
				toolSafety: t.toolSafety,
			})),
		)
	}
	getAllToolDefinitions(t = !0) {
		return this.getToolDefinitions()
	}
	getTool(t) {
		return this._tools.find((r) => r.name === t)
	}
	getName() {
		return this.hostName
	}
	async callTool(t, r, n, i, s) {
		let o = this._tools.find((a) => a.name.toString() === n)
		if (o === void 0) return { isError: !0, text: `Tool ${n} not found.` }
		this._runningTool = { requestId: t, toolUseId: r, tool: o }
		try {
			let a = (this._abortController = new AbortController())
			return await o.call(i, s, a.signal)
		} finally {
			;(this._runningTool = void 0), (this._abortController = void 0)
		}
	}
	async checkToolCallSafe(t, r) {
		let n = this._tools.find((i) => i.name === t)
		return n === void 0 ? Promise.resolve(!1) : n.checkToolCallSafe(r)
	}
	isRequestActive(t, r) {
		return this._runningTool?.requestId === t && this._runningTool?.toolUseId === r
	}
	close(t = !1) {
		return this._abortController?.abort(), Promise.resolve()
	}
	closeAllToolProcesses() {
		return Promise.resolve()
	}
}
function Xl(e, t, r = !1) {
	let n = [...e]
	return n.length <= t
		? e
		: r
			? t <= 3
				? "..."
				: "..." + n.slice(3 - t).join("")
			: n.slice(0, Math.max(t - 3, 0)).join("") + "..."
}
function $I(e, t) {
	if (e.length <= t || e.length === 0) return e
	let r = e.split(`
`),
		i = "... additional lines truncated ..." + (r[0].endsWith("\r") ? "\r" : ""),
		s = ""
	if (r.length < 2 || r[0].length + r[r.length - 1].length + i.length > t) {
		let o = Math.floor(t / 2)
		s = [e.slice(0, o), "<...>", e.slice(-o)].join("")
	} else {
		let o = [],
			a = [],
			l = i.length + 1
		for (let c = 0; c < Math.floor(r.length / 2); c++) {
			let u = r[c],
				f = r[r.length - 1 - c],
				p = u.length + f.length + 2
			if (l + p > t) break
			;(l += p), o.push(u), a.push(f)
		}
		o.push(i),
			o.push(...a.reverse()),
			(s = o.join(`
`))
	}
	return s
}
var ja
;(function (e) {
	;(e.shell = "shell"),
		(e.webFetch = "web-fetch"),
		(e.strReplaceEditor = "str-replace-editor"),
		(e.codebaseRetrieval = "codebase-retrieval")
})(ja || (ja = {}))
var YI = {
	strReplaceEditor: "str_replace_editor_tool",
	backendEditTool: "backend_edit_tool",
}
function Zt(e, t) {
	return { text: e, isError: !1, requestId: t }
}
function ut(e, t) {
	return { text: e, isError: !0, requestId: t }
}
var KI = class extends rn {
	_maxRetrievalSize = 2e4
	constructor() {
		super(ja.codebaseRetrieval, xt.Safe)
	}
	description = `This tool is Augment's context engine, the world's best codebase context engine. It:
1. Takes in a natural language description of the code you are looking for;
2. Uses a proprietary retrieval/embedding model suite that produces the highest-quality recall of relevant code snippets from across the codebase;
3. Maintains a real-time index of the codebase, so the results are always up-to-date and reflects the current state of the codebase;
4. Can retrieve across different programming languages;
5. Only reflects the current state of the codebase on the disk, and has no information on version control or code history.`
	inputSchemaJson = JSON.stringify({
		type: "object",
		properties: {
			information_request: {
				type: "string",
				description: "A description of the information you need.",
			},
		},
		required: ["information_request"],
	})
	version = 2
	checkToolCallSafe(t) {
		return !0
	}
	async call(t, r, n) {
		let i = pd()
		try {
			let s = t.information_request,
				o = await Rf().agentCodebaseRetrieval(i, s, r, this._maxRetrievalSize, n),
				a = Xl(o.formattedRetrieval, this._maxRetrievalSize)
			return Zt(a, i)
		} catch (s) {
			return ut(`Failed to retrieve codebase information: ${s instanceof Error ? s.message : String(s)}`, i)
		}
	}
}
var DK = require("util"),
	TK = require("child_process")
function nK(e) {
	return typeof e > "u" || e === null
}
function x1e(e) {
	return typeof e == "object" && e !== null
}
function _1e(e) {
	return Array.isArray(e) ? e : nK(e) ? [] : [e]
}
function w1e(e, t) {
	var r, n, i, s
	if (t) for (s = Object.keys(t), r = 0, n = s.length; r < n; r += 1) (i = s[r]), (e[i] = t[i])
	return e
}
function I1e(e, t) {
	var r = "",
		n
	for (n = 0; n < t; n += 1) r += e
	return r
}
function S1e(e) {
	return e === 0 && Number.NEGATIVE_INFINITY === 1 / e
}
var B1e = nK,
	D1e = x1e,
	T1e = _1e,
	R1e = I1e,
	k1e = S1e,
	M1e = w1e,
	Ui = {
		isNothing: B1e,
		isObject: D1e,
		toArray: T1e,
		repeat: R1e,
		isNegativeZero: k1e,
		extend: M1e,
	}
function iK(e, t) {
	var r = "",
		n = e.reason || "(unknown reason)"
	return e.mark
		? (e.mark.name && (r += 'in "' + e.mark.name + '" '),
			(r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")"),
			!t &&
				e.mark.snippet &&
				(r +=
					`

` + e.mark.snippet),
			n + " " + r)
		: n
}
function Hv(e, t) {
	Error.call(this),
		(this.name = "YAMLException"),
		(this.reason = e),
		(this.mark = t),
		(this.message = iK(this, !1)),
		Error.captureStackTrace
			? Error.captureStackTrace(this, this.constructor)
			: (this.stack = new Error().stack || "")
}
Hv.prototype = Object.create(Error.prototype)
Hv.prototype.constructor = Hv
Hv.prototype.toString = function (t) {
	return this.name + ": " + iK(this, t)
}
var ko = Hv
function DP(e, t, r, n, i) {
	var s = "",
		o = "",
		a = Math.floor(i / 2) - 1
	return (
		n - t > a && ((s = " ... "), (t = n - a + s.length)),
		r - n > a && ((o = " ..."), (r = n + a - o.length)),
		{
			str: s + e.slice(t, r).replace(/\t/g, "\u2192") + o,
			pos: n - t + s.length,
		}
	)
}
function TP(e, t) {
	return Ui.repeat(" ", t - e.length) + e
}
function F1e(e, t) {
	if (((t = Object.create(t || null)), !e.buffer)) return null
	t.maxLength || (t.maxLength = 79),
		typeof t.indent != "number" && (t.indent = 1),
		typeof t.linesBefore != "number" && (t.linesBefore = 3),
		typeof t.linesAfter != "number" && (t.linesAfter = 2)
	for (var r = /\r?\n|\r|\0/g, n = [0], i = [], s, o = -1; (s = r.exec(e.buffer)); )
		i.push(s.index), n.push(s.index + s[0].length), e.position <= s.index && o < 0 && (o = n.length - 2)
	o < 0 && (o = n.length - 1)
	var a = "",
		l,
		c,
		u = Math.min(e.line + t.linesAfter, i.length).toString().length,
		f = t.maxLength - (t.indent + u + 3)
	for (l = 1; l <= t.linesBefore && !(o - l < 0); l++)
		(c = DP(e.buffer, n[o - l], i[o - l], e.position - (n[o] - n[o - l]), f)),
			(a =
				Ui.repeat(" ", t.indent) +
				TP((e.line - l + 1).toString(), u) +
				" | " +
				c.str +
				`
` +
				a)
	for (
		c = DP(e.buffer, n[o], i[o], e.position, f),
			a +=
				Ui.repeat(" ", t.indent) +
				TP((e.line + 1).toString(), u) +
				" | " +
				c.str +
				`
`,
			a +=
				Ui.repeat("-", t.indent + u + 3 + c.pos) +
				`^
`,
			l = 1;
		l <= t.linesAfter && !(o + l >= i.length);
		l++
	)
		(c = DP(e.buffer, n[o + l], i[o + l], e.position - (n[o] - n[o + l]), f)),
			(a +=
				Ui.repeat(" ", t.indent) +
				TP((e.line + l + 1).toString(), u) +
				" | " +
				c.str +
				`
`)
	return a.replace(/\n$/, "")
}
var Q1e = F1e,
	N1e = [
		"kind",
		"multi",
		"resolve",
		"construct",
		"instanceOf",
		"predicate",
		"represent",
		"representName",
		"defaultStyle",
		"styleAliases",
	],
	P1e = ["scalar", "sequence", "mapping"]
function L1e(e) {
	var t = {}
	return (
		e !== null &&
			Object.keys(e).forEach(function (r) {
				e[r].forEach(function (n) {
					t[String(n)] = r
				})
			}),
		t
	)
}
function U1e(e, t) {
	if (
		((t = t || {}),
		Object.keys(t).forEach(function (r) {
			if (N1e.indexOf(r) === -1)
				throw new ko('Unknown option "' + r + '" is met in definition of "' + e + '" YAML type.')
		}),
		(this.options = t),
		(this.tag = e),
		(this.kind = t.kind || null),
		(this.resolve =
			t.resolve ||
			function () {
				return !0
			}),
		(this.construct =
			t.construct ||
			function (r) {
				return r
			}),
		(this.instanceOf = t.instanceOf || null),
		(this.predicate = t.predicate || null),
		(this.represent = t.represent || null),
		(this.representName = t.representName || null),
		(this.defaultStyle = t.defaultStyle || null),
		(this.multi = t.multi || !1),
		(this.styleAliases = L1e(t.styleAliases || null)),
		P1e.indexOf(this.kind) === -1)
	)
		throw new ko('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.')
}
var Fs = U1e
function VY(e, t) {
	var r = []
	return (
		e[t].forEach(function (n) {
			var i = r.length
			r.forEach(function (s, o) {
				s.tag === n.tag && s.kind === n.kind && s.multi === n.multi && (i = o)
			}),
				(r[i] = n)
		}),
		r
	)
}
function O1e() {
	var e = {
			scalar: {},
			sequence: {},
			mapping: {},
			fallback: {},
			multi: { scalar: [], sequence: [], mapping: [], fallback: [] },
		},
		t,
		r
	function n(i) {
		i.multi ? (e.multi[i.kind].push(i), e.multi.fallback.push(i)) : (e[i.kind][i.tag] = e.fallback[i.tag] = i)
	}
	for (t = 0, r = arguments.length; t < r; t += 1) arguments[t].forEach(n)
	return e
}
function kP(e) {
	return this.extend(e)
}
kP.prototype.extend = function (t) {
	var r = [],
		n = []
	if (t instanceof Fs) n.push(t)
	else if (Array.isArray(t)) n = n.concat(t)
	else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
		t.implicit && (r = r.concat(t.implicit)), t.explicit && (n = n.concat(t.explicit))
	else
		throw new ko(
			"Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })",
		)
	r.forEach(function (s) {
		if (!(s instanceof Fs))
			throw new ko("Specified list of YAML types (or a single Type object) contains a non-Type object.")
		if (s.loadKind && s.loadKind !== "scalar")
			throw new ko(
				"There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.",
			)
		if (s.multi)
			throw new ko(
				"There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.",
			)
	}),
		n.forEach(function (s) {
			if (!(s instanceof Fs))
				throw new ko("Specified list of YAML types (or a single Type object) contains a non-Type object.")
		})
	var i = Object.create(kP.prototype)
	return (
		(i.implicit = (this.implicit || []).concat(r)),
		(i.explicit = (this.explicit || []).concat(n)),
		(i.compiledImplicit = VY(i, "implicit")),
		(i.compiledExplicit = VY(i, "explicit")),
		(i.compiledTypeMap = O1e(i.compiledImplicit, i.compiledExplicit)),
		i
	)
}
var q1e = kP,
	V1e = new Fs("tag:yaml.org,2002:str", {
		kind: "scalar",
		construct: function (e) {
			return e !== null ? e : ""
		},
	}),
	H1e = new Fs("tag:yaml.org,2002:seq", {
		kind: "sequence",
		construct: function (e) {
			return e !== null ? e : []
		},
	}),
	W1e = new Fs("tag:yaml.org,2002:map", {
		kind: "mapping",
		construct: function (e) {
			return e !== null ? e : {}
		},
	}),
	G1e = new q1e({ explicit: [V1e, H1e, W1e] })
function $1e(e) {
	if (e === null) return !0
	var t = e.length
	return (t === 1 && e === "~") || (t === 4 && (e === "null" || e === "Null" || e === "NULL"))
}
function Y1e() {
	return null
}
function K1e(e) {
	return e === null
}
var J1e = new Fs("tag:yaml.org,2002:null", {
	kind: "scalar",
	resolve: $1e,
	construct: Y1e,
	predicate: K1e,
	represent: {
		canonical: function () {
			return "~"
		},
		lowercase: function () {
			return "null"
		},
		uppercase: function () {
			return "NULL"
		},
		camelcase: function () {
			return "Null"
		},
		empty: function () {
			return ""
		},
	},
	defaultStyle: "lowercase",
})
function z1e(e) {
	if (e === null) return !1
	var t = e.length
	return (
		(t === 4 && (e === "true" || e === "True" || e === "TRUE")) ||
		(t === 5 && (e === "false" || e === "False" || e === "FALSE"))
	)
}
function j1e(e) {
	return e === "true" || e === "True" || e === "TRUE"
}
function Z1e(e) {
	return Object.prototype.toString.call(e) === "[object Boolean]"
}
var X1e = new Fs("tag:yaml.org,2002:bool", {
	kind: "scalar",
	resolve: z1e,
	construct: j1e,
	predicate: Z1e,
	represent: {
		lowercase: function (e) {
			return e ? "true" : "false"
		},
		uppercase: function (e) {
			return e ? "TRUE" : "FALSE"
		},
		camelcase: function (e) {
			return e ? "True" : "False"
		},
	},
	defaultStyle: "lowercase",
})
function eQe(e) {
	return (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102)
}
function tQe(e) {
	return 48 <= e && e <= 55
}
function rQe(e) {
	return 48 <= e && e <= 57
}
function nQe(e) {
	if (e === null) return !1
	var t = e.length,
		r = 0,
		n = !1,
		i
	if (!t) return !1
	if (((i = e[r]), (i === "-" || i === "+") && (i = e[++r]), i === "0")) {
		if (r + 1 === t) return !0
		if (((i = e[++r]), i === "b")) {
			for (r++; r < t; r++)
				if (((i = e[r]), i !== "_")) {
					if (i !== "0" && i !== "1") return !1
					n = !0
				}
			return n && i !== "_"
		}
		if (i === "x") {
			for (r++; r < t; r++)
				if (((i = e[r]), i !== "_")) {
					if (!eQe(e.charCodeAt(r))) return !1
					n = !0
				}
			return n && i !== "_"
		}
		if (i === "o") {
			for (r++; r < t; r++)
				if (((i = e[r]), i !== "_")) {
					if (!tQe(e.charCodeAt(r))) return !1
					n = !0
				}
			return n && i !== "_"
		}
	}
	if (i === "_") return !1
	for (; r < t; r++)
		if (((i = e[r]), i !== "_")) {
			if (!rQe(e.charCodeAt(r))) return !1
			n = !0
		}
	return !(!n || i === "_")
}
function iQe(e) {
	var t = e,
		r = 1,
		n
	if (
		(t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")),
		(n = t[0]),
		(n === "-" || n === "+") && (n === "-" && (r = -1), (t = t.slice(1)), (n = t[0])),
		t === "0")
	)
		return 0
	if (n === "0") {
		if (t[1] === "b") return r * parseInt(t.slice(2), 2)
		if (t[1] === "x") return r * parseInt(t.slice(2), 16)
		if (t[1] === "o") return r * parseInt(t.slice(2), 8)
	}
	return r * parseInt(t, 10)
}
function sQe(e) {
	return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !Ui.isNegativeZero(e)
}
var oQe = new Fs("tag:yaml.org,2002:int", {
		kind: "scalar",
		resolve: nQe,
		construct: iQe,
		predicate: sQe,
		represent: {
			binary: function (e) {
				return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1)
			},
			octal: function (e) {
				return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1)
			},
			decimal: function (e) {
				return e.toString(10)
			},
			hexadecimal: function (e) {
				return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1)
			},
		},
		defaultStyle: "decimal",
		styleAliases: {
			binary: [2, "bin"],
			octal: [8, "oct"],
			decimal: [10, "dec"],
			hexadecimal: [16, "hex"],
		},
	}),
	aQe = new RegExp(
		"^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$",
	)
function lQe(e) {
	return !(e === null || !aQe.test(e) || e[e.length - 1] === "_")
}
function cQe(e) {
	var t, r
	return (
		(t = e.replace(/_/g, "").toLowerCase()),
		(r = t[0] === "-" ? -1 : 1),
		"+-".indexOf(t[0]) >= 0 && (t = t.slice(1)),
		t === ".inf"
			? r === 1
				? Number.POSITIVE_INFINITY
				: Number.NEGATIVE_INFINITY
			: t === ".nan"
				? NaN
				: r * parseFloat(t, 10)
	)
}
var uQe = /^[-+]?[0-9]+e/
function dQe(e, t) {
	var r
	if (isNaN(e))
		switch (t) {
			case "lowercase":
				return ".nan"
			case "uppercase":
				return ".NAN"
			case "camelcase":
				return ".NaN"
		}
	else if (Number.POSITIVE_INFINITY === e)
		switch (t) {
			case "lowercase":
				return ".inf"
			case "uppercase":
				return ".INF"
			case "camelcase":
				return ".Inf"
		}
	else if (Number.NEGATIVE_INFINITY === e)
		switch (t) {
			case "lowercase":
				return "-.inf"
			case "uppercase":
				return "-.INF"
			case "camelcase":
				return "-.Inf"
		}
	else if (Ui.isNegativeZero(e)) return "-0.0"
	return (r = e.toString(10)), uQe.test(r) ? r.replace("e", ".e") : r
}
function fQe(e) {
	return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || Ui.isNegativeZero(e))
}
var hQe = new Fs("tag:yaml.org,2002:float", {
		kind: "scalar",
		resolve: lQe,
		construct: cQe,
		predicate: fQe,
		represent: dQe,
		defaultStyle: "lowercase",
	}),
	gQe = G1e.extend({ implicit: [J1e, X1e, oQe, hQe] }),
	pQe = gQe,
	sK = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
	oK = new RegExp(
		"^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$",
	)
function AQe(e) {
	return e === null ? !1 : sK.exec(e) !== null || oK.exec(e) !== null
}
function mQe(e) {
	var t,
		r,
		n,
		i,
		s,
		o,
		a,
		l = 0,
		c = null,
		u,
		f,
		p
	if (((t = sK.exec(e)), t === null && (t = oK.exec(e)), t === null)) throw new Error("Date resolve error")
	if (((r = +t[1]), (n = +t[2] - 1), (i = +t[3]), !t[4])) return new Date(Date.UTC(r, n, i))
	if (((s = +t[4]), (o = +t[5]), (a = +t[6]), t[7])) {
		for (l = t[7].slice(0, 3); l.length < 3; ) l += "0"
		l = +l
	}
	return (
		t[9] && ((u = +t[10]), (f = +(t[11] || 0)), (c = (u * 60 + f) * 6e4), t[9] === "-" && (c = -c)),
		(p = new Date(Date.UTC(r, n, i, s, o, a, l))),
		c && p.setTime(p.getTime() - c),
		p
	)
}
function yQe(e) {
	return e.toISOString()
}
var CQe = new Fs("tag:yaml.org,2002:timestamp", {
	kind: "scalar",
	resolve: AQe,
	construct: mQe,
	instanceOf: Date,
	represent: yQe,
})
function vQe(e) {
	return e === "<<" || e === null
}
var EQe = new Fs("tag:yaml.org,2002:merge", { kind: "scalar", resolve: vQe }),
	PP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`
function bQe(e) {
	if (e === null) return !1
	var t,
		r,
		n = 0,
		i = e.length,
		s = PP
	for (r = 0; r < i; r++)
		if (((t = s.indexOf(e.charAt(r))), !(t > 64))) {
			if (t < 0) return !1
			n += 6
		}
	return n % 8 === 0
}
function xQe(e) {
	var t,
		r,
		n = e.replace(/[\r\n=]/g, ""),
		i = n.length,
		s = PP,
		o = 0,
		a = []
	for (t = 0; t < i; t++)
		t % 4 === 0 && t && (a.push((o >> 16) & 255), a.push((o >> 8) & 255), a.push(o & 255)),
			(o = (o << 6) | s.indexOf(n.charAt(t)))
	return (
		(r = (i % 4) * 6),
		r === 0
			? (a.push((o >> 16) & 255), a.push((o >> 8) & 255), a.push(o & 255))
			: r === 18
				? (a.push((o >> 10) & 255), a.push((o >> 2) & 255))
				: r === 12 && a.push((o >> 4) & 255),
		new Uint8Array(a)
	)
}
function _Qe(e) {
	var t = "",
		r = 0,
		n,
		i,
		s = e.length,
		o = PP
	for (n = 0; n < s; n++)
		n % 3 === 0 &&
			n &&
			((t += o[(r >> 18) & 63]), (t += o[(r >> 12) & 63]), (t += o[(r >> 6) & 63]), (t += o[r & 63])),
			(r = (r << 8) + e[n])
	return (
		(i = s % 3),
		i === 0
			? ((t += o[(r >> 18) & 63]), (t += o[(r >> 12) & 63]), (t += o[(r >> 6) & 63]), (t += o[r & 63]))
			: i === 2
				? ((t += o[(r >> 10) & 63]), (t += o[(r >> 4) & 63]), (t += o[(r << 2) & 63]), (t += o[64]))
				: i === 1 && ((t += o[(r >> 2) & 63]), (t += o[(r << 4) & 63]), (t += o[64]), (t += o[64])),
		t
	)
}
function wQe(e) {
	return Object.prototype.toString.call(e) === "[object Uint8Array]"
}
var IQe = new Fs("tag:yaml.org,2002:binary", {
		kind: "scalar",
		resolve: bQe,
		construct: xQe,
		predicate: wQe,
		represent: _Qe,
	}),
	SQe = Object.prototype.hasOwnProperty,
	BQe = Object.prototype.toString
function DQe(e) {
	if (e === null) return !0
	var t = [],
		r,
		n,
		i,
		s,
		o,
		a = e
	for (r = 0, n = a.length; r < n; r += 1) {
		if (((i = a[r]), (o = !1), BQe.call(i) !== "[object Object]")) return !1
		for (s in i)
			if (SQe.call(i, s))
				if (!o) o = !0
				else return !1
		if (!o) return !1
		if (t.indexOf(s) === -1) t.push(s)
		else return !1
	}
	return !0
}
function TQe(e) {
	return e !== null ? e : []
}
var RQe = new Fs("tag:yaml.org,2002:omap", {
		kind: "sequence",
		resolve: DQe,
		construct: TQe,
	}),
	kQe = Object.prototype.toString
function MQe(e) {
	if (e === null) return !0
	var t,
		r,
		n,
		i,
		s,
		o = e
	for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1) {
		if (((n = o[t]), kQe.call(n) !== "[object Object]" || ((i = Object.keys(n)), i.length !== 1))) return !1
		s[t] = [i[0], n[i[0]]]
	}
	return !0
}
function FQe(e) {
	if (e === null) return []
	var t,
		r,
		n,
		i,
		s,
		o = e
	for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1)
		(n = o[t]), (i = Object.keys(n)), (s[t] = [i[0], n[i[0]]])
	return s
}
var QQe = new Fs("tag:yaml.org,2002:pairs", {
		kind: "sequence",
		resolve: MQe,
		construct: FQe,
	}),
	NQe = Object.prototype.hasOwnProperty
function PQe(e) {
	if (e === null) return !0
	var t,
		r = e
	for (t in r) if (NQe.call(r, t) && r[t] !== null) return !1
	return !0
}
function LQe(e) {
	return e !== null ? e : {}
}
var UQe = new Fs("tag:yaml.org,2002:set", {
		kind: "mapping",
		resolve: PQe,
		construct: LQe,
	}),
	aK = pQe.extend({ implicit: [CQe, EQe], explicit: [IQe, RQe, QQe, UQe] }),
	Nf = Object.prototype.hasOwnProperty,
	JI = 1,
	lK = 2,
	cK = 3,
	zI = 4,
	RP = 1,
	OQe = 2,
	HY = 3,
	qQe =
		/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
	VQe = /[\x85\u2028\u2029]/,
	HQe = /[,\[\]\{\}]/,
	uK = /^(?:!|!!|![a-z\-]+!)$/i,
	dK = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i
function WY(e) {
	return Object.prototype.toString.call(e)
}
function zc(e) {
	return e === 10 || e === 13
}
function Wg(e) {
	return e === 9 || e === 32
}
function Mo(e) {
	return e === 9 || e === 32 || e === 10 || e === 13
}
function pm(e) {
	return e === 44 || e === 91 || e === 93 || e === 123 || e === 125
}
function WQe(e) {
	var t
	return 48 <= e && e <= 57 ? e - 48 : ((t = e | 32), 97 <= t && t <= 102 ? t - 97 + 10 : -1)
}
function GQe(e) {
	return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0
}
function $Qe(e) {
	return 48 <= e && e <= 57 ? e - 48 : -1
}
function GY(e) {
	return e === 48
		? "\0"
		: e === 97
			? "\x07"
			: e === 98
				? "\b"
				: e === 116 || e === 9
					? "	"
					: e === 110
						? `
`
						: e === 118
							? "\v"
							: e === 102
								? "\f"
								: e === 114
									? "\r"
									: e === 101
										? "\x1B"
										: e === 32
											? " "
											: e === 34
												? '"'
												: e === 47
													? "/"
													: e === 92
														? "\\"
														: e === 78
															? "\x85"
															: e === 95
																? "\xA0"
																: e === 76
																	? "\u2028"
																	: e === 80
																		? "\u2029"
																		: ""
}
function YQe(e) {
	return e <= 65535
		? String.fromCharCode(e)
		: String.fromCharCode(((e - 65536) >> 10) + 55296, ((e - 65536) & 1023) + 56320)
}
var fK = new Array(256),
	hK = new Array(256)
for (Hg = 0; Hg < 256; Hg++) (fK[Hg] = GY(Hg) ? 1 : 0), (hK[Hg] = GY(Hg))
var Hg
function KQe(e, t) {
	;(this.input = e),
		(this.filename = t.filename || null),
		(this.schema = t.schema || aK),
		(this.onWarning = t.onWarning || null),
		(this.legacy = t.legacy || !1),
		(this.json = t.json || !1),
		(this.listener = t.listener || null),
		(this.implicitTypes = this.schema.compiledImplicit),
		(this.typeMap = this.schema.compiledTypeMap),
		(this.length = e.length),
		(this.position = 0),
		(this.line = 0),
		(this.lineStart = 0),
		(this.lineIndent = 0),
		(this.firstTabInLine = -1),
		(this.documents = [])
}
function gK(e, t) {
	var r = {
		name: e.filename,
		buffer: e.input.slice(0, -1),
		position: e.position,
		line: e.line,
		column: e.position - e.lineStart,
	}
	return (r.snippet = Q1e(r)), new ko(t, r)
}
function Xe(e, t) {
	throw gK(e, t)
}
function jI(e, t) {
	e.onWarning && e.onWarning.call(null, gK(e, t))
}
var $Y = {
	YAML: function (t, r, n) {
		var i, s, o
		t.version !== null && Xe(t, "duplication of %YAML directive"),
			n.length !== 1 && Xe(t, "YAML directive accepts exactly one argument"),
			(i = /^([0-9]+)\.([0-9]+)$/.exec(n[0])),
			i === null && Xe(t, "ill-formed argument of the YAML directive"),
			(s = parseInt(i[1], 10)),
			(o = parseInt(i[2], 10)),
			s !== 1 && Xe(t, "unacceptable YAML version of the document"),
			(t.version = n[0]),
			(t.checkLineBreaks = o < 2),
			o !== 1 && o !== 2 && jI(t, "unsupported YAML version of the document")
	},
	TAG: function (t, r, n) {
		var i, s
		n.length !== 2 && Xe(t, "TAG directive accepts exactly two arguments"),
			(i = n[0]),
			(s = n[1]),
			uK.test(i) || Xe(t, "ill-formed tag handle (first argument) of the TAG directive"),
			Nf.call(t.tagMap, i) && Xe(t, 'there is a previously declared suffix for "' + i + '" tag handle'),
			dK.test(s) || Xe(t, "ill-formed tag prefix (second argument) of the TAG directive")
		try {
			s = decodeURIComponent(s)
		} catch {
			Xe(t, "tag prefix is malformed: " + s)
		}
		t.tagMap[i] = s
	},
}
function Qf(e, t, r, n) {
	var i, s, o, a
	if (t < r) {
		if (((a = e.input.slice(t, r)), n))
			for (i = 0, s = a.length; i < s; i += 1)
				(o = a.charCodeAt(i)), o === 9 || (32 <= o && o <= 1114111) || Xe(e, "expected valid JSON character")
		else qQe.test(a) && Xe(e, "the stream contains non-printable characters")
		e.result += a
	}
}
function YY(e, t, r, n) {
	var i, s, o, a
	for (
		Ui.isObject(r) || Xe(e, "cannot merge mappings; the provided source object is unacceptable"),
			i = Object.keys(r),
			o = 0,
			a = i.length;
		o < a;
		o += 1
	)
		(s = i[o]), Nf.call(t, s) || ((t[s] = r[s]), (n[s] = !0))
}
function Am(e, t, r, n, i, s, o, a, l) {
	var c, u
	if (Array.isArray(i))
		for (i = Array.prototype.slice.call(i), c = 0, u = i.length; c < u; c += 1)
			Array.isArray(i[c]) && Xe(e, "nested arrays are not supported inside keys"),
				typeof i == "object" && WY(i[c]) === "[object Object]" && (i[c] = "[object Object]")
	if (
		(typeof i == "object" && WY(i) === "[object Object]" && (i = "[object Object]"),
		(i = String(i)),
		t === null && (t = {}),
		n === "tag:yaml.org,2002:merge")
	)
		if (Array.isArray(s)) for (c = 0, u = s.length; c < u; c += 1) YY(e, t, s[c], r)
		else YY(e, t, s, r)
	else
		!e.json &&
			!Nf.call(r, i) &&
			Nf.call(t, i) &&
			((e.line = o || e.line),
			(e.lineStart = a || e.lineStart),
			(e.position = l || e.position),
			Xe(e, "duplicated mapping key")),
			i === "__proto__"
				? Object.defineProperty(t, i, {
						configurable: !0,
						enumerable: !0,
						writable: !0,
						value: s,
					})
				: (t[i] = s),
			delete r[i]
	return t
}
function LP(e) {
	var t
	;(t = e.input.charCodeAt(e.position)),
		t === 10
			? e.position++
			: t === 13
				? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++)
				: Xe(e, "a line break is expected"),
		(e.line += 1),
		(e.lineStart = e.position),
		(e.firstTabInLine = -1)
}
function _i(e, t, r) {
	for (var n = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
		for (; Wg(i); )
			i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position),
				(i = e.input.charCodeAt(++e.position))
		if (t && i === 35)
			do i = e.input.charCodeAt(++e.position)
			while (i !== 10 && i !== 13 && i !== 0)
		if (zc(i))
			for (LP(e), i = e.input.charCodeAt(e.position), n++, e.lineIndent = 0; i === 32; )
				e.lineIndent++, (i = e.input.charCodeAt(++e.position))
		else break
	}
	return r !== -1 && n !== 0 && e.lineIndent < r && jI(e, "deficient indentation"), n
}
function eS(e) {
	var t = e.position,
		r
	return (
		(r = e.input.charCodeAt(t)),
		!!(
			(r === 45 || r === 46) &&
			r === e.input.charCodeAt(t + 1) &&
			r === e.input.charCodeAt(t + 2) &&
			((t += 3), (r = e.input.charCodeAt(t)), r === 0 || Mo(r))
		)
	)
}
function UP(e, t) {
	t === 1
		? (e.result += " ")
		: t > 1 &&
			(e.result += Ui.repeat(
				`
`,
				t - 1,
			))
}
function JQe(e, t, r) {
	var n,
		i,
		s,
		o,
		a,
		l,
		c,
		u,
		f = e.kind,
		p = e.result,
		g
	if (
		((g = e.input.charCodeAt(e.position)),
		Mo(g) ||
			pm(g) ||
			g === 35 ||
			g === 38 ||
			g === 42 ||
			g === 33 ||
			g === 124 ||
			g === 62 ||
			g === 39 ||
			g === 34 ||
			g === 37 ||
			g === 64 ||
			g === 96 ||
			((g === 63 || g === 45) && ((i = e.input.charCodeAt(e.position + 1)), Mo(i) || (r && pm(i)))))
	)
		return !1
	for (e.kind = "scalar", e.result = "", s = o = e.position, a = !1; g !== 0; ) {
		if (g === 58) {
			if (((i = e.input.charCodeAt(e.position + 1)), Mo(i) || (r && pm(i)))) break
		} else if (g === 35) {
			if (((n = e.input.charCodeAt(e.position - 1)), Mo(n))) break
		} else {
			if ((e.position === e.lineStart && eS(e)) || (r && pm(g))) break
			if (zc(g))
				if (((l = e.line), (c = e.lineStart), (u = e.lineIndent), _i(e, !1, -1), e.lineIndent >= t)) {
					;(a = !0), (g = e.input.charCodeAt(e.position))
					continue
				} else {
					;(e.position = o), (e.line = l), (e.lineStart = c), (e.lineIndent = u)
					break
				}
		}
		a && (Qf(e, s, o, !1), UP(e, e.line - l), (s = o = e.position), (a = !1)),
			Wg(g) || (o = e.position + 1),
			(g = e.input.charCodeAt(++e.position))
	}
	return Qf(e, s, o, !1), e.result ? !0 : ((e.kind = f), (e.result = p), !1)
}
function zQe(e, t) {
	var r, n, i
	if (((r = e.input.charCodeAt(e.position)), r !== 39)) return !1
	for (
		e.kind = "scalar", e.result = "", e.position++, n = i = e.position;
		(r = e.input.charCodeAt(e.position)) !== 0;

	)
		if (r === 39)
			if ((Qf(e, n, e.position, !0), (r = e.input.charCodeAt(++e.position)), r === 39))
				(n = e.position), e.position++, (i = e.position)
			else return !0
		else
			zc(r)
				? (Qf(e, n, i, !0), UP(e, _i(e, !1, t)), (n = i = e.position))
				: e.position === e.lineStart && eS(e)
					? Xe(e, "unexpected end of the document within a single quoted scalar")
					: (e.position++, (i = e.position))
	Xe(e, "unexpected end of the stream within a single quoted scalar")
}
function jQe(e, t) {
	var r, n, i, s, o, a
	if (((a = e.input.charCodeAt(e.position)), a !== 34)) return !1
	for (
		e.kind = "scalar", e.result = "", e.position++, r = n = e.position;
		(a = e.input.charCodeAt(e.position)) !== 0;

	) {
		if (a === 34) return Qf(e, r, e.position, !0), e.position++, !0
		if (a === 92) {
			if ((Qf(e, r, e.position, !0), (a = e.input.charCodeAt(++e.position)), zc(a))) _i(e, !1, t)
			else if (a < 256 && fK[a]) (e.result += hK[a]), e.position++
			else if ((o = GQe(a)) > 0) {
				for (i = o, s = 0; i > 0; i--)
					(a = e.input.charCodeAt(++e.position)),
						(o = WQe(a)) >= 0 ? (s = (s << 4) + o) : Xe(e, "expected hexadecimal character")
				;(e.result += YQe(s)), e.position++
			} else Xe(e, "unknown escape sequence")
			r = n = e.position
		} else
			zc(a)
				? (Qf(e, r, n, !0), UP(e, _i(e, !1, t)), (r = n = e.position))
				: e.position === e.lineStart && eS(e)
					? Xe(e, "unexpected end of the document within a double quoted scalar")
					: (e.position++, (n = e.position))
	}
	Xe(e, "unexpected end of the stream within a double quoted scalar")
}
function ZQe(e, t) {
	var r = !0,
		n,
		i,
		s,
		o = e.tag,
		a,
		l = e.anchor,
		c,
		u,
		f,
		p,
		g,
		m = Object.create(null),
		y,
		C,
		v,
		b
	if (((b = e.input.charCodeAt(e.position)), b === 91)) (u = 93), (g = !1), (a = [])
	else if (b === 123) (u = 125), (g = !0), (a = {})
	else return !1
	for (e.anchor !== null && (e.anchorMap[e.anchor] = a), b = e.input.charCodeAt(++e.position); b !== 0; ) {
		if ((_i(e, !0, t), (b = e.input.charCodeAt(e.position)), b === u))
			return e.position++, (e.tag = o), (e.anchor = l), (e.kind = g ? "mapping" : "sequence"), (e.result = a), !0
		r
			? b === 44 && Xe(e, "expected the node content, but found ','")
			: Xe(e, "missed comma between flow collection entries"),
			(C = y = v = null),
			(f = p = !1),
			b === 63 && ((c = e.input.charCodeAt(e.position + 1)), Mo(c) && ((f = p = !0), e.position++, _i(e, !0, t))),
			(n = e.line),
			(i = e.lineStart),
			(s = e.position),
			mm(e, t, JI, !1, !0),
			(C = e.tag),
			(y = e.result),
			_i(e, !0, t),
			(b = e.input.charCodeAt(e.position)),
			(p || e.line === n) &&
				b === 58 &&
				((f = !0), (b = e.input.charCodeAt(++e.position)), _i(e, !0, t), mm(e, t, JI, !1, !0), (v = e.result)),
			g ? Am(e, a, m, C, y, v, n, i, s) : f ? a.push(Am(e, null, m, C, y, v, n, i, s)) : a.push(y),
			_i(e, !0, t),
			(b = e.input.charCodeAt(e.position)),
			b === 44 ? ((r = !0), (b = e.input.charCodeAt(++e.position))) : (r = !1)
	}
	Xe(e, "unexpected end of the stream within a flow collection")
}
function XQe(e, t) {
	var r,
		n,
		i = RP,
		s = !1,
		o = !1,
		a = t,
		l = 0,
		c = !1,
		u,
		f
	if (((f = e.input.charCodeAt(e.position)), f === 124)) n = !1
	else if (f === 62) n = !0
	else return !1
	for (e.kind = "scalar", e.result = ""; f !== 0; )
		if (((f = e.input.charCodeAt(++e.position)), f === 43 || f === 45))
			RP === i ? (i = f === 43 ? HY : OQe) : Xe(e, "repeat of a chomping mode identifier")
		else if ((u = $Qe(f)) >= 0)
			u === 0
				? Xe(e, "bad explicit indentation width of a block scalar; it cannot be less than one")
				: o
					? Xe(e, "repeat of an indentation width identifier")
					: ((a = t + u - 1), (o = !0))
		else break
	if (Wg(f)) {
		do f = e.input.charCodeAt(++e.position)
		while (Wg(f))
		if (f === 35)
			do f = e.input.charCodeAt(++e.position)
			while (!zc(f) && f !== 0)
	}
	for (; f !== 0; ) {
		for (LP(e), e.lineIndent = 0, f = e.input.charCodeAt(e.position); (!o || e.lineIndent < a) && f === 32; )
			e.lineIndent++, (f = e.input.charCodeAt(++e.position))
		if ((!o && e.lineIndent > a && (a = e.lineIndent), zc(f))) {
			l++
			continue
		}
		if (e.lineIndent < a) {
			i === HY
				? (e.result += Ui.repeat(
						`
`,
						s ? 1 + l : l,
					))
				: i === RP &&
					s &&
					(e.result += `
`)
			break
		}
		for (
			n
				? Wg(f)
					? ((c = !0),
						(e.result += Ui.repeat(
							`
`,
							s ? 1 + l : l,
						)))
					: c
						? ((c = !1),
							(e.result += Ui.repeat(
								`
`,
								l + 1,
							)))
						: l === 0
							? s && (e.result += " ")
							: (e.result += Ui.repeat(
									`
`,
									l,
								))
				: (e.result += Ui.repeat(
						`
`,
						s ? 1 + l : l,
					)),
				s = !0,
				o = !0,
				l = 0,
				r = e.position;
			!zc(f) && f !== 0;

		)
			f = e.input.charCodeAt(++e.position)
		Qf(e, r, e.position, !1)
	}
	return !0
}
function KY(e, t) {
	var r,
		n = e.tag,
		i = e.anchor,
		s = [],
		o,
		a = !1,
		l
	if (e.firstTabInLine !== -1) return !1
	for (
		e.anchor !== null && (e.anchorMap[e.anchor] = s), l = e.input.charCodeAt(e.position);
		l !== 0 &&
		(e.firstTabInLine !== -1 &&
			((e.position = e.firstTabInLine), Xe(e, "tab characters must not be used in indentation")),
		!(l !== 45 || ((o = e.input.charCodeAt(e.position + 1)), !Mo(o))));

	) {
		if (((a = !0), e.position++, _i(e, !0, -1) && e.lineIndent <= t)) {
			s.push(null), (l = e.input.charCodeAt(e.position))
			continue
		}
		if (
			((r = e.line),
			mm(e, t, cK, !1, !0),
			s.push(e.result),
			_i(e, !0, -1),
			(l = e.input.charCodeAt(e.position)),
			(e.line === r || e.lineIndent > t) && l !== 0)
		)
			Xe(e, "bad indentation of a sequence entry")
		else if (e.lineIndent < t) break
	}
	return a ? ((e.tag = n), (e.anchor = i), (e.kind = "sequence"), (e.result = s), !0) : !1
}
function eNe(e, t, r) {
	var n,
		i,
		s,
		o,
		a,
		l,
		c = e.tag,
		u = e.anchor,
		f = {},
		p = Object.create(null),
		g = null,
		m = null,
		y = null,
		C = !1,
		v = !1,
		b
	if (e.firstTabInLine !== -1) return !1
	for (e.anchor !== null && (e.anchorMap[e.anchor] = f), b = e.input.charCodeAt(e.position); b !== 0; ) {
		if (
			(!C &&
				e.firstTabInLine !== -1 &&
				((e.position = e.firstTabInLine), Xe(e, "tab characters must not be used in indentation")),
			(n = e.input.charCodeAt(e.position + 1)),
			(s = e.line),
			(b === 63 || b === 58) && Mo(n))
		)
			b === 63
				? (C && (Am(e, f, p, g, m, null, o, a, l), (g = m = y = null)), (v = !0), (C = !0), (i = !0))
				: C
					? ((C = !1), (i = !0))
					: Xe(
							e,
							"incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line",
						),
				(e.position += 1),
				(b = n)
		else {
			if (((o = e.line), (a = e.lineStart), (l = e.position), !mm(e, r, lK, !1, !0))) break
			if (e.line === s) {
				for (b = e.input.charCodeAt(e.position); Wg(b); ) b = e.input.charCodeAt(++e.position)
				if (b === 58)
					(b = e.input.charCodeAt(++e.position)),
						Mo(b) ||
							Xe(
								e,
								"a whitespace character is expected after the key-value separator within a block mapping",
							),
						C && (Am(e, f, p, g, m, null, o, a, l), (g = m = y = null)),
						(v = !0),
						(C = !1),
						(i = !1),
						(g = e.tag),
						(m = e.result)
				else if (v) Xe(e, "can not read an implicit mapping pair; a colon is missed")
				else return (e.tag = c), (e.anchor = u), !0
			} else if (v) Xe(e, "can not read a block mapping entry; a multiline key may not be an implicit key")
			else return (e.tag = c), (e.anchor = u), !0
		}
		if (
			((e.line === s || e.lineIndent > t) &&
				(C && ((o = e.line), (a = e.lineStart), (l = e.position)),
				mm(e, t, zI, !0, i) && (C ? (m = e.result) : (y = e.result)),
				C || (Am(e, f, p, g, m, y, o, a, l), (g = m = y = null)),
				_i(e, !0, -1),
				(b = e.input.charCodeAt(e.position))),
			(e.line === s || e.lineIndent > t) && b !== 0)
		)
			Xe(e, "bad indentation of a mapping entry")
		else if (e.lineIndent < t) break
	}
	return (
		C && Am(e, f, p, g, m, null, o, a, l),
		v && ((e.tag = c), (e.anchor = u), (e.kind = "mapping"), (e.result = f)),
		v
	)
}
function tNe(e) {
	var t,
		r = !1,
		n = !1,
		i,
		s,
		o
	if (((o = e.input.charCodeAt(e.position)), o !== 33)) return !1
	if (
		(e.tag !== null && Xe(e, "duplication of a tag property"),
		(o = e.input.charCodeAt(++e.position)),
		o === 60
			? ((r = !0), (o = e.input.charCodeAt(++e.position)))
			: o === 33
				? ((n = !0), (i = "!!"), (o = e.input.charCodeAt(++e.position)))
				: (i = "!"),
		(t = e.position),
		r)
	) {
		do o = e.input.charCodeAt(++e.position)
		while (o !== 0 && o !== 62)
		e.position < e.length
			? ((s = e.input.slice(t, e.position)), (o = e.input.charCodeAt(++e.position)))
			: Xe(e, "unexpected end of the stream within a verbatim tag")
	} else {
		for (; o !== 0 && !Mo(o); )
			o === 33 &&
				(n
					? Xe(e, "tag suffix cannot contain exclamation marks")
					: ((i = e.input.slice(t - 1, e.position + 1)),
						uK.test(i) || Xe(e, "named tag handle cannot contain such characters"),
						(n = !0),
						(t = e.position + 1))),
				(o = e.input.charCodeAt(++e.position))
		;(s = e.input.slice(t, e.position)), HQe.test(s) && Xe(e, "tag suffix cannot contain flow indicator characters")
	}
	s && !dK.test(s) && Xe(e, "tag name cannot contain such characters: " + s)
	try {
		s = decodeURIComponent(s)
	} catch {
		Xe(e, "tag name is malformed: " + s)
	}
	return (
		r
			? (e.tag = s)
			: Nf.call(e.tagMap, i)
				? (e.tag = e.tagMap[i] + s)
				: i === "!"
					? (e.tag = "!" + s)
					: i === "!!"
						? (e.tag = "tag:yaml.org,2002:" + s)
						: Xe(e, 'undeclared tag handle "' + i + '"'),
		!0
	)
}
function rNe(e) {
	var t, r
	if (((r = e.input.charCodeAt(e.position)), r !== 38)) return !1
	for (
		e.anchor !== null && Xe(e, "duplication of an anchor property"),
			r = e.input.charCodeAt(++e.position),
			t = e.position;
		r !== 0 && !Mo(r) && !pm(r);

	)
		r = e.input.charCodeAt(++e.position)
	return (
		e.position === t && Xe(e, "name of an anchor node must contain at least one character"),
		(e.anchor = e.input.slice(t, e.position)),
		!0
	)
}
function nNe(e) {
	var t, r, n
	if (((n = e.input.charCodeAt(e.position)), n !== 42)) return !1
	for (n = e.input.charCodeAt(++e.position), t = e.position; n !== 0 && !Mo(n) && !pm(n); )
		n = e.input.charCodeAt(++e.position)
	return (
		e.position === t && Xe(e, "name of an alias node must contain at least one character"),
		(r = e.input.slice(t, e.position)),
		Nf.call(e.anchorMap, r) || Xe(e, 'unidentified alias "' + r + '"'),
		(e.result = e.anchorMap[r]),
		_i(e, !0, -1),
		!0
	)
}
function mm(e, t, r, n, i) {
	var s,
		o,
		a,
		l = 1,
		c = !1,
		u = !1,
		f,
		p,
		g,
		m,
		y,
		C
	if (
		(e.listener !== null && e.listener("open", e),
		(e.tag = null),
		(e.anchor = null),
		(e.kind = null),
		(e.result = null),
		(s = o = a = zI === r || cK === r),
		n &&
			_i(e, !0, -1) &&
			((c = !0), e.lineIndent > t ? (l = 1) : e.lineIndent === t ? (l = 0) : e.lineIndent < t && (l = -1)),
		l === 1)
	)
		for (; tNe(e) || rNe(e); )
			_i(e, !0, -1)
				? ((c = !0),
					(a = s),
					e.lineIndent > t ? (l = 1) : e.lineIndent === t ? (l = 0) : e.lineIndent < t && (l = -1))
				: (a = !1)
	if (
		(a && (a = c || i),
		(l === 1 || zI === r) &&
			(JI === r || lK === r ? (y = t) : (y = t + 1),
			(C = e.position - e.lineStart),
			l === 1
				? (a && (KY(e, C) || eNe(e, C, y))) || ZQe(e, y)
					? (u = !0)
					: ((o && XQe(e, y)) || zQe(e, y) || jQe(e, y)
							? (u = !0)
							: nNe(e)
								? ((u = !0),
									(e.tag !== null || e.anchor !== null) &&
										Xe(e, "alias node should not have any properties"))
								: JQe(e, y, JI === r) && ((u = !0), e.tag === null && (e.tag = "?")),
						e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
				: l === 0 && (u = a && KY(e, C))),
		e.tag === null)
	)
		e.anchor !== null && (e.anchorMap[e.anchor] = e.result)
	else if (e.tag === "?") {
		for (
			e.result !== null &&
				e.kind !== "scalar" &&
				Xe(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'),
				f = 0,
				p = e.implicitTypes.length;
			f < p;
			f += 1
		)
			if (((m = e.implicitTypes[f]), m.resolve(e.result))) {
				;(e.result = m.construct(e.result)),
					(e.tag = m.tag),
					e.anchor !== null && (e.anchorMap[e.anchor] = e.result)
				break
			}
	} else if (e.tag !== "!") {
		if (Nf.call(e.typeMap[e.kind || "fallback"], e.tag)) m = e.typeMap[e.kind || "fallback"][e.tag]
		else
			for (m = null, g = e.typeMap.multi[e.kind || "fallback"], f = 0, p = g.length; f < p; f += 1)
				if (e.tag.slice(0, g[f].tag.length) === g[f].tag) {
					m = g[f]
					break
				}
		m || Xe(e, "unknown tag !<" + e.tag + ">"),
			e.result !== null &&
				m.kind !== e.kind &&
				Xe(
					e,
					"unacceptable node kind for !<" +
						e.tag +
						'> tag; it should be "' +
						m.kind +
						'", not "' +
						e.kind +
						'"',
				),
			m.resolve(e.result, e.tag)
				? ((e.result = m.construct(e.result, e.tag)), e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
				: Xe(e, "cannot resolve a node with !<" + e.tag + "> explicit tag")
	}
	return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || u
}
function iNe(e) {
	var t = e.position,
		r,
		n,
		i,
		s = !1,
		o
	for (
		e.version = null,
			e.checkLineBreaks = e.legacy,
			e.tagMap = Object.create(null),
			e.anchorMap = Object.create(null);
		(o = e.input.charCodeAt(e.position)) !== 0 &&
		(_i(e, !0, -1), (o = e.input.charCodeAt(e.position)), !(e.lineIndent > 0 || o !== 37));

	) {
		for (s = !0, o = e.input.charCodeAt(++e.position), r = e.position; o !== 0 && !Mo(o); )
			o = e.input.charCodeAt(++e.position)
		for (
			n = e.input.slice(r, e.position),
				i = [],
				n.length < 1 && Xe(e, "directive name must not be less than one character in length");
			o !== 0;

		) {
			for (; Wg(o); ) o = e.input.charCodeAt(++e.position)
			if (o === 35) {
				do o = e.input.charCodeAt(++e.position)
				while (o !== 0 && !zc(o))
				break
			}
			if (zc(o)) break
			for (r = e.position; o !== 0 && !Mo(o); ) o = e.input.charCodeAt(++e.position)
			i.push(e.input.slice(r, e.position))
		}
		o !== 0 && LP(e), Nf.call($Y, n) ? $Y[n](e, n, i) : jI(e, 'unknown document directive "' + n + '"')
	}
	if (
		(_i(e, !0, -1),
		e.lineIndent === 0 &&
		e.input.charCodeAt(e.position) === 45 &&
		e.input.charCodeAt(e.position + 1) === 45 &&
		e.input.charCodeAt(e.position + 2) === 45
			? ((e.position += 3), _i(e, !0, -1))
			: s && Xe(e, "directives end mark is expected"),
		mm(e, e.lineIndent - 1, zI, !1, !0),
		_i(e, !0, -1),
		e.checkLineBreaks &&
			VQe.test(e.input.slice(t, e.position)) &&
			jI(e, "non-ASCII line breaks are interpreted as content"),
		e.documents.push(e.result),
		e.position === e.lineStart && eS(e))
	) {
		e.input.charCodeAt(e.position) === 46 && ((e.position += 3), _i(e, !0, -1))
		return
	}
	if (e.position < e.length - 1) Xe(e, "end of the stream or a document separator is expected")
	else return
}
function pK(e, t) {
	;(e = String(e)),
		(t = t || {}),
		e.length !== 0 &&
			(e.charCodeAt(e.length - 1) !== 10 &&
				e.charCodeAt(e.length - 1) !== 13 &&
				(e += `
`),
			e.charCodeAt(0) === 65279 && (e = e.slice(1)))
	var r = new KQe(e, t),
		n = e.indexOf("\0")
	for (
		n !== -1 && ((r.position = n), Xe(r, "null byte is not allowed in input")), r.input += "\0";
		r.input.charCodeAt(r.position) === 32;

	)
		(r.lineIndent += 1), (r.position += 1)
	for (; r.position < r.length - 1; ) iNe(r)
	return r.documents
}
function sNe(e, t, r) {
	t !== null && typeof t == "object" && typeof r > "u" && ((r = t), (t = null))
	var n = pK(e, r)
	if (typeof t != "function") return n
	for (var i = 0, s = n.length; i < s; i += 1) t(n[i])
}
function oNe(e, t) {
	var r = pK(e, t)
	if (r.length !== 0) {
		if (r.length === 1) return r[0]
		throw new ko("expected a single document in the stream, but found more")
	}
}
var aNe = sNe,
	lNe = oNe,
	AK = { loadAll: aNe, load: lNe },
	mK = Object.prototype.toString,
	yK = Object.prototype.hasOwnProperty,
	OP = 65279,
	cNe = 9,
	Wv = 10,
	uNe = 13,
	dNe = 32,
	fNe = 33,
	hNe = 34,
	MP = 35,
	gNe = 37,
	pNe = 38,
	ANe = 39,
	mNe = 42,
	CK = 44,
	yNe = 45,
	ZI = 58,
	CNe = 61,
	vNe = 62,
	ENe = 63,
	bNe = 64,
	vK = 91,
	EK = 93,
	xNe = 96,
	bK = 123,
	_Ne = 124,
	xK = 125,
	Qs = {}
Qs[0] = "\\0"
Qs[7] = "\\a"
Qs[8] = "\\b"
Qs[9] = "\\t"
Qs[10] = "\\n"
Qs[11] = "\\v"
Qs[12] = "\\f"
Qs[13] = "\\r"
Qs[27] = "\\e"
Qs[34] = '\\"'
Qs[92] = "\\\\"
Qs[133] = "\\N"
Qs[160] = "\\_"
Qs[8232] = "\\L"
Qs[8233] = "\\P"
var wNe = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"],
	INe = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/
function SNe(e, t) {
	var r, n, i, s, o, a, l
	if (t === null) return {}
	for (r = {}, n = Object.keys(t), i = 0, s = n.length; i < s; i += 1)
		(o = n[i]),
			(a = String(t[o])),
			o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)),
			(l = e.compiledTypeMap.fallback[o]),
			l && yK.call(l.styleAliases, a) && (a = l.styleAliases[a]),
			(r[o] = a)
	return r
}
function BNe(e) {
	var t, r, n
	if (((t = e.toString(16).toUpperCase()), e <= 255)) (r = "x"), (n = 2)
	else if (e <= 65535) (r = "u"), (n = 4)
	else if (e <= 4294967295) (r = "U"), (n = 8)
	else throw new ko("code point within a string may not be greater than 0xFFFFFFFF")
	return "\\" + r + Ui.repeat("0", n - t.length) + t
}
var DNe = 1,
	Gv = 2
function TNe(e) {
	;(this.schema = e.schema || aK),
		(this.indent = Math.max(1, e.indent || 2)),
		(this.noArrayIndent = e.noArrayIndent || !1),
		(this.skipInvalid = e.skipInvalid || !1),
		(this.flowLevel = Ui.isNothing(e.flowLevel) ? -1 : e.flowLevel),
		(this.styleMap = SNe(this.schema, e.styles || null)),
		(this.sortKeys = e.sortKeys || !1),
		(this.lineWidth = e.lineWidth || 80),
		(this.noRefs = e.noRefs || !1),
		(this.noCompatMode = e.noCompatMode || !1),
		(this.condenseFlow = e.condenseFlow || !1),
		(this.quotingType = e.quotingType === '"' ? Gv : DNe),
		(this.forceQuotes = e.forceQuotes || !1),
		(this.replacer = typeof e.replacer == "function" ? e.replacer : null),
		(this.implicitTypes = this.schema.compiledImplicit),
		(this.explicitTypes = this.schema.compiledExplicit),
		(this.tag = null),
		(this.result = ""),
		(this.duplicates = []),
		(this.usedDuplicates = null)
}
function JY(e, t) {
	for (var r = Ui.repeat(" ", t), n = 0, i = -1, s = "", o, a = e.length; n < a; )
		(i = e.indexOf(
			`
`,
			n,
		)),
			i === -1 ? ((o = e.slice(n)), (n = a)) : ((o = e.slice(n, i + 1)), (n = i + 1)),
			o.length &&
				o !==
					`
` &&
				(s += r),
			(s += o)
	return s
}
function FP(e, t) {
	return (
		`
` + Ui.repeat(" ", e.indent * t)
	)
}
function RNe(e, t) {
	var r, n, i
	for (r = 0, n = e.implicitTypes.length; r < n; r += 1) if (((i = e.implicitTypes[r]), i.resolve(t))) return !0
	return !1
}
function XI(e) {
	return e === dNe || e === cNe
}
function $v(e) {
	return (
		(32 <= e && e <= 126) ||
		(161 <= e && e <= 55295 && e !== 8232 && e !== 8233) ||
		(57344 <= e && e <= 65533 && e !== OP) ||
		(65536 <= e && e <= 1114111)
	)
}
function zY(e) {
	return $v(e) && e !== OP && e !== uNe && e !== Wv
}
function jY(e, t, r) {
	var n = zY(e),
		i = n && !XI(e)
	return (
		((r ? n : n && e !== CK && e !== vK && e !== EK && e !== bK && e !== xK) && e !== MP && !(t === ZI && !i)) ||
		(zY(t) && !XI(t) && e === MP) ||
		(t === ZI && i)
	)
}
function kNe(e) {
	return (
		$v(e) &&
		e !== OP &&
		!XI(e) &&
		e !== yNe &&
		e !== ENe &&
		e !== ZI &&
		e !== CK &&
		e !== vK &&
		e !== EK &&
		e !== bK &&
		e !== xK &&
		e !== MP &&
		e !== pNe &&
		e !== mNe &&
		e !== fNe &&
		e !== _Ne &&
		e !== CNe &&
		e !== vNe &&
		e !== ANe &&
		e !== hNe &&
		e !== gNe &&
		e !== bNe &&
		e !== xNe
	)
}
function MNe(e) {
	return !XI(e) && e !== ZI
}
function Vv(e, t) {
	var r = e.charCodeAt(t),
		n
	return r >= 55296 && r <= 56319 && t + 1 < e.length && ((n = e.charCodeAt(t + 1)), n >= 56320 && n <= 57343)
		? (r - 55296) * 1024 + n - 56320 + 65536
		: r
}
function _K(e) {
	var t = /^\n* /
	return t.test(e)
}
var wK = 1,
	QP = 2,
	IK = 3,
	SK = 4,
	gm = 5
function FNe(e, t, r, n, i, s, o, a) {
	var l,
		c = 0,
		u = null,
		f = !1,
		p = !1,
		g = n !== -1,
		m = -1,
		y = kNe(Vv(e, 0)) && MNe(Vv(e, e.length - 1))
	if (t || o)
		for (l = 0; l < e.length; c >= 65536 ? (l += 2) : l++) {
			if (((c = Vv(e, l)), !$v(c))) return gm
			;(y = y && jY(c, u, a)), (u = c)
		}
	else {
		for (l = 0; l < e.length; c >= 65536 ? (l += 2) : l++) {
			if (((c = Vv(e, l)), c === Wv)) (f = !0), g && ((p = p || (l - m - 1 > n && e[m + 1] !== " ")), (m = l))
			else if (!$v(c)) return gm
			;(y = y && jY(c, u, a)), (u = c)
		}
		p = p || (g && l - m - 1 > n && e[m + 1] !== " ")
	}
	return !f && !p
		? y && !o && !i(e)
			? wK
			: s === Gv
				? gm
				: QP
		: r > 9 && _K(e)
			? gm
			: o
				? s === Gv
					? gm
					: QP
				: p
					? SK
					: IK
}
function QNe(e, t, r, n, i) {
	e.dump = (function () {
		if (t.length === 0) return e.quotingType === Gv ? '""' : "''"
		if (!e.noCompatMode && (wNe.indexOf(t) !== -1 || INe.test(t)))
			return e.quotingType === Gv ? '"' + t + '"' : "'" + t + "'"
		var s = e.indent * Math.max(1, r),
			o = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s),
			a = n || (e.flowLevel > -1 && r >= e.flowLevel)
		function l(c) {
			return RNe(e, c)
		}
		switch (FNe(t, a, e.indent, o, l, e.quotingType, e.forceQuotes && !n, i)) {
			case wK:
				return t
			case QP:
				return "'" + t.replace(/'/g, "''") + "'"
			case IK:
				return "|" + ZY(t, e.indent) + XY(JY(t, s))
			case SK:
				return ">" + ZY(t, e.indent) + XY(JY(NNe(t, o), s))
			case gm:
				return '"' + PNe(t) + '"'
			default:
				throw new ko("impossible error: invalid scalar style")
		}
	})()
}
function ZY(e, t) {
	var r = _K(e) ? String(t) : "",
		n =
			e[e.length - 1] ===
			`
`,
		i =
			n &&
			(e[e.length - 2] ===
				`
` ||
				e ===
					`
`),
		s = i ? "+" : n ? "" : "-"
	return (
		r +
		s +
		`
`
	)
}
function XY(e) {
	return e[e.length - 1] ===
		`
`
		? e.slice(0, -1)
		: e
}
function NNe(e, t) {
	for (
		var r = /(\n+)([^\n]*)/g,
			n = (function () {
				var c = e.indexOf(`
`)
				return (c = c !== -1 ? c : e.length), (r.lastIndex = c), eK(e.slice(0, c), t)
			})(),
			i =
				e[0] ===
					`
` || e[0] === " ",
			s,
			o;
		(o = r.exec(e));

	) {
		var a = o[1],
			l = o[2]
		;(s = l[0] === " "),
			(n +=
				a +
				(!i && !s && l !== ""
					? `
`
					: "") +
				eK(l, t)),
			(i = s)
	}
	return n
}
function eK(e, t) {
	if (e === "" || e[0] === " ") return e
	for (var r = / [^ ]/g, n, i = 0, s, o = 0, a = 0, l = ""; (n = r.exec(e)); )
		(a = n.index),
			a - i > t &&
				((s = o > i ? o : a),
				(l +=
					`
` + e.slice(i, s)),
				(i = s + 1)),
			(o = a)
	return (
		(l += `
`),
		e.length - i > t && o > i
			? (l +=
					e.slice(i, o) +
					`
` +
					e.slice(o + 1))
			: (l += e.slice(i)),
		l.slice(1)
	)
}
function PNe(e) {
	for (var t = "", r = 0, n, i = 0; i < e.length; r >= 65536 ? (i += 2) : i++)
		(r = Vv(e, i)), (n = Qs[r]), !n && $v(r) ? ((t += e[i]), r >= 65536 && (t += e[i + 1])) : (t += n || BNe(r))
	return t
}
function LNe(e, t, r) {
	var n = "",
		i = e.tag,
		s,
		o,
		a
	for (s = 0, o = r.length; s < o; s += 1)
		(a = r[s]),
			e.replacer && (a = e.replacer.call(r, String(s), a)),
			(vd(e, t, a, !1, !1) || (typeof a > "u" && vd(e, t, null, !1, !1))) &&
				(n !== "" && (n += "," + (e.condenseFlow ? "" : " ")), (n += e.dump))
	;(e.tag = i), (e.dump = "[" + n + "]")
}
function tK(e, t, r, n) {
	var i = "",
		s = e.tag,
		o,
		a,
		l
	for (o = 0, a = r.length; o < a; o += 1)
		(l = r[o]),
			e.replacer && (l = e.replacer.call(r, String(o), l)),
			(vd(e, t + 1, l, !0, !0, !1, !0) || (typeof l > "u" && vd(e, t + 1, null, !0, !0, !1, !0))) &&
				((!n || i !== "") && (i += FP(e, t)),
				e.dump && Wv === e.dump.charCodeAt(0) ? (i += "-") : (i += "- "),
				(i += e.dump))
	;(e.tag = s), (e.dump = i || "[]")
}
function UNe(e, t, r) {
	var n = "",
		i = e.tag,
		s = Object.keys(r),
		o,
		a,
		l,
		c,
		u
	for (o = 0, a = s.length; o < a; o += 1)
		(u = ""),
			n !== "" && (u += ", "),
			e.condenseFlow && (u += '"'),
			(l = s[o]),
			(c = r[l]),
			e.replacer && (c = e.replacer.call(r, l, c)),
			vd(e, t, l, !1, !1) &&
				(e.dump.length > 1024 && (u += "? "),
				(u += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " ")),
				vd(e, t, c, !1, !1) && ((u += e.dump), (n += u)))
	;(e.tag = i), (e.dump = "{" + n + "}")
}
function ONe(e, t, r, n) {
	var i = "",
		s = e.tag,
		o = Object.keys(r),
		a,
		l,
		c,
		u,
		f,
		p
	if (e.sortKeys === !0) o.sort()
	else if (typeof e.sortKeys == "function") o.sort(e.sortKeys)
	else if (e.sortKeys) throw new ko("sortKeys must be a boolean or a function")
	for (a = 0, l = o.length; a < l; a += 1)
		(p = ""),
			(!n || i !== "") && (p += FP(e, t)),
			(c = o[a]),
			(u = r[c]),
			e.replacer && (u = e.replacer.call(r, c, u)),
			vd(e, t + 1, c, !0, !0, !0) &&
				((f = (e.tag !== null && e.tag !== "?") || (e.dump && e.dump.length > 1024)),
				f && (e.dump && Wv === e.dump.charCodeAt(0) ? (p += "?") : (p += "? ")),
				(p += e.dump),
				f && (p += FP(e, t)),
				vd(e, t + 1, u, !0, f) &&
					(e.dump && Wv === e.dump.charCodeAt(0) ? (p += ":") : (p += ": "), (p += e.dump), (i += p)))
	;(e.tag = s), (e.dump = i || "{}")
}
function rK(e, t, r) {
	var n, i, s, o, a, l
	for (i = r ? e.explicitTypes : e.implicitTypes, s = 0, o = i.length; s < o; s += 1)
		if (
			((a = i[s]),
			(a.instanceOf || a.predicate) &&
				(!a.instanceOf || (typeof t == "object" && t instanceof a.instanceOf)) &&
				(!a.predicate || a.predicate(t)))
		) {
			if (
				(r ? (a.multi && a.representName ? (e.tag = a.representName(t)) : (e.tag = a.tag)) : (e.tag = "?"),
				a.represent)
			) {
				if (((l = e.styleMap[a.tag] || a.defaultStyle), mK.call(a.represent) === "[object Function]"))
					n = a.represent(t, l)
				else if (yK.call(a.represent, l)) n = a.represent[l](t, l)
				else throw new ko("!<" + a.tag + '> tag resolver accepts not "' + l + '" style')
				e.dump = n
			}
			return !0
		}
	return !1
}
function vd(e, t, r, n, i, s, o) {
	;(e.tag = null), (e.dump = r), rK(e, r, !1) || rK(e, r, !0)
	var a = mK.call(e.dump),
		l = n,
		c
	n && (n = e.flowLevel < 0 || e.flowLevel > t)
	var u = a === "[object Object]" || a === "[object Array]",
		f,
		p
	if (
		(u && ((f = e.duplicates.indexOf(r)), (p = f !== -1)),
		((e.tag !== null && e.tag !== "?") || p || (e.indent !== 2 && t > 0)) && (i = !1),
		p && e.usedDuplicates[f])
	)
		e.dump = "*ref_" + f
	else {
		if ((u && p && !e.usedDuplicates[f] && (e.usedDuplicates[f] = !0), a === "[object Object]"))
			n && Object.keys(e.dump).length !== 0
				? (ONe(e, t, e.dump, i), p && (e.dump = "&ref_" + f + e.dump))
				: (UNe(e, t, e.dump), p && (e.dump = "&ref_" + f + " " + e.dump))
		else if (a === "[object Array]")
			n && e.dump.length !== 0
				? (e.noArrayIndent && !o && t > 0 ? tK(e, t - 1, e.dump, i) : tK(e, t, e.dump, i),
					p && (e.dump = "&ref_" + f + e.dump))
				: (LNe(e, t, e.dump), p && (e.dump = "&ref_" + f + " " + e.dump))
		else if (a === "[object String]") e.tag !== "?" && QNe(e, e.dump, t, s, l)
		else {
			if (a === "[object Undefined]") return !1
			if (e.skipInvalid) return !1
			throw new ko("unacceptable kind of an object to dump " + a)
		}
		e.tag !== null &&
			e.tag !== "?" &&
			((c = encodeURI(e.tag[0] === "!" ? e.tag.slice(1) : e.tag).replace(/!/g, "%21")),
			e.tag[0] === "!"
				? (c = "!" + c)
				: c.slice(0, 18) === "tag:yaml.org,2002:"
					? (c = "!!" + c.slice(18))
					: (c = "!<" + c + ">"),
			(e.dump = c + " " + e.dump))
	}
	return !0
}
function qNe(e, t) {
	var r = [],
		n = [],
		i,
		s
	for (NP(e, r, n), i = 0, s = n.length; i < s; i += 1) t.duplicates.push(r[n[i]])
	t.usedDuplicates = new Array(s)
}
function NP(e, t, r) {
	var n, i, s
	if (e !== null && typeof e == "object")
		if (((i = t.indexOf(e)), i !== -1)) r.indexOf(i) === -1 && r.push(i)
		else if ((t.push(e), Array.isArray(e))) for (i = 0, s = e.length; i < s; i += 1) NP(e[i], t, r)
		else for (n = Object.keys(e), i = 0, s = n.length; i < s; i += 1) NP(e[n[i]], t, r)
}
function VNe(e, t) {
	t = t || {}
	var r = new TNe(t)
	r.noRefs || qNe(e, r)
	var n = e
	return (
		r.replacer && (n = r.replacer.call({ "": n }, "", n)),
		vd(r, 0, n, !0, !0)
			? r.dump +
				`
`
			: ""
	)
}
var HNe = VNe,
	WNe = { dump: HNe }
function qP(e, t) {
	return function () {
		throw new Error(
			"Function yaml." +
				e +
				" is removed in js-yaml 4. Use yaml." +
				t +
				" instead, which is now safe by default.",
		)
	}
}
var tS = AK.load,
	nbt = AK.loadAll,
	ibt = WNe.dump
var sbt = qP("safeLoad", "load"),
	obt = qP("safeLoadAll", "loadAll"),
	abt = qP("safeDump", "dump")
var $Ne = [">", "<", "|", "&", "$", "`", ";"],
	YNe = ["|", "&", ";", "$", "`", "(", ")", "{", "}", "<", ">", "[", "]", '"', "'", "."]
function BK(e, t) {
	if (t === "bash") {
		for (let r of $Ne) if (e.includes(r)) return
		return e.split(" ")
	} else if (t === "powershell") {
		for (let r of YNe) if (e.includes(r)) return
		return e.split(" ")
	}
}
var KNe = `
auto_approval:
  git:
    - type: prefix
      args: ["status"]
    - type: prefix
      args: ["log"]
    - type: prefix
      args: ["diff"]
    - type: prefix
      args: ["show"]
    - type: exact
      args: ["branch"]
    - type: prefix
      args: ["ls-files"]
    - type: prefix
      args: ["blame"]
    - type: prefix
      args: ["rev-parse"]
    - type: prefix
      args: ["remote", "-v"]
    - type: prefix
      args: ["config", "--list"]
    - type: exact
      args: ["config", "user.name"]
    - type: exact
      args: ["config", "user.email"]
    - type: exact
      args: ["branch", "--show-current"]

  kubectl:
    - type: prefix
      args: ["get"]
    - type: prefix
      args: ["describe"]
    - type: prefix
      args: ["explain"]
    - type: prefix
      args: ["logs"]
    - type: prefix
      args: ["top"]
    - type: prefix
      args: ["api-resources"]
    - type: prefix
      args: ["api-versions"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["wait"]
    - type: prefix
      args: ["auth", "can-i"]
    - type: prefix
      args: ["config", "get-contexts"]
    - type: prefix
      args: ["config", "view"]

  bazel:
    - type: prefix
      args: ["query"]
    - type: prefix
      args: ["cquery"]
    - type: prefix
      args: ["config"]
    - type: prefix
      args: ["info"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["help"]
    - type: prefix
      args: ["analyze-profile"]
    - type: prefix
      args: ["aquery"]
    - type: prefix
      args: ["dump"]
    - type: prefix
      args: ["license"]
    - type: prefix
      args: ["print"]
    - type: prefix
      args: ["build", "--nobuild"]
    - type: prefix
      args: ["coverage", "--nobuild"]
    - type: prefix
      args: ["mobile-install", "--nobuild"]
    - type: prefix
      args: ["run", "--nobuild"]
    - type: prefix
      args: ["text", "--nobuild"]
    - type: prefix
      args: ["clean", "--expunge", "--dry-run"]

  docker:
    - type: prefix
      args: ["ps"]
    - type: prefix
      args: ["images"]
    - type: prefix
      args: ["network", "ls"]
    - type: prefix
      args: ["volume", "ls"]
    - type: prefix
      args: ["port"]
    - type: prefix
      args: ["stats"]
    - type: prefix
      args: ["events"]
    - type: prefix
      args: ["diff"]
    - type: prefix
      args: ["history"]
    - type: prefix
      args: ["system", "df"]
    - type: prefix
      args: ["top"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["inspect"]

  npm:
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["outdated"]
    - type: prefix
      args: ["doctor"]
    - type: prefix
      args: ["audit"]
    - type: prefix
      args: ["token", "list"]
    - type: prefix
      args: ["ping"]
    - type: prefix
      args: ["view"]
    - type: prefix
      args: ["owner", "ls"]
    - type: prefix
      args: ["fund"]
    - type: prefix
      args: ["explain"]
    - type: prefix
      args: ["ls"]
    - type: prefix
      args: ["why"]
    - type: prefix
      args: ["prefix"]

  terraform:
    - type: prefix
      args: ["show"]
    - type: prefix
      args: ["providers"]
    - type: prefix
      args: ["state", "list"]
    - type: prefix
      args: ["state", "show"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["fmt", "--check"]
    - type: prefix
      args: ["validate"]
    - type: prefix
      args: ["graph"]
    - type: prefix
      args: ["console"]
    - type: prefix
      args: ["output"]
    - type: prefix
      args: ["refresh", "--dry-run"]
    - type: prefix
      args: ["plan"]

  gradle:
    - type: prefix
      args: ["dependencies"]
    - type: prefix
      args: ["projects"]
    - type: prefix
      args: ["properties"]
    - type: prefix
      args: ["tasks"]
    - type: prefix
      args: ["components"]
    - type: prefix
      args: ["model"]
    - type: prefix
      args: ["buildEnvironment"]
    - type: prefix
      args: ["projectsEvaluated"]
    - type: prefix
      args: ["projects", "--dry-run"]
    - type: prefix
      args: ["dependencies", "--dry-run"]
    - type: prefix
      args: ["help"]
    - type: prefix
      args: ["version"]

  helm:
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["get", "values"]
    - type: prefix
      args: ["get", "manifest"]
    - type: prefix
      args: ["get", "hooks"]
    - type: prefix
      args: ["get", "notes"]
    - type: prefix
      args: ["status"]
    - type: prefix
      args: ["dependency", "list"]
    - type: prefix
      args: ["show", "chart"]
    - type: prefix
      args: ["show", "values"]
    - type: prefix
      args: ["verify"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["env"]

  aws:
    - type: prefix
      args: ["s3", "ls"]
    - type: prefix
      args: ["ec2", "describe-instances"]
    - type: prefix
      args: ["rds", "describe-db-instances"]
    - type: prefix
      args: ["iam", "list-users"]
    - type: prefix
      args: ["iam", "list-roles"]
    - type: prefix
      args: ["lambda", "list-functions"]
    - type: prefix
      args: ["eks", "list-clusters"]
    - type: prefix
      args: ["ecr", "describe-repositories"]
    - type: prefix
      args: ["cloudformation", "list-stacks"]
    - type: prefix
      args: ["configure", "list"]

  gcloud:
    - type: prefix
      args: ["projects", "list"]
    - type: prefix
      args: ["compute", "instances", "list"]
    - type: prefix
      args: ["compute", "zones", "list"]
    - type: prefix
      args: ["compute", "regions", "list"]
    - type: prefix
      args: ["container", "clusters", "list"]
    - type: prefix
      args: ["services", "list"]
    - type: prefix
      args: ["iam", "roles", "list"]
    - type: prefix
      args: ["config", "list"]
    - type: prefix
      args: ["components", "list"]
    - type: prefix
      args: ["version"]

  postgres:
    - type: prefix
      args: ["psql", "-l"]
    - type: prefix
      args: ["pg_dump", "--schema-only"]
    - type: prefix
      args: ["pg_dump", "--schema", "public", "--dry-run"]
    - type: prefix
      args: ["pg_dump", "-s", "-t"]
    - type: prefix
      args: ["pg_controldata"]
    - type: prefix
      args: ["pg_isready"]
    - type: prefix
      args: ["pg_lsclusters"]
    - type: prefix
      args: ["pg_activity"]
    - type: prefix
      args: ["pgbench", "-i", "--dry-run"]

  maven:
    - type: prefix
      args: ["dependency:tree"]
    - type: prefix
      args: ["dependency:analyze"]
    - type: prefix
      args: ["help:effective-pom"]
    - type: prefix
      args: ["help:describe"]
    - type: prefix
      args: ["help:evaluate"]
    - type: prefix
      args: ["dependency:list"]
    - type: prefix
      args: ["dependency:build-classpath"]
    - type: prefix
      args: ["help:active-profiles"]
    - type: prefix
      args: ["help:effective-settings"]
    - type: prefix
      args: ["version"]

  redis-cli:
    - type: prefix
      args: ["info"]
    - type: prefix
      args: ["monitor"]
    - type: prefix
      args: ["memory", "stats"]
    - type: prefix
      args: ["memory", "doctor"]
    - type: prefix
      args: ["latency", "doctor"]
    - type: prefix
      args: ["cluster", "info"]
    - type: prefix
      args: ["client", "list"]
    - type: prefix
      args: ["slowlog", "get"]
    - type: prefix
      args: ["config", "get"]
    - type: prefix
      args: ["info", "keyspace"]

  yarn:
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["info"]
    - type: prefix
      args: ["why"]
    - type: prefix
      args: ["licenses", "list"]
    - type: prefix
      args: ["outdated"]
    - type: prefix
      args: ["check"]
    - type: prefix
      args: ["audit"]
    - type: prefix
      args: ["workspaces", "info"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["config", "list"]

  az:
    - type: prefix
      args: ["account", "list"]
    - type: prefix
      args: ["group", "list"]
    - type: prefix
      args: ["vm", "list"]
    - type: prefix
      args: ["aks", "list"]
    - type: prefix
      args: ["acr", "list"]
    - type: prefix
      args: ["storage", "account", "list"]
    - type: prefix
      args: ["network", "vnet", "list"]
    - type: prefix
      args: ["webapp", "list"]
    - type: prefix
      args: ["functionapp", "list"]
    - type: prefix
      args: ["version"]

  vault:
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["policy", "list"]
    - type: prefix
      args: ["auth", "list"]
    - type: prefix
      args: ["secrets", "list"]
    - type: prefix
      args: ["audit", "list"]
    - type: prefix
      args: ["status"]
    - type: prefix
      args: ["token", "lookup"]
    - type: prefix
      args: ["read"]
    - type: prefix
      args: ["version"]

  podman:
    - type: prefix
      args: ["ps"]
    - type: prefix
      args: ["images"]
    - type: prefix
      args: ["pod", "ps"]
    - type: prefix
      args: ["volume", "ls"]
    - type: prefix
      args: ["network", "ls"]
    - type: prefix
      args: ["stats"]
    - type: prefix
      args: ["top"]
    - type: prefix
      args: ["logs"]
    - type: prefix
      args: ["inspect"]
    - type: prefix
      args: ["port"]

  deno:
    - type: prefix
      args: ["info"]
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["doc"]
    - type: prefix
      args: ["lint"]
    - type: prefix
      args: ["types"]
    - type: prefix
      args: ["check"]
    - type: prefix
      args: ["compile", "--dry-run"]
    - type: prefix
      args: ["task", "--list"]
    - type: prefix
      args: ["test", "--dry-run"]
    - type: prefix
      args: ["version"]

  rustup:
    - type: prefix
      args: ["show"]
    - type: prefix
      args: ["toolchain", "list"]
    - type: prefix
      args: ["target", "list"]
    - type: prefix
      args: ["component", "list"]
    - type: prefix
      args: ["override", "list"]
    - type: prefix
      args: ["which"]
    - type: prefix
      args: ["doc"]
    - type: prefix
      args: ["man"]
    - type: prefix
      args: ["version"]

  cargo:
    - type: prefix
      args: ["tree"]
    - type: prefix
      args: ["metadata"]
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["verify"]
    - type: prefix
      args: ["search"]
    - type: prefix
      args: ["vendor", "--dry-run"]
    - type: prefix
      args: ["outdated"]
    - type: prefix
      args: ["doc"]
    - type: prefix
      args: ["config", "get"]
    - type: prefix
      args: ["version"]

  pip:
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["show"]
    - type: prefix
      args: ["check"]
    - type: prefix
      args: ["debug"]
    - type: prefix
      args: ["config", "list"]
    - type: prefix
      args: ["index"]
    - type: prefix
      args: ["hash"]
    - type: prefix
      args: ["cache", "list"]
    - type: prefix
      args: ["freeze"]
    - type: prefix
      args: ["version"]
`,
	JNe = `
auto_approval:
  cd:
    type: any
  date:
    type: any
  cal:
    type: any
  uname:
    type: prefix
    args: ["-a"]
  hostname:
    type: any
  whoami:
    type: any
  id:
    type: any
  ps:
    type: any
  free:
    type: any
  w:
    type: any
  who:
    type: any
  ping:
    type: not_contains
    args: ["-f"]
  netstat:
    type: any
  ss:
    type: any
  ip:
    type: prefix
    args: ["addr"]
  dig:
    type: any
  nslookup:
    type: any
  pwd:
    type: any
  ls:
    type: any
  file:
    type: any
  stat:
    type: any
  du:
    type: any
  df:
    type: any
  cat:
    type: any
  less:
    type: any
  more:
    type: any
  head:
    type: any
  tail:
    type: not_contains
    args: ["-f"]
  wc:
    type: any
`,
	zNe = `
auto_approval:
  cd:
    type: any
  Get-Date:
    type: any
  date:
    type: any
  Get-ComputerInfo:
    type: any
  Get-Host:
    type: any
  $env:USERNAME:
    type: any
  whoami:
    type: any
  Get-Process:
    type: any
  ps:
    type: any
  gps:
    type: any
  Get-Service:
    type: any
  gsv:
    type: any
  Get-NetIPAddress:
    type: any
  ipconfig:
    type: any
  Get-NetTCPConnection:
    type: any
  netstat:
    type: any
  Resolve-DnsName:
    type: any
  nslookup:
    type: any
  Get-DnsClientServerAddress:
    type: any
  Get-Location:
    type: any
  pwd:
    type: any
  gl:
    type: any
  Get-ChildItem:
    type: any
  dir:
    type: any
  ls:
    type: any
  gci:
    type: any
  Get-Item:
    type: any
  gi:
    type: any
  Get-ItemProperty:
    type: any
  gp:
    type: any
  Get-Content:
    type: not_contains
    args: ["-Wait"]
  cat:
    type: any
  gc:
    type: any
  type:
    type: any
  Select-String:
    type: any
  sls:
    type: any
  findstr:
    type: any
  Get-PSDrive:
    type: any
  gdr:
    type: any
  Get-Volume:
    type: any
  Measure-Object:
    type: any
  measure:
    type: any
  Select-Object:
    type: any
  select:
    type: any
`
function ym(e, t) {
	let r
	if (e === "win32") {
		if (t !== "powershell") throw new Error("Only PowerShell is supported on Windows")
		r = tS(zNe)
	} else {
		if (t !== "bash") throw new Error("Only bash is supported on non-Windows platforms")
		r = tS(JNe)
	}
	let n = tS(KNe)
	return { auto_approval: { ...r.auto_approval, ...n.auto_approval } }
}
function Cm(e, t, r) {
	let n = r
	if (n !== "bash" && n !== "powershell") return !1
	let i = BK(t, n)
	if (!i || i.length === 0) return !1
	let s = i[0],
		o = i.slice(1),
		a = e.auto_approval[s]
	if (!a) return !1
	for (let l of Array.isArray(a) ? a : [a]) {
		let c = l.args ?? []
		if (l.type === "prefix") {
			if (c.length <= o.length && c.every((u, f) => o[f] === u)) return !0
		} else if (l.type === "exact") {
			if (c.length === o.length && c.every((u, f) => o[f] === u)) return !0
		} else {
			if (l.type === "any") return !0
			if (l.type === "not_contains" && !c.some((u) => o.includes(u))) return !0
		}
	}
	return !1
}
var vm = class extends rn {
	_getAgentConfig
	_chatMode
	_platform
	_shellName
	execPromise = (0, DK.promisify)(TK.exec)
	_allowlist
	constructor(t, r, n, i) {
		super(ja.shell, xt.Check),
			(this._getAgentConfig = t),
			(this._chatMode = r),
			(this._platform = n),
			(this._shellName = i),
			(this._allowlist = ym(process.platform, this._shellName))
	}
	get description() {
		return `Execute a shell command.

- You can use this tool to interact with the user's local version control system. Do not use the
retrieval tool for that purpose.
- If there is a more specific tool available that can perform the function, use that tool instead of
this one.

The OS is ${process.platform}. The shell is '${this._shellName}'.`
	}
	inputSchemaJson = JSON.stringify({
		type: "object",
		properties: {
			command: { type: "string", description: "The shell command to execute." },
		},
		required: ["command"],
	})
	checkToolCallSafe(t) {
		if (this._getAgentConfig().shellCommandsAlwaysSafe) return !0
		if (this._chatMode === Mn.agent) {
			let r = t.command
			return Cm(this._allowlist, r, this._shellName)
		}
		return !1
	}
	async call(t, r, n) {
		let i = t.command
		try {
			let s = await this.execPromise(i, {
				signal: n,
				cwd: await Do().getCwd(),
				shell: this._shellName,
			})
			return { text: s.stdout + s.stderr, isError: !1 }
		} catch (s) {
			return jNe(s) && s.stdout !== void 0 && s.stderr !== void 0
				? { text: s.stdout + s.stderr, isError: !1 }
				: {
						text: `Failed to execute shell command: ${s instanceof Error ? s.message : String(s)}`,
						isError: !0,
					}
		}
	}
}
function jNe(e) {
	return (
		e !== null &&
		typeof e == "object" &&
		"code" in e &&
		"stderr" in e &&
		"stdout" in e &&
		"message" in e &&
		"name" in e
	)
}
function RK(e) {
	let t = [],
		r = ""
	for (let n = 0; n < e.length; n++) {
		let i = e[n]
		;/[a-zA-Z0-9_]/.test(i)
			? (r += i)
			: /\s/.test(i)
				? r && (t.push(r), (r = ""))
				: (r && (t.push(r), (r = "")), t.push(i))
	}
	return r && t.push(r), t
}
function ZNe(e, t, r = 100) {
	let n = e.length,
		i = t.length,
		s = Array.from({ length: n }).fill(-1)
	if (n === 0 || i === 0) return s
	let o = Array.from({ length: n + 1 })
			.fill([])
			.map(() => Array.from({ length: 2 * r + 1 }).fill(0)),
		a = Array.from({ length: n + 1 })
			.fill([])
			.map(() => Array.from({ length: 2 * r + 1 }).fill([0, 0]))
	for (let m = 1; m <= n; m++) {
		let y = Math.max(1, m - r),
			C = Math.min(i, m + r)
		for (let v = y; v <= C; v++) {
			let b = v - (m - r)
			if (e[m - 1] === t[v - 1]) {
				let w = m - 1,
					B = v - 1
				if (B >= Math.max(1, w - r) && B <= Math.min(i, w + r)) {
					let M = B - (w - r)
					;(o[m][b] = o[w][M] + 1), (a[m][b] = [-1, -1])
				} else (o[m][b] = 1), (a[m][b] = [-1, -1])
			} else {
				let w = 0,
					B = 0
				v - 1 >= y && (w = o[m][b - 1])
				let M = m - 1
				if (v >= Math.max(1, M - r) && v <= Math.min(i, M + r)) {
					let Q = v - (M - r)
					B = o[M][Q]
				}
				w >= B ? ((o[m][b] = w), (a[m][b] = [0, -1])) : ((o[m][b] = B), (a[m][b] = [-1, 0]))
			}
		}
	}
	let l = n,
		c = i,
		u = 0,
		f = i,
		p = Math.max(1, n - r),
		g = Math.min(i, n + r)
	for (let m = p; m <= g; m++) {
		let y = m - (n - r)
		o[n][y] > u && ((u = o[n][y]), (f = m))
	}
	for (l = n, c = f; l > 0 && c > 0; ) {
		let m = c - (l - r)
		if (m < 0 || m >= 2 * r + 1) break
		let [y, C] = a[l][m]
		if ((y === -1 && C === -1 && (s[l - 1] = c - 1), (l += y), (c += C), y === 0 && C === 0)) break
	}
	return s
}
function kK(e, t) {
	let r = e.map((f) => RK(f)),
		n = t.map((f) => RK(f))
	function i(f) {
		let p = [],
			g = []
		for (let m = 0; m < f.length; m++) for (let y = 0; y < f[m].length; y++) p.push(f[m][y]), g.push(m)
		return [p, g]
	}
	let [s, o] = i(r),
		[a, l] = i(n),
		c = ZNe(s, a),
		u = Array.from({ length: e.length })
			.fill([])
			.map(() => [])
	for (let f = 0; f < c.length; f++) {
		let p = c[f]
		if (p !== -1) {
			let g = o[f],
				m = l[p]
			u[g].includes(m) || u[g].push(m)
		}
	}
	return u
}
var XNe = 5e4,
	e2e =
		"<response clipped><NOTE>To save on context only part of this file has been shown to you. You should retry this tool after you have searched inside the file with `grep -n` in order to find the line numbers of what you are looking for.</NOTE>"
function t2e(e) {
	let t = e.includes(`\r
`)
		? `\r
`
		: `
`
	return e
		.split(t)
		.map((i) => i.replace(/\s+$/, ""))
		.join(t)
}
function MK(e, t, r = 1, n) {
	;(e = r2e(e)),
		(e = e
			.split(
				`
`,
			)
			.map((s, o) => `${String(o + r).padStart(6)}	${s}`).join(`
`))
	let i = `Here's the result of running \`cat -n\` on ${t}:
${e}
`
	return (
		n !== void 0 &&
			(i += `Total lines in file: ${n}
`),
		i
	)
}
function r2e(e, t = XNe) {
	return e.length <= t ? e : e.slice(0, t) + e2e
}
function VP(e) {
	return e.replaceAll(
		`\r
`,
		`
`,
	)
}
function n2e(e) {
	return e.includes(`\r
`)
		? `\r
`
		: `
`
}
function Em(e) {
	let t = n2e(e)
	return { content: VP(t2e(e)), originalLineEnding: t }
}
function HP(e, t) {
	return t ===
		`
`
		? e
		: e.replaceAll(
				`
`,
				t,
			)
}
function FK(e, t) {
	let r = ""
	if (!Array.isArray(e) || e.length !== 2 || !e.every((s) => typeof s == "number"))
		return (
			(r = `Invalid view range provided. Showing entire file (lines 1-${t}).`),
			{ initLine: 1, finalLine: t, message: r }
		)
	let n = e[0],
		i = e[1]
	return (
		n < 1
			? ((r += `Start line ${n} is less than 1. Adjusted to 1.
`),
				(n = 1))
			: n > t &&
				((r += `Start line ${n} exceeds file length (${t}). Adjusted to 1.
`),
				(n = 1)),
		i === -1
			? (i = t)
			: i > t
				? ((r += `End line ${i} exceeds file length (${t}). Adjusted to ${t}. `), (i = t))
				: i < n && ((r += `End line ${i} is less than start line ${n}. Adjusted to ${t}. `), (i = t)),
		(r = r.trim()),
		{ initLine: n, finalLine: i, message: r }
	)
}
function i2e(e, t, r, n) {
	let i = Math.max(0, t - n),
		s = t + r - 1 + n
	return (
		(e = e.replaceAll(
			`\r
`,
			`
`,
		)),
		{
			snippet: e
				.split(
					`
`,
				)
				.slice(i, s + 1).join(`
`),
			startLine: i,
		}
	)
}
function rS(e, t, r, n) {
	let { snippet: i, startLine: s } = i2e(e, t, r, n)
	return i
		.split(
			`
`,
		)
		.map((a, l) => `${String(l + s + 1).padStart(6)}	${a}`).join(`
`)
}
function QK(e, t, r, n) {
	if (t === -1) return { initLine: e, finalLine: t }
	let i = t - e + 1
	if (i >= r) return { initLine: e, finalLine: t }
	let s = r - i,
		o = Math.floor(s / 2)
	o = Math.min(o, e - 1)
	let a = s - o
	;(a = Math.min(a, n - t)), (o = Math.min(e - 1, s - a))
	let l = Math.max(1, e - o),
		c = Math.min(n, t + a)
	return { initLine: l, finalLine: c }
}
function nS(e) {
	let t = e.split(`
`),
		r = 0,
		n = 0,
		i = 0
	for (let s of t) {
		if (s.trim() === "") continue
		let o = s.match(/^( +)/),
			a = s.match(/^(\t+)/)
		o ? (r++, i === 0 && (i = o[1].length)) : a && n++
	}
	return n > r ? { type: "tab", size: 1 } : { type: "space", size: i || 2 }
}
function WP(e, t) {
	let r = e.split(`
`),
		n = t.type === "tab" ? /^\t/ : new RegExp(`^ {1,${t.size}}`)
	return r.map((i) => i.replace(n, "")).join(`
`)
}
function GP(e, t) {
	return e
		.split(
			`
`,
		)
		.every((n) => {
			if (n.trim() === "") return !0
			let i = t.type === "tab" ? /^\t/ : new RegExp(`^ {1,${t.size}}`)
			return n.match(i)
		})
}
function $P(e, t) {
	let r = e.split(`
`),
		n = t.split(`
`),
		i = []
	if (t.trim() === "" || n.length > r.length) return i
	if (n.length === 1)
		return (
			r.forEach((c, u) => {
				c.includes(t) && i.push({ startLine: u, endLine: u })
			}),
			i
		)
	let s = e,
		o = t,
		a = 0,
		l
	for (; (l = s.indexOf(o, a)) !== -1; ) {
		let c = s.substring(0, l),
			u = s.substring(0, l + o.length),
			f = (c.match(/\n/g) || []).length,
			p = (u.match(/\n/g) || []).length
		i.push({ startLine: f, endLine: p }), (a = l + 1)
	}
	return i
}
function NK(e, t, r, n) {
	if (e.length === 0) return -1
	if (e.length === 1) return 0
	for (let u = 0; u < e.length; u++) {
		let f = e[u]
		if (f.startLine === t && f.endLine === r) return u
	}
	if (n === 0) return -1
	let i = -1,
		s = Number.MAX_SAFE_INTEGER
	for (let u = 0; u < e.length; u++) {
		let f = e[u],
			p = Math.abs(f.startLine - t)
		p < s && ((s = p), (i = u))
	}
	if (n === 1) return i
	if (i === -1) return -1
	let o = Number.MAX_SAFE_INTEGER,
		a = -1
	for (let u = 0; u < e.length; u++) {
		if (u === i) continue
		let f = e[u],
			p = Math.abs(f.startLine - t)
		p < o && ((o = p), (a = u))
	}
	let l = Math.abs(e[a].startLine - e[i].startLine),
		c = Math.floor((l / 2) * n)
	return s <= c ? i : -1
}
function PK(e) {
	if (e === void 0) throw new Error("Missing required parameter `str_replace_entries` for `str_replace` command.")
	if (!Array.isArray(e))
		throw new Error(
			"Invalid parameter `str_replace_entries` for `str_replace` command. It must be an array of objects.",
		)
	if (e.length === 0) throw new Error("Empty required parameter `str_replace_entries` for `str_replace` command.")
	let t = []
	for (let r of e) {
		if (typeof r != "object" || !r)
			throw new Error(
				"Invalid parameter `str_replace_entries` for `str_replace` command. It must be an array of objects.",
			)
		let n = r
		if (n.old_str === void 0) throw new Error("Missing required parameter `old_str` for `str_replace` command.")
		if (n.new_str === void 0) throw new Error("Missing required parameter `new_str` for `str_replace` command.")
		if (
			(n.old_str_start_line_number === 0 && (n.old_str_start_line_number = void 0),
			n.old_str_end_line_number === 0 && (n.old_str_end_line_number = void 0),
			n.old_str_start_line_number !== void 0 &&
				(!Number.isInteger(n.old_str_start_line_number) || n.old_str_start_line_number < 1))
		)
			throw new Error(
				"Invalid parameter `old_str_start_line_number` for `str_replace` command. It must be a positive integer.",
			)
		if (
			n.old_str_end_line_number !== void 0 &&
			(!Number.isInteger(n.old_str_end_line_number) || n.old_str_end_line_number < 1)
		)
			throw new Error(
				"Invalid parameter `old_str_end_line_number` for `str_replace` command. It must be a positive integer.",
			)
		t.push({
			old_str: n.old_str,
			new_str: n.new_str,
			old_str_start_line_number: n.old_str_start_line_number,
			old_str_end_line_number: n.old_str_end_line_number,
		})
	}
	return t
}
function LK(e) {
	let t = e
	return (
		t.forEach((r, n) => {
			r.index = n
		}),
		(t = s2e(t)),
		t.sort((r, n) => {
			let i = r.old_str_start_line_number ?? -1
			return (n.old_str_start_line_number ?? -1) - i
		}),
		t
	)
}
function UK(e, t) {
	let r = e.old_str_start_line_number,
		n = e.old_str_end_line_number
	if (!(r === void 0 || n === void 0))
		for (let i of t) {
			if (e.index == i.index || i.old_str_start_line_number === void 0 || i.old_str_end_line_number === void 0)
				continue
			let s = {
				startLine: i.old_str_start_line_number,
				endLine: i.old_str_end_line_number,
			}
			if (
				(r <= s.startLine && s.startLine <= n) ||
				(r <= s.endLine && s.endLine <= n) ||
				(s.startLine <= r && r <= s.endLine)
			)
				return i
		}
}
function OK(e, t) {
	let r = e.old_str_start_line_number + 1,
		n = e.old_str_end_line_number + 1,
		i = t.old_str_start_line_number + 1,
		s = t.old_str_end_line_number + 1
	return `old_str line numbers range overlaps with another entry.
This entry range: [${r}-${n}]
Overlapping entry index: ${t.index}
Overlapping entry range: [${i}-${s}]`
}
function qK(e) {
	if (e === void 0) throw new Error("Missing required parameter `insert_line_entries` for `insert` command.")
	if (!Array.isArray(e))
		throw new Error("Invalid parameter `insert_line_entries` for `insert` command. It must be an array of objects.")
	if (e.length === 0) throw new Error("Empty required parameter `insert_line_entries` for `insert` command.")
	let t = []
	for (let r of e) {
		if (typeof r != "object" || !r)
			throw new Error(
				"Invalid parameter `insert_line_entries` for `insert` command. It must be an array of objects.",
			)
		let n = r
		if (n.insert_line === void 0) throw new Error("Missing required parameter `insert_line` for `insert` command.")
		if (n.new_str === void 0) throw new Error("Missing required parameter `new_str` for `insert` command.")
		if (!Number.isInteger(n.insert_line) || n.insert_line < 0)
			throw new Error("Invalid parameter `insert_line` for `insert` command. It must be a non-negative integer.")
		t.push({ insert_line: n.insert_line, new_str: n.new_str })
	}
	return t
}
function s2e(e) {
	return e.map((t) => ({
		...t,
		old_str_start_line_number: t.old_str_start_line_number !== void 0 ? t.old_str_start_line_number - 1 : void 0,
		old_str_end_line_number: t.old_str_end_line_number !== void 0 ? t.old_str_end_line_number - 1 : void 0,
	}))
}
function VK(e, t) {
	t = t.replaceAll(
		`\r
`,
		`
`,
	)
	let r = e.newContent.split(`
`),
		n = t.split(`
`),
		i = kK(r, n)
	;(e.newStrStartLineNumber = i[e.newStrStartLineNumber][0] ?? e.newStrStartLineNumber),
		(e.newStrEndLineNumber = i[e.newStrEndLineNumber][i[e.newStrEndLineNumber].length - 1] ?? e.newStrEndLineNumber)
}
var YP = 4,
	iS = class extends rn {
		_checkpointManager
		_minViewSize
		_lineNumberErrorTolerance
		_waitForAutoFormatMs
		_logger
		constructor(t, r = 0, n = 0.2, i = 1e3) {
			super(ja.strReplaceEditor, xt.Safe),
				(this._checkpointManager = t),
				(this._minViewSize = r),
				(this._lineNumberErrorTolerance = n),
				(this._waitForAutoFormatMs = i),
				(this._logger = dn("StrReplaceEditorTool")),
				this._logger.debug(
					`Initialized with params: minViewSize=${r}, lineNumberErrorTolerance=${n}, waitForAutoFormatSec=${i}`,
				)
		}
		description =
			"Custom editing tool for viewing, creating and editing files\n* `path` is a file path relative to the workspace root\n* command `view` displays the result of applying `cat -n`.\n* If a `command` generates a long output, it will be truncated and marked with `<response clipped>`\n* `insert` and `str_replace` commands output a snippet of the edited section for each entry. This snippet reflects the final state of the file after all edits and IDE auto-formatting have been applied.\n\n\nNotes for using the `str_replace` command:\n* Use the `str_replace_entries` parameter with an array of objects\n* Each object should have `old_str`, `new_str`, `old_str_start_line_number` and `old_str_end_line_number` properties\n* The `old_str_start_line_number` and `old_str_end_line_number` parameters are 1-based line numbers\n* Both `old_str_start_line_number` and `old_str_end_line_number` are INCLUSIVE\n* The `old_str` parameter should match EXACTLY one or more consecutive lines from the original file. Be mindful of whitespace!\n* Empty `old_str` is allowed only when the file is empty or contains only whitespaces\n* It is important to specify `old_str_start_line_number` and `old_str_end_line_number` to disambiguate between multiple occurrences of `old_str` in the file\n* Make sure that `old_str_start_line_number` and `old_str_end_line_number` do not overlap with other entries in `str_replace_entries`\n* The `new_str` parameter should contain the edited lines that should replace the `old_str`. Can be an empty string to delete content\n\nNotes for using the `insert` command:\n* Use the `insert_line_entries` parameter with an array of objects\n* Each object should have `insert_line` and `new_str` properties\n* The `insert_line` parameter specifies the line number after which to insert the new string\n* The `insert_line` parameter is 1-based line number\n* To insert at the very beginning of the file, use `insert_line: 0`\n\nNotes for using the `view` command:\n* Strongly prefer to use larger ranges of at least 1000 lines when scanning through files. One call with large range is much more efficient than many calls with small ranges\n* Prefer to use grep instead of view when looking for a specific symbol in the file\n\nIMPORTANT:\n* This is the only tool you should use for editing files.\n* If it fails try your best to fix inputs and retry.\n* DO NOT fall back to removing the whole file and recreating it from scratch.\n* DO NOT use sed or any other command line tools for editing files.\n* Try to fit as many edits in one tool call as possible\n* Use view command to read the file before editing it.\n"
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				command: {
					type: "string",
					enum: ["view", "str_replace", "insert"],
					description: "The commands to run. Allowed options are: 'view', 'str_replace', 'insert'.",
				},
				path: {
					description:
						"Full path to file relative to the workspace root, e.g. 'services/api_proxy/file.py' or 'services/api_proxy'.",
					type: "string",
				},
				view_range: {
					description:
						"Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [11, 12] will show lines 11 and 12. Indexing at 1 to start. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file.",
					type: "array",
					items: { type: "integer" },
				},
				insert_line_entries: {
					description:
						"Required parameter of `insert` command. A list of entries to insert. Each entry is a dictionary with keys `insert_line` and `new_str`.",
					type: "array",
					items: {
						type: "object",
						properties: {
							insert_line: {
								description:
									"The line number after which to insert the new string. This line number is relative to the state of the file before any insertions in the current tool call have been applied.",
								type: "integer",
							},
							new_str: {
								description: "The string to insert. Can be an empty string.",
								type: "string",
							},
						},
						required: ["insert_line", "new_str"],
					},
				},
				str_replace_entries: {
					description:
						"Required parameter of `str_replace` command. A list of entries to replace. Each entry is a dictionary with keys `old_str`, `old_str_start_line_number`, `old_str_end_line_number` and `new_str`. `old_str` from different entries should not overlap.",
					type: "array",
					items: {
						type: "object",
						properties: {
							old_str: {
								description: "The string in `path` to replace.",
								type: "string",
							},
							old_str_start_line_number: {
								description:
									"The line number of the first line of `old_str` in the file. This is used to disambiguate between multiple occurrences of `old_str` in the file.",
								type: "integer",
							},
							old_str_end_line_number: {
								description:
									"The line number of the last line of `old_str` in the file. This is used to disambiguate between multiple occurrences of `old_str` in the file.",
								type: "integer",
							},
							new_str: {
								description:
									"The string to replace `old_str` with. Can be an empty string to delete content.",
								type: "string",
							},
						},
						required: ["old_str", "new_str", "old_str_start_line_number", "old_str_end_line_number"],
					},
				},
			},
			required: ["command", "path"],
		})
		checkToolCallSafe(t) {
			return !0
		}
		async readFile(t) {
			this._logger.debug(`Reading file: ${t}`)
			try {
				let r = await Do().readFile(t)
				if (r === void 0 || r.contents === void 0 || r.filepath === void 0)
					throw (
						(this._logger.error(`Failed to read file: ${t} - file details undefined`),
						new Error(`Cannot read file: ${t}`))
					)
				return (
					this._logger.debug(`Successfully read file: ${t} (${r.contents.length} bytes)`),
					{ contents: r.contents, filepath: r.filepath }
				)
			} catch (r) {
				throw (
					(this._logger.error(`Error reading file ${t}: ${r instanceof Error ? r.message : String(r)}`),
					new Error(`Ran into ${r instanceof Error ? r.message : String(r)} while trying to read ${t}`))
				)
			}
		}
		createCheckpoint(t, r, n, i) {
			this._logger.debug(`Creating checkpoint for file: ${t.absPath}`)
			let s = new hi(t, r, n, {}),
				o = i.at(-1)?.request_id ?? pd(),
				a = this._checkpointManager.currentConversationId ?? ""
			this._logger.debug(`Adding checkpoint with conversationId: ${a}, requestId: ${o}`),
				this._checkpointManager.addCheckpoint(
					{ conversationId: a, path: t },
					{
						sourceToolCallRequestId: o,
						timestamp: Date.now(),
						document: s,
						conversationId: a,
					},
				)
		}
		async call(t, r, n) {
			try {
				this._logger.debug(`Tool called with command: ${String(t.command)}, path: ${String(t.path)}`)
				let i = t.command
				if (t.path === void 0)
					return (
						this._logger.error("Missing required parameter 'path'"), ut("Missing required parameter `path`")
					)
				if (typeof t.path != "string")
					return (
						this._logger.error("Invalid parameter 'path'. It must be a string."),
						ut("Invalid parameter `path`. It must be a string.")
					)
				if (t.path.trim() === "")
					return (
						this._logger.error("Invalid parameter 'path'. It must not be empty."),
						ut("Invalid parameter `path`. It must not be empty.")
					)
				let s = t.path,
					o = await this.readFile(s)
				switch (i) {
					case "view":
						return (
							this._logger.debug(
								`Handling 'view' command for ${s} with range: ${JSON.stringify(t.view_range)}`,
							),
							this.handleView(s, o, t.view_range)
						)
					case "str_replace":
						return (
							this._logger.debug(
								`Handling 'str_replace' command for ${s} with ${
									Array.isArray(t.str_replace_entries) ? t.str_replace_entries.length : 0
								} entries`,
							),
							this.handleStrReplace(s, o, t.str_replace_entries, r)
						)
					case "insert":
						return (
							this._logger.debug(
								`Handling 'insert' command for ${s} with ${
									Array.isArray(t.insert_line_entries) ? t.insert_line_entries.length : 0
								} entries`,
							),
							this.handleInsert(s, o, t.insert_line_entries, r)
						)
					default:
						return this._logger.error(`Unknown command: ${String(i)}`), ut(`Unknown command: ${String(i)}`)
				}
			} catch (i) {
				return (
					this._logger.error(`Error in tool call: ${i instanceof Error ? i.message : String(i)}`),
					i instanceof Error ? ut(i.message) : ut(`Unknown error: ${String(i)}`)
				)
			}
		}
		async prepareToolResponse(t, r, n, i, s, o, a, l) {
			this._logger.debug(`Preparing tool response for ${a} command on ${t}`)
			let c = HP(n, i),
				u = HP(s, i)
			if (c !== u) {
				this._logger.debug("Content changed, creating checkpoint and waiting for auto-formatting"),
					this.createCheckpoint(r.filepath, c, u, o),
					await Kl(this._waitForAutoFormatMs)
				let C = (await this.readFile(t)).contents,
					v = C !== u
				v && this._logger.debug("File was auto-formatted after edit"),
					(u = C),
					l.sort((w, B) => (w.newStrStartLineNumber ?? -1) - (B.newStrStartLineNumber ?? -1))
				let b = 0
				for (let w of l)
					w.newStrStartLineNumber !== void 0 &&
						w.newStrEndLineNumber !== void 0 &&
						(this._logger.debug(
							`Adjusting line numbers for result: start=${w.newStrStartLineNumber}, end=${w.newStrEndLineNumber}, shift=${b}`,
						),
						(w.newStrStartLineNumber += b),
						(w.newStrEndLineNumber += b),
						v &&
							(VK(w, u),
							this._logger.debug(
								`Updated line numbers after reformatting: start=${w.newStrStartLineNumber}, end=${w.newStrEndLineNumber}`,
							)),
						(b += w.numLinesDiff)),
						(w.newContent = u)
			} else this._logger.debug("No content changes detected")
			let f = l.every((C) => C.isError),
				p = l.every((C) => !C.isError)
			this._logger.debug(`Results summary: all errors=${f}, all success=${p}, total results=${l.length}`)
			let m = l.map((C, v) => {
					let b = C.genMessageFunc ? C.genMessageFunc(C) : "No message available"
					return `Result for ${a}_entries[${v}]:
${b}
`
				}).join(`
`),
				y
			return (
				f
					? (y = `Failed to edit the file ${t}. See below for details.
${m}
Fix failed ${a}_entries accordingly and try again.
`)
					: p
						? (y = `Successfully edited the file ${t}.
${m}
Review the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).
Edit the file again if necessary.
`)
						: (y = `Partially edited the file ${t}. See below for details.
${m}
Fix failed ${a}_entries accordingly and try again.
`),
				f
					? (this._logger.debug(`Returning error response for ${t}`), ut(y))
					: (this._logger.debug(`Returning success response for ${t}`), Zt(y))
			)
		}
		handleView(t, r, n) {
			this._logger.debug(`Handling view command for ${t} with range: ${JSON.stringify(n)}`)
			let s = VP(r.contents).split(`
`),
				o = s.length
			this._logger.debug(`File ${t} has ${o} lines`)
			let a = 1,
				l = o,
				c = ""
			if (n)
				try {
					let p = FK(n, o)
					;(a = p.initLine),
						(l = p.finalLine),
						p.message &&
							(c = `Note:
${p.message}

`)
					let g = Math.min(this._minViewSize, o),
						m = QK(a, l, g, o)
					;(a = m.initLine), (l = m.finalLine)
				} catch (p) {
					throw p instanceof Error ? p : new Error(`Invalid view_range: ${String(p)}`)
				}
			let u =
					l === -1
						? s.slice(a - 1).join(`
`)
						: s.slice(a - 1, l).join(`
`),
				f = MK(u, t.toString(), a, o)
			return Zt(c + f)
		}
		singleStrReplace(t, r, n, i, s, o) {
			;(n = Em(n).content), (i = Em(i).content)
			let a = (y, C, v, b, w, B) => ({
					isError: !1,
					oldStr: n,
					oldStrStartLineNumber: s,
					oldStrEndLineNumber: o,
					newContent: y,
					newStr: C,
					newStrStartLineNumber: v,
					newStrEndLineNumber: b,
					numLinesDiff: w,
					genMessageFunc: B,
				}),
				l = (y) => ({
					isError: !0,
					oldStr: n,
					oldStrStartLineNumber: s,
					oldStrEndLineNumber: o,
					numLinesDiff: 0,
					genMessageFunc: y,
				}),
				c,
				u = 0,
				f = 0
			if (n.trim() === "")
				if (r.trim() === "")
					(c = i),
						(u = 0),
						(f =
							i.split(`
`).length - 1)
				else
					return l(
						() =>
							`No replacement was performed, old_str is empty which is only allowed when the file is empty or contains only whitespace. The file ${t} is not empty.`,
					)
			else {
				let y = $P(r, n)
				if (y.length === 0) {
					let C = nS(r),
						v = nS(n),
						b = nS(i)
					if (C.type === "tab" && v.type === "tab" && b.type === "tab" && GP(n, C) && GP(i, C)) {
						let w = WP(n, C),
							B = WP(i, C)
						;(y = $P(r, w)), y.length > 0 && ((n = w), (i = B))
					}
					if (y.length === 0)
						return l((B) => {
							let M = `No replacement was performed, oldStr did not appear verbatim in ${t}.`
							if (B.oldStrStartLineNumber !== void 0 && B.oldStrEndLineNumber !== void 0) {
								let Q = rS(
										r,
										B.oldStrStartLineNumber,
										B.oldStrEndLineNumber - B.oldStrStartLineNumber + 1,
										YP,
									),
									O = r
										.split(
											`
`,
										)
										.slice(B.oldStrStartLineNumber, B.oldStrEndLineNumber + 1).join(`
`),
									Y = vI(
										"oldStr",
										"regionContent",
										B.oldStr +
											`
`,
										O +
											`
`,
										void 0,
										void 0,
										{ context: 3 },
									)
								M += `
The content in the specified region is:
${Q}

Diff between oldStr and the specified region is:
${Y}`
							}
							return M
						})
				}
				if (y.length === 1) {
					let C = y[0]
					;(c = r.replace(n, (v) => i)),
						(u = C.startLine),
						(f =
							C.startLine +
							i.split(`
`).length -
							1)
				} else {
					if (s === void 0 || o === void 0)
						return l(
							() =>
								`Multiple occurrences of oldStr \`${n}\` found. Please provide line numbers to disambiguate.`,
						)
					let C = NK(y, s, o, this._lineNumberErrorTolerance)
					if (C === -1) {
						let j = s + 1,
							ne = o + 1
						return l(() => `No match found close to the provided line numbers (${j}, ${ne}).`)
					}
					let v = y[C],
						b = r.split(`
`),
						w = b.slice(0, v.startLine).join(`
`),
						B = b.slice(v.endLine + 1).join(`
`),
						M = b.slice(v.startLine, v.endLine + 1).join(`
`),
						Q = M.indexOf(n)
					if (Q === -1) return l(() => "Internal error: Could not find the exact position of the match.")
					let O = M.substring(0, Q),
						Y = M.substring(Q + n.length)
					;(c =
						w +
						(w
							? `
`
							: "") +
						O +
						i +
						Y +
						(B
							? `
`
							: "") +
						B),
						(u = v.startLine),
						(f =
							v.startLine +
							i.split(`
`).length -
							1)
				}
			}
			let p = n.split(`
`).length,
				m =
					i.split(`
`).length - p
			return a(
				c,
				i,
				u,
				f,
				m,
				(y) => `Replacement successful.
Edited section after IDE auto-formatting was applied:
${rS(y.newContent, y.newStrStartLineNumber, y.newStrEndLineNumber - y.newStrStartLineNumber + 1, YP)}`,
			)
		}
		handleStrReplace(t, r, n, i) {
			this._logger.debug(`Handling str_replace command for ${t}`)
			let s = PK(n)
			this._logger.debug(`Validated ${s.length} str_replace entries`)
			let o = LK(s),
				{ content: a, originalLineEnding: l } = Em(r.contents),
				c = a,
				u = new Array(o.length)
			for (let f of o) {
				let p = UK(f, o),
					g
				p !== void 0
					? (g = {
							isError: !0,
							oldStr: f.old_str,
							oldStrStartLineNumber: f.old_str_start_line_number,
							oldStrEndLineNumber: f.old_str_end_line_number,
							numLinesDiff: 0,
							genMessageFunc: () => OK(f, p),
						})
					: (g = this.singleStrReplace(
							t,
							c,
							f.old_str,
							f.new_str,
							f.old_str_start_line_number,
							f.old_str_end_line_number,
						)),
					(u[f.index] = g),
					!g.isError && g.newContent !== void 0 && (c = g.newContent)
			}
			return this.prepareToolResponse(t, r, a, l, c, i, "str_replace", u)
		}
		handleInsert(t, r, n, i) {
			this._logger.debug(`Handling insert command for ${t}`)
			let s = qK(n)
			this._logger.debug(`Validated ${s.length} insert entries`)
			let { content: o, originalLineEnding: a } = Em(r.contents),
				l = o,
				c = l.split(`
`),
				u = s
			u.forEach((p, g) => {
				p.index = g
			}),
				u.sort((p, g) => g.insert_line - p.insert_line)
			let f = new Array(u.length)
			for (let p of u) {
				let g = p.insert_line,
					m = Em(p.new_str).content
				if (
					((c = l.split(`
`)),
					g < 0 || g > c.length)
				) {
					f[p.index] = {
						isError: !0,
						oldStr: "",
						oldStrStartLineNumber: g,
						oldStrEndLineNumber: g,
						numLinesDiff: 0,
						genMessageFunc: () =>
							`Invalid \`insert_line\` parameter: ${g}. It should be within the range of lines of the file: [0, ${c.length}]`,
					}
					continue
				}
				let y = m.split(`
`)
				;(l = [...c.slice(0, g), ...y, ...c.slice(g)].join(`
`)),
					(f[p.index] = {
						isError: !1,
						oldStr: "",
						oldStrStartLineNumber: g,
						oldStrEndLineNumber: g,
						newContent: l,
						newStr: m,
						newStrStartLineNumber: g,
						newStrEndLineNumber: g + y.length - 1,
						numLinesDiff: y.length,
						genMessageFunc: (v) => `Successfully inserted new_str.
Edited section after IDE auto-formatting was applied:
${rS(v.newContent, v.newStrStartLineNumber, v.newStrEndLineNumber - v.newStrStartLineNumber + 1, YP)}`,
					})
			}
			return this.prepareToolResponse(t, r, o, a, l, i, "insert", f)
		}
	}
var o7 = W(s7()),
	HS = class extends rn {
		_turndownService
		_userAgent
		constructor(t) {
			super(ja.webFetch, xt.Unsafe)
			let r = new o7.default()
			r.addRule("removeStyleAndScriptTags", {
				filter: ["style", "script"],
				replacement: function () {
					return ""
				},
			}),
				(this._turndownService = r),
				(this._userAgent = t || "Augment-WebFetch/1.0")
		}
		description = `Fetches data from a webpage and converts it into Markdown.

1. The tool takes in a URL and returns the content of the page in Markdown format;
2. If the return is not valid Markdown, it means the tool cannot successfully parse this page.`
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: { url: { type: "string", description: "The URL to fetch." } },
			required: ["url"],
		})
		checkToolCallSafe(t) {
			return !1
		}
		async call(t, r, n) {
			let i = t.url
			try {
				let o = await (
					await fetch(i, {
						signal: n,
						headers: { "User-Agent": this._userAgent },
					})
				).text()
				return { text: this._turndownService.turndown(o), isError: !1 }
			} catch (s) {
				return {
					text: `Failed to fetch URL: ${i}: ${s instanceof Error ? s.message : String(s)}`,
					isError: !0,
				}
			}
		}
	}
var WS = class e extends hm {
	_chatMode
	_clientFeatureFlags
	_checkpointManager
	_getAgentConfig
	_userAgent
	constructor(t, r, n, i, s) {
		let o = process.platform === "win32" ? "powershell" : "bash",
			a = [new HS(s)]
		i().disableRetrievalTool || a.push(new KI()),
			t === Mn.agent && !i().useIDETerminalForShellCommands && a.push(new vm(i, t, process.platform, o)),
			t === Mn.agent && r.flags.agentEditTool === YI.strReplaceEditor && a.push(new iS(n)),
			super(a, Ro.sidecarToolHost),
			(this._chatMode = t),
			(this._clientFeatureFlags = r),
			(this._checkpointManager = n),
			(this._getAgentConfig = i),
			(this._userAgent = s)
	}
	factory() {
		return new e(
			this._chatMode,
			this._clientFeatureFlags,
			this._checkpointManager,
			this._getAgentConfig,
			this._userAgent,
		)
	}
}
var GS = class {
	_mcpServers
	_clientToolHostFactory
	_remoteInfoSource
	_mcpToolsStartupErrorFn
	_clientFeatureFlags
	_checkpointManager
	_getMemoriesAbsPath
	_getAgentConfig
	_getToolUseRequestEventReporter
	_options
	_userAgent
	_hosts = []
	_allToolHosts = []
	_chatMode = Mn.chat
	_logger = dn("ToolsModel")
	constructor(t, r, n, i, s, o, a, l, c, u = {}, f) {
		;(this._mcpServers = t),
			(this._clientToolHostFactory = r),
			(this._remoteInfoSource = n),
			(this._mcpToolsStartupErrorFn = i),
			(this._clientFeatureFlags = s),
			(this._checkpointManager = o),
			(this._getMemoriesAbsPath = a),
			(this._getAgentConfig = l),
			(this._getToolUseRequestEventReporter = c),
			(this._options = u),
			(this._userAgent = f),
			this.restartHosts()
	}
	get memoriesAbsPath() {
		return this._getMemoriesAbsPath()
	}
	async getToolMap() {
		let t = new Map()
		for (let r of this.hosts) {
			let n = await r.getToolDefinitions()
			for (let i of n)
				this.isEnabled(i.definition.name) &&
					(this._options.unsupportedTools?.has(i.definition.name) || t.set(i.definition.name.toString(), r))
		}
		return t
	}
	get hosts() {
		return this._hosts
	}
	get chatMode() {
		return this._chatMode
	}
	setMode(t) {
		t !== this._chatMode && ((this._chatMode = t), this.restartHosts())
	}
	getMode() {
		return this._chatMode
	}
	onFlagsChanged() {
		this.restartHosts()
	}
	setMcpServers(t) {
		;(this._mcpServers = t), this.restartHosts()
	}
	async getToolDefinitions() {
		let t = []
		for (let r of this.hosts) {
			let n = await r.getToolDefinitions()
			for (let i of n)
				this.isEnabled(i.definition.name) &&
					(this._options.unsupportedTools?.has(i.definition.name) || t.push(i))
		}
		return t
	}
	async getToolStatusForSettingsPanel(t = !0) {
		let r = []
		for (let n of this._allToolHosts) {
			let i = (await n.getAllToolDefinitions(t)).filter(
				(s) => !this._options.unsupportedTools?.has(s.definition.name),
			)
			r.push(...i)
		}
		return r
	}
	async callTool(t, r, n, i, s, o) {
		let l = (await this.getToolMap()).get(n)
		if (l === void 0) return { isError: !0, text: `Tool ${n} not found.` }
		if (!this.isEnabled(n)) return { isError: !0, text: `Tool ${n} is disabled.` }
		let c = Date.now(),
			u = await l.callTool(t, r, n, i, s),
			f = this._getToolUseRequestEventReporter()
		return (
			f !== void 0 &&
				f.reportEvent(t, n, r, i, u.isError, Date.now() - c, l instanceof Ov, o, s.length, u.requestId),
			u
		)
	}
	async checkToolCallSafe(t, r) {
		let i = (await this.getToolMap()).get(t)
		if (i === void 0) throw new Error(`Cannot find the host for tool '${t}'.`)
		return await i.checkToolCallSafe(t, r)
	}
	async checkToolExists(t) {
		return (await this.getToolMap()).has(t)
	}
	async cancelToolRun(t, r) {
		for (let n = 0; n < this.hosts.length; n++) {
			let i = this.hosts[n]
			if (i.isRequestActive(t, r)) {
				let s = i.close(!0)
				return (this._hosts[n] = i.factory(s)), s
			}
		}
		return Promise.resolve()
	}
	restartHosts() {
		let t = this._allToolHosts.map((l) => l.close()),
			r = Promise.all(t).then(() => {}),
			n = this._mcpServers.map((l) => new Ov(l, r, this._mcpToolsStartupErrorFn)),
			i = new GI(this._remoteInfoSource),
			s = this._clientToolHostFactory(this._chatMode, this._getAgentConfig),
			o = new WS(
				this._chatMode,
				this._clientFeatureFlags,
				this._checkpointManager,
				this._getAgentConfig,
				this._userAgent,
			)
		this._allToolHosts = [...n, s, i, o]
		let a =
			(this._chatMode === Mn.chat && this._clientFeatureFlags.flags.enableChatWithTools) ||
			(this._chatMode === Mn.agent && this._clientFeatureFlags.flags.enableAgentMode)
		;(this._hosts = [...n]), a && (this._hosts = this.hosts.concat([s, i, o])), this.logTools()
	}
	closeAllToolProcesses() {
		for (let t of this.hosts) t.closeAllToolProcesses()
	}
	getTool(t) {
		for (let r of this.hosts) {
			let n = r.getTool(t)
			if (n) return n
		}
	}
	async logTools() {
		this._logger.info(`Tools Mode: ${this._chatMode}`)
		for (let t of this.hosts) {
			let r = await t.getToolDefinitions(),
				n = [],
				i = []
			for (let a of r) (this.isEnabled(a.definition.name) ? n : i).push(a.definition.name)
			let s = n.map((a) => ` + ${a}`).join(`
`),
				o = i.map((a) => ` - ${a}`).join(`
`)
			this._logger.info(`Host: ${t.getName()}
${s}
${o}`)
		}
	}
	isEnabled(t) {
		return !(t === "codebase-retrieval" && this._getAgentConfig().disableRetrievalTool)
	}
}
var qf
;(function (e) {
	e.empty = "empty"
})(qf || (qf = {}))
var el
;(function (e) {
	;(e.getEditListRequest = "agent-get-edit-list-request"),
		(e.getEditListResponse = "agent-get-edit-list-response"),
		(e.getEditChangesByRequestIdRequest = "agent-get-edit-changes-by-request-id-request"),
		(e.getEditChangesByRequestIdResponse = "agent-get-edit-changes-by-request-id-response"),
		(e.setCurrentConversation = "agent-set-current-conversation"),
		(e.revertToTimestamp = "revert-to-timestamp"),
		(e.chatAgentEditAcceptAll = "chat-agent-edit-accept-all")
})(el || (el = {}))
var $S = class {
	_checkpointManager
	_logger = dn("AgentWebviewMessageHandler")
	supportedTypes = el
	constructor(t) {
		this._checkpointManager = t
	}
	async handle(t, r) {
		switch (t.type) {
			case el.getEditListRequest: {
				let n = t,
					i = await this._getAgentEditList(n)
				r(i)
				break
			}
			case el.setCurrentConversation: {
				let n = t
				this._checkpointManager.setCurrentConversation(n.data.conversationId), r({ type: qf.empty })
				break
			}
			case el.getEditChangesByRequestIdRequest: {
				let n = t,
					i = await this._getAgentEditChangesByRequestId(n)
				r(i)
				break
			}
			case el.revertToTimestamp: {
				let n = t
				n.data.qualifiedPathNames?.length
					? await Promise.all(
							n.data.qualifiedPathNames.map(async (i) => {
								await this._checkpointManager.revertDocumentToTimestamp(Je.from(i), n.data.timestamp)
							}),
						)
					: await this._checkpointManager.revertToTimestamp(n.data.timestamp),
					r({ type: qf.empty })
				break
			}
			case el.chatAgentEditAcceptAll: {
				let n = this._checkpointManager.currentConversationId
				n && (await this._checkpointManager.clearConversationCheckpoints(n)), r({ type: qf.empty })
				break
			}
		}
	}
	_getAgentEditList = async (t) => {
		let { fromTimestamp: r, toTimestamp: n } = t.data,
			i = await this._checkpointManager.getAggregateCheckpoint({
				minTimestamp: r,
				maxTimestamp: n,
			})
		return {
			type: el.getEditListResponse,
			data: {
				edits: i.files.map((s) => ({
					qualifiedPathName: s.changeDocument.filePath,
					changesSummary: s.changesSummary,
				})),
			},
		}
	}
	_getAgentEditChangesByRequestId = async (t) => {
		let r = await this._checkpointManager.getCheckpointByRequestId(t.data.requestId)
		return r !== void 0
			? {
					type: el.getEditChangesByRequestIdResponse,
					data: r.files.at(0)?.changesSummary,
				}
			: { type: el.getEditChangesByRequestIdResponse, data: void 0 }
	}
}
var Vf
;(function (e) {
	;(e.closeAllToolProcesses = "close-all-tool-processes"),
		(e.getToolIdentifierRequest = "get-tool-identifier-request"),
		(e.getToolIdentifierResponse = "get-tool-identifier-response")
})(Vf || (Vf = {}))
var YS = class {
	_toolsModel
	_logger = dn("ToolsWebviewMessageHandler")
	supportedTypes = Vf
	constructor(t) {
		this._toolsModel = t
	}
	async handle(t, r) {
		switch (t.type) {
			case Vf.closeAllToolProcesses: {
				this._logger.info("Received closeAllToolProcesses message"),
					this._toolsModel.closeAllToolProcesses(),
					r({ type: qf.empty })
				break
			}
			case Vf.getToolIdentifierRequest: {
				let n = await this.getToolIdentifier(t)
				r(n)
				break
			}
		}
		return Promise.resolve()
	}
	getToolIdentifier = async (t) => {
		let r = await this._toolsModel.getToolDefinitions()
		for (let n of r)
			if (n.definition.name === t.data.toolName)
				return {
					type: Vf.getToolIdentifierResponse,
					data: { found: !0, toolIdentifier: n.identifier },
				}
		return { type: Vf.getToolIdentifierResponse, data: { found: !1 } }
	}
}
var KS = class {
	_handlers = new Map()
	_logger = dn("WebviewMessageBroker")
	registerHandler(t) {
		let r = Object.values(t.supportedTypes)
		for (let n of r) this._handlers.set(n, (i, s) => t.handle(i, s))
	}
	handle(t, r) {
		let n = this._handlers.get(t.type)
		return n
			? (n(t, r), !0)
			: (this._logger.debug(`No webview message handler found for '${t.type}' in the sidecar broker.`), !1)
	}
}
var JS = class {
	_broker
	constructor(t, r) {
		this._broker = new KS()
		let n = [new $S(t), new YS(r)]
		for (let i of n) this._broker.registerHandler(i)
	}
	onMessage(t, r) {
		return this._broker.handle(t, r)
	}
}
var a7 = W(require("crypto")),
	hE = 2023102300,
	fE = class extends Error {
		constructor(t) {
			super(`content exceeds maximum size of ${t}`)
		}
	},
	Hf = class {
		maxBlobSize
		_textEncoder = new TextEncoder()
		constructor(t) {
			this.maxBlobSize = t
		}
		_hash(t, r) {
			let n = a7.createHash("sha256")
			return n.update(t), n.update(r), n.digest("hex")
		}
		calculateOrThrow(t, r, n = !0) {
			if ((typeof r == "string" && (r = this._textEncoder.encode(r)), n && r.length > this.maxBlobSize))
				throw new fE(this.maxBlobSize)
			return this._hash(t, r)
		}
		calculate(t, r) {
			try {
				return this.calculateOrThrow(t, r, !0)
			} catch {
				return
			}
		}
		calculateNoThrow(t, r) {
			return this.calculateOrThrow(t, r, !1)
		}
	}
var Swe = require("console"),
	Bwe = require("crypto"),
	Dwe = W(gs()),
	E6 = W(see()),
	Twe = W(yue()),
	kN = W(require("os"))
var Cue = W(require("crypto")),
	PT = new Uint8Array(256),
	NT = PT.length
function u3() {
	return NT > PT.length - 16 && (Cue.default.randomFillSync(PT), (NT = 0)), PT.slice(NT, (NT += 16))
}
var vue =
	/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
function pet(e) {
	return typeof e == "string" && vue.test(e)
}
var d3 = pet
var bs = []
for (let e = 0; e < 256; ++e) bs.push((e + 256).toString(16).slice(1))
function Eue(e, t = 0) {
	return (
		bs[e[t + 0]] +
		bs[e[t + 1]] +
		bs[e[t + 2]] +
		bs[e[t + 3]] +
		"-" +
		bs[e[t + 4]] +
		bs[e[t + 5]] +
		"-" +
		bs[e[t + 6]] +
		bs[e[t + 7]] +
		"-" +
		bs[e[t + 8]] +
		bs[e[t + 9]] +
		"-" +
		bs[e[t + 10]] +
		bs[e[t + 11]] +
		bs[e[t + 12]] +
		bs[e[t + 13]] +
		bs[e[t + 14]] +
		bs[e[t + 15]]
	)
}
var bue = W(require("crypto")),
	f3 = { randomUUID: bue.default.randomUUID }
function Aet(e, t, r) {
	if (f3.randomUUID && !t && !e) return f3.randomUUID()
	e = e || {}
	let n = e.random || (e.rng || u3)()
	if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), t)) {
		r = r || 0
		for (let i = 0; i < 16; ++i) t[r + i] = n[i]
		return t
	}
	return Eue(n)
}
var Eh = Aet
var je = W(require("vscode"))
var Ob = class extends Error {
	constructor(r) {
		super(`Configured model "${r}" is not available`)
		this.modelName = r
	}
}
var LT = class extends Error {
		constructor() {
			super("No models available")
		}
	},
	bh = class extends Error {
		constructor(t = "Skipping inline completion.") {
			super(t)
		}
	}
function met(e) {
	return e.cause instanceof String ? String(e.cause) : e.cause instanceof Object ? JSON.stringify(e.cause) : ""
}
function Ye(e, t = !1) {
	if (e instanceof Error) {
		if (t) {
			let r = met(e)
			if (r !== "") return `${e.message} (due to ${r})`
		}
		return e.message
	}
	return String(e)
}
var zR = W(qde()),
	mx = W(require("vscode"))
var FAe = W(require("vscode")),
	kh = W(MAe()),
	QAe = W(Dh()),
	jH = class extends QAe.default {
		constructor(r) {
			super()
			this.outputChannel = r
			this._logFns.set("info", r.info),
				this._logFns.set("debug", r.debug),
				this._logFns.set("warn", r.warn),
				this._logFns.set("error", r.error),
				this._logFns.set("verbose", r.trace)
		}
		_logFns = new Map()
		log(r, n) {
			setImmediate(() => {
				this.emit("logged", r)
			})
			let i = [r.prefix ? `'${r.prefix}'` : "", r.message].join(" "),
				s = this._logFns.get(r.level)
			s ? s(i) : this.outputChannel.appendLine(i), n()
		}
	},
	px
function Rct() {
	if (px) return px
	let e = FAe.window.createOutputChannel("Augment", { log: !0 }),
		t = [new jH(e)]
	return (
		process.env.CONSOLE_LOG_LEVEL && t.push(new kh.transports.Console({ level: process.env.CONSOLE_LOG_LEVEL })),
		(px = (0, kh.createLogger)({
			level: "debug",
			exitOnError: !1,
			format: kh.format.combine(
				kh.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss.SSS" }),
				kh.format.printf((r) => `${r.timestamp} [${r.level}] '${r.prefix}': ${r.message}`),
			),
			transports: t,
		})),
		g$(px),
		px
	)
}
function X(e) {
	return Rct().child({ prefix: e })
}
var Ax = W(gs()),
	gy = class {
		constructor(t, r, n) {
			this.name = t
			this._logger = r
			this._configListener = n
		}
		_isSet = !1
		_value
		get value() {
			return this._value
		}
		update(t) {
			return this._isSet && (0, Ax.isEqual)(t, this._value)
				? !1
				: (this._isSet
						? this._logger.info(`${this.name} changed:
${this.diff(this.value, t).map((r) => `  - ${r}`).join(`
`)}`)
						: this._logger.info(`${this.name} changed from <unset> to ${this._formatValue(t)}`),
					(this._value = (0, Ax.cloneDeep)(t)),
					(this._isSet = !0),
					!0)
		}
		diff(t, r, n = []) {
			if ((0, Ax.isEqual)(r, t)) return []
			if (!this.isObject(r) || !this.isObject(t)) return [`${this._formatValue(t)} to ${this._formatValue(r)}`]
			let i = new Set([...Object.keys(t || {}), ...Object.keys(r || {})]),
				s = []
			for (let o of i) {
				if (this._configListener && !this._configListener.config.enableDebugFeatures && o === "memoriesParams")
					continue
				let a = r ? r[o] : void 0,
					l = t ? t[o] : void 0
				!this.isObject(a) || !this.isObject(l)
					? a !== l &&
						s.push(`${n.concat(o).join(" > ")}: ${this._formatValue(l)} to ${this._formatValue(a)}`)
					: s.push(...this.diff(l, a, n.concat(o)))
			}
			return s
		}
		isObject(t) {
			return typeof t == "object" && t !== null
		}
		toString() {
			return this._isSet ? this._formatValue(this.value) : "<unset>"
		}
		_formatValue(t) {
			return t === void 0 ? "undefined" : JSON.stringify(t)
		}
	}
var Cc = class {
		_disposables = []
		add(t) {
			if (t === void 0) throw new Error("Attempt to add undefined disposable to DisposableCollection")
			return this._disposables.push(t), t
		}
		addAll(...t) {
			t.forEach((r) => this.add(r))
		}
		adopt(t) {
			this._disposables.push(...t._disposables), (t._disposables.length = 0)
		}
		dispose() {
			for (let t of this._disposables) t.dispose()
			this._disposables.length = 0
		}
	},
	z = class {
		_disposables = new Cc()
		_priorityDisposables = new Cc()
		constructor(t = new Cc(), r = new Cc()) {
			this._disposables.adopt(t), this._priorityDisposables.adopt(r)
		}
		addDisposable(t, r = !1) {
			return r ? this._priorityDisposables.add(t) : this._disposables.add(t)
		}
		addDisposables(...t) {
			this._disposables.addAll(...t)
		}
		dispose() {
			this._priorityDisposables.dispose(), this._disposables.dispose()
		}
	}
var kct = 128 * 1024,
	Gp = {
		gitDiff: !1,
		gitDiffPollingFrequencyMSec: 0,
		additionalChatModels: "",
		smallSyncThreshold: 15,
		bigSyncThreshold: 1e3,
		enableWorkspaceManagerUi: !0,
		enableInstructions: !1,
		enableSmartPaste: !1,
		enableSmartPasteMinVersion: "",
		enableViewTextDocument: !1,
		bypassLanguageFilter: !1,
		enableHindsight: !1,
		maxUploadSizeBytes: kct,
		vscodeNextEditBottomPanelMinVersion: "",
		vscodeNextEditMinVersion: "",
		vscodeNextEditUx1MaxVersion: "",
		vscodeNextEditUx2MaxVersion: "",
		vscodeFlywheelMinVersion: "",
		vscodeExternalSourcesInChatMinVersion: "",
		vscodeShareMinVersion: "",
		maxTrackableFileCount: 25e4,
		maxTrackableFileCountWithoutPermission: 15e4,
		minUploadedPercentageWithoutPermission: 90,
		vscodeSourcesMinVersion: "",
		vscodeChatHintDecorationMinVersion: "",
		nextEditDebounceMs: 400,
		enableCompletionFileEditEvents: !1,
		vscodeEnableCpuProfile: !1,
		verifyFolderIsSourceRepo: !1,
		refuseToSyncHomeDirectories: !1,
		enableFileLimitsForSyncingPermission: !1,
		enableChatMermaidDiagrams: !1,
		enableSummaryTitles: !1,
		smartPastePrecomputeMode: "visible-hover",
		vscodeNewThreadsMenuMinVersion: "",
		vscodeEditableHistoryMinVersion: "",
		vscodeEnableChatMermaidDiagramsMinVersion: "",
		userGuidelinesLengthLimit: 2e3,
		workspaceGuidelinesLengthLimit: 2e3,
		enableGuidelines: !1,
		useCheckpointManagerContextMinVersion: "",
		validateCheckpointManagerContext: !1,
		vscodeDesignSystemRichTextEditorMinVersion: "",
		allowClientFeatureFlagOverrides: !1,
		vscodeChatWithToolsMinVersion: "",
		vscodeChatMultimodalMinVersion: "",
		vscodeAgentModeMinVersion: "",
		vscodeBackgroundAgentsMinVersion: "",
		vscodeAgentEditTool: "backend_edit_tool",
		vscodeRichCheckpointInfoMinVersion: "",
		memoriesParams: {},
		eloModelConfiguration: {
			highPriorityModels: [],
			regularBattleModels: [],
			highPriorityThreshold: 0.5,
		},
		truncateChatHistory: !1,
	},
	ZH = class {
		constructor(t, r, n) {
			this._watchedFlags = r
			this._callback = n
			this._currentFlags = (0, zR.default)(t)
		}
		_disposed = !1
		_currentFlags
		get disposed() {
			return this._disposed
		}
		trigger(t) {
			if (this._disposed) return
			let r = []
			for (let n of this._watchedFlags) t[n] !== this._currentFlags[n] && r.push(n)
			r.length > 0 &&
				this._callback({
					previousFlags: this._currentFlags,
					newFlags: t,
					changedFlags: r,
				})
		}
		dispose() {
			this._disposed = !0
		}
	},
	jR = class extends z {
		_subscriptions = []
		_refreshTimer
		_disposed = !1
		_logger = X("FeatureFlagManager")
		_flags
		constructor(t, r) {
			super(),
				(this._flags = new gy("feature flags", this._logger, r)),
				this._flags.update(t?.initialFlags ?? Gp),
				this._setupRefreshTimer(t),
				this.addDisposable(
					mx.workspace.onDidChangeConfiguration(() => {
						this._subscriptions = this._subscriptions.filter((n) => !n.disposed)
						for (let n of this._subscriptions) n.trigger(this.currentFlags)
					}),
				)
		}
		get currentFlags() {
			if (this._disposed) throw Error("FeatureFlagManager has been disposed")
			return this._flags.value?.allowClientFeatureFlagOverrides
				? {
						...(0, zR.default)(this._flags.value),
						...this.readOverridesFromConfig(),
					}
				: (0, zR.default)(this._flags.value)
		}
		readOverridesFromConfig() {
			let t = mx.workspace.getConfiguration("augment")
			if (t.advanced == null || typeof t.advanced != "object") return {}
			let r = t.advanced.featureFlagOverrides,
				n = {}
			if (typeof r == "object")
				for (let i of Object.keys(r))
					Gp[i] === void 0
						? X("AugmentConfigListener").warn(`Feature flag override for ${i} is not a valid feature flag.`)
						: typeof r[i] != typeof Gp[i]
							? X("AugmentConfigListener").warn(
									`Feature flag override for ${i} is does not match default type ${typeof Gp[i]}.`,
								)
							: r[i] !== void 0 && Gp[i] !== void 0 && Object.assign(n, { [i]: r[i] })
			return n
		}
		update(t) {
			if (this._disposed) throw Error("FeatureFlagManager has been disposed")
			this._flags.update(t), (this._subscriptions = this._subscriptions.filter((r) => !r.disposed))
			for (let r of this._subscriptions) r.trigger(t)
		}
		subscribe(t, r) {
			if (this._disposed) throw Error("FeatureFlagManager has been disposed")
			let n = new ZH(this._flags.value, t, r)
			return this._subscriptions.push(n), n
		}
		_setupRefreshTimer(t) {
			if (!t?.fetcher || !t?.refreshIntervalMSec) return
			this._cleanupRefreshTimer()
			let r = new mx.CancellationTokenSource().token,
				n = t.fetcher,
				i = t.refreshIntervalMSec,
				s = async () => {
					let o = await n(r)
					o ? this.update(o) : r.isCancellationRequested && this._cleanupRefreshTimer()
				}
			this._refreshTimer = setInterval(() => void s(), i)
		}
		_cleanupRefreshTimer() {
			clearInterval(this._refreshTimer), (this._refreshTimer = void 0)
		}
		dispose() {
			this._disposed ||
				(super.dispose(),
				this._subscriptions.forEach((t) => t.dispose()),
				(this._subscriptions = []),
				this._cleanupRefreshTimer(),
				(this._disposed = !0))
		}
	}
var Fct = NAe(),
	XH = [],
	Qct = new Set()
for (let e of Fct) {
	XH.push({ name: e.name, vscodeName: e.vscodeName, extensions: e.extensions })
	for (let t of e.extensions) Qct.add(t)
}
var ws = ((re) => (
		(re.Unknown = "unknown"),
		(re.Command = "command"),
		(re.Background = "background"),
		(re.Global = "global"),
		(re.Click = "click"),
		(re.RightClick = "right-click"),
		(re.HoverClick = "hover-click"),
		(re.EditorActionClick = "editor-action-click"),
		(re.Keybinding = "keybinding"),
		(re.Keyboard = "keyboard"),
		(re.ActiveEditorChanged = "active-editor-changed"),
		(re.EditorSelectionChanged = "editor-selection-changed"),
		(re.EditorVisibleRangesChanged = "editor-visible-ranges-changed"),
		(re.HoveredOutsideSuggestion = "hovered-outside-suggestion"),
		(re.DocumentChanged = "document-changed"),
		(re.NextEditPanelItemFocusClick = "next-edit-panel-item-focus-click"),
		(re.NextEditPanelItemClick = "next-edit-panel-item-click"),
		(re.CodeAction = "code-action"),
		(re.GutterClick = "gutter-click"),
		(re.CodeLens = "code-lens"),
		(re.Tutorial = "tutorial"),
		(re.Error = "error"),
		(re.ValidationExpected = "validation-expected"),
		(re.ValidationUnexpected = "validation-unexpected"),
		(re.DebugSession = "debug-session"),
		(re.NotebookDocument = "notebook-document"),
		(re.UnsupportedUri = "unsupported-uri"),
		(re.MissingPathName = "missing-path-name"),
		(re.NotActiveEditor = "not-active-editor"),
		(re.NoContentChanges = "no-content-changes"),
		(re.FreshSuggestions = "fresh-suggestions"),
		re
	))(ws || {}),
	eW = class {
		constructor(t, r, n, i, s) {
			this.path = t
			this.range = r
			this.charStart = n
			this.charStop = i
			this.header = s
		}
	},
	ZR = class extends eW {
		constructor(t, r, n, i, s) {
			super(t, r, n, i, s)
		}
	}
var XR = class {
	constructor(t, r, n, i, s, o, a) {
		this.requestId = t
		this.mode = r
		this.scope = n
		this.qualifiedPathName = i
		this.apiResult = s
		this.suggestions = o
		this.requestTime = a
	}
	occurredAt = new Date()
}
function ek(e, t) {
	return e != null && typeof e == "object" && t in e
}
function Wn(e) {
	return e == null
}
function PAe(e) {
	if (ek(AbortSignal, "any") && typeof AbortSignal.any == "function") return AbortSignal.any(e)
	let t = new AbortController()
	if (e.some((i) => i.aborted)) return t.abort(), t.signal
	let r = [],
		n = () => {
			t.abort(), r.forEach((i) => i())
		}
	for (let i of e) i.addEventListener("abort", n), r.push(() => i.removeEventListener("abort", n))
	return t.signal
}
function py(e, t, r) {
	if (!Array.isArray(r)) throw new Error(`Value of ${e}.${t} is not Array`)
}
function Vi(e, t, r) {
	let n = typeof r
	if (n !== "number") throw new Error(`Value of ${e}.${t} has unexpected type. Expected number, received ${n}`)
	return r
}
function mi(e, t, r) {
	let n = typeof r
	if (n !== "string") throw new Error(`Value of ${e}.${t} has unexpected type. Expected string, received ${n}`)
	return r
}
function ml(e, t, r) {
	py(e, t, r)
	let n = []
	for (let i of r) n.push(mi(e, t, i))
	return n
}
function wu(e, t, r, n = !1) {
	if (r === null) return n
	let i = typeof r
	if (i !== "boolean") throw new Error(`Value of ${e}.${t} has unexpected type. Expected boolean, received ${i}`)
	return r
}
function Ay(e, t = "") {
	let r = []
	if (typeof e != "object" || e === null) return LAe(e)
	for (let [n, i] of Object.entries(e))
		if (Array.isArray(i)) {
			r.push(`${t}${n}: (array) ${i.length} (array length) ${JSON.stringify(i).length} (char length)`)
			let s = 20
			i.slice(0, s).forEach((o, a) => {
				r.push(`${t}  [${a}]: ${Ay(o, t + "  ")}`)
			}),
				i.length > s && r.push(`${t}  ${i.length - s} more items...`)
		} else
			typeof i == "object" && i !== null
				? (r.push(
						`${t}${n}: (object) ${Object.keys(i).length} (object size) ${
							JSON.stringify(i).length
						} (char length)`,
					),
					r.push(Ay(i, t + "  ")))
				: r.push(`${t}${n}: ${LAe(i)}`)
	return r.join(`
`)
}
function LAe(e) {
	return typeof e == "string"
		? `${e.length} (string length)`
		: typeof e == "boolean" || e === null || typeof e == "number"
			? "1"
			: "N/A"
}
function tk(e, t = "", r = {}) {
	for (let n in e)
		if (Object.hasOwn(e, n)) {
			let i = t ? `${t}.${n}` : n
			typeof e[n] == "object" && e[n] !== null ? tk(e[n], i, r) : (r[i] = String(e[n]))
		}
	return r
}
var Nct = W(require("vscode"))
function $p(e) {
	let t
	return new Promise((r) => {
		t = e((n) => {
			t.dispose(), r(n)
		})
	})
}
async function yx(e, t) {
	let r = new Promise((n, i) => {
		setTimeout(() => {
			i(new Error("Execution aborted due to timeout."))
		}, t)
	})
	return await Promise.race([e, r])
}
function yl(e) {
	return [...e].length
}
function tW(e, t) {
	return [...e].slice(0, t).join("").length
}
var rW = class {
	_items = new Map()
	_inProgress = !1
	_stopping = !1
	dispose() {
		this._stopping = !0
	}
	get size() {
		return this._items.size
	}
	cancel(t) {
		this._items.delete(t)
	}
	_insert(t, r, n = !1) {
		let i = this._items.has(t)
		return !n && i ? !1 : (this._items.set(t, r), !i)
	}
	async kick() {
		if (!(this._inProgress || this._stopping || this._items.size === 0)) {
			for (this._inProgress = !0; this._items.size > 0 && !this._stopping; ) {
				let t = this._items
				this._items = new Map()
				for (let r of t) {
					try {
						await this._processEntry(r)
					} catch {}
					if (this._stopping) break
				}
			}
			;(this._inProgress = !1), await this._processEntry(void 0)
		}
	}
}
var $o = class extends rW {
		constructor(r) {
			super()
			this._processItem = r
		}
		insert(r, n, i = !1) {
			return this._insert(r, n, i)
		}
		get(r) {
			return this._items.get(r)
		}
		async _processEntry(r) {
			return this._processItem(r)
		}
	},
	Ia = class {
		constructor(t) {
			this._processItem = t
		}
		_keys = new Set()
		_items = new Array()
		_inProgress = !1
		_stopping = !1
		get size() {
			return this._items.length
		}
		dispose() {
			this._stopping = !0
		}
		insert(t) {
			return this._keys.has(t) ? !1 : (this._keys.add(t), this._items.push(t), !0)
		}
		async kick() {
			if (!(this._inProgress || this._stopping)) {
				for (this._inProgress = !0; this._items.length > 0 && !this._stopping; ) {
					let t = this._items
					this._keys.clear(), (this._items = new Array())
					for (let r of t) {
						try {
							await this._processItem(r)
						} catch {}
						if (this._stopping) break
					}
				}
				;(this._inProgress = !1), await this._processItem(void 0)
			}
		}
	},
	vc = class {
		constructor(t, r) {
			this._toKick = t
			this._intervalId = setInterval(this._kick.bind(this), r)
		}
		_intervalId
		_kick() {
			this._toKick.kick()
		}
		dispose() {
			this._intervalId !== void 0 && clearInterval(this._intervalId)
		}
	},
	rk = class {
		constructor(t) {
			this._processItem = t
		}
		_items = []
		_inProgress = !1
		_stopping = !1
		get size() {
			return this._items.length
		}
		dispose() {
			this._stopping = !0
		}
		insert(t) {
			return new Promise((r, n) => {
				this._items.push({ itemArg: t, resolve: r, reject: n })
			})
		}
		insertAndKick(t) {
			let r = this.insert(t)
			return this.kick(), r
		}
		async kick() {
			if (!(this._inProgress || this._stopping)) {
				for (this._inProgress = !0; this._items.length > 0 && !this._stopping; ) {
					let t = this._items.pop()
					try {
						let r = await this._processItem(t.itemArg)
						t.resolve(r)
					} catch (r) {
						t.reject(r)
					}
				}
				;(this._inProgress = !1), await this._processItem(void 0)
			}
		}
	}
function Ec(e) {
	return {
		checkpoint_id: e.checkpointId,
		added_blobs: e.addedBlobs.sort(),
		deleted_blobs: e.deletedBlobs.sort(),
	}
}
var nk = class extends Error {
		constructor(t, r) {
			super(`Conversion failure: ${t}. Response = ${r}`)
		}
	},
	nW = class e {
		constructor(t, r, n, i, s) {
			this._configListener = t
			this._auth = r
			this.sessionId = n
			this._userAgent = i
			this._fetchFunction = s
		}
		static defaultRequestTimeoutMs = 3e4
		_sequenceId = new iW()
		_logger = X("AugmentExtension")
		getSessionId() {
			return this.sessionId
		}
		createRequestId() {
			return Eh()
		}
		async callApi(t, r, n, i, s, o, a, l, c, u) {
			let f = u ?? r.apiToken,
				p = !1
			if (this._auth.useOAuth && !u) {
				let Q = await this._auth.getSession()
				Q && ((f = Q.accessToken), (p = !0), o || (o = Q.tenantURL))
			} else o || (o = r.completionURL)
			if (!o) throw new Error("Please configure Augment API URL")
			let g
			try {
				g = new URL(n, o)
			} catch (Q) {
				throw (this._logger.error("Augment API URL is invalid:", Q), new Yp())
			}
			if (!g.protocol.startsWith("http"))
				throw new Error("Augment API URL must start with 'http://' or 'https://'")
			let m = JSON.stringify(i, (Q, O) => (O === void 0 ? null : O)),
				y = a ?? e.defaultRequestTimeoutMs,
				C = AbortSignal.timeout(y),
				v = "POST",
				b,
				w,
				B
			try {
				let Q = {
					"Content-Type": "application/json",
					"User-Agent": this._userAgent,
					"x-request-id": `${t}`,
					"x-request-session-id": `${this.sessionId}`,
					"x-api-version": "2",
				}
				f && (Q.Authorization = `Bearer ${f}`),
					(w = Date.now()),
					(b = await yx(
						this._fetchFunction(g.toString(), {
							method: v,
							headers: Q,
							body: m,
							signal: PAe([C].concat(c ? [c] : [])),
						}),
						y,
					)),
					(B = Date.now())
			} catch (Q) {
				throw Q instanceof Error
					? (this._logger.error(`API request ${t} to ${g.toString()} failed: ${Ye(Q, !0)}`),
						kr.transientIssue(Q.message))
					: (this._logger.debug(`API request ${t} to ${g.toString()} failed`), Q)
			}
			if ((l && ((l.rpcStart = w), (l.rpcEnd = B)), !b.ok))
				throw b.status === 499
					? kr.fromResponse(b)
					: (b.status === 401 && p && this._auth.removeSession(),
						b.status === 400 &&
							r.enableDebugFeatures &&
							this._logger.error(`API request ${t} to ${g.toString()} failed: ${await b.text()}`),
						this._logger.error(`API request ${t} to ${g.toString()} response ${b.status}: ${b.statusText}`),
						kr.fromResponse(b).status === He.augmentTooLarge &&
							this._logger.debug(`object size is ${Ay(i)} `),
						kr.fromResponse(b))
			let M
			try {
				if (b.headers.get("content-length") === "0") return
				M = await b.json()
			} catch (Q) {
				throw (
					(this._logger.error(
						`API request ${t} to ${g.toString()} failed to convert response to json: ${Q.message}`,
					),
					Q)
				)
			}
			try {
				return s ? s(M) : M
			} catch (Q) {
				throw new nk(Ye(Q), JSON.stringify(M))
			}
		}
		/**
		 * Make a request to the API, following redirects and handling errors.
		 * @param {string} t - method (e.g. 'GET', 'POST')
		 * @param {string} r - API endpoint (e.g. '/api/v2/complete')
		 * @param {RequestInit} [i] - request options
		 * @param {(response: Response) => T} [s] - response transformer
		 * @param {string} [o] - base URL (if not set, use value from config)
		 * @param {boolean} [a] - log request and response bodies
		 * @param {import('./logger').Logger} [l] - logger (if not set, use default logger)
		 */
		async callApiStream(t, r, n, i, s = (c) => c, o, a, l) {
			let c = r.apiToken
			if (this._auth.useOAuth) {
				let w = await this._auth.getSession()
				w && ((c = w.accessToken), o || (o = w.tenantURL))
			} else o || (o = r.completionURL)
			if (!o) throw new Error("Please configure Augment API URL")
			let u
			try {
				u = new URL(n, o)
			} catch (w) {
				throw (this._logger.error("Augment API URL is invalid:", w), new Yp())
			}
			if (!u.protocol.startsWith("http"))
				throw new Error("Augment API URL must start with 'http://' or 'https://'")
			let f = JSON.stringify(i, (w, B) => (B === void 0 ? null : B)),
				p = a ?? e.defaultRequestTimeoutMs,
				g = AbortSignal.timeout(p),
				m = "POST",
				y
			try {
				let w = {
					"Content-Type": "application/json",
					"User-Agent": this._userAgent,
					"x-request-id": `${t}`,
					"x-request-session-id": `${l ?? this.sessionId}`,
				}
				c && (w.Authorization = `Bearer ${c}`),
					(y = await yx(
						this._fetchFunction(u.toString(), {
							method: m,
							headers: w,
							body: f,
							signal: g,
						}),
						p,
					))
			} catch (w) {
				throw w instanceof Error
					? (this._logger.error(`API request ${t} to ${u.toString()} failed: ${Ye(w, !0)}`),
						w.stack && this._logger.error(w.stack),
						kr.transientIssue(w.message))
					: w
			}
			if (!y.ok)
				throw y.status === 499
					? kr.fromResponse(y)
					: (y.status === 401 && this._auth.removeSession(),
						y.status === 400 &&
							r.enableDebugFeatures &&
							this._logger.error(`API request ${t} to ${u.toString()} failed: ${await y.text()}`),
						this._logger.error(`API request ${t} to ${u.toString()} response ${y.status}: ${y.statusText}`),
						kr.fromResponse(y).status === He.augmentTooLarge &&
							this._logger.debug(`object size is ${i ? Ay(i) : 0} `),
						kr.fromResponse(y))
			let C = y.body.getReader(),
				v = this._logger
			async function* b(w) {
				let B = new TextDecoder(),
					M = ""
				for (;;) {
					let { value: Q, done: O } = await w.read(new Uint8Array())
					if (O) return
					for (
						M += B.decode(Q, { stream: !0 });
						M.includes(`
`);

					) {
						let Y = M.indexOf(`
`),
							j = M.substring(0, Y)
						M = M.substring(Y + 1)
						try {
							let ne = JSON.parse(j)
							yield s(ne)
						} catch (ne) {
							v.error(`JSON parse failed for ${j}: ${Ye(ne)}`)
						}
					}
				}
			}
			return b(C)
		}
		_toCompletionItem(t) {
			if (typeof t.text != "string") throw new Error(`Completion item text is not a string: ${JSON.stringify(t)}`)
			if (t.skipped_suffix !== void 0 && typeof t.skipped_suffix != "string")
				throw new Error(`Completion item skipped suffix is not a string: ${JSON.stringify(t)}`)
			if (t.suffix_replacement_text !== void 0 && typeof t.suffix_replacement_text != "string")
				throw new Error(`Completion item suffix replacement text is not a string: ${JSON.stringify(t)}`)
			return {
				text: t.text,
				suffixReplacementText: t.suffix_replacement_text ?? "",
				skippedSuffix: t.skipped_suffix ?? "",
				filterScore: t.filter_score ?? void 0,
			}
		}
		_extractCompletions(t) {
			return Array.isArray(t.completion_items)
				? t.completion_items.map((r) => this._toCompletionItem(r))
				: Array.isArray(t.completions)
					? ml("BackCompletionResult", "completions", t.completions).map((n) => ({
							text: n,
							suffixReplacementText: "",
							skippedSuffix: "",
						}))
					: [
							{
								text: mi("BackCompletionResult", "text", t.text),
								suffixReplacementText: "",
								skippedSuffix: "",
							},
						]
		}
		toCompleteResult(t) {
			let r = this._extractCompletions(t),
				n = ml(
					"BackCompletionResult",
					"unknown_blob_names/unknown_memory_names",
					t.unknown_blob_names ?? t.unknown_memory_names,
				),
				i =
					t.checkpoint_not_found === void 0
						? !1
						: wu("BackCompletionResult", "checkpoint_not_found", t.checkpoint_not_found, !1)
			return {
				completionItems: r,
				unknownBlobNames: n,
				checkpointNotFound: i,
				suggestedPrefixCharCount: t.suggested_prefix_char_count,
				suggestedSuffixCharCount: t.suggested_suffix_char_count,
				completionTimeoutMs: t.completion_timeout_ms,
			}
		}
		toCheckpointBlobsResult(t) {
			return {
				newCheckpointId: mi("BackCheckpointBlobsResult", "new_checkpoint_id", t.new_checkpoint_id),
			}
		}
		async complete(t, r, n, i, s, o, a, l, c, u, f, p, g) {
			let m = this._configListener.config,
				y = { recent_changes: c },
				C = {
					model: m.modelName,
					prompt: r,
					suffix: n,
					path: i,
					blob_name: s,
					prefix_begin: o?.prefixBegin,
					cursor_position: o?.cursorPosition,
					suffix_end: o?.suffixEnd,
					lang: a,
					blobs: Ec(l),
					recency_info: y,
					probe_only: p,
					sequence_id: this._sequenceId.next(),
					filter_threshold: m.completions.filterThreshold,
					edit_events: this.toFileDiffsPayload(u ?? []),
				}
			return await this.callApi(t, m, "completion", C, (v) => this.toCompleteResult(v), void 0, f, g)
		}
		async checkpointBlobs(t) {
			let r = this.createRequestId(),
				n = this._configListener.config,
				i = { blobs: Ec(t) },
				s = await this.callApi(r, n, "checkpoint-blobs", i, (o) => this.toCheckpointBlobsResult(o))
			for (let o of this.getUniqueExtraURLs())
				(await this.callApi(r, n, "checkpoint-blobs", i, (l) => this.toCheckpointBlobsResult(l), o))
					.newCheckpointId !== s.newCheckpointId &&
					this._logger.error(`Checkpoint blobs API returned different checkpoint IDs for ${o}`)
			return s
		}
		convertToCodeEditResult(t) {
			let r =
					t.unknown_blob_names === void 0
						? []
						: ml("BackCodeEditResult", "unknown_blob_names", t.unknown_blob_names),
				n =
					t.checkpoint_not_found === void 0
						? !1
						: wu("BackCodeEditResult", "checkpoint_not_found", t.checkpoint_not_found, !1)
			return {
				unknownBlobNames: r,
				checkpointNotFound: n,
				modifiedCode: t.text,
			}
		}
		async editCode(t, r, n, i, s, o, a, l, c, u, f) {
			let p = this._configListener.config,
				m = {
					model: p.codeInstruction.model,
					instruction: r,
					prefix: i,
					selected_text: n,
					suffix: s,
					blob_name: a,
					prefix_begin: l,
					suffix_end: c,
					lang: u,
					path: o,
					blobs: Ec(f),
					sequence_id: this._sequenceId.next(),
				}
			return await this.callApi(t, p, "edit", m, (y) => this.convertToCodeEditResult(y), void 0, 12e4)
		}
		toChatResult(t) {
			let r = mi("BackChatResult", "text", t.text),
				n =
					t.unknown_blob_names === void 0
						? []
						: ml("BackChatResult", "unknown_blob_names", t.unknown_blob_names),
				i =
					t.checkpoint_not_found === void 0
						? !1
						: wu("BackChatResult", "checkpoint_not_found", t.checkpoint_not_found, !1),
				s =
					t.workspace_file_chunks === void 0
						? []
						: t.workspace_file_chunks.map((a) => ({
								charStart: Vi("BackWorkspaceFileChunk", "char_start", a.char_start),
								charEnd: Vi("BackWorkspaceFileChunk", "char_end", a.char_end),
								blobName: mi("BackWorkspaceFileChunk", "blob_name", a.blob_name),
							})),
				o = t.nodes
			return {
				text: r,
				unknownBlobNames: n,
				checkpointNotFound: i,
				workspaceFileChunks: s,
				nodes: o,
			}
		}
		async chat(t, r, n, i, s, o, a, l, c, u, f, p, g, m, y) {
			let C = this._configListener.config,
				v = {
					model: a ?? C.chat.model,
					path: m,
					prefix: p,
					selected_code: f,
					suffix: g,
					message: r,
					chat_history: n,
					lang: y,
					blobs: Ec(i),
					user_guided_blobs: s,
					external_source_ids: o,
					enable_preference_collection: C.preferenceCollection.enable,
					context_code_exchange_request_id: u,
					vcs_change: this.toVCSChangePayload(l),
					recency_info_recent_changes: c,
					feature_detection_flags: { support_raw_output: !0 },
				}
			return await this.callApi(t, C, "chat", v, (b) => this.toChatResult(b), C.chat.url, 3e5)
		}
		async chatStream(t, r, n, i, s, o, a, l, c, u, f, p, g, m, y, C, v, b, w, B, M, Q, O) {
			let Y = this._configListener.config,
				j = {
					model: a ?? Y.chat.model,
					path: m,
					prefix: p,
					selected_code: f,
					suffix: g,
					message: r,
					chat_history: n,
					lang: y,
					blobs: Ec(i),
					user_guided_blobs: s,
					context_code_exchange_request_id: u,
					vcs_change: this.toVCSChangePayload(l),
					recency_info_recent_changes: c,
					external_source_ids: o,
					disable_auto_external_sources: v,
					user_guidelines: b,
					workspace_guidelines: w,
					feature_detection_flags: { support_raw_output: !0 },
					tool_definitions: B ?? [],
					nodes: M ?? [],
					mode: Q ?? Mn.chat,
					agent_memories: O,
				}
			return await xi(
				() => this.callApiStream(t, Y, "chat-stream", j, this.toChatResult.bind(this), Y.chat.url, 3e5, C),
				this._logger,
				{ initialMS: 250, mult: 2, maxMS: 5e3, maxTries: 5, maxTotalMs: 5e3 },
			)
		}
		toChatInstructionStreamResult(t) {
			let r =
					t.unknown_blob_names === void 0
						? []
						: ml("BackChatInstructionStreamResult", "unknown_blob_names", t.unknown_blob_names),
				n =
					t.checkpoint_not_found === void 0
						? !1
						: wu("BackChatInstructionStreamResult", "checkpoint_not_found", t.checkpoint_not_found, !1)
			return {
				text: t.text,
				unknownBlobNames: r,
				checkpointNotFound: n,
				replacementText: t.replacement_text,
				replacementOldText: t.replacement_old_text,
				replacementStartLine: t.replacement_start_line,
				replacementEndLine: t.replacement_end_line,
			}
		}
		async chatInstructionStream(
			t,
			r,
			n,
			i,
			s = "",
			o = "",
			a = "",
			l = "",
			c = "",
			u = void 0,
			f = void 0,
			p = "",
			g,
			m,
			y,
		) {
			let C = this._configListener.config,
				v = r.length === 0,
				b,
				w
			v
				? ((b = C.smartPaste.url ?? C.chat.url), (w = C.smartPaste.model))
				: ((b = C.chat.url), (w = C.instructions.model))
			let B = {
				model: w,
				prefix: o,
				selected_text: s,
				suffix: a,
				path: l,
				instruction: r,
				lang: p,
				blob_name: c,
				prefix_begin: u,
				suffix_end: f,
				blobs: Ec(n),
				chat_history: i,
				context_code_exchange_request_id: y,
				user_guidelines: g,
				workspace_guidelines: m,
			}
			return await this.callApiStream(
				t,
				C,
				"instruction-stream",
				B,
				this.toChatInstructionStreamResult.bind(this),
				b,
				12e4,
			)
		}
		_smartPasteQueue = new rk(this._processSingleSmartPasteRequest.bind(this))
		async smartPasteStream(
			t,
			r,
			n,
			i,
			s = "",
			o = "",
			a = "",
			l = "",
			c = "",
			u = void 0,
			f = void 0,
			p = "",
			g = "",
			m = "",
			y = "",
			C,
		) {
			let v = {
				requestId: t,
				instruction: r,
				blobs: n,
				chatHistory: i,
				selectedText: s,
				prefix: o,
				suffix: a,
				pathName: l,
				blobName: c,
				prefixBegin: u,
				suffixEnd: f,
				language: p,
				codeBlock: g,
				targetFilePath: m,
				targetFileContent: y,
				contextCodeExchangeRequestId: C,
			}
			return this._smartPasteQueue.insertAndKick(v)
		}
		async _processSingleSmartPasteRequest(t) {
			if (t === void 0) return
			if (t.requestServicedSignal !== void 0) return await t.requestServicedSignal
			let r = this._configListener.config,
				n = t.instruction.length === 0,
				i,
				s
			n ? ((i = r.smartPaste.url ?? r.chat.url), (s = r.smartPaste.model)) : (i = r.chat.url)
			let o = {
					model: s,
					prefix: t.prefix,
					selected_text: t.selectedText,
					suffix: t.suffix,
					path: t.pathName,
					instruction: t.instruction,
					lang: t.language,
					blob_name: t.blobName,
					prefix_begin: t.prefixBegin,
					suffix_end: t.suffixEnd,
					blobs: Ec(t.blobs),
					chat_history: t.chatHistory,
					code_block: t.codeBlock,
					target_file_path: t.targetFilePath,
					target_file_content: t.targetFileContent,
					context_code_exchange_request_id: t.contextCodeExchangeRequestId,
				},
				a
			return (
				(t.requestServicedSignal = new Promise((c) => {
					a = c
				})),
				this._smartPasteQueue.insertAndKick(t),
				async function* () {
					try {
						yield* await this.callApiStream(
							t.requestId,
							r,
							"smart-paste-stream",
							o,
							this.toChatInstructionStreamResult.bind(this),
							i,
							12e4,
						)
					} finally {
						a()
					}
				}.bind(this)()
			)
		}
		toGenerateCommitMessageResult(t) {
			return { text: t.text }
		}
		async generateCommitMessageStream(t, r) {
			let n = this._configListener.config,
				i = {
					changed_file_stats: r.changedFileStats,
					diff: r.diff,
					relevant_commit_messages: r.generatedCommitMessageSubrequest.relevant_commit_messages,
					example_commit_messages: r.generatedCommitMessageSubrequest.example_commit_messages,
				}
			return await this.callApiStream(
				t,
				n,
				"generate-commit-message-stream",
				i,
				this.toGenerateCommitMessageResult.bind(this),
				void 0,
				12e4,
			)
		}
		async createRemoteAgent(t, r, n, i) {
			let s = this.createRequestId(),
				o = this._configListener.config,
				a = {
					workspace_setup: t,
					initial_request_details: {
						request_nodes: r.request_nodes,
						user_guidelines: r.user_guidelines ?? o.chat.userGuidelines,
						workspace_guidelines: r.workspace_guidelines ?? "",
						agent_memories: r.agent_memories ?? "",
					},
					model: n ?? o.modelName,
					setup_script: i,
				}
			if (this._auth.useOAuth) {
				let l = await this._auth.getSession()
				l && (a.token = l.accessToken)
			}
			return (
				a.token || (a.token = o.remoteAgent.apiToken),
				console.log("Calling /remote-agents/create with payload: ", a),
				await this.callApi(
					s,
					o,
					"remote-agents/create",
					a,
					void 0,
					o.remoteAgent.url,
					void 0,
					void 0,
					void 0,
					o.remoteAgent.apiToken,
				)
			)
		}
		async remoteAgentChat(t, r) {
			let n = this.createRequestId(),
				i = this._configListener.config,
				s = {
					remote_agent_id: t,
					request_details: {
						request_nodes: r.request_nodes,
						user_guidelines: r.user_guidelines ?? i.chat.userGuidelines,
						workspace_guidelines: r.workspace_guidelines ?? "",
						agent_memories: r.agent_memories ?? "",
					},
				},
				o = await this.callApi(
					n,
					i,
					"remote-agents/chat",
					s,
					void 0,
					i.remoteAgent.url,
					void 0,
					void 0,
					void 0,
					i.remoteAgent.apiToken,
				)
			return { remoteAgentId: o.remote_agent_id, nodes: o.nodes }
		}
		async deleteRemoteAgent(t) {
			let r = this.createRequestId(),
				n = this._configListener.config,
				i = { remote_agent_id: t }
			return await this.callApi(
				r,
				n,
				"remote-agents/delete",
				i,
				void 0,
				n.remoteAgent.url,
				void 0,
				void 0,
				void 0,
				n.remoteAgent.apiToken,
			)
		}
		async interruptRemoteAgent(t) {
			let r = this.createRequestId(),
				n = this._configListener.config,
				i = { remote_agent_id: t }
			return await this.callApi(
				r,
				n,
				"remote-agents/interrupt",
				i,
				void 0,
				n.remoteAgent.url,
				void 0,
				void 0,
				void 0,
				n.remoteAgent.apiToken,
			)
		}
		async listRemoteAgents() {
			let t = this.createRequestId(),
				r = this._configListener.config
			return await this.callApi(
				t,
				r,
				"remote-agents/list",
				{},
				void 0,
				r.remoteAgent.url,
				void 0,
				void 0,
				void 0,
				r.remoteAgent.apiToken,
			)
		}
		async getRemoteAgentChatHistory(t) {
			let r = this.createRequestId(),
				n = this._configListener.config,
				i = { remote_agent_id: t }
			return await this.callApi(
				r,
				n,
				"remote-agents/get-chat-history",
				i,
				void 0,
				n.remoteAgent.url,
				void 0,
				void 0,
				void 0,
				n.remoteAgent.apiToken,
			)
		}
		toAutofixCommandPayload(t) {
			return { input: t.input, output: t.output, exit_code: t.exitCode }
		}
		toVCSChangePayload(t) {
			return {
				working_directory_changes: t.workingDirectory.map((r) => ({
					before_path: r.beforePath,
					after_path: r.afterPath,
					change_type: r.changeType,
					head_blob_name: r.headBlobName,
					indexed_blob_name: r.indexedBlobName,
					current_blob_name: r.currentBlobName,
				})),
			}
		}
		toBackTextReplacement(t) {
			return {
				description: t.description,
				path: t.path,
				text: t.text,
				old_text: t.oldText,
				start_line: t.startLine,
				end_line: t.endLine,
				sequence_id: t.sequenceId,
				old_blob_name: t.oldBlobName,
			}
		}
		toFileDiffsPayload(t) {
			return t.map((r) => ({
				path: r.path,
				before_blob_name: r.beforeBlobName,
				after_blob_name: r.afterBlobName,
				edits: r.edits.map((n) => ({
					before_start: n.beforeStart,
					after_start: n.afterStart,
					before_text: n.beforeText,
					after_text: n.afterText,
				})),
			}))
		}
		toFileCharRangePayload(t) {
			return t
				.filter((r) => r.charStart !== void 0 && r.charStop !== void 0)
				.map((r) => ({
					path: r.path,
					char_start: r.charStart,
					char_end: r.charStop,
				}))
		}
		toNextEditLocationResult(t) {
			py("BackNextEditLocationResult", "candidate_locations", t.candidate_locations)
			let r =
					t.unknown_blob_names === void 0
						? []
						: ml("BackNextEditLocationResult", "unknown_blob_names", t.unknown_blob_names),
				n =
					t.checkpoint_not_found === void 0
						? !1
						: wu("BackNextEditResult", "checkpoint_not_found", t.checkpoint_not_found, !1),
				i =
					t.critical_errors === void 0 || t.critical_errors === null
						? []
						: ml("BackNextEditResult", "critical_errors", t.critical_errors),
				s = []
			for (let o of t.candidate_locations) {
				let a = {
						start: Vi("BackLineRange", "start", o.item.range.start),
						stop: Vi("BackLineRange", "stop", o.item.range.stop),
					},
					c = {
						item: { path: mi("BackLocation", "path", o.item.path), range: a },
						score: Vi("BackScored", "score", o.score),
						debugInfo: o.debug_info,
					}
				s.push(c)
			}
			return {
				candidateLocations: s,
				unknownBlobNames: r,
				checkpointNotFound: n,
				criticalErrors: i,
			}
		}
		async nextEditLocation(t, r, n, i, s, o, a, l, c, u) {
			let f = this._configListener.config,
				p = {
					instruction: r,
					path: n,
					vcs_change: this.toVCSChangePayload(i),
					edit_events: this.toFileDiffsPayload(s),
					blobs: Ec(o),
					recent_changes: a,
					diagnostics: l,
					num_results: c,
					is_single_file: u,
				}
			return await this.callApi(
				t,
				f,
				"next_edit_loc",
				p,
				(g) => this.toNextEditLocationResult(g),
				f.nextEdit.locationUrl,
				12e4,
			)
		}
		convertToAutofixCheckResponse(t) {
			return {
				containsFailure: wu("BackAutofixCheckResponse", "contains_failure", t.contains_failure, !1),
				isCodeRelated: wu("BackAutofixCheckResponse", "is_code_related", t.is_code_related, !1),
			}
		}
		convertToAutofixPlanResponse(t) {
			return {
				unknownBlobNames: ml("BackAutofixPlanResponse", "unknown_blob_names", t.unknown_blob_names),
				checkpointNotFound: wu("BackAutofixPlanResponse", "checkpoint_not_found", t.checkpoint_not_found, !1),
				summary: t.summary,
				replacements: t.replacements.map((r) => ({
					description: r.description,
					path: r.path,
					text: r.text,
					oldText: r.old_text,
					startLine: r.start_line,
					endLine: r.end_line,
					sequenceId: r.sequence_id,
					oldBlobName: r.old_blob_name,
				})),
			}
		}
		convertToNextEditGenerationResult(t) {
			let r =
					t.unknown_blob_names === void 0
						? []
						: ml("BackNextEditGenerationResult", "unknown_blob_names", t.unknown_blob_names),
				n =
					t.checkpoint_not_found === void 0
						? !1
						: wu("BackNextEditResult", "checkpoint_not_found", t.checkpoint_not_found, !1)
			return {
				result: this.convertToNextEditResult(t.next_edit),
				unknownBlobNames: r,
				checkpointNotFound: n,
			}
		}
		convertToNextEditResult(t) {
			let r = mi("BackNextEditResult", "suggestion_id", t.suggestion_id),
				n = mi("BackNextEditResult", "path", t.path),
				i = mi("BackNextEditResult", "blob_name", t.blob_name),
				s = Vi("BackNextEditResult", "char_start", t.char_start),
				o = Vi("BackNextEditResult", "char_end", t.char_end),
				a = mi("BackNextEditResult", "existing_code", t.existing_code),
				l = mi("BackNextEditResult", "suggested_code", t.suggested_code),
				c =
					t.truncation_char === void 0 || t.truncation_char === null
						? void 0
						: Vi("BackNextEditResult", "truncation_char", t.truncation_char),
				u =
					t.change_description === void 0
						? ""
						: mi("BackNextEditResult", "change_description", t.change_description),
				f = t.diff_spans?.map((y) => ({
					original: {
						start: Vi("BackCharRange", "start", y.original.start),
						stop: Vi("BackCharRange", "stop", y.original.stop),
					},
					updated: {
						start: Vi("BackCharRange", "start", y.updated.start),
						stop: Vi("BackCharRange", "stop", y.updated.stop),
					},
				})),
				p = Vi("BackNextEditResult", "editing_score", t.editing_score),
				g = Vi("BackNextEditResult", "localization_score", t.localization_score),
				m =
					t.editing_score_threshold === void 0
						? 1
						: Vi("BackNextEditResult", "editing_score_threshold", t.editing_score_threshold)
			return {
				suggestionId: r,
				path: n,
				blobName: i,
				charStart: s,
				charEnd: o,
				existingCode: a,
				suggestedCode: l,
				truncationChar: c,
				changeDescription: u,
				diffSpans: f,
				editingScore: p,
				localizationScore: g,
				editingScoreThreshold: m,
			}
		}
		async nextEditStream(t) {
			let r = this._configListener.config,
				n = r.nextEdit.model,
				i = t.prefix ? yl(t.prefix) : void 0,
				s = {
					model: n,
					instruction: t.instruction ?? "",
					prefix: t.prefix,
					selected_text: t.selectedCode,
					suffix: t.suffix,
					selection_begin_char: i,
					selection_end_char:
						t.prefix !== void 0 && t.selectedCode !== void 0 ? i + yl(t.selectedCode) : void 0,
					blob_name: t.blobName,
					lang: t.language,
					path: t.pathName?.relPath,
					blobs: (t.blobs && Ec(t.blobs)) ?? {
						checkpoint_id: void 0,
						added_blobs: [],
						deleted_blobs: [],
					},
					recent_changes: t.recentChanges,
					diagnostics: t.diagnostics,
					vcs_change: this.toVCSChangePayload({
						workingDirectory: [],
						commits: [],
					}),
					edit_events: this.toFileDiffsPayload(t.fileEditEvents ?? []),
					blocked_locations: this.toFileCharRangePayload(t.blockedLocations ?? []),
					mode: t.mode,
					scope: t.scope,
					api_version: 2,
					sequence_id: this._sequenceId.next(),
					client_created_at: t.clientCreatedAt,
					unindexed_edit_events: this.toFileDiffsPayload(t.unindexedEditEvents),
					unindexed_edit_events_base_blob_names: t.unindexedEditEventsBaseBlobNames,
				}
			return await this.callApiStream(
				t.requestId,
				r,
				"next-edit-stream",
				s,
				this.convertToNextEditGenerationResult.bind(this),
				r.nextEdit.generationUrl,
				12e4,
			)
		}
		getUniqueExtraURLs() {
			let t = this._configListener.config,
				r = new Set()
			return (
				t.nextEdit.url && r.add(t.nextEdit.url),
				t.nextEdit.locationUrl && r.add(t.nextEdit.locationUrl),
				t.nextEdit.generationUrl && r.add(t.nextEdit.generationUrl),
				t.chat.url && r.add(t.chat.url),
				r
			)
		}
		toMemorizeResult(t) {
			return {
				blobName:
					t.blob_name !== void 0
						? mi("BackMemorizeResult", "blob_name", t.blob_name)
						: mi("BackMemorizeResult", "mem_object_name", t.mem_object_name),
			}
		}
		async memorize(t, r, n, i, s) {
			let o = this.createRequestId(),
				a = this._configListener.config,
				l = await this.callApi(
					o,
					a,
					"memorize",
					{
						model: a.modelName,
						path: t,
						t: r,
						blob_name: n,
						metadata: i,
						timeout_ms: s,
					},
					(c) => this.toMemorizeResult(c),
				)
			for (let c of this.getUniqueExtraURLs())
				await this.callApi(
					o,
					a,
					"memorize",
					{ model: a.modelName, path: t, t: r, blob_name: n, metadata: i },
					(u) => this.toMemorizeResult(u),
					c,
				)
			return l
		}
		toBatchUploadResult(t) {
			return { blobNames: t.blob_names }
		}
		async batchUpload(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			try {
				let i = await this.callApi(
					r,
					n,
					"batch-upload",
					{
						blobs: t.map((s) => ({
							blob_name: s.blobName,
							path: s.pathName,
							content: s.text,
						})),
					},
					this.toBatchUploadResult.bind(this),
				)
				for (let s of this.getUniqueExtraURLs())
					await this.callApi(
						r,
						n,
						"batch-upload",
						{
							blobs: t.map((o) => ({
								blob_name: o.blobName,
								path: o.pathName,
								content: o.text,
							})),
						},
						this.toBatchUploadResult.bind(this),
						s,
					)
				return i
			} catch (i) {
				if (!kr.isAPIErrorWithStatus(i, He.unimplemented)) throw i
				let s = []
				for (let o of t) {
					let a = await this.memorize(o.pathName, o.text, o.blobName, o.metadata)
					s.push(a.blobName)
				}
				return { blobNames: s }
			}
		}
		toFindMissingResult(t) {
			return {
				unknownBlobNames: ml("BackFindMissingResult", "unknown_memory_names", t.unknown_memory_names),
				nonindexedBlobNames: ml("BackFindMissingResult", "nonindexed_blob_names", t.nonindexed_blob_names),
			}
		}
		async findMissing(t) {
			let r = this._configListener.config,
				n = this.createRequestId(),
				i = r.modelName,
				s = [...t].sort(),
				o = await this.callApi(n, r, "find-missing", { model: i, mem_object_names: s }, (a) =>
					this.toFindMissingResult(a),
				)
			for (let a of this.getUniqueExtraURLs()) {
				let l = await this.callApi(
					n,
					r,
					"find-missing",
					{ model: i, mem_object_names: s },
					(c) => this.toFindMissingResult(c),
					a,
				)
				;(o.unknownBlobNames = o.unknownBlobNames.concat(l.unknownBlobNames)),
					(o.nonindexedBlobNames = o.nonindexedBlobNames.concat(l.nonindexedBlobNames))
			}
			return o
		}
		async resolveCompletions(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(r, n, "resolve-completions", {
				client_name: "vscode-extension",
				resolutions: t,
			})
		}
		async logCodeEditResolution(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(r, n, "resolve-edit", {
				client_name: "vscode-extension",
				...t,
			})
		}
		async logSmartPasteResolution(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(r, n, "resolve-smart-paste", {
				client_name: "vscode-extension",
				...t,
			})
		}
		async logInstructionResolution(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(r, n, "resolve-instruction", {
				client_name: "vscode-extension",
				...t,
			})
		}
		async resolveNextEdits(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(
				r,
				n,
				"resolve-next-edit",
				{ client_name: "vscode-extension", resolutions: t },
				void 0,
				n.nextEdit.url,
			)
		}
		async logNextEditSessionEvent(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(
				r,
				n,
				"record-session-events",
				{
					client_name: "vscode-extension",
					events: t.map((i) => ({
						time: new Date(i.event_time_sec * 1e3 + i.event_time_nsec / 1e6).toISOString(),
						event: {
							next_edit_session_event: { ...i, user_agent: this._userAgent },
						},
					})),
				},
				void 0,
				n.nextEdit.url,
			)
		}
		async logOnboardingSessionEvent(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(
				r,
				n,
				"record-session-events",
				{
					client_name: "vscode-extension",
					events: t.map((i) => ({
						time: new Date(i.event_time_sec * 1e3 + i.event_time_nsec / 1e6).toISOString(),
						event: {
							onboarding_session_event: { ...i, user_agent: this._userAgent },
						},
					})),
				},
				void 0,
			)
		}
		async logAgentSessionEvent(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(
				r,
				n,
				"record-session-events",
				{
					client_name: "vscode-extension",
					events: t.map((i) => ({
						time: new Date(i.event_time_sec * 1e3 + i.event_time_nsec / 1e6).toISOString(),
						event: {
							agent_session_event: { ...i, user_agent: this._userAgent },
						},
					})),
				},
				void 0,
			)
		}
		async logAgentRequestEvent(t) {
			let r = new Map()
			for (let n of t) {
				let i = r.get(n.request_id) || []
				r.has(n.request_id) || r.set(n.request_id, i)
				let { request_id: s, ...o } = n
				i.push(o)
			}
			for (let [n, i] of r) {
				let s = this._configListener.config
				await this.callApi(
					n,
					s,
					"record-request-events",
					{
						events: i.map((o) => ({
							time: new Date(o.event_time_sec * 1e3 + o.event_time_nsec / 1e6).toISOString(),
							event: {
								agent_request_event: { ...o, user_agent: this._userAgent },
							},
						})),
					},
					void 0,
				)
			}
		}
		async logExtensionSessionEvent(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(
				r,
				n,
				"record-session-events",
				{
					client_name: "vscode-extension",
					events: t.map((i) => ({
						time: i.time_iso,
						event: {
							extension_session_event: { ...i, user_agent: this._userAgent },
						},
					})),
				},
				void 0,
			)
		}
		async logToolUseRequestEvent(t) {
			let r = new Map()
			for (let n of t) {
				let i = r.get(n.requestId)
				i === void 0 ? r.set(n.requestId, [n]) : i.push(n)
			}
			for (let [n, i] of r) {
				let s = this._configListener.config
				await this.callApi(
					n,
					s,
					"record-request-events",
					{
						events: i.map((o) => {
							let a = {
								tool_name: o.toolName,
								tool_use_id: o.toolUseId,
								tool_output_is_error: o.toolOutputIsError,
								tool_run_duration_ms: o.toolRunDurationMs,
								tool_input: JSON.stringify(o.toolInput),
								is_mcp_tool: o.isMcpTool,
								conversation_id: o.conversationId,
								chat_history_length: o.chatHistoryLength,
								tool_request_id: o.toolRequestId,
							}
							return {
								time: new Date(o.eventTimeSec * 1e3 + o.eventTimeNsec / 1e6).toISOString(),
								event: { tool_use_data: a },
							}
						}),
					},
					void 0,
				)
			}
		}
		async recordPreferenceSample(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(r, n, "record-preference-sample", {
				client_name: "vscode-extension",
				...t,
			})
		}
		toModel(t) {
			let r =
				t.completion_timeout_ms !== void 0
					? Vi("BackModelInfo", "completion_timeout_ms", t.completion_timeout_ms)
					: void 0
			return {
				name: mi("BackModelInfo", "name", t.name),
				suggestedPrefixCharCount: Vi(
					"BackModelInfo",
					"suggested_prefix_char_count",
					t.suggested_prefix_char_count,
				),
				suggestedSuffixCharCount: Vi(
					"BackModelInfo",
					"suggested_suffix_char_count",
					t.suggested_suffix_char_count,
				),
				completionTimeoutMs: r,
				internalName: t.internal_name && mi("BackModelInfo", "internal_name", t.internal_name),
			}
		}
		toLanguage(t) {
			let r = mi("BackLanguageInfo", "name", t.name),
				n = mi("BackLanguageInfo", "vscodeName", t.vscode_name)
			py("BackLanguageInfo", "extensions", t.extensions)
			let i = []
			for (let s of t.extensions) i.push(mi("BackLanguageInfo", "extensions", s))
			return { name: r, vscodeName: n, extensions: i }
		}
		toGetModelsResult(t) {
			let r = mi("BackGetModelsResult", "default_model", t.default_model)
			py("BackGetModelsResult", "models", t.models)
			let n = []
			for (let a of t.models) n.push(this.toModel(a))
			let i = Gp
			if (t.feature_flags !== void 0) {
				let a = t.feature_flags.git_diff_polling_freq_msec
				if (
					(a !== void 0 && a > 0 && ((i.gitDiff = !0), (i.gitDiffPollingFrequencyMSec = a)),
					t.feature_flags.small_sync_threshold !== void 0 &&
						(i.smallSyncThreshold = t.feature_flags.small_sync_threshold),
					t.feature_flags.big_sync_threshold !== void 0 &&
						(i.bigSyncThreshold = t.feature_flags.big_sync_threshold),
					t.feature_flags.enable_workspace_manager_ui_launch !== void 0 &&
						(i.enableWorkspaceManagerUi = t.feature_flags.enable_workspace_manager_ui_launch),
					t.feature_flags.enable_instructions !== void 0 &&
						(i.enableInstructions = t.feature_flags.enable_instructions),
					t.feature_flags.enable_smart_paste !== void 0 &&
						(i.enableSmartPaste = t.feature_flags.enable_smart_paste),
					t.feature_flags.enable_smart_paste_min_version !== void 0 &&
						(i.enableSmartPasteMinVersion = t.feature_flags.enable_smart_paste_min_version),
					t.feature_flags.enable_view_text_document !== void 0 &&
						(i.enableViewTextDocument = t.feature_flags.enable_view_text_document),
					t.feature_flags.bypass_language_filter !== void 0 &&
						(i.bypassLanguageFilter = t.feature_flags.bypass_language_filter),
					t.feature_flags.additional_chat_models !== void 0 &&
						(i.additionalChatModels = t.feature_flags.additional_chat_models),
					t.feature_flags.enable_hindsight !== void 0 &&
						(i.enableHindsight = t.feature_flags.enable_hindsight),
					t.feature_flags.max_upload_size_bytes !== void 0 &&
						(i.maxUploadSizeBytes = t.feature_flags.max_upload_size_bytes),
					t.feature_flags.vscode_next_edit_min_version !== void 0 &&
						(i.vscodeNextEditMinVersion = t.feature_flags.vscode_next_edit_min_version),
					t.feature_flags.vscode_next_edit_ux1_max_version !== void 0 &&
						(i.vscodeNextEditUx1MaxVersion = t.feature_flags.vscode_next_edit_ux1_max_version),
					t.feature_flags.vscode_next_edit_ux2_max_version !== void 0 &&
						(i.vscodeNextEditUx2MaxVersion = t.feature_flags.vscode_next_edit_ux2_max_version),
					t.feature_flags.vscode_flywheel_min_version !== void 0 &&
						(i.vscodeFlywheelMinVersion = t.feature_flags.vscode_flywheel_min_version),
					t.feature_flags.vscode_external_sources_in_chat_min_version !== void 0 &&
						(i.vscodeExternalSourcesInChatMinVersion =
							t.feature_flags.vscode_external_sources_in_chat_min_version),
					t.feature_flags.vscode_share_min_version !== void 0 &&
						(i.vscodeShareMinVersion = t.feature_flags.vscode_share_min_version),
					t.feature_flags.max_trackable_file_count !== void 0 &&
						(i.maxTrackableFileCount = t.feature_flags.max_trackable_file_count),
					t.feature_flags.max_trackable_file_count_without_permission !== void 0 &&
						(i.maxTrackableFileCountWithoutPermission =
							t.feature_flags.max_trackable_file_count_without_permission),
					t.feature_flags.min_uploaded_percentage_without_permission !== void 0 &&
						(i.minUploadedPercentageWithoutPermission =
							t.feature_flags.min_uploaded_percentage_without_permission),
					t.feature_flags.vscode_sources_min_version !== void 0 &&
						(i.vscodeSourcesMinVersion = t.feature_flags.vscode_sources_min_version),
					t.feature_flags.vscode_chat_hint_decoration_min_version !== void 0 &&
						(i.vscodeChatHintDecorationMinVersion =
							t.feature_flags.vscode_chat_hint_decoration_min_version),
					t.feature_flags.next_edit_debounce_ms !== void 0 &&
						(i.nextEditDebounceMs = t.feature_flags.next_edit_debounce_ms),
					t.feature_flags.enable_completion_file_edit_events !== void 0 &&
						(i.enableCompletionFileEditEvents = t.feature_flags.enable_completion_file_edit_events),
					t.feature_flags.vscode_enable_cpu_profile !== void 0 &&
						(i.vscodeEnableCpuProfile = t.feature_flags.vscode_enable_cpu_profile),
					t.feature_flags.verify_folder_is_source_repo !== void 0 &&
						(i.verifyFolderIsSourceRepo = t.feature_flags.verify_folder_is_source_repo),
					t.feature_flags.refuse_to_sync_home_directories !== void 0 &&
						(i.refuseToSyncHomeDirectories = t.feature_flags.refuse_to_sync_home_directories),
					t.feature_flags.enable_file_limits_for_syncing_permission !== void 0 &&
						(i.enableFileLimitsForSyncingPermission =
							t.feature_flags.enable_file_limits_for_syncing_permission),
					t.feature_flags.enable_chat_mermaid_diagrams !== void 0 &&
						(i.enableChatMermaidDiagrams = t.feature_flags.enable_chat_mermaid_diagrams),
					t.feature_flags.enable_summary_titles !== void 0 &&
						(i.enableSummaryTitles = t.feature_flags.enable_summary_titles),
					t.feature_flags.smart_paste_precompute_mode !== void 0 &&
						(i.smartPastePrecomputeMode = t.feature_flags.smart_paste_precompute_mode),
					t.feature_flags.vscode_new_threads_menu_min_version !== void 0 &&
						(i.vscodeNewThreadsMenuMinVersion = t.feature_flags.vscode_new_threads_menu_min_version),
					t.feature_flags.vscode_editable_history_min_version !== void 0 &&
						(i.vscodeEditableHistoryMinVersion = t.feature_flags.vscode_editable_history_min_version),
					t.feature_flags.vscode_enable_chat_mermaid_diagrams_min_version !== void 0 &&
						(i.vscodeEnableChatMermaidDiagramsMinVersion =
							t.feature_flags.vscode_enable_chat_mermaid_diagrams_min_version),
					t.feature_flags.enable_guidelines !== void 0 &&
						(i.enableGuidelines = t.feature_flags.enable_guidelines),
					t.feature_flags.vscode_use_checkpoint_manager_context_min_version !== void 0 &&
						(i.useCheckpointManagerContextMinVersion =
							t.feature_flags.vscode_use_checkpoint_manager_context_min_version),
					t.feature_flags.vscode_validate_checkpoint_manager_context !== void 0 &&
						(i.validateCheckpointManagerContext =
							t.feature_flags.vscode_validate_checkpoint_manager_context),
					t.feature_flags.vscode_design_system_rich_text_editor_min_version !== void 0 &&
						(i.vscodeDesignSystemRichTextEditorMinVersion =
							t.feature_flags.vscode_design_system_rich_text_editor_min_version),
					t.feature_flags.allow_client_feature_flag_overrides !== void 0 &&
						(i.allowClientFeatureFlagOverrides = t.feature_flags.allow_client_feature_flag_overrides),
					t.feature_flags.vscode_chat_with_tools_min_version !== void 0 &&
						(i.vscodeChatWithToolsMinVersion = t.feature_flags.vscode_chat_with_tools_min_version),
					t.feature_flags.vscode_agent_mode_min_version !== void 0 &&
						(i.vscodeAgentModeMinVersion = t.feature_flags.vscode_agent_mode_min_version),
					t.feature_flags.vscode_background_agents_min_version !== void 0 &&
						(i.vscodeBackgroundAgentsMinVersion = t.feature_flags.vscode_background_agents_min_version),
					t.feature_flags.vscode_agent_edit_tool !== void 0 &&
						(i.vscodeAgentEditTool = t.feature_flags.vscode_agent_edit_tool),
					t.feature_flags.memories_params !== void 0)
				)
					try {
						i.memoriesParams = JSON.parse(t.feature_flags.memories_params)
					} catch {
						this._logger.error('Parsing of "memories_params" failed.')
					}
				if (t.feature_flags.elo_model_configuration !== void 0)
					try {
						i.eloModelConfiguration = JSON.parse(t.feature_flags.elo_model_configuration)
					} catch {
						this._logger.error('Parsing of "elo_model_configuration" failed.')
					}
				t.feature_flags.client_truncate_chat_history !== void 0 &&
					(i.truncateChatHistory = t.feature_flags.client_truncate_chat_history),
					t.feature_flags.vscode_next_edit_bottom_panel_min_version !== void 0 &&
						(i.vscodeNextEditBottomPanelMinVersion =
							t.feature_flags.vscode_next_edit_bottom_panel_min_version),
					t.feature_flags.vscode_chat_multimodal_min_version !== void 0 &&
						(i.vscodeChatMultimodalMinVersion = t.feature_flags.vscode_chat_multimodal_min_version),
					t.feature_flags.workspace_guidelines_length_limit !== void 0 &&
						(i.workspaceGuidelinesLengthLimit = t.feature_flags.workspace_guidelines_length_limit),
					t.feature_flags.user_guidelines_length_limit !== void 0 &&
						(i.userGuidelinesLengthLimit = t.feature_flags.user_guidelines_length_limit),
					t.feature_flags.vscode_rich_checkpoint_info_min_version !== void 0 &&
						(i.vscodeRichCheckpointInfoMinVersion = t.feature_flags.vscode_rich_checkpoint_info_min_version)
			}
			let s = []
			if (t.languages === void 0) s = XH
			else {
				py("BackGetModelsResult", "languages", t.languages), (s = [])
				for (let a of t.languages) s.push(this.toLanguage(a))
			}
			let o = t.user_tier?.toLowerCase().replace("_tier", "") ?? "unknown"
			return {
				defaultModel: r,
				models: n,
				languages: s,
				featureFlags: i,
				userTier: o,
			}
		}
		async getModelConfig() {
			let t = this._configListener.config,
				r = this.createRequestId()
			return await this.callApi(r, t, "get-models", {}, (i) => this.toGetModelsResult(i))
		}
		async completionFeedback(t) {
			let r = this._configListener.config,
				n = this.createRequestId()
			await this.callApi(
				n,
				r,
				"completion-feedback",
				{ request_id: t.requestId, rating: t.rating, note: t.note },
				void 0,
			)
		}
		async chatFeedback(t) {
			let r = this._configListener.config,
				n = this.createRequestId()
			await this.callApi(
				n,
				r,
				"chat-feedback",
				{
					request_id: t.requestId,
					rating: t.rating,
					note: t.note,
					mode: t.mode,
				},
				void 0,
			)
		}
		async nextEditFeedback(t) {
			let r = this._configListener.config,
				n = this.createRequestId()
			await this.callApi(
				n,
				r,
				"next-edit-feedback",
				{ request_id: t.requestId, rating: t.rating, note: t.note },
				void 0,
				r.nextEdit.url,
			)
		}
		async getAccessToken(t, r, n, i) {
			let s = this._configListener.config,
				o = this.createRequestId(),
				a = {
					grant_type: "authorization_code",
					client_id: s.oauth.clientID,
					code_verifier: n,
					redirect_uri: t,
					code: i,
				}
			return await this.callApi(o, s, "token", a, (l) => l.access_token, r)
		}
		async uploadUserEvents(t) {
			let r = this.createRequestId()
			return await this.callApi(r, this._configListener.config, "record-user-events", { extension_data: t })
		}
		async clientMetrics(t) {
			let r = this._configListener.config,
				n = this.createRequestId()
			await this.callApi(n, r, "client-metrics", { metrics: t }, void 0, void 0, e.defaultRequestTimeoutMs)
		}
		async searchExternalSources(t, r) {
			let n = this._configListener.config,
				i = this.createRequestId()
			return await this.callApi(i, n, "search-external-sources", { query: t, source_types: r }, (s) => s)
		}
		async getImplicitExternalSources(t) {
			let r = this._configListener.config,
				n = this.createRequestId()
			return await this.callApi(n, r, "get-implicit-external-sources", { message: t }, (i) => i)
		}
		convertToAgentCodebaseRetrievalResult(t) {
			return { formattedRetrieval: t.formatted_retrieval }
		}
		async agentCodebaseRetrieval(t, r, n, i, s, o) {
			let a = this._configListener.config
			return await this.callApi(
				t,
				a,
				"agents/codebase-retrieval",
				{
					information_request: r,
					blobs: Ec(n),
					dialog: i,
					max_output_length: s,
				},
				(l) => this.convertToAgentCodebaseRetrievalResult(l),
				a.chat.url,
				12e4,
				void 0,
				o,
			)
		}
		convertToAgentEditFileResult(t) {
			return {
				modifiedFileContents: t.modified_file_contents,
				isError: t.is_error,
			}
		}
		async agentEditFile(t, r, n, i, s, o) {
			let a = this._configListener.config
			return await this.callApi(
				t,
				a,
				"agents/edit-file",
				{
					file_path: r,
					edit_summary: n,
					detailed_edit_description: i,
					file_contents: s,
				},
				(l) => this.convertToAgentEditFileResult(l),
				a.chat.url,
				12e4,
				void 0,
				o,
			)
		}
		convertToToolSafety(t) {
			switch (t) {
				case 0:
					return xt.Unsafe
				case 1:
					return xt.Safe
				case 2:
					return xt.Check
				default:
					return xt.Unsafe
			}
		}
		convertToListRemoteToolsResult(t) {
			return {
				tools: t.tools.map((r) => ({
					toolDefinition: r.tool_definition,
					remoteToolId: r.remote_tool_id,
					availabilityStatus: r.availability_status,
					toolSafety: this.convertToToolSafety(r.tool_safety),
					oauthUrl: r.oauth_url,
				})),
			}
		}
		async listRemoteTools(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(
				r,
				n,
				"agents/list-remote-tools",
				{ tool_id_list: { tool_ids: t } },
				(i) => this.convertToListRemoteToolsResult(i),
				n.chat.url,
				12e4,
			)
		}
		convertToCheckToolSafetyResult(t) {
			return t.is_safe
		}
		async checkToolSafety(t, r) {
			let n = this.createRequestId(),
				i = this._configListener.config
			return await this.callApi(
				n,
				i,
				"agents/check-tool-safety",
				{ tool_id: t, tool_input_json: r },
				(s) => this.convertToCheckToolSafetyResult(s),
				i.chat.url,
				12e4,
			)
		}
		convertToRunRemoteToolResult(t) {
			return {
				toolOutput: t.tool_output,
				toolResultMessage: t.tool_result_message,
				status: t.status,
			}
		}
		async runRemoteTool(t, r, n, i, s, o) {
			let a = this._configListener.config,
				l = {}
			if (s)
				if (i === Li.Jira || i === Li.Confluence) {
					let c = s
					l = {
						extra_tool_input: {
							atlassian_tool_extra_input: {
								server_url: c.serverUrl,
								personal_api_token: c.personalApiToken,
								username: c.username,
							},
						},
					}
				} else
					i === Li.Notion
						? (l = {
								extra_tool_input: {
									notion_tool_extra_input: { api_token: s.apiToken },
								},
							})
						: i === Li.Linear
							? (l = {
									extra_tool_input: {
										linear_tool_extra_input: { api_token: s.apiToken },
									},
								})
							: i === Li.GitHubApi &&
								(l = {
									extra_tool_input: {
										github_tool_extra_input: { api_token: s.apiToken },
									},
								})
			return await this.callApi(
				t,
				a,
				"agents/run-remote-tool",
				{ tool_name: r, tool_input_json: n, tool_id: i, ...l },
				(c) => this.convertToRunRemoteToolResult(c),
				a.chat.url,
				12e4,
				void 0,
				o,
			)
		}
		convertToRevokeToolAccessResult(t) {
			return { status: t.status }
		}
		async revokeToolAccess(t) {
			let r = this.createRequestId(),
				n = this._configListener.config
			return await this.callApi(
				r,
				n,
				"agents/revoke-tool-access",
				{ tool_id: t },
				(i) => this.convertToRevokeToolAccessResult(i),
				n.chat.url,
			)
		}
		reportError(t, r, n, i) {
			return Promise.reject(new Error("reportError should only be used via APIServerImplWithErrorReporting"))
		}
		async reportClientCompletionTimelines(t) {
			let r = this._configListener.config,
				n = this.createRequestId()
			await this.callApi(
				n,
				r,
				"/client-completion-timelines",
				{ timelines: t },
				void 0,
				void 0,
				e.defaultRequestTimeoutMs,
			)
		}
		async checkCommand(t, r, n) {
			let i = this._configListener.config,
				s = { command: t, output: r }
			return await this.callApi(n, i, "check_command", s, (o) => o, i.autofix.autofixUrl, 1e4)
		}
		async containErrors(t, r, n) {
			let i = this._configListener.config,
				s = { command: t, output: r }
			return await this.callApi(n, i, "contain_errors", s, (o) => o, i.autofix.autofixUrl, 1e4)
		}
		async createFixPlan(t, r, n, i, s) {
			let o = this._configListener.config,
				a = {
					output: { command: r, output: n },
					git_diff: t,
					edit_locations: i,
				}
			return await this.callApi(s, o, "create_fix_plan", a, (l) => l, o.autofix.autofixUrl, 3e4)
		}
		async applyFileFix(t, r, n) {
			let i = this._configListener.config,
				s = { file_fix: t, source_content: r }
			return await this.callApi(n, i, "apply_file_fix", s, (o) => o, i.autofix.autofixUrl, 3e4)
		}
		async autofixCheck(t) {
			let r = this._configListener.config,
				n = this.createRequestId()
			return await this.callApi(
				n,
				r,
				"/autofix/check",
				{ command: this.toAutofixCommandPayload(t) },
				(i) => this.convertToAutofixCheckResponse(i),
				r.autofix.autofixUrl,
				1e4,
			)
		}
		async autofixPlan(t, r, n, i) {
			let s = this._configListener.config,
				o = this.createRequestId()
			return await this.callApi(
				o,
				s,
				"/autofix/plan",
				{
					command: this.toAutofixCommandPayload(t),
					vcs_change: this.toVCSChangePayload(r),
					blobs: Ec(n),
					steering_history: (i || []).map((a) => ({
						request_message: a.requestMessage,
						summary: a.summary,
						replacements: a.replacements.map((l) => this.toBackTextReplacement(l)),
						request_id: a.requestId,
					})),
				},
				(a) => this.convertToAutofixPlanResponse(a),
				s.autofix.autofixUrl,
				6e4,
			)
		}
		async saveChat(t, r, n) {
			let i = this._configListener.config,
				s = this.createRequestId(),
				o = {
					conversation_id: t,
					chat: r.map((l) => ({
						request_message: l.request_message,
						response_text: l.response_text,
						request_id: l.request_id,
					})),
					title: n,
				}
			return await this.callApi(s, i, "/save-chat", o, (l) => l, i.chat.url, e.defaultRequestTimeoutMs)
		}
	},
	ik = class extends nW {
		constructor(t, r, n, i, s) {
			super(t, r, n, i, s)
		}
		async callApi(t, r, n, i, s = (f) => f, o, a, l, c, u) {
			let f = Date.now()
			try {
				return await super.callApi(t, r, n, i, s, o, a, l, c, u)
			} catch (p) {
				throw (await this.handleError(p, n, i, o ?? "", t, f), p)
			}
		}
		async handleError(t, r, n, i, s, o) {
			if (kr.isAPIErrorWithStatus(t, He.cancelled)) throw t
			let l = [
					{
						key: "body_length",
						value: `${JSON.stringify(n, (p, g) => (g === void 0 ? null : g)).length}`,
					},
					{ key: "start_time", value: `${o}` },
					{ key: "end_time", value: `${Date.now()}` },
					{ key: "message", value: Ye(t) },
				],
				c = t instanceof Error ? t.stack : void 0
			t instanceof kr &&
				t.status === He.augmentTooLarge &&
				l.push({ key: "object_size_breakdown", value: `${Ay(n)}` })
			let u = t instanceof kr ? t.status : He.unknown,
				f = `${r} call failed with APIStatus ${He[u]}`
			throw (
				(t instanceof nk && (f = `converting ${r} response failed`),
				i && this.getUniqueExtraURLs().has(i)
					? this._logger.error(`API error ${r} to ${i}: ${f}`)
					: await this.reportError(s, f, c ?? "", l),
				t)
			)
		}
		async callApiStream(t, r, n, i, s, o, a, l) {
			let c = Date.now()
			try {
				return await super.callApiStream(t, r, n, i, s, o, a, l)
			} catch (u) {
				throw (await this.handleError(u, n, i, o ?? "", t, c), u)
			}
		}
		async reportError(t, r, n, i) {
			let s = this._configListener.config,
				o = this.createRequestId(),
				a = n.replace(/ \(\/[^()]+\)/g, "")
			try {
				return await super.callApi(
					o,
					s,
					"report-error",
					{
						original_request_id: t,
						sanitized_message: r,
						stack_trace: a,
						diagnostics: i,
					},
					void 0,
					void 0,
					500,
				)
			} catch (l) {
				this._logger.error(`Dropping error report "${r}" due to error: ${Ye(l)}`)
			}
		}
	},
	Yp = class extends Error {
		constructor() {
			super("The completion URL setting is invalid")
		}
	},
	iW = class {
		_sequenceId = 0
		next() {
			return this._sequenceId++
		}
	}
var qAe = W(gs()),
	bc = W(require("vscode"))
var Pct = { Augment: null },
	Lct = R.object({
		apiToken: R.string(),
		completionURL: R.string(),
		disableCompletionsByLanguage: R.array(R.string()),
		enableAutomaticCompletions: R.boolean(),
		completions: R.object({
			enableAutomaticCompletions: R.boolean(),
			disableCompletionsByLanguage: R.array(R.string()),
			enableQuickSuggestions: R.boolean(),
		}),
		shortcutsDisplayDelayMS: R.number(),
		enableEmptyFileHint: R.boolean(),
		conflictingCodingAssistantCheck: R.boolean(),
		chat: R.object({ userGuidelines: R.string() }),
		nextEdit: R.object({
			enableBackgroundSuggestions: R.boolean(),
			enableGlobalBackgroundSuggestions: R.boolean(),
			highlightSuggestionsInTheEditor: R.boolean(),
			showDiffInHover: R.boolean(),
			enableAutoApply: R.boolean(),
		}),
		advanced: R.object({
			apiToken: R.string(),
			completionURL: R.string(),
			oauth: R.object({ clientID: R.string(), url: R.string() }),
			model: R.string(),
			codeInstruction: R.object({ model: R.string() }),
			chat: R.object({
				url: R.string(),
				model: R.string(),
				stream: R.boolean(),
				enableEditableHistory: R.boolean(),
				useRichTextHistory: R.boolean(),
				smartPasteUsePrecomputation: R.boolean(),
				experimentalFullFilePaste: R.boolean(),
				modelDisplayNameToId: R.record(R.string().nullable()),
			}),
			autofix: R.object({
				enabled: R.boolean(),
				locationUrl: R.string(),
				autofixUrl: R.string(),
			}),
			enableDebugFeatures: R.boolean(),
			enableWorkspaceUpload: R.boolean(),
			enableReviewerWorkflows: R.boolean(),
			completions: R.object({
				timeoutMs: R.number(),
				maxWaitMs: R.number(),
				addIntelliSenseSuggestions: R.boolean(),
				filterThreshold: R.number(),
				filter_threshold: R.number(),
			}),
			openFileManager: R.object({ v2Enabled: R.boolean() }),
			enableDataCollection: R.boolean(),
			nextEditURL: R.string(),
			nextEditLocationURL: R.string(),
			nextEditGenerationURL: R.string(),
			nextEditBackgroundGeneration: R.boolean(),
			nextEdit: R.object({
				enabled: R.boolean(),
				backgroundEnabled: R.boolean(),
				url: R.string(),
				locationUrl: R.string(),
				generationUrl: R.string(),
				model: R.string(),
				useDebounceMs: R.number(),
				useCursorDecorations: R.boolean(),
				allowDuringDebugging: R.boolean(),
				useMockResults: R.boolean(),
				noDiffModeUseCodeLens: R.boolean(),
				enableGotoHinting: R.boolean(),
				enableBottomPanel: R.boolean(),
			}),
			recencySignalManager: R.object({ collectTabSwitchEvents: R.boolean() }),
			preferenceCollection: R.object({
				enable: R.boolean(),
				enableRetrievalDataCollection: R.boolean(),
				enableRandomizedMode: R.boolean(),
			}),
			vcs: R.object({ watcherEnabled: R.boolean() }),
			smartPaste: R.object({ url: R.string(), model: R.string() }),
			instructions: R.object({ model: R.string() }),
			integrations: R.object({
				atlassian: R.object({
					serverUrl: R.string(),
					personalApiToken: R.string(),
					username: R.string(),
				}),
				notion: R.object({ apiToken: R.string() }),
				linear: R.object({ apiToken: R.string() }),
				github: R.object({ apiToken: R.string() }),
			}),
			mcpServers: R.array(
				R.object({
					command: R.string(),
					args: R.array(R.string()),
					timeoutMs: R.number(),
					env: R.record(R.string()),
				}),
			),
			agent: R.object({
				shellCommandsAlwaysSafe: R.boolean(),
				useIDETerminalForShellCommands: R.boolean(),
				disableRetrievalTool: R.boolean(),
			}),
			remoteAgent: R.object({ url: R.string(), apiToken: R.string() }),
		}),
	}),
	UAe = Lct.deepPartial(),
	sk = class e extends z {
		_config
		_configChanged = new bc.EventEmitter()
		_configMonitor
		_logger = X("AugmentConfigListener")
		constructor() {
			super(),
				(this._configMonitor = new gy("Config", this._logger)),
				this._refreshConfig(),
				this.addDisposable(bc.workspace.onDidChangeConfiguration(() => this._refreshConfig()))
		}
		get config() {
			return this._config
		}
		get onDidChange() {
			return this._configChanged.event
		}
		_refreshConfig() {
			let t = this._config
			;(this._config = e.normalizeConfig(this._getRawSettings())),
				this._configMonitor.update(this._config) &&
					this._configChanged.fire({
						previousConfig: t,
						newConfig: this._config,
					})
		}
		static normalizeConfig(t) {
			return {
				apiToken: (t?.advanced?.apiToken ?? t.apiToken ?? "").trim().toUpperCase(),
				completionURL: (t?.advanced?.completionURL ?? t.completionURL ?? "").trim(),
				modelName: t?.advanced?.model ?? "",
				conflictingCodingAssistantCheck: t.conflictingCodingAssistantCheck ?? !0,
				codeInstruction: { model: t.advanced?.codeInstruction?.model },
				chat: {
					url: t.advanced?.chat?.url,
					model: t.advanced?.chat?.model,
					stream: t.advanced?.chat?.stream,
					enableEditableHistory: t.advanced?.chat?.enableEditableHistory ?? !1,
					useRichTextHistory: t.advanced?.chat?.useRichTextHistory ?? !0,
					smartPasteUsePrecomputation: t.advanced?.chat?.smartPasteUsePrecomputation ?? !0,
					experimentalFullFilePaste: t.advanced?.chat?.experimentalFullFilePaste ?? !1,
					modelDisplayNameToId: t.advanced?.chat?.modelDisplayNameToId ?? Pct,
					userGuidelines: t.chat?.userGuidelines || "",
				},
				autofix: {
					enabled: t.advanced?.autofix?.enabled ?? !1,
					locationUrl: t.advanced?.autofix?.locationUrl,
					autofixUrl: t.advanced?.autofix?.autofixUrl,
				},
				oauth: {
					clientID: t.advanced?.oauth?.clientID ?? "augment-vscode-extension",
					url: t.advanced?.oauth?.url ?? "https://auth.augmentcode.com",
				},
				enableUpload: t.advanced?.enableWorkspaceUpload ?? !0,
				shortcutsDisplayDelayMS: t.shortcutsDisplayDelayMS ?? 2e3,
				enableEmptyFileHint: t.enableEmptyFileHint ?? !0,
				enableDataCollection: t.advanced?.enableDataCollection ?? !1,
				enableDebugFeatures: t.advanced?.enableDebugFeatures ?? !1,
				enableReviewerWorkflows: t.advanced?.enableReviewerWorkflows ?? !1,
				completions: {
					enableAutomaticCompletions:
						t.enableAutomaticCompletions ?? t.completions?.enableAutomaticCompletions ?? !0,
					disableCompletionsByLanguage: new Set(
						t.disableCompletionsByLanguage ?? t.completions?.disableCompletionsByLanguage ?? [],
					),
					enableQuickSuggestions: t.completions?.enableQuickSuggestions ?? !0,
					timeoutMs: t.advanced?.completions?.timeoutMs ?? 800,
					maxWaitMs: t.advanced?.completions?.maxWaitMs ?? 1600,
					addIntelliSenseSuggestions: t.advanced?.completions?.addIntelliSenseSuggestions ?? !0,
					filterThreshold: t.advanced?.completions?.filter_threshold,
				},
				openFileManager: {
					v2Enabled: t.advanced?.openFileManager?.v2Enabled ?? !1,
				},
				nextEdit: {
					enabled: t.advanced?.nextEdit?.enabled,
					backgroundEnabled: t.advanced?.nextEdit?.backgroundEnabled ?? !0,
					url: t.advanced?.nextEdit?.url,
					locationUrl: t.advanced?.nextEdit?.locationUrl ?? t.advanced?.nextEdit?.url,
					generationUrl: t.advanced?.nextEdit?.generationUrl ?? t.advanced?.nextEdit?.url,
					model: t.advanced?.nextEdit?.model,
					useDebounceMs: t.advanced?.nextEdit?.useDebounceMs,
					useCursorDecorations: t.advanced?.nextEdit?.useCursorDecorations ?? !1,
					allowDuringDebugging: t.advanced?.nextEdit?.allowDuringDebugging ?? !1,
					useMockResults: t.advanced?.nextEdit?.useMockResults ?? !1,
					noDiffModeUseCodeLens: t.advanced?.nextEdit?.noDiffModeUseCodeLens ?? !1,
					enableBackgroundSuggestions: t.nextEdit?.enableBackgroundSuggestions ?? !0,
					enableGlobalBackgroundSuggestions: t.nextEdit?.enableGlobalBackgroundSuggestions ?? !1,
					highlightSuggestionsInTheEditor: t.nextEdit?.highlightSuggestionsInTheEditor ?? !1,
					showDiffInHover: t.nextEdit?.showDiffInHover ?? !1,
					enableAutoApply: t.nextEdit?.enableAutoApply ?? !0,
					enableGotoHinting: t.advanced?.nextEdit?.enableGotoHinting ?? !1,
					enableBottomPanel: t.advanced?.nextEdit?.enableBottomPanel,
				},
				recencySignalManager: {
					collectTabSwitchEvents: t.advanced?.recencySignalManager?.collectTabSwitchEvents ?? !1,
				},
				preferenceCollection: {
					enable: t.advanced?.preferenceCollection?.enable ?? !1,
					enableRetrievalDataCollection:
						t.advanced?.preferenceCollection?.enableRetrievalDataCollection ?? !1,
					enableRandomizedMode: t.advanced?.preferenceCollection?.enableRandomizedMode ?? !0,
				},
				vcs: { watcherEnabled: t.advanced?.vcs?.watcherEnabled ?? !1 },
				smartPaste: {
					url: t.advanced?.smartPaste?.url,
					model: t.advanced?.smartPaste?.model,
				},
				instructions: { model: t.advanced?.instructions?.model },
				integrations: {
					atlassian: t.advanced?.integrations?.atlassian
						? {
								serverUrl: t.advanced.integrations.atlassian.serverUrl || "",
								personalApiToken: t.advanced.integrations.atlassian.personalApiToken || "",
								username: t.advanced.integrations.atlassian.username || "",
							}
						: void 0,
					notion: t.advanced?.integrations?.notion
						? { apiToken: t.advanced.integrations.notion.apiToken || "" }
						: void 0,
					linear: t.advanced?.integrations?.linear
						? { apiToken: t.advanced.integrations.linear.apiToken || "" }
						: void 0,
					github: t.advanced?.integrations?.github
						? { apiToken: t.advanced.integrations.github.apiToken || "" }
						: void 0,
				},
				mcpServers: (t.advanced?.mcpServers ?? [])
					.filter((r) => r !== void 0)
					.map((r) => ({
						command: OAe(r.command || ""),
						args: r.args?.map((n) => OAe(n)),
						timeoutMs: r.timeoutMs,
						env: r.env,
					})),
				agent: {
					shellCommandsAlwaysSafe: t.advanced?.agent?.shellCommandsAlwaysSafe ?? !1,
					useIDETerminalForShellCommands: t.advanced?.agent?.useIDETerminalForShellCommands ?? !0,
					disableRetrievalTool: t.advanced?.agent?.disableRetrievalTool ?? !1,
				},
				remoteAgent: {
					url: t.advanced?.remoteAgent?.url,
					apiToken: t.advanced?.remoteAgent?.apiToken,
				},
			}
		}
		_getRawSettings() {
			let t = bc.workspace.getConfiguration("augment")
			return e.parseSettings(t)
		}
		async migrateLegacyConfig() {
			let t = bc.workspace.getConfiguration("augment")
			await this._moveConfig(t, "enableAutomaticCompletions", "completions.enableAutomaticCompletions"),
				await this._moveConfig(t, "disableCompletionsByLanguage", "completions.disableCompletionsByLanguage"),
				await this._moveConfig(t, "enableBackgroundSuggestions", "nextEdit.enableBackgroundSuggestions"),
				await this._moveConfig(
					t,
					"enableGlobalBackgroundSuggestions",
					"nextEdit.enableGlobalBackgroundSuggestions",
				),
				await this._moveConfig(t, "highlightSuggestionsInTheEditor", "nextEdit.highlightSuggestionsInTheEditor")
		}
		async _moveConfig(t, r, n) {
			let i = t.inspect(r)
			if (!i) return
			let s = t.inspect(n),
				o = [
					{
						target: bc.ConfigurationTarget.Workspace,
						oldValue: i.workspaceValue,
						newValue: s?.workspaceValue,
					},
					{
						target: bc.ConfigurationTarget.Global,
						oldValue: i.globalValue,
						newValue: s?.globalValue,
					},
				]
			for (let a of o)
				a.oldValue !== void 0 &&
					(a.newValue === void 0 && (await t.update(n, a.oldValue, a.target)),
					await t.update(r, void 0, a.target))
		}
		static parseSettings(t) {
			let r = X("AugmentConfigListener"),
				n = UAe.safeParse(t)
			if (!n.success) {
				let i = n.error.issues.map((l) => "[" + l.path.join(".") + "]: " + l.message)
				r.error(`Failed to parse settings: 
${i.join(`
`)}`)
				let s = n.error.issues.map((l) => l.path.join(".")),
					o = (0, qAe.omit)(JSON.parse(JSON.stringify(t)), s),
					a = UAe.safeParse(o)
				return a.success ? (r.info("settings parsed successfully after cleaning"), a.data) : {}
			}
			return r.info("settings parsed successfully"), n.data
		}
	}
function OAe(e) {
	let t = "${workspaceFolder}"
	if (!e.includes(t)) return e
	let r = bc.workspace.workspaceFolders?.length ?? 0
	r !== 1 &&
		X("AugmentConfigListener").warn(
			`Variable ${t} cannot be expanded because there are ${r} workspace folders open.`,
		)
	let n = bc.workspace.workspaceFolders?.[0]?.uri
	return n && (e = e.replaceAll(t, n.fsPath)), e
}
var ok = class extends z {
	constructor(r, n, i) {
		super()
		this._actionsModel = r
		this._authSession = n
		this._configListener = i
		this.addDisposable(
			this._authSession.onDidChangeSession(() => {
				this._updateSignInState()
			}),
		),
			this.addDisposable(
				this._authSession.onReady(() => {
					this._updateSignInState()
				}),
			),
			this.addDisposable(
				this._configListener.onDidChange(({ newConfig: s, previousConfig: o }) => {
					;(s.apiToken === o.apiToken && s.completionURL === o.completionURL) || this._updateSignInState()
				}),
			),
			this._updateSignInState()
	}
	_updateSignInState() {
		if (!this._authSession.useOAuth) {
			this._actionsModel.setSystemStateStatus("authenticated", "complete")
			return
		}
		if (this._authSession.isLoggedIn === void 0) return
		this._authSession.isLoggedIn === !1 &&
			this._configListener.config.enableDebugFeatures &&
			this._actionsModel.restartActionsState()
		let r = this._authSession.isLoggedIn ? "complete" : "incomplete"
		this._actionsModel.setSystemStateStatus("authenticated", r)
	}
}
var VAe = W(gs()),
	Mh = W(require("vscode"))
var vx = "augment.sessions",
	ak = ["email"],
	lk = class extends z {
		constructor(r, n) {
			super()
			this._context = r
			this._config = n
			this.addDisposables(
				this.onDidChangeSession((i) => {
					;(this._isLoggedIn = !!i),
						Mh.commands.executeCommand("setContext", "vscode-augment.isLoggedIn", this._isLoggedIn)
				}),
				this._context.secrets.onDidChange(async (i) => {
					i.key === vx && this._sessionChangeEmitter.fire(await this.getSession())
				}),
				this._config.onDidChange(() => {
					Mh.commands.executeCommand("setContext", "vscode-augment.useOAuth", this.useOAuth)
				}),
			),
				(this._ready = this.initState())
		}
		_sessionChangeEmitter = new Mh.EventEmitter()
		_readyEmitter = new Mh.EventEmitter()
		_isLoggedIn
		_ready
		get onDidChangeSession() {
			return this._sessionChangeEmitter.event
		}
		get onReady() {
			return this._readyEmitter.event
		}
		get useOAuth() {
			let r = this._config.config
			return !!r.oauth && !!r.oauth.url && !!r.oauth.clientID && !r.apiToken && !r.completionURL
		}
		async initState() {
			;(this._isLoggedIn = !!(await this.getSession())),
				Mh.commands.executeCommand("setContext", "vscode-augment.isLoggedIn", this._isLoggedIn),
				Mh.commands.executeCommand("setContext", "vscode-augment.useOAuth", this.useOAuth),
				this._readyEmitter.fire()
		}
		get isLoggedIn() {
			return this._isLoggedIn
		}
		async saveSession(r, n) {
			await this._context.secrets.store(vx, JSON.stringify({ accessToken: r, tenantURL: n, scopes: ak }))
		}
		async getSession() {
			let r = await this._context.secrets.get(vx)
			if (r) {
				let n = JSON.parse(r)
				if ((0, VAe.isEqual)(n.scopes, ak)) return n
			}
			return null
		}
		async removeSession() {
			;(await this._context.secrets.get(vx)) && (await this._context.secrets.delete(vx))
		}
	}
var vy = require("crypto"),
	fo = W(require("vscode"))
async function Iu(e) {
	return new Promise((t) => {
		let r = e((n) => {
			r.dispose(), t(n)
		})
	})
}
var ck = "augment.oauth-state",
	Uct = ".augmentcode.com",
	HAe = 10,
	uk = class {
		constructor(t, r, n, i, s) {
			this._context = t
			this._config = r
			this._apiServer = n
			this._authSession = i
			this._onboardingSessionEventReporter = s
			this.authRedirectURI = fo.Uri.from({
				scheme: fo.env.uriScheme,
				authority: this._context.extension.id,
				path: "/auth/result",
			})
		}
		_logger = X("OAuthFlow")
		_programmaticCancellation = new fo.EventEmitter()
		_previousLogin
		authRedirectURI
		doProgrammaticCancellation() {
			this._programmaticCancellation.fire("Cancelled by user")
		}
		async startFlow(t = !0) {
			try {
				this._programmaticCancellation.fire("Cancelled due to new sign in"),
					await Promise.allSettled([this._previousLogin]),
					this._logger.info("Creating new session...")
				let r
				t ? (r = await this.loginWithProgress()) : (r = await this.loginWithoutProgress()),
					this._logger.info(`Created session ${r.tenantURL}`),
					this._onboardingSessionEventReporter.reportEvent("signed-in")
			} catch (r) {
				throw (fo.window.showErrorMessage(`Sign in failed. ${Ye(r)}`), r)
			}
		}
		async createOAuthState() {
			let t = WAe((0, vy.randomBytes)(32)),
				r = WAe(Oct(Buffer.from(t))),
				n = (0, vy.randomUUID)(),
				i = {
					codeVerifier: t,
					codeChallenge: r,
					state: n,
					creationTime: new Date().getTime(),
				}
			return await this._context.secrets.store(ck, JSON.stringify(i)), i
		}
		async getOAuthState() {
			let t = await this._context.secrets.get(ck)
			if (t) {
				let r = JSON.parse(t)
				if (new Date().getTime() - r.creationTime < HAe * 60 * 1e3) return r
			}
			return null
		}
		async removeOAuthState() {
			;(await this._context.secrets.get(ck)) && (await this._context.secrets.delete(ck))
		}
		async loginWithoutProgress() {
			let t = new fo.CancellationTokenSource()
			return this.login(t.token)
		}
		async loginWithProgress() {
			let t = {
					location: fo.ProgressLocation.Notification,
					title: "Signing in...",
					cancellable: !0,
				},
				r = (n, i) => ((this._previousLogin = this.login(i)), this._previousLogin)
			return fo.window.withProgress(t, r)
		}
		async login(t) {
			if (!this._config.config.oauth.url) throw new Error("No OAuth URL defined.")
			let r = [
				this.waitForSessionChange(),
				new Promise((n, i) => setTimeout(() => i("Timed out"), HAe * 60 * 1e3)),
				this.waitForProgrammaticCancellation(),
				this.waitForCancellation(t, "User cancelled"),
			]
			try {
				let n = await this.createOAuthState()
				return await this.openBrowser(n), await Promise.race(r)
			} finally {
				await this.removeOAuthState()
			}
		}
		async openBrowser(t) {
			let r = ak.join(" "),
				n = new URLSearchParams({
					response_type: "code",
					code_challenge: t.codeChallenge,
					code_challenge_method: "S256",
					client_id: this._config.config.oauth.clientID || "",
					redirect_uri: this.authRedirectURI.toString(),
					state: t.state,
					scope: r,
					prompt: "login",
				}),
				i = new URL(`/authorize?${n.toString()}`, this._config.config.oauth.url),
				s = fo.Uri.parse(i.toString())
			await fo.env.openExternal(s)
		}
		async waitForSessionChange() {
			let t = await Iu(this._authSession.onDidChangeSession)
			if (!t) throw new Error("No session")
			return t
		}
		async waitForProgrammaticCancellation() {
			let t = await Iu(this._programmaticCancellation.event)
			throw new Error(t)
		}
		async waitForCancellation(t, r) {
			throw (await Iu(t.onCancellationRequested), new Error(r))
		}
		async processAuthRedirect(t) {
			let r = new URLSearchParams(t.query),
				n = r.get("state")
			if (!n) throw new Error("No state")
			let i = await this.getOAuthState()
			if (!i) throw new Error("No OAuth state found")
			if ((await this.removeOAuthState(), i.state !== n)) throw new Error("Unknown state")
			let s = r.get("error")
			if (s) {
				let l = [`(${s})`],
					c = r.get("error_description")
				throw (c && l.push(c), new Error(`OAuth request failed: ${l.join(" ")}`))
			}
			let o = r.get("code")
			if (!o) throw new Error("No code")
			let a = r.get("tenant_url")
			if (a) {
				if (!new URL(a).hostname.endsWith(Uct))
					throw new Error("OAuth request failed: invalid OAuth tenant URL")
			} else throw new Error("No tenant URL")
			try {
				let l = await this._apiServer.getAccessToken(this.authRedirectURI.toString(), a, i.codeVerifier, o)
				await this._authSession.saveSession(l, a)
			} catch (l) {
				throw (
					(this._logger.error(`Failed to get and save access token: ${Ye(l)}`),
					new Error(`If you have a firewall, please add "${a}" to your allowlist.`))
				)
			}
		}
		async handleAuthURI(t) {
			try {
				await this.processAuthRedirect(t)
			} catch (r) {
				this._logger.warn("Failed to process auth request:", r), this._programmaticCancellation.fire(Ye(r))
			}
		}
	}
function WAe(e) {
	return e.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
}
function Oct(e) {
	return (0, vy.createHash)("sha256").update(e).digest()
}
function qct(e) {
	return e === void 0
		? { num_lines: -1, num_chars: -1 }
		: {
				num_lines: e.split(`
`).length,
				num_chars: e.length,
			}
}
var dk = class {
		tracingData = { flags: {}, nums: {}, string_stats: {}, request_ids: {} }
		setFlag(t, r = !0) {
			this.tracingData.flags[t] = {
				value: r,
				timestamp: new Date().toISOString(),
			}
		}
		setNum(t, r) {
			this.tracingData.nums[t] = {
				value: r,
				timestamp: new Date().toISOString(),
			}
		}
		setStringStats(t, r) {
			this.tracingData.string_stats[t] = {
				value: qct(r),
				timestamp: new Date().toISOString(),
			}
		}
		setRequestId(t, r) {
			this.tracingData.request_ids[t] = {
				value: r,
				timestamp: new Date().toISOString(),
			}
		}
	},
	fk
;(function (e) {
	;(e[(e.unspecified = 0)] = "unspecified"),
		(e[(e.classify_and_distill = 1)] = "classify_and_distill"),
		(e[(e.orientation = 2)] = "orientation")
})(fk || (fk = {}))
var Wr
;(function (e) {
	;(e.memoriesRequestId = "memoriesRequestId"),
		(e.exceptionThrown = "exceptionThrown"),
		(e.toolOutputIsError = "toolOutputIsError"),
		(e.injectionNoCodeWrapper = "injectionNoCodeWrapper"),
		(e.rememberToolModelNameMissing = "rememberToolModelNameMissing"),
		(e.compressionStarted = "compressionStarted"),
		(e.compressionTargetMissing = "compressionTargetMissing"),
		(e.compressionPromptMissing = "compressionPromptMissing"),
		(e.compressionNumRecentMemoriesToKeepMissing = "compressionNumRecentMemoriesToKeepMissing"),
		(e.compressionRecentMemoriesSubpromptMissing = "compressionRecentMemoriesSubpromptMissing"),
		(e.compressionMemoriesQueueSize = "compressionMemoriesQueueSize"),
		(e.compressionPromptStats = "compressionPromptStats"),
		(e.compressionRequestId = "compressionRequestId"),
		(e.compressionMemoriesStats = "compressedMemoriesStats"),
		(e.compressionFailed = "compressionFailed"),
		(e.setMemoriesStart = "setMemoriesStart"),
		(e.setMemoriesUpperBoundSizeMissing = "setMemoriesUpperBoundSizeMissing"),
		(e.setMemoriesNonEmptyLines = "nonEmptyLines"),
		(e.setMemoriesNoMemoriesFile = "noMemoriesFile"),
		(e.setMemoriesUpdateBufferFailed = "updateBufferFailed"),
		(e.setMemoriesNoChangesMade = "noChangesMade"),
		(e.injectionStarted = "injectionStarted"),
		(e.injectionCurrentMemoriesStats = "injectionCurrentMemoriesStats"),
		(e.injectionPromptMissing = "injectionPromptMissing"),
		(e.injectionPromptStats = "injectionPromptStats"),
		(e.injectionRequestId = "injectionRequestId"),
		(e.injectionUpdatedMemoriesStats = "injectionUpdatedMemoriesStats"),
		(e.injectionFailed = "injectionFailed")
})(Wr || (Wr = {}))
var hk = class e extends dk {
		caller
		is_complex_new_memory
		constructor(t, r) {
			super(), (this.caller = t), (this.is_complex_new_memory = r)
		}
		static create(t, r) {
			return new e(t, r)
		}
	},
	GAe
;(function (e) {
	;(e.start = "start"),
		(e.end = "end"),
		(e.memoriesRequestId = "memoriesRequestId"),
		(e.exceptionThrown = "exceptionThrown"),
		(e.lastUserExchangeRequestId = "lastUserExchangeRequestId"),
		(e.noMemoryData = "noMemoryData"),
		(e.agenticTurnHasRememberToolCall = "agenticTurnHasRememberToolCall"),
		(e.emptyMemory = "emptyMemory"),
		(e.removeUserExchangeMemoryFailed = "removeUserExchangeMemoryFailed")
})(GAe || (GAe = {}))
var Is
;(function (e) {
	;(e.openedAgentConversation = "opened-agent-conversation"),
		(e.revertCheckpoint = "revert-checkpoint"),
		(e.agentInterruption = "agent-interruption"),
		(e.sentUserMessage = "sent-user-message"),
		(e.rememberToolCall = "remember-tool-call"),
		(e.openedMemoriesFile = "opened-memories-file"),
		(e.initialOrientation = "initial-orientation"),
		(e.classifyAndDistill = "classify-and-distill"),
		(e.flushMemories = "flush-memories"),
		(e.vsCodeTerminalShellIntegrationNotAvailable = "vs-code-terminal-shell-integration-not-available"),
		(e.vsCodeTerminalReadingApproximateOutput = "vs-code-terminal-reading-approximate-output"),
		(e.vsCodeTerminalTimedOutWaitingForNoopCommand = "vs-code-terminal-timed-out-waiting-for-noop-command"),
		(e.vsCodeTerminalFailedToUseShellIntegration = "vs-code-terminal-failed-to-use-shell-integration"),
		(e.vsCodeTerminalLastCommandIsSameAsCurrent = "vs-code-terminal-last-command-is-same-as-current"),
		(e.vsCodeTerminalPollingDeterminedProcessIsDone = "vs-code-terminal-polling-determined-process-is-done"),
		(e.vsCodeTerminalFailedToReadOutput = "vs-code-terminal-failed-to-read-output"),
		(e.vsCodeTerminalBuggyOutput = "vs-code-terminal-buggy-output")
})(Is || (Is = {}))
var $Ae
;(function (e) {
	e.sentUserMessage = "sent-user-message"
})($Ae || ($Ae = {}))
var Ey
;(function (e) {
	;(e[(e.unspecified = 0)] = "unspecified"), (e[(e.onboarding = 1)] = "onboarding"), (e[(e.command = 2)] = "command")
})(Ey || (Ey = {}))
var Cr
;(function (e) {
	;(e.exceptionThrown = "exceptionThrown"),
		(e.start = "start"),
		(e.end = "end"),
		(e.concurrencyLevelMissing = "concurrencyLevelMissing"),
		(e.initialOrientationDisabled = "initialOrientationDisabled"),
		(e.noRootFolderFound = "noRootFolderFound"),
		(e.retryWithLowerConcurrencyLevel = "retryWithLowerConcurrencyLevel"),
		(e.localizationPromptMissing = "localizationPromptMissing"),
		(e.detectLanguagesPromptMissing = "detectLanguagesPromptMissing"),
		(e.orientationCompressionPromptMissing = "orientationCompressionPromptMissing"),
		(e.orientationMaxLanguagesMissing = "orientationMaxLanguagesMissing"),
		(e.orientationBuildTestQueryMissing = "orientationBuildTestQueryMissing"),
		(e.orientationModelNameMissing = "orientationModelNameMissing"),
		(e.topLanguagesNumFiles = "topLanguagesNumFiles"),
		(e.topLanguagesRequestId = "topLanguagesRequestId"),
		(e.topLanguagesModelResponseStats = "topLanguagesModelResponseStats"),
		(e.topLanguagesNumDetectedLanguages = "topLanguagesNumDetectedLanguages"),
		(e.topLanguagesNumFinalLanguages = "topLanguagesNumFinalLanguages"),
		(e.localizationStarted = "localizationStarted"),
		(e.localizationEnded = "localizationEnded"),
		(e.localizationPromptStats_0 = "localizationPromptStats_0"),
		(e.localizationPromptStats_1 = "localizationPromptStats_1"),
		(e.localizationPromptStats_2 = "localizationPromptStats_2"),
		(e.localizationPromptStats_3 = "localizationPromptStats_3"),
		(e.localizationPromptStats_4 = "localizationPromptStats_4"),
		(e.localizationPromptStats_5 = "localizationPromptStats_5"),
		(e.localizationRequestId_0 = "localizationRequestId_0"),
		(e.localizationRequestId_1 = "localizationRequestId_1"),
		(e.localizationRequestId_2 = "localizationRequestId_2"),
		(e.localizationRequestId_3 = "localizationRequestId_3"),
		(e.localizationRequestId_4 = "localizationRequestId_4"),
		(e.localizationRequestId_5 = "localizationRequestId_5"),
		(e.localizationResponseStats_0 = "localizationResponseStats_0"),
		(e.localizationResponseStats_1 = "localizationResponseStats_1"),
		(e.localizationResponseStats_2 = "localizationResponseStats_2"),
		(e.localizationResponseStats_3 = "localizationResponseStats_3"),
		(e.localizationResponseStats_4 = "localizationResponseStats_4"),
		(e.localizationResponseStats_5 = "localizationResponseStats_5"),
		(e.localizationParsingFailed_0 = "localizationParsingFailed_0"),
		(e.localizationParsingFailed_1 = "localizationParsingFailed_1"),
		(e.localizationParsingFailed_2 = "localizationParsingFailed_2"),
		(e.localizationParsingFailed_3 = "localizationParsingFailed_3"),
		(e.localizationParsingFailed_4 = "localizationParsingFailed_4"),
		(e.localizationParsingFailed_5 = "localizationParsingFailed_5"),
		(e.localizationNumLocations_0 = "localizationNumLocations_0"),
		(e.localizationNumLocations_1 = "localizationNumLocations_1"),
		(e.localizationNumLocations_2 = "localizationNumLocations_2"),
		(e.localizationNumLocations_3 = "localizationNumLocations_3"),
		(e.localizationNumLocations_4 = "localizationNumLocations_4"),
		(e.localizationNumLocations_5 = "localizationNumLocations_5"),
		(e.failedToListRootFolder = "failedToListRootFolder"),
		(e.agenticStarted = "agenticStarted"),
		(e.agenticEnded = "agenticEnded"),
		(e.agenticNumTurns_0 = "agenticNumTurns_0"),
		(e.agenticNumTurns_1 = "agenticNumTurns_1"),
		(e.agenticNumTurns_2 = "agenticNumTurns_2"),
		(e.agenticNumTurns_3 = "agenticNumTurns_3"),
		(e.agenticNumTurns_4 = "agenticNumTurns_4"),
		(e.agenticNumTurns_5 = "agenticNumTurns_5"),
		(e.agenticModelResponseStats_0 = "agenticModelResponseStats_0"),
		(e.agenticModelResponseStats_1 = "agenticModelResponseStats_1"),
		(e.agenticModelResponseStats_2 = "agenticModelResponseStats_2"),
		(e.agenticModelResponseStats_3 = "agenticModelResponseStats_3"),
		(e.agenticModelResponseStats_4 = "agenticModelResponseStats_4"),
		(e.agenticModelResponseStats_5 = "agenticModelResponseStats_5"),
		(e.agenticFailedToComplete_0 = "agenticFailedToComplete_0"),
		(e.agenticFailedToComplete_1 = "agenticFailedToComplete_1"),
		(e.agenticFailedToComplete_2 = "agenticFailedToComplete_2"),
		(e.agenticFailedToComplete_3 = "agenticFailedToComplete_3"),
		(e.agenticFailedToComplete_4 = "agenticFailedToComplete_4"),
		(e.agenticFailedToComplete_5 = "agenticFailedToComplete_5"),
		(e.agenticModelResponseStats = "agenticModelResponseStats"),
		(e.compressionRequestId = "compressionRequestId"),
		(e.compressionModelResponseStats = "compressionModelResponseStats"),
		(e.compressionParsingFailed = "compressionParsingFailed"),
		(e.rememberStarted = "rememberStarted"),
		(e.rememberEnded = "rememberEnded"),
		(e.failedToReadGuidelines = "failedToReadGuidelines"),
		(e.failedToWriteGuidelines = "failedToWriteGuidelines")
})(Cr || (Cr = {}))
var gk = class e extends dk {
		caller
		constructor(t) {
			super(), (this.caller = t)
		}
		static create(t) {
			return new e(t)
		}
	},
	YAe
;(function (e) {
	;(e.memoriesRequestId = "memoriesRequestId"),
		(e.exceptionThrown = "exceptionThrown"),
		(e.start = "start"),
		(e.end = "end"),
		(e.noPendingUserMessage = "noPendingUserMessage"),
		(e.startSendSilentExchange = "startSendSilentExchange"),
		(e.sendSilentExchangeRequestId = "sendSilentExchangeRequestId"),
		(e.sendSilentExchangeResponseStats = "sendSilentExchangeResponseStats"),
		(e.noRequestId = "noRequestId"),
		(e.conversationChanged = "conversationChanged"),
		(e.explanationStats = "explanationStats"),
		(e.contentStats = "contentStats"),
		(e.invalidResponse = "invalidResponse"),
		(e.worthRemembering = "worthRemembering"),
		(e.lastUserExchangeRequestId = "lastUserExchangeRequestId"),
		(e.noLastUserExchangeRequestId = "noLastUserExchangeRequestId")
})(YAe || (YAe = {}))
async function Kp(e, t, r, n, i, s, o) {
	return await Rf().chatStream(e, t, r, n, i, s, o)
}
var mme = W(ZAe()),
	pW = W(rme()),
	Sx = W(require("path")),
	Gn = W(require("vscode"))
var _y = W(require("vscode"))
var nme = W(require("crypto")),
	by = W(require("fs")),
	ai = W(require("fs/promises"))
function ime(e) {
	return e.isFile() ? "File" : e.isDirectory() ? "Directory" : "Other"
}
function aut(e) {
	return e.isFile() ? "File" : e.isDirectory() ? "Directory" : "Other"
}
function sme(e) {
	return { size: e.size, type: aut(e), mtime: Math.floor(e.mtimeMs) }
}
async function xy(e) {
	let t = await ai.lstat(e)
	return sme(t)
}
async function ome(e) {
	try {
		return await ai.access(e), !0
	} catch {
		return !1
	}
}
function Pn(e) {
	try {
		return Fh(e).type === "File"
	} catch {
		return !1
	}
}
async function $d(e) {
	try {
		return (await ai.stat(e)).isDirectory()
	} catch {
		return !1
	}
}
function Fh(e) {
	let t = by.lstatSync(e)
	return sme(t)
}
async function Ex(e) {
	let t = [],
		r = await ai.readdir(e, { withFileTypes: !0 })
	for (let n of r) t.push([n.name, ime(n)])
	return t
}
function bx(e) {
	let t = [],
		r = by.readdirSync(e, { withFileTypes: !0 })
	for (let n of r) t.push([n.name, ime(n)])
	return t
}
async function Su(e) {
	await ai.mkdir(e, { recursive: !0 })
}
async function cW(e, t) {
	await ai.rename(e, t)
}
async function Ak(e) {
	return await ai.readFile(e)
}
async function ame(e, t) {
	let r = `${e}.${nme.randomBytes(8).toString("hex")}.tmp`
	try {
		await ai.writeFile(r, t), await ai.rename(r, e)
	} catch (n) {
		throw (await ai.unlink(r), n)
	}
}
async function Fr(e) {
	return await ai.readFile(e, { encoding: "utf8" })
}
async function Bu(e, t) {
	return await ai.writeFile(e, t, { encoding: "utf8" })
}
function lme(e, t) {
	return by.writeFileSync(e, t, { encoding: "utf8" })
}
async function cme(e) {
	return await ai.unlink(e)
}
function xc(e, t) {
	_y.commands.executeCommand("setContext", e, t)
}
var mk = class e {
	constructor(t) {
		this._extensionContext = t
	}
	static storageSubDir = "augment-global-state"
	update(t, r) {
		return this._extensionContext.globalState.update(t, r)
	}
	get(t) {
		return this._extensionContext.globalState.get(t)
	}
	async save(t, r, n) {
		await this._ensureStorageUriExists(n)
		let i = this._getFileUri(t, n)
		return await Bu(i.fsPath, JSON.stringify(r))
	}
	async load(t, r) {
		await this._ensureStorageUriExists(r)
		let n = this._getFileUri(t, r)
		try {
			let i = await Fr(n.fsPath)
			return JSON.parse(i)
		} catch {
			return
		}
	}
	async _ensureStorageUriExists(t) {
		let r = this._getStorageUri(t)
		;(await $d(r.fsPath)) || (await Su(r.fsPath))
	}
	_getStorageUri(t) {
		return t?.uniquePerWorkspace && this._extensionContext.storageUri
			? _y.Uri.joinPath(this._extensionContext.storageUri, e.storageSubDir)
			: _y.Uri.joinPath(this._extensionContext.globalStorageUri, e.storageSubDir)
	}
	_getFileUri(t, r) {
		return _y.Uri.joinPath(this._getStorageUri(r), `${t}.json`)
	}
}
var Ix = W(require("vscode"))
var In = W(require("path")),
	uW = W(require("vscode"))
var xx = In.posix.sep,
	cut = new RegExp("/\\/g")
function Qh(e) {
	return In.isAbsolute(e)
}
function uut(e) {
	return In.sep === "\\" ? e.replace(cut, xx) : e
}
function ume(e) {
	return uut(e)
}
function _x(e) {
	return e.with({ path: In.dirname(e.fsPath) })
}
function dme(e) {
	return In.basename(e)
}
function _c(e) {
	let t = In.dirname(e)
	return t === "." ? "" : dut(t)
}
function dut(e) {
	return e.endsWith(xx) ? e : e + xx
}
function wy(e) {
	for (;;) {
		if (e === In.sep || e === xx || (!e.endsWith(xx) && !e.endsWith(In.sep))) return e
		e = e.slice(0, -1)
	}
}
function vl(e, t) {
	let r = typeof e == "string" ? e : e.fsPath,
		n = typeof t == "string" ? t : t.fsPath
	return In.relative(r, n)
}
function Yd(e, t) {
	let r = vl(e, t)
	return r === "." ? "" : r.length > 0 && !r.endsWith(In.sep) ? r + In.sep : r
}
function Nh(e, t) {
	let r = vl(e, t)
	if (!(r === ".." || r.startsWith(".." + In.sep) || r.startsWith(".." + In.posix.sep))) return r
}
function Ss(e, t) {
	return Nh(e, t) !== void 0
}
function Iy(e, t) {
	let r = vl(e, t)
	return r === "" || r === "." || r === "." + In.sep || r === "." + In.posix.sep
}
function dW(e) {
	if (In.isAbsolute(e)) throw new Error(`splitPath: ${e} must be a relative path`)
	let t = e,
		r = new Array()
	for (let n = 0; t.length > 0; n++) {
		if (n > 1e4) throw new Error(`Too-deep or malformed path name ${e}`)
		let i = In.basename(t)
		i !== "." && r.push(i)
		let s = _c(t)
		if (s === t || s === ".") break
		t = s
	}
	return r.reverse()
}
async function yk(e, t, r) {
	let n = typeof e == "string" ? uW.Uri.file(e) : e
	for (;;) {
		try {
			let s = uW.Uri.joinPath(n, t),
				o = await xy(s.fsPath)
			if (r === void 0 || o.type === r) return n
		} catch {}
		let i = In.dirname(n.fsPath)
		if (In.relative(i, n.fsPath).length === 0) return
		n = n.with({ path: i })
	}
}
var hme = require("util"),
	wc = W(require("vscode")),
	wx = class {
		constructor(t) {
			this.doc = t
		}
		get eol() {
			return this.doc.eol
		}
		get lineCount() {
			return this.doc.lineCount
		}
		getText(t) {
			return this.doc.getText(t)
		}
		offsetAt(t) {
			return this.doc.offsetAt(t)
		}
		positionAt(t) {
			return this.doc.positionAt(t)
		}
		validateRange(t) {
			return this.doc.validateRange(t)
		}
		validatePosition(t) {
			return this.doc.validatePosition(t)
		}
		getWordRangeAtPosition(t, r) {
			return this.doc.getWordRangeAtPosition(t, r)
		}
		lineAt(t) {
			return typeof t == "number" ? this.doc.lineAt(t) : this.doc.lineAt(t)
		}
	},
	gme = "quiet-background-file",
	fW = !1
function pme() {
	let e = wc.workspace.registerTextDocumentContentProvider(gme, {
		async provideTextDocumentContent(t) {
			return wc.workspace.fs
				.readFile(t.with({ scheme: "file" }))
				.then((r) => new hme.TextDecoder("utf-8").decode(r))
		},
	})
	return (
		(fW = !0),
		new wc.Disposable(() => {
			;(fW = !1), e.dispose()
		})
	)
}
async function ho(e) {
	let t
	if ((typeof e == "string" ? (t = wc.Uri.file(e)) : (t = e), !fW || t.scheme !== "file"))
		return wc.workspace.openTextDocument(t)
	let r = t.toString()
	for (let n of wc.workspace.textDocuments) if (n.uri.scheme === t.scheme && n.uri.toString() === r) return new wx(n)
	return new Promise((n, i) => {
		let s = wc.workspace.onDidOpenTextDocument((o) => {
			o.uri.scheme === t.scheme && o.uri.toString() === r && (s.dispose(), n(new wx(o)))
		})
		wc.workspace.openTextDocument(t.with({ scheme: gme })).then(
			(o) => {
				s.dispose(), n(new wx(o))
			},
			(o) => {
				s.dispose(), i(o)
			},
		)
	})
}
function Kd(e) {
	let t
	if (Ix.window.activeTextEditor) {
		let r = Ix.window.activeTextEditor.document.uri.fsPath
		t = e.getFolderRoot(r)
	}
	return (
		t === void 0 &&
			((t = e.getMostRecentlyChangedFolderRoot()),
			t === void 0 && (t = Ix.workspace.workspaceFolders?.[0]?.uri.fsPath)),
		t
	)
}
function Du(e, t) {
	if (Qh(e)) {
		let i = t.getFolderRoot(e)
		return i === void 0 ? void 0 : new Je(i, vl(i, e))
	}
	let r = t.findBestWorkspaceRootMatch(e)
	if (r) {
		let i = r.qualifiedPathName.rootPath
		return new Je(i, e)
	}
	let n = Kd(t)
	if (n) return new Je(n, e)
}
async function Sy(e, t) {
	let r = Du(e, t)?.absPath
	if (r !== void 0)
		try {
			return (await ho(r)).getText()
		} catch {
			return
		}
}
async function Ame(e, t) {
	let r = Du(e, t)?.absPath
	if (r !== void 0)
		try {
			return (await Ex(r)).map(([i, s]) => i)
		} catch {
			return
		}
}
async function vk(e) {
	let t = e()
	return !t || !Pn(t) ? void 0 : (await Fr(t)).replace(/^\s+/, "")
}
async function yme(e, t) {
	if (!e) return
	let r = Gn.Uri.joinPath(e, "Augment-Memories").fsPath,
		n = Gn.Uri.joinPath(e, "Agent-Memories").fsPath
	if (Pn(n))
		try {
			if (!Pn(r)) {
				let i = await Fr(n)
				if (i.trim() === "") return
				await Bu(r, i),
					await Gn.workspace.fs.delete(Gn.Uri.file(n)),
					t.info("Migrated memories from Agent-Memories to Augment-Memories")
			}
		} catch (i) {
			t.error("Error during memories migration:", i)
		}
}
var Bx = class {
		static gitConfigured(t, r) {
			let n = ""
			return (
				r ? (n = `You are inside git repo "${t}".`) : (n = `You are inside folder "${t}".`),
				`${n}

Instructions for you:
- Briefly, welcome user to the Augment. Be friendly, warm, and welcoming. And nice! Use \u{1F44B} when saying Hi
- Run \`git config user.name\` and \`git config user.email\`
- Briefly mention that you will use \`\u{1F4E6} Agent Memories\` to store personalized memories and improve experience
- Store user name and email using remember tool (don't specify git command used to query them)
- Run the "ls" command to look at current folder structure
- Run code retrieval to figure out what this repository is doing
- Briefly describe what this repo is doing high-level
- Ask user what they need help with
`
			)
		}
		static gitNotConfigured(t, r) {
			let n = ""
			return (
				r ? (n = `You are inside git repo "${t}".`) : (n = `You are inside folder "${t}".`),
				`${n}

Instructions for you:
- Briefly, welcome user to the Augment. Be friendly, warm, and welcoming. And nice! Use \u{1F44B} when saying Hi
- Run the "ls" command to look at current folder structure
- Run code retrieval to figure out what this repository is doing
- Briefly describe what this repo is doing high-level
- Ask user what they need help with
`
			)
		}
		static default() {
			return `
Instructions for you:
- Briefly, welcome user to the Augment. Be friendly, warm, and welcoming. And nice! Use \u{1F44B} when saying Hi
- Run the "ls" command to look at current folder structure
- Ask user what they need help with
`
		}
	},
	Ck = class {
		constructor(t, r) {
			this.shellTool = t
			this.workspaceManager = r
		}
		timeoutMsec = 1e3
		async getOnboardingInstructions() {
			return (
				`System instructions (don't mention them to user):

Basic context:
- Assistant (you) is Augment, a coding agent that I (user) use for the first time
- Assistant (you) is tasked with welcoming and onboarding me to the agent
- Assistant (you) always keeps messages friendly, warm, and welcoming. And nice!

Complete the following instructions.
` + (await this._getOnboardingInstructions())
			)
		}
		async _getOnboardingInstructions() {
			try {
				let t = Kd(this.workspaceManager)
				if (t === void 0) throw new Error("Cannot determine current working directory")
				let [r, n] = await this._getUserNameAndEmail(),
					i = await this._isInsideGitRepo()
				return r === void 0 || n === void 0 ? Bx.gitNotConfigured(t, i) : Bx.gitConfigured(t, i)
			} catch {
				return Bx.default()
			}
		}
		async _isInsideGitRepo() {
			return (
				(
					await this.shellTool.call(
						{ command: "git rev-parse --is-inside-work-tree" },
						[],
						AbortSignal.timeout(this.timeoutMsec),
					)
				).text.replace(
					`
`,
					"",
				) === "true"
			)
		}
		async _getUserNameAndEmail() {
			let t = await this.shellTool.call(
					{ command: "git config user.name" },
					[],
					AbortSignal.timeout(this.timeoutMsec),
				),
				r = await this.shellTool.call(
					{ command: "git config user.email" },
					[],
					AbortSignal.timeout(this.timeoutMsec),
				)
			return t.isError || r.isError
				? [void 0, void 0]
				: [
						t.text.replace(
							`
`,
							"",
						),
						r.text.replace(
							`
`,
							"",
						),
					]
		}
	},
	fut = String.raw`
                     __  __                           _
                    |  \/  |                         (_)
                    | \  / | ___ _ __ ___   ___  _ __ _  ___  ___
                    | |\/| |/ _ \ '_ ' _ \ / _ \| '__| |/ _ \/ __|
                    | |  | |  __/ | | | | | (_) | |  | |  __/\__ \
                    |_|  |_|\___|_| |_| |_|\___/|_|  |_|\___||___/

 .+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.
( Memories help me remember useful details for future interactions.               )
 )                                                                               (
( During Agent sessions, I'll try to create useful Memories automatically.        )
 )Memories can be about your codebase, technologies or your personal preferences.(
(                                                                                 )
 )Your Memories belong to you and are stored locally at the bottom of this file; (
( in the future, we may give you an option to share your memories with others.    )
 )                                                                               (
( NOTE: Memories will be compressed when this file grows too large.               )
 )For personal Memories: consider putting them in User Guidelines (via '@' menu) (
( For repository-level Memories: consider using '.augment-guidelines' file        )
 )Neither will be compressed.                                                    (
(                                                                                 )
 )Happy Coding!                                                                  (
(                                                                                 )
 "+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"
                  ()
                O
              o
{AUGGIE_LOGO}

↓↓↓ MEMORIES START HERE ↓↓↓`,
	hut = [
		String.raw`
      .dKWMMMMMMMMMMMMMMWd                  dWMMMMMMMMMMMMMMWKd.
     :WMMW0OOOOOOOOOOOOOk:                  ckkkkkkkkkkkkkkKMMMW;
     OMMMl                                                  oMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:          .;cc,                   .;c:'           cMMMk
     OMMM:         dWMMMMN;                dMMMMMN,         :MMMO
    :WMMX.         KMMMMMMo                KMMMMMMo         .XMMN;
dOKNMW0o.          .dOKKkc                 .d0KKk:           .o0WMNKOo
:dxOWMNk'                                                    ,kNMWOxd:
    .NMMW.           .oxc                   cxo.            'WMMX.
     OMMM:           .OMMNo'             ,oXMWO.            cMMMk
     OMMM:             'xWMMNOdl::;::ldONMMNx'              cMMMk
     OMMM:                ,lx0XNWMMMWNX0xc,                 cMMMk
     OMMM:                       ...                        cMMMk
     OMMM:                                                  cMMMk
     kMMMx.                                                .xMMMk
     'KMMMWNNNNNNNNNNNNNXd                  dXNNNNNNNNNNNNNWMMMK.
       ;x0KKKKKKKKKKKKKK0;                  ;0KKKKKKKKKKKKKK0x;
`,
		`
      .dKWMMMMMMMMMMMMMMWd                  dWMMMMMMMMMMMMMMWKd.
     :WMMW0OOOOOOOOOOOOOk:                  ckkkkkkkkkkkkkkKMMMW;
     OMMMl                                                  oMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:          .;cc,                     ,cc;.         cMMMk
     OMMM:         dWMMMMN;                 '0MWWMNo        :MMMO
    :WMMX.         KMMMMMMo               .dWM0,.dWMK,      .XMMN;
dOKNMW0o.          .dOKKkc                ;kd;    .okx.      .o0WMNKOo
:dxOWMNk'                                                    ,kNMWOxd:
    .NMMW.           .oxc                   cxo.            'WMMX.
     OMMM:           .OMMNo'             ,oXMWO.            cMMMk
     OMMM:             'xWMMNOdl::;::ldONMMNx'              cMMMk
     OMMM:                ,lx0XNWMMMWNX0xc,                 cMMMk
     OMMM:                       ...                        cMMMk
     OMMM:                                                  cMMMk
     kMMMx.                                                .xMMMk
     'KMMMWNNNNNNNNNNNNNXd                  dXNNNNNNNNNNNNNWMMMK.
       ;x0KKKKKKKKKKKKKK0;                  ;0KKKKKKKKKKKKKK0x;
`,
		`
      .dKWMMMMMMMMMMMMMMWd                  dWMMMMMMMMMMMMMMWKd.
     :WMMW0OOOOOOOOOOOOOk:                  ckkkkkkkkkkkkkkKMMMW;
     OMMMl                                                  oMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:          .;cc,                     ,cc;.         cMMMk
     OMMM:         oWMWMM0'                 '0MWWMNo        :MMMO
    :WMMX.       ,XMWx.,0MWd.             .xWM0,.dWMK,      .XMMN;
dOKNMW0o.        dkl.    ;dkc             ;kd;    .okx.      .o0WMNKOo
:dxOWMNk'                                                    ,kNMWOxd:
    .NMMW.           .oxc                   cxo.            'WMMX.
     OMMM:           .OMMNo'             ,oXMWO.            cMMMk
     OMMM:             'xWMMNOdl::;::ldONMMNx'              cMMMk
     OMMM:                ,lx0XNWMMMWNX0xc,                 cMMMk
     OMMM:                       ...                        cMMMk
     OMMM:                                                  cMMMk
     kMMMx.                                                .xMMMk
     'KMMMWNNNNNNNNNNNNNXd                  dXNNNNNNNNNNNNNWMMMK.
       ;x0KKKKKKKKKKKKKK0;                  ;0KKKKKKKKKKKKKK0x;
`,
	],
	gut = hut.map((e) => fut.replace("{AUGGIE_LOGO}", e)),
	put = [
		String.raw`
                     __  __                           _
                    |  \/  |                         (_)
                    | \  / | ___ _ __ ___   ___  _ __ _  ___  ___
                    | |\/| |/ _ \ '_ ' _ \ / _ \| '__| |/ _ \/ __|
                    | |  | |  __/ | | | | | (_) | |  | |  __/\__ \
                    |_|  |_|\___|_| |_| |_|\___/|_|  |_|\___||___/

 __________________________________________________________________________________
/\                                                                                 \
\_| NOTE: Memories will be compressed when this file grows too large.              |
  | For personal Memories: consider putting them in User Guidelines (via '@' menu) |
  | For repository-level Memories: consider using '.augment-guidelines' file       |
  | Neither will be compressed.                                                    |
  |   _____________________________________________________________________________|_
   \_/_______________________________________________________________________________/

↓↓↓ MEMORIES START HERE ↓↓↓`,
	],
	hW,
	Cme = Gn.window.createTextEditorDecorationType({
		isWholeLine: !0,
		before: { contentText: "", fontWeight: "bold" },
	})
function vme() {
	return Cme
}
function AW(e) {
	let t = e[0].split(`
`).length
	if (
		!e.every(
			(r) =>
				r.split(`
`).length === t,
		)
	)
		throw new Error("All animation frames must have the same number of lines")
	return t
}
async function Eme(e, t, r) {
	let n = t()
	if (!n || e?.document.uri.fsPath !== Gn.Uri.file(n).fsPath) return
	let i = r.get("memoriesFileOpenCount") ?? 0
	await r.update("memoriesFileOpenCount", i + 1)
}
async function CW(e, t, r) {
	let n = bme(r),
		i = t()
	if (!i || e?.document.uri.fsPath !== Gn.Uri.file(i).fsPath) return
	hW !== void 0 && clearInterval(hW)
	let s = e.document.getText().replace(/^\s+/, "")
	;(s =
		`
`.repeat(AW(n)) + s),
		await e.edit((c) => {
			let u = e.document.lineAt(0),
				f = e.document.lineAt(e.document.lineCount - 1),
				p = new Gn.Range(u.range.start, f.range.end)
			c.replace(p, s)
		}),
		await e.document.save()
	let o = 0,
		a = 1e3,
		l = (0, mme.default)(() => {
			let f = n[o]
				.split(
					`
`,
				)
				.map((p, g) => ({
					range: new Gn.Range(g, 0, g, 1e4),
					renderOptions: { before: { contentText: p.replace(/ /g, "\xA0") } },
				}))
			e.setDecorations(Cme, f), (o = (o + 1) % n.length)
		}, a)
	l(), (hW = setInterval(l, a))
}
function bme(e) {
	return (e.get("memoriesFileOpenCount") ?? 0) <= 3 ? gut : put
}
function xme(e, t, r, n) {
	if (e.document.uri.fsPath !== r() || !t || t.document !== e.document) return
	let i = bme(n)
	if (
		!e.document.getText().startsWith(
			`
`.repeat(AW(i)),
		)
	)
		for (let s of e.contentChanges) s.range.start.line < AW(i) && CW(t, r, n)
}
var mW = class {
		constructor(t, r, n, i) {
			this.workspaceManager = t
			this.apiServer = r
			this.logger = n
			this.progressTracker = i
		}
		toolDefinitions = [
			{
				name: "ls",
				description: "Lists a content of a folder by a relative path to it.",
				input_schema_json: JSON.stringify({
					type: "object",
					properties: {
						folder: {
							type: "string",
							description: "Relative path to a folder. Can be either '.' or './*'",
						},
					},
					required: ["folder"],
				}),
				tool_safety: xt.Safe,
			},
			{
				name: "read-file",
				description: "Read a file.",
				input_schema_json: JSON.stringify({
					type: "object",
					properties: {
						file_path: {
							type: "string",
							description: "The path of the file to read.",
						},
					},
					required: ["file_path"],
				}),
				tool_safety: xt.Safe,
			},
			{
				name: "complete",
				description: "Tool which should be called at the very end to return final response.",
				input_schema_json: JSON.stringify({
					type: "object",
					properties: {
						response: {
							type: "string",
							description: "Final response to the user.",
						},
					},
					required: ["response"],
				}),
				tool_safety: xt.Safe,
			},
			{
				name: "codebase-retrieval",
				description:
					"Use this tool to request information from the codebase. It will return relevant snippets for the requested information.",
				input_schema_json: JSON.stringify({
					type: "object",
					properties: {
						information_request: {
							type: "string",
							description: "A description of the information you need.",
						},
					},
					required: ["information_request"],
				}),
				tool_safety: xt.Safe,
			},
		]
		getToolDefinitions() {
			return this.toolDefinitions
		}
		async runTool(t, r) {
			switch (t) {
				case "codebase-retrieval": {
					let n = this.apiServer.createRequestId(),
						i = r.information_request
					try {
						let s = await this.apiServer.agentCodebaseRetrieval(
							n,
							i,
							this.workspaceManager.getContext().blobs,
							[],
							2e4,
						)
						return Zt(s.formattedRetrieval, n)
					} catch (s) {
						return (
							this.logger.error(`Failed to retrieve codebase information: ${s}`),
							ut("Failed to retrieve codebase information.")
						)
					}
				}
				case "ls": {
					let n = r.folder,
						i = Du(n, this.workspaceManager)?.absPath
					if (i === void 0) return ut(`Failed to list directory: ${n}`)
					if (!(await $d(i))) return ut(`Directory does not exist: ${n}`)
					try {
						let o = (await Ex(i)).map(([a, l]) => a)
						return Zt(
							o.join(`
`),
						)
					} catch {
						return this.logger.error(`Failed to list directory: ${n}`), ut(`Failed to list directory: ${n}`)
					}
				}
				case "read-file": {
					let n = r.file_path,
						i = Du(n, this.workspaceManager)?.absPath
					if (i === void 0) return ut(`Failed to read file: ${n}`)
					if (!Pn(i)) return ut(`File does not exist: ${n}`)
					let s = await Fr(i)
					return s === void 0
						? (this.logger.error(`Failed to read file: ${n}`), ut(`Failed to read file: ${n}`))
						: Zt(s)
				}
				default:
					return ut(`Unknown tool: ${t}`)
			}
		}
	},
	yW = class e {
		constructor(t, r, n, i, s, o, a, l) {
			this.rootAbsPath = t
			this.apiServer = r
			this.workspaceManager = n
			this.featureFlagManager = i
			this.logger = s
			this.orientationConcurrencyLevel = o
			this.progressTracker = a
			this.trace = l
			if (
				((this.localizationPrompt =
					this.featureFlagManager.currentFlags.memoriesParams.language_localization_prompt),
				!this.localizationPrompt)
			)
				throw (this.trace.setFlag(Cr.localizationPromptMissing), new Error("Localization prompt missing"))
			if (
				((this.detectLanguagesPrompt =
					this.featureFlagManager.currentFlags.memoriesParams.detect_languages_prompt),
				!this.detectLanguagesPrompt)
			)
				throw (
					(this.trace.setFlag(Cr.detectLanguagesPromptMissing), new Error("Detect languages prompt missing"))
				)
			if (
				((this.orientationCompressionPrompt =
					this.featureFlagManager.currentFlags.memoriesParams.orientation_compression_prompt),
				!this.orientationCompressionPrompt)
			)
				throw (
					(this.trace.setFlag(Cr.orientationCompressionPromptMissing),
					new Error("Orientation compression prompt missing"))
				)
			if (
				((this.orientationMaxLanguages =
					this.featureFlagManager.currentFlags.memoriesParams.orientation_max_languages),
				!this.orientationMaxLanguages)
			)
				throw (
					(this.trace.setFlag(Cr.orientationMaxLanguagesMissing),
					new Error("Orientation max languages missing"))
				)
			if (
				((this.buildTestQuery =
					this.featureFlagManager.currentFlags.memoriesParams.orientation_build_test_query),
				!this.buildTestQuery)
			)
				throw (this.trace.setFlag(Cr.orientationBuildTestQueryMissing), new Error("Build test prompt missing"))
			if (
				((this.modelName = this.featureFlagManager.currentFlags.memoriesParams.orientation_model_name),
				this.modelName === void 0)
			)
				throw (this.trace.setFlag(Cr.orientationModelNameMissing), new Error("Orientation model name missing"))
			this.modelName === "default" && (this.modelName = void 0),
				(this.queries = [{ name: "build-test", template: this.buildTestQuery }]),
				(this.tools = new mW(n, r, this.logger, a))
		}
		localizationPrompt
		detectLanguagesPrompt
		orientationCompressionPrompt
		orientationMaxLanguages
		modelName
		buildTestQuery
		tools
		queries
		static agentMdPattern = new RegExp("<agent_md>(?:\\s*```(?:\\w+)?\\n?)?(.*?)(?:```\\s*)?</agent_md>", "s")
		async appendToWorkspaceGuidelines(t) {
			let r = "[//]: # (AUGMENT-CODEBASE-ORIENTATION-RESULTS-START)",
				n = "[//]: # (AUGMENT-CODEBASE-ORIENTATION-RESULTS-END)",
				i = this.workspaceManager.getMostRecentlyChangedFolderRoot()
			if (!i) throw (this.trace.setFlag(Cr.noRootFolderFound), new Error("No root folder found"))
			let s = Sx.default.join(i, ".augment-guidelines"),
				o = ""
			try {
				Pn(s) && (o = await Fr(s))
			} catch (u) {
				this.trace.setFlag(Cr.failedToReadGuidelines),
					this.logger.error(`Failed to read existing guidelines: ${u}`)
			}
			let a = "",
				l = o.indexOf(r),
				c = o.indexOf(n)
			if (l !== -1 && c !== -1 && c > l) {
				let u = o.substring(0, l),
					f = o.substring(c + n.length)
				;(a =
					u +
					r +
					`
` +
					t +
					`
` +
					n +
					f),
					this.logger.debug("Replacing existing orientation results between markers")
			} else {
				let u =
					o.trim().length > 0
						? `

`
						: ""
				;(a =
					o.trim() +
					u +
					r +
					`
` +
					t +
					`
` +
					n),
					this.logger.debug("Appending new orientation results with markers")
			}
			try {
				await Gn.workspace.fs.writeFile(Gn.Uri.file(s), Buffer.from(a, "utf8")),
					this.logger.debug(`Successfully updated workspace guidelines at ${s}`)
			} catch (u) {
				throw (
					(this.trace.setFlag(Cr.failedToWriteGuidelines),
					new Error(`Failed to write workspace guidelines: ${u}`))
				)
			}
		}
		async run() {
			let { languages: t, allFiles: r } = await this.getTopProgrammingLanguages()
			if (Object.keys(t).length === 0) throw new Error("No programming languages detected")
			this.progressTracker.set(10)
			let n = await this.localizeLanguages(r, t)
			this.progressTracker.set(25)
			let i = (await Ame(".", this.workspaceManager))?.join(`
`)
			if (!i) throw (this.trace.setFlag(Cr.failedToListRootFolder), new Error("Failed to list root folder"))
			this.progressTracker.set(30)
			let s = (0, pW.default)(this.orientationConcurrencyLevel),
				o = Object.keys(t),
				l = 60 / o.length / this.queries.length
			this.trace.setFlag(Cr.agenticStarted)
			let c = o.map((C, v) =>
					s(async () => {
						this.logger.debug(`Processing language: ${C}`)
						let b = []
						for (let w of this.queries) {
							this.logger.debug(`Processing query: ${w.name}`)
							let B = w.template
									.replace(/{language}/g, C)
									.replace(/{rootFolderContent}/g, i)
									.replace(
										/{locationList}/g,
										n[C].split(",").join(`
`),
									),
								M = await this.doAgenticTurn(B, l, v)
							b.push(M), this.logger.debug(`Response language "${C}" and query "${w.name}": ${M}`)
						}
						return b
					}),
				),
				u = await Promise.all(c)
			this.trace.setFlag(Cr.agenticEnded)
			let f = u.flat().join(`

`)
			this.trace.setStringStats(Cr.agenticModelResponseStats, f), this.progressTracker.set(90)
			let p = this.apiServer.createRequestId()
			this.trace.setRequestId(Cr.compressionRequestId, p)
			let g = await this.simpleLlmCall(this.orientationCompressionPrompt.replace(/{assembledKnowledge}/g, f), p)
			this.trace.setStringStats(Cr.compressionModelResponseStats, g)
			let m = g.match(e.agentMdPattern)
			if (!m)
				throw (
					(this.trace.setFlag(Cr.compressionParsingFailed), new Error("Failed to parse compression response"))
				)
			let y = m[1].trim()
			this.logger.debug(`Compressed knowledge: ${y}`),
				this.progressTracker.set(95),
				this.trace.setFlag(Cr.rememberStarted),
				await this.appendToWorkspaceGuidelines(y),
				this.trace.setFlag(Cr.rememberEnded),
				this.progressTracker.set(100)
		}
		async doAgenticTurn(t, r, n) {
			let i = t,
				s = [],
				o = [],
				a = {
					request_message: i,
					response_text: "",
					request_id: this.apiServer.createRequestId(),
					request_nodes: [],
					response_nodes: [],
				},
				l,
				c = 30,
				u = 32,
				f = r / u,
				p = 0
			do {
				if ((this.trace.setNum(`agenticNumTurns_${n}`, p), p > c)) {
					if (p > u) throw new Error("Too many turns in agentic loop")
					s = [
						...s,
						{
							id: 2,
							type: $c.TEXT,
							text_node: {
								content: "You did too many turns already. Call `complete` tool immediately.",
							},
						},
					]
				}
				this.logger.debug(`Running agentic turn ${p}.`), this.progressTracker.inc(f)
				let g = this.apiServer.createRequestId(),
					m = await Kp(i, g, o, this.tools.getToolDefinitions(), s, Mn.agent)
				for await (let y of m)
					if (y.nodes) {
						let C = y.nodes.filter((v) => v.type === Jl.TOOL_USE || v.type === Jl.RAW_RESPONSE)
						;(a.response_nodes = a.response_nodes || []), a.response_nodes.push(...C)
					}
				if (((l = a.response_nodes?.find((y) => y.type === Jl.TOOL_USE)), l?.tool_use !== void 0)) {
					let y = l.tool_use,
						C = y.tool_name,
						v = JSON.parse(y.input_json)
					if ((this.logger.debug(`Calling tool: ${C}. Args: ${JSON.stringify(v)}`), C === "complete"))
						return (
							this.logger.debug(`Agentic turn complete. Took ${p} turns.`),
							this.progressTracker.inc(f * (u - p - 1)),
							this.trace.setStringStats(`agenticModelResponseStats_${n}`, v.response),
							v.response
						)
					let b = await this.tools.runTool(y.tool_name, v)
					;(s = [
						{
							id: 1,
							type: $c.TOOL_RESULT,
							tool_result_node: {
								tool_use_id: y.tool_use_id,
								content: b.text,
								is_error: b.isError,
							},
						},
					]),
						this.logger.debug(
							`Tool result: ${
								b.text.trim().split(`
`)[0]
							}...`,
						),
						(i = ""),
						o.push(a),
						(a = {
							request_message: "",
							response_text: "",
							request_id: this.apiServer.createRequestId(),
							request_nodes: s,
							response_nodes: [],
						})
				}
				p++
			} while (l?.tool_use !== void 0)
			throw (
				(this.trace.setFlag(`agenticFailedToComplete_${n}`), new Error("Agent didn't call the complete tool."))
			)
		}
		async localizeLanguages(t, r) {
			let n = {},
				i = (0, pW.default)(this.orientationConcurrencyLevel),
				o = 15 / Object.keys(r).length
			this.trace.setFlag(Cr.localizationStarted)
			let a = Object.entries(r).map(([c, u], f) =>
					i(async () => {
						this.logger.debug(`Localizing language: ${c} (index: ${f})`)
						let p = Aut(t, u)
						if (p.trim().length === 0) throw new Error(`Failed to render folder tree for ${c}`)
						let g = this.localizationPrompt
							.replace(/{programmingLanguage}/g, c)
							.replace(/{languageTree}/g, p)
						this.trace.setStringStats(`localizationPromptStats_${f}`, g)
						let m = this.apiServer.createRequestId()
						this.trace.setRequestId(`localizationRequestId_${f}`, m)
						let y = await this.simpleLlmCall(g, m)
						this.trace.setStringStats(`localizationResponseStats_${f}`, y)
						let C = y.match(/<locations>(.*?)<\/locations>/)
						if (!C)
							throw (
								(this.trace.setFlag(`localizationParsingFailed_${f}`),
								new Error(`Failed to extract locations from response: ${y}`))
							)
						return this.progressTracker.inc(o), { language: c, locations: C[1].trim() }
					}),
				),
				l = await Promise.all(a)
			return (
				this.trace.setFlag(Cr.localizationEnded),
				l.forEach(({ language: c, locations: u }, f) => {
					let p = u.split(",").length
					this.trace.setNum(`localizationNumLocations_${f}`, p), (n[c] = u)
				}),
				n
			)
		}
		async getTopProgrammingLanguages() {
			let t = new Set([
					"ad",
					"adown",
					"argdown",
					"argdn",
					"bicep",
					"c",
					"cpp",
					"cc",
					"cp",
					"cxx",
					"h",
					"hpp",
					"hxx",
					"cs",
					"ex",
					"elm",
					"erb",
					"rhtml",
					"gd",
					"godot",
					"tres",
					"tscn",
					"go",
					"haml",
					"hs",
					"hx",
					"html",
					"htm",
					"java",
					"js",
					"jsx",
					"kt",
					"ml",
					"mli",
					"mll",
					"mly",
					"php",
					"py",
					"r",
					"rb",
					"rs",
					"res",
					"resi",
					"sass",
					"scala",
					"styl",
					"swift",
					"tf",
					"tfvars",
					"ts",
					"tsx",
					"vue",
					"vala",
				]),
				r = {},
				n = [],
				i = async (p) => {
					let g = await Ex(p)
					if (g)
						for (let [m, y] of g) {
							if (m.startsWith(".")) continue
							let C = Sx.default.join(p, m)
							if (y === "Directory") await i(C)
							else if (y === "File") {
								let v = Sx.default.relative(this.rootAbsPath, C)
								n.push(v)
								let b = m.includes(".") ? m.split(".").pop().toLowerCase() : ""
								b && t.has(b) && (r[b] = (r[b] || 0) + 1)
							}
						}
				}
			await i(this.rootAbsPath), this.trace.setNum(Cr.topLanguagesNumFiles, n.length)
			let s = Object.entries(r)
					.sort(([, p], [, g]) => g - p)
					.slice(0, 20)
					.map(([p, g]) => `${p}: ${g}`).join(`
`),
				o = this.apiServer.createRequestId()
			this.trace.setRequestId(Cr.topLanguagesRequestId, o)
			let a = await this.simpleLlmCall(this.detectLanguagesPrompt.replace(/{fileExtensionsList}/g, s), o)
			this.trace.setStringStats(Cr.topLanguagesModelResponseStats, a),
				this.logger.debug(`Detected languages: "${a}"`)
			let l = JSON.parse(a.trim())
			this.trace.setNum(Cr.topLanguagesNumDetectedLanguages, Object.keys(l).length)
			let c = {}
			for (let [p, g] of Object.entries(l))
				(c[p] = g.reduce((m, y) => m + (r[y] || 0), 0)), this.logger.debug(`${p}: ${c[p]} files`)
			let u = Object.entries(c)
					.sort(([, p], [, g]) => g - p)
					.slice(0, this.orientationMaxLanguages)
					.map(([p]) => p),
				f = {}
			for (let p of u) f[p] = l[p]
			return (
				this.logger.debug(`Top ${this.orientationMaxLanguages} languages: ${JSON.stringify(f)}`),
				this.trace.setNum(Cr.topLanguagesNumFinalLanguages, Object.keys(f).length),
				{ languages: f, allFiles: n }
			)
		}
		async simpleLlmCall(t, r) {
			let n = await Kp(t, r, [], [], [], Mn.chat, this.modelName)
			for await (let i of n)
				if (i.nodes) {
					for (let s of i.nodes) if (s.type === Jl.RAW_RESPONSE) return s.content
				}
			throw new Error("No response from model")
		}
	}
function _me(e, t = "", r = !0, n = "", i = 0, s = 3) {
	if (i > s) return ""
	let o = []
	if (n) {
		let c = e.isDirectory ? `${n}/` : n
		o.push(`${t}${r ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 "}${c}`)
	}
	let a = t + (r ? "    " : "\u2502   "),
		l = Array.from(e.children.entries()).sort(([c], [u]) => c.localeCompare(u))
	return (
		l.forEach(([c, u], f) => {
			let p = f === l.length - 1,
				g = _me(u, a, p, c, i + 1, s)
			g && o.push(g)
		}),
		o.join(`
`)
	)
}
function Aut(e, t) {
	let r = e.filter((i) => {
		let s = i.split(".").pop()?.toLowerCase()
		return s && t.includes(s)
	})
	if (r.length === 0) return ""
	let n = { isDirectory: !0, children: new Map() }
	for (let i of r) {
		let o = Gn.workspace.asRelativePath(i).split(Sx.default.sep),
			a = n
		for (let l = 0; l < o.length - 1; l++) {
			let c = o[l]
			a.children.has(c) || a.children.set(c, { isDirectory: !0, children: new Map() }), (a = a.children.get(c))
		}
	}
	return n.children.size === 0 ? "" : _me(n)
}
var gW = !1
async function Ek(e, t, r, n, i, s) {
	if (gW) {
		Gn.window.showInformationMessage("Augment Agent orientation is already in progress")
		return
	}
	let o = X("InitialOrientation"),
		a = gk.create(s)
	a.setFlag(Cr.start)
	try {
		;(gW = !0), await mut(e, t, r, n, i, o, a)
	} catch (l) {
		a.setFlag(Cr.exceptionThrown),
			o.error(`Error in initial orientation: ${l}`),
			Gn.window.showErrorMessage("Augment agent orientation process failed :(")
	} finally {
		;(gW = !1),
			a.setFlag(Cr.end),
			i.reportEvent({
				eventName: Is.initialOrientation,
				conversationId: "",
				eventData: { initialOrientationData: a },
			})
	}
}
async function mut(e, t, r, n, i, s, o) {
	s.debug("Starting initial orientation process.")
	let a = r.currentFlags.memoriesParams?.orientation_concurrency_level
	if (!a) {
		o.setFlag(Cr.concurrencyLevelMissing), s.error("Failed to get concurrency level for initial orientation.")
		return
	}
	if (!r.currentFlags.memoriesParams?.enable_initial_orientation) {
		o.setFlag(Cr.initialOrientationDisabled), s.error("Initial orientation is not enabled.")
		return
	}
	let l = (c) => {
		let u = 0
		return {
			inc: (f) => {
				c.report({ increment: f, message: `${Math.round(u)}%` }), (u = Math.min(u + f, 100))
			},
			set: (f) => {
				f <= u ||
					((f = Math.min(f, 100)), c.report({ increment: f - u, message: `${Math.round(u)}%` }), (u = f))
			},
			reset: () => {
				c.report({ increment: -1 * u, message: "0%" }), (u = 0)
			},
		}
	}
	await Gn.window.withProgress(
		{
			location: Gn.ProgressLocation.Window,
			title: "Augment Codebase Orientation",
		},
		async (c, u) => {
			let f = l(c)
			await wme(e, t, r, n, s, a, f, i, o)
		},
	)
}
async function wme(e, t, r, n, i, s, o, a, l) {
	o.set(1)
	try {
		let c = t.getMostRecentlyChangedFolderRoot()
		if (!c) throw (l.setFlag(Cr.noRootFolderFound), new Error("No root folder found"))
		i.debug(`Root folder: ${c}.`), o.set(2), o.set(3)
		let u = new yW(c, e, t, r, i, s, o, l)
		o.set(5),
			await u.run(),
			o.set(100),
			Gn.window.showInformationMessage(
				"Augment Agent completed orientation process. Workspace guidelines were updated!",
			)
	} catch (c) {
		if (s > 1 && kr.isAPIErrorWithStatus(c, He.resourceExhausted)) {
			l.setFlag(Cr.retryWithLowerConcurrencyLevel),
				Gn.window.showErrorMessage(
					"Augment agent orientation process failed: Rate limit exceeded. Retrying...",
				),
				i.error("Retrying initial orientation with concurrency level 1."),
				await new Promise((u) => setTimeout(u, 5e3)),
				o.reset(),
				await wme(e, t, r, n, i, 1, o, a, l)
			return
		}
		throw c
	}
}
var r0e = W(require("vscode"))
var vW = class {
	_status = "running"
	_buffer = new Array()
	_triggerYield
	_resolveFn
	_rejectFn
	constructor(t) {
		;(this._triggerYield = new Promise((r, n) => {
			;(this._resolveFn = r), (this._rejectFn = n)
		})),
			this.collectBaseGenerator(t)
	}
	cancel = () => {
		this.isFinished || this._reject(new Error("Cancelled"))
	}
	get isFinished() {
		return this._status !== "running"
	}
	get hasErrored() {
		return this._status === "errored"
	}
	collectBaseGenerator = async (t) => {
		try {
			this._resolve(),
				(this._triggerYield = new Promise((r, n) => {
					;(this._resolveFn = r), (this._rejectFn = n)
				}))
			for await (let r of t)
				this._buffer.push(r),
					this._resolve(),
					(this._triggerYield = new Promise((n, i) => {
						;(this._resolveFn = n), (this._rejectFn = i)
					}))
			;(this._status = "success"), this._resolve()
		} catch (r) {
			this._reject(r)
		}
	}
	_reject = (t) => {
		;(this._status = "errored"), this._rejectFn(t)
	}
	_resolve = () => {
		this._resolveFn()
	}
	async *copy() {
		let t = 0
		for (;;) {
			if (t < this._buffer.length) {
				yield this._buffer[t], (t += 1)
				continue
			}
			if ((await this._triggerYield, t === this._buffer.length && this.isFinished)) return
		}
	}
}
var Jp = vW
var Di = W(require("vscode"))
var Dx = W(require("vscode"))
function Ime(e, t, r = !1, n = !0) {
	let i = new Dx.Position(e.start.line, 0),
		s = e.end.line
	n && e.end.character === 0 && s > e.start.line && (s -= 1)
	let o = t.lineAt(s).range.end
	return r && t.lineCount > e.end.line + 1 && (o = new Dx.Position(e.end.line + 1, 0)), new Dx.Range(i, o)
}
function Sme(e) {
	return e
		? ((e.selections = e.selections.map((t) => {
				if (e.document.getText(t).trim() === "") return t
				let n = Ime(t, e.document)
				return t.active.isBefore(t.anchor) ? new Di.Selection(n.end, n.start) : new Di.Selection(n.start, n.end)
			})),
			!0)
		: !1
}
function Bme() {
	let e = Di.window.activeTextEditor
	if (!e) return []
	let { document: t, selection: r } = e,
		n = []
	return (
		r.isEmpty ||
			(n = Di.languages
				.getDiagnostics(t.uri)
				.filter((o) => o.range.intersection(r))
				.map((o) => ({
					location: {
						path: t.fileName,
						line_start: o.range.start.line,
						line_end: o.range.end.line,
					},
					char_start: 0,
					char_end: 0,
					blob_name: "",
					current_blob_name: "",
					message: o.message,
					severity: (() => {
						switch (o.severity) {
							case Di.DiagnosticSeverity.Error:
								return "ERROR"
							case Di.DiagnosticSeverity.Warning:
								return "WARNING"
							case Di.DiagnosticSeverity.Information:
								return "INFORMATION"
							case Di.DiagnosticSeverity.Hint:
								return "HINT"
							default:
								return "ERROR"
						}
					})(),
				}))),
		n
	)
}
function EW(e, t, r, n) {
	if (!e) return null
	let { document: i, selection: s } = e,
		o = t.safeResolvePathName(i.uri)
	if (!o) return X("getSelectedCodeDetails").error("Unable to resolve path name for document"), null
	let a = i.languageId,
		l = i.lineAt(0).range.start,
		c = i.lineAt(i.lineCount - 1).range.end,
		u = i.getText(s),
		f,
		p
	if (u.trim() === "") {
		let y = new Di.Position(s.active.line + 1, 0)
		;(f = new Di.Range(l, y)), (p = new Di.Range(y, c))
	} else (f = new Di.Range(l, s.start)), (p = new Di.Range(s.end, c))
	var g = i.getText(f),
		m = i.getText(p)
	return (
		g.length > r && (g = g.slice(g.length - r)),
		m.length > n && (m = m.slice(0, n)),
		m.trim() === "" && ((u += m), (m = "")),
		{
			selectedCode: u,
			prefix: g,
			suffix: m,
			path: o.relPath,
			language: a,
			prefixBegin: f.start.character,
			suffixEnd: p.end.character,
		}
	)
}
function yut(e, t, r, n, i, s, o) {
	return {
		blob_name: e,
		path: t,
		char_start: r,
		char_end: n,
		replacement_text: i,
		present_in_blob: s,
		expected_blob_name: o,
	}
}
function By(e) {
	return e.map((t) =>
		yut(t.blobName, t.pathName, t.origStart, t.origStart + t.origLength, t.text, t.uploaded, t.expectedBlobName),
	)
}
function Jd(e) {
	return Array.isArray ? Array.isArray(e) : Nme(e) === "[object Array]"
}
var Cut = 1 / 0
function vut(e) {
	if (typeof e == "string") return e
	let t = e + ""
	return t == "0" && 1 / e == -Cut ? "-0" : t
}
function Eut(e) {
	return e == null ? "" : vut(e)
}
function Ru(e) {
	return typeof e == "string"
}
function Fme(e) {
	return typeof e == "number"
}
function but(e) {
	return e === !0 || e === !1 || (xut(e) && Nme(e) == "[object Boolean]")
}
function Qme(e) {
	return typeof e == "object"
}
function xut(e) {
	return Qme(e) && e !== null
}
function Sa(e) {
	return e != null
}
function bW(e) {
	return !e.trim().length
}
function Nme(e) {
	return e == null ? (e === void 0 ? "[object Undefined]" : "[object Null]") : Object.prototype.toString.call(e)
}
var _ut = "Incorrect 'index' type",
	wut = (e) => `Invalid value for key ${e}`,
	Iut = (e) => `Pattern length exceeds max of ${e}.`,
	Sut = (e) => `Missing ${e} property in key`,
	But = (e) => `Property 'weight' in key '${e}' must be a positive integer`,
	Dme = Object.prototype.hasOwnProperty,
	xW = class {
		constructor(t) {
			;(this._keys = []), (this._keyMap = {})
			let r = 0
			t.forEach((n) => {
				let i = Pme(n)
				this._keys.push(i), (this._keyMap[i.id] = i), (r += i.weight)
			}),
				this._keys.forEach((n) => {
					n.weight /= r
				})
		}
		get(t) {
			return this._keyMap[t]
		}
		keys() {
			return this._keys
		}
		toJSON() {
			return JSON.stringify(this._keys)
		}
	}
function Pme(e) {
	let t = null,
		r = null,
		n = null,
		i = 1,
		s = null
	if (Ru(e) || Jd(e)) (n = e), (t = Tme(e)), (r = _W(e))
	else {
		if (!Dme.call(e, "name")) throw new Error(Sut("name"))
		let o = e.name
		if (((n = o), Dme.call(e, "weight") && ((i = e.weight), i <= 0))) throw new Error(But(o))
		;(t = Tme(o)), (r = _W(o)), (s = e.getFn)
	}
	return { path: t, id: r, weight: i, src: n, getFn: s }
}
function Tme(e) {
	return Jd(e) ? e : e.split(".")
}
function _W(e) {
	return Jd(e) ? e.join(".") : e
}
function Dut(e, t) {
	let r = [],
		n = !1,
		i = (s, o, a) => {
			if (Sa(s))
				if (!o[a]) r.push(s)
				else {
					let l = o[a],
						c = s[l]
					if (!Sa(c)) return
					if (a === o.length - 1 && (Ru(c) || Fme(c) || but(c))) r.push(Eut(c))
					else if (Jd(c)) {
						n = !0
						for (let u = 0, f = c.length; u < f; u += 1) i(c[u], o, a + 1)
					} else o.length && i(c, o, a + 1)
				}
		}
	return i(e, Ru(t) ? t.split(".") : t, 0), n ? r : r[0]
}
var Tut = { includeMatches: !1, findAllMatches: !1, minMatchCharLength: 1 },
	Rut = {
		isCaseSensitive: !1,
		includeScore: !1,
		keys: [],
		shouldSort: !0,
		sortFn: (e, t) => (e.score === t.score ? (e.idx < t.idx ? -1 : 1) : e.score < t.score ? -1 : 1),
	},
	kut = { location: 0, threshold: 0.6, distance: 100 },
	Mut = {
		useExtendedSearch: !1,
		getFn: Dut,
		ignoreLocation: !1,
		ignoreFieldNorm: !1,
		fieldNormWeight: 1,
	},
	Dt = { ...Rut, ...Tut, ...kut, ...Mut },
	Fut = /[^ ]+/g
function Qut(e = 1, t = 3) {
	let r = new Map(),
		n = Math.pow(10, t)
	return {
		get(i) {
			let s = i.match(Fut).length
			if (r.has(s)) return r.get(s)
			let o = 1 / Math.pow(s, 0.5 * e),
				a = parseFloat(Math.round(o * n) / n)
			return r.set(s, a), a
		},
		clear() {
			r.clear()
		},
	}
}
var Tx = class {
	constructor({ getFn: t = Dt.getFn, fieldNormWeight: r = Dt.fieldNormWeight } = {}) {
		;(this.norm = Qut(r, 3)), (this.getFn = t), (this.isCreated = !1), this.setIndexRecords()
	}
	setSources(t = []) {
		this.docs = t
	}
	setIndexRecords(t = []) {
		this.records = t
	}
	setKeys(t = []) {
		;(this.keys = t),
			(this._keysMap = {}),
			t.forEach((r, n) => {
				this._keysMap[r.id] = n
			})
	}
	create() {
		this.isCreated ||
			!this.docs.length ||
			((this.isCreated = !0),
			Ru(this.docs[0])
				? this.docs.forEach((t, r) => {
						this._addString(t, r)
					})
				: this.docs.forEach((t, r) => {
						this._addObject(t, r)
					}),
			this.norm.clear())
	}
	add(t) {
		let r = this.size()
		Ru(t) ? this._addString(t, r) : this._addObject(t, r)
	}
	removeAt(t) {
		this.records.splice(t, 1)
		for (let r = t, n = this.size(); r < n; r += 1) this.records[r].i -= 1
	}
	getValueForItemAtKeyId(t, r) {
		return t[this._keysMap[r]]
	}
	size() {
		return this.records.length
	}
	_addString(t, r) {
		if (!Sa(t) || bW(t)) return
		let n = { v: t, i: r, n: this.norm.get(t) }
		this.records.push(n)
	}
	_addObject(t, r) {
		let n = { i: r, $: {} }
		this.keys.forEach((i, s) => {
			let o = i.getFn ? i.getFn(t) : this.getFn(t, i.path)
			if (Sa(o)) {
				if (Jd(o)) {
					let a = [],
						l = [{ nestedArrIndex: -1, value: o }]
					for (; l.length; ) {
						let { nestedArrIndex: c, value: u } = l.pop()
						if (Sa(u))
							if (Ru(u) && !bW(u)) {
								let f = { v: u, i: c, n: this.norm.get(u) }
								a.push(f)
							} else
								Jd(u) &&
									u.forEach((f, p) => {
										l.push({ nestedArrIndex: p, value: f })
									})
					}
					n.$[s] = a
				} else if (Ru(o) && !bW(o)) {
					let a = { v: o, n: this.norm.get(o) }
					n.$[s] = a
				}
			}
		}),
			this.records.push(n)
	}
	toJSON() {
		return { keys: this.keys, records: this.records }
	}
}
function Lme(e, t, { getFn: r = Dt.getFn, fieldNormWeight: n = Dt.fieldNormWeight } = {}) {
	let i = new Tx({ getFn: r, fieldNormWeight: n })
	return i.setKeys(e.map(Pme)), i.setSources(t), i.create(), i
}
function Nut(e, { getFn: t = Dt.getFn, fieldNormWeight: r = Dt.fieldNormWeight } = {}) {
	let { keys: n, records: i } = e,
		s = new Tx({ getFn: t, fieldNormWeight: r })
	return s.setKeys(n), s.setIndexRecords(i), s
}
function bk(
	e,
	{
		errors: t = 0,
		currentLocation: r = 0,
		expectedLocation: n = 0,
		distance: i = Dt.distance,
		ignoreLocation: s = Dt.ignoreLocation,
	} = {},
) {
	let o = t / e.length
	if (s) return o
	let a = Math.abs(n - r)
	return i ? o + a / i : a ? 1 : o
}
function Put(e = [], t = Dt.minMatchCharLength) {
	let r = [],
		n = -1,
		i = -1,
		s = 0
	for (let o = e.length; s < o; s += 1) {
		let a = e[s]
		a && n === -1 ? (n = s) : !a && n !== -1 && ((i = s - 1), i - n + 1 >= t && r.push([n, i]), (n = -1))
	}
	return e[s - 1] && s - n >= t && r.push([n, s - 1]), r
}
var zp = 32
function Lut(
	e,
	t,
	r,
	{
		location: n = Dt.location,
		distance: i = Dt.distance,
		threshold: s = Dt.threshold,
		findAllMatches: o = Dt.findAllMatches,
		minMatchCharLength: a = Dt.minMatchCharLength,
		includeMatches: l = Dt.includeMatches,
		ignoreLocation: c = Dt.ignoreLocation,
	} = {},
) {
	if (t.length > zp) throw new Error(Iut(zp))
	let u = t.length,
		f = e.length,
		p = Math.max(0, Math.min(n, f)),
		g = s,
		m = p,
		y = a > 1 || l,
		C = y ? Array(f) : [],
		v
	for (; (v = e.indexOf(t, m)) > -1; ) {
		let O = bk(t, {
			currentLocation: v,
			expectedLocation: p,
			distance: i,
			ignoreLocation: c,
		})
		if (((g = Math.min(O, g)), (m = v + u), y)) {
			let Y = 0
			for (; Y < u; ) (C[v + Y] = 1), (Y += 1)
		}
	}
	m = -1
	let b = [],
		w = 1,
		B = u + f,
		M = 1 << (u - 1)
	for (let O = 0; O < u; O += 1) {
		let Y = 0,
			j = B
		for (; Y < j; )
			bk(t, {
				errors: O,
				currentLocation: p + j,
				expectedLocation: p,
				distance: i,
				ignoreLocation: c,
			}) <= g
				? (Y = j)
				: (B = j),
				(j = Math.floor((B - Y) / 2 + Y))
		B = j
		let ne = Math.max(1, p - j + 1),
			q = o ? f : Math.min(p + j, f) + u,
			me = Array(q + 2)
		me[q + 1] = (1 << O) - 1
		for (let N = q; N >= ne; N -= 1) {
			let re = N - 1,
				K = r[e.charAt(re)]
			if (
				(y && (C[re] = +!!K),
				(me[N] = ((me[N + 1] << 1) | 1) & K),
				O && (me[N] |= ((b[N + 1] | b[N]) << 1) | 1 | b[N + 1]),
				me[N] & M &&
					((w = bk(t, {
						errors: O,
						currentLocation: re,
						expectedLocation: p,
						distance: i,
						ignoreLocation: c,
					})),
					w <= g))
			) {
				if (((g = w), (m = re), m <= p)) break
				ne = Math.max(1, 2 * p - m)
			}
		}
		if (
			bk(t, {
				errors: O + 1,
				currentLocation: p,
				expectedLocation: p,
				distance: i,
				ignoreLocation: c,
			}) > g
		)
			break
		b = me
	}
	let Q = { isMatch: m >= 0, score: Math.max(0.001, w) }
	if (y) {
		let O = Put(C, a)
		O.length ? l && (Q.indices = O) : (Q.isMatch = !1)
	}
	return Q
}
function Uut(e) {
	let t = {}
	for (let r = 0, n = e.length; r < n; r += 1) {
		let i = e.charAt(r)
		t[i] = (t[i] || 0) | (1 << (n - r - 1))
	}
	return t
}
var xk = class {
		constructor(
			t,
			{
				location: r = Dt.location,
				threshold: n = Dt.threshold,
				distance: i = Dt.distance,
				includeMatches: s = Dt.includeMatches,
				findAllMatches: o = Dt.findAllMatches,
				minMatchCharLength: a = Dt.minMatchCharLength,
				isCaseSensitive: l = Dt.isCaseSensitive,
				ignoreLocation: c = Dt.ignoreLocation,
			} = {},
		) {
			if (
				((this.options = {
					location: r,
					threshold: n,
					distance: i,
					includeMatches: s,
					findAllMatches: o,
					minMatchCharLength: a,
					isCaseSensitive: l,
					ignoreLocation: c,
				}),
				(this.pattern = l ? t : t.toLowerCase()),
				(this.chunks = []),
				!this.pattern.length)
			)
				return
			let u = (p, g) => {
					this.chunks.push({ pattern: p, alphabet: Uut(p), startIndex: g })
				},
				f = this.pattern.length
			if (f > zp) {
				let p = 0,
					g = f % zp,
					m = f - g
				for (; p < m; ) u(this.pattern.substr(p, zp), p), (p += zp)
				if (g) {
					let y = f - zp
					u(this.pattern.substr(y), y)
				}
			} else u(this.pattern, 0)
		}
		searchIn(t) {
			let { isCaseSensitive: r, includeMatches: n } = this.options
			if ((r || (t = t.toLowerCase()), this.pattern === t)) {
				let m = { isMatch: !0, score: 0 }
				return n && (m.indices = [[0, t.length - 1]]), m
			}
			let {
					location: i,
					distance: s,
					threshold: o,
					findAllMatches: a,
					minMatchCharLength: l,
					ignoreLocation: c,
				} = this.options,
				u = [],
				f = 0,
				p = !1
			this.chunks.forEach(({ pattern: m, alphabet: y, startIndex: C }) => {
				let {
					isMatch: v,
					score: b,
					indices: w,
				} = Lut(t, m, y, {
					location: i + C,
					distance: s,
					threshold: o,
					findAllMatches: a,
					minMatchCharLength: l,
					includeMatches: n,
					ignoreLocation: c,
				})
				v && (p = !0), (f += b), v && w && (u = [...u, ...w])
			})
			let g = { isMatch: p, score: p ? f / this.chunks.length : 1 }
			return p && n && (g.indices = u), g
		}
	},
	ku = class {
		constructor(t) {
			this.pattern = t
		}
		static isMultiMatch(t) {
			return Rme(t, this.multiRegex)
		}
		static isSingleMatch(t) {
			return Rme(t, this.singleRegex)
		}
		search() {}
	}
function Rme(e, t) {
	let r = e.match(t)
	return r ? r[1] : null
}
var wW = class extends ku {
		constructor(t) {
			super(t)
		}
		static get type() {
			return "exact"
		}
		static get multiRegex() {
			return /^="(.*)"$/
		}
		static get singleRegex() {
			return /^=(.*)$/
		}
		search(t) {
			let r = t === this.pattern
			return {
				isMatch: r,
				score: r ? 0 : 1,
				indices: [0, this.pattern.length - 1],
			}
		}
	},
	IW = class extends ku {
		constructor(t) {
			super(t)
		}
		static get type() {
			return "inverse-exact"
		}
		static get multiRegex() {
			return /^!"(.*)"$/
		}
		static get singleRegex() {
			return /^!(.*)$/
		}
		search(t) {
			let n = t.indexOf(this.pattern) === -1
			return { isMatch: n, score: n ? 0 : 1, indices: [0, t.length - 1] }
		}
	},
	SW = class extends ku {
		constructor(t) {
			super(t)
		}
		static get type() {
			return "prefix-exact"
		}
		static get multiRegex() {
			return /^\^"(.*)"$/
		}
		static get singleRegex() {
			return /^\^(.*)$/
		}
		search(t) {
			let r = t.startsWith(this.pattern)
			return {
				isMatch: r,
				score: r ? 0 : 1,
				indices: [0, this.pattern.length - 1],
			}
		}
	},
	BW = class extends ku {
		constructor(t) {
			super(t)
		}
		static get type() {
			return "inverse-prefix-exact"
		}
		static get multiRegex() {
			return /^!\^"(.*)"$/
		}
		static get singleRegex() {
			return /^!\^(.*)$/
		}
		search(t) {
			let r = !t.startsWith(this.pattern)
			return { isMatch: r, score: r ? 0 : 1, indices: [0, t.length - 1] }
		}
	},
	DW = class extends ku {
		constructor(t) {
			super(t)
		}
		static get type() {
			return "suffix-exact"
		}
		static get multiRegex() {
			return /^"(.*)"\$$/
		}
		static get singleRegex() {
			return /^(.*)\$$/
		}
		search(t) {
			let r = t.endsWith(this.pattern)
			return {
				isMatch: r,
				score: r ? 0 : 1,
				indices: [t.length - this.pattern.length, t.length - 1],
			}
		}
	},
	TW = class extends ku {
		constructor(t) {
			super(t)
		}
		static get type() {
			return "inverse-suffix-exact"
		}
		static get multiRegex() {
			return /^!"(.*)"\$$/
		}
		static get singleRegex() {
			return /^!(.*)\$$/
		}
		search(t) {
			let r = !t.endsWith(this.pattern)
			return { isMatch: r, score: r ? 0 : 1, indices: [0, t.length - 1] }
		}
	},
	_k = class extends ku {
		constructor(
			t,
			{
				location: r = Dt.location,
				threshold: n = Dt.threshold,
				distance: i = Dt.distance,
				includeMatches: s = Dt.includeMatches,
				findAllMatches: o = Dt.findAllMatches,
				minMatchCharLength: a = Dt.minMatchCharLength,
				isCaseSensitive: l = Dt.isCaseSensitive,
				ignoreLocation: c = Dt.ignoreLocation,
			} = {},
		) {
			super(t),
				(this._bitapSearch = new xk(t, {
					location: r,
					threshold: n,
					distance: i,
					includeMatches: s,
					findAllMatches: o,
					minMatchCharLength: a,
					isCaseSensitive: l,
					ignoreLocation: c,
				}))
		}
		static get type() {
			return "fuzzy"
		}
		static get multiRegex() {
			return /^"(.*)"$/
		}
		static get singleRegex() {
			return /^(.*)$/
		}
		search(t) {
			return this._bitapSearch.searchIn(t)
		}
	},
	wk = class extends ku {
		constructor(t) {
			super(t)
		}
		static get type() {
			return "include"
		}
		static get multiRegex() {
			return /^'"(.*)"$/
		}
		static get singleRegex() {
			return /^'(.*)$/
		}
		search(t) {
			let r = 0,
				n,
				i = [],
				s = this.pattern.length
			for (; (n = t.indexOf(this.pattern, r)) > -1; ) (r = n + s), i.push([n, r - 1])
			let o = !!i.length
			return { isMatch: o, score: o ? 0 : 1, indices: i }
		}
	},
	RW = [wW, wk, SW, BW, TW, DW, IW, _k],
	kme = RW.length,
	Out = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,
	qut = "|"
function Vut(e, t = {}) {
	return e.split(qut).map((r) => {
		let n = r
				.trim()
				.split(Out)
				.filter((s) => s && !!s.trim()),
			i = []
		for (let s = 0, o = n.length; s < o; s += 1) {
			let a = n[s],
				l = !1,
				c = -1
			for (; !l && ++c < kme; ) {
				let u = RW[c],
					f = u.isMultiMatch(a)
				f && (i.push(new u(f, t)), (l = !0))
			}
			if (!l)
				for (c = -1; ++c < kme; ) {
					let u = RW[c],
						f = u.isSingleMatch(a)
					if (f) {
						i.push(new u(f, t))
						break
					}
				}
		}
		return i
	})
}
var Hut = new Set([_k.type, wk.type]),
	kW = class {
		constructor(
			t,
			{
				isCaseSensitive: r = Dt.isCaseSensitive,
				includeMatches: n = Dt.includeMatches,
				minMatchCharLength: i = Dt.minMatchCharLength,
				ignoreLocation: s = Dt.ignoreLocation,
				findAllMatches: o = Dt.findAllMatches,
				location: a = Dt.location,
				threshold: l = Dt.threshold,
				distance: c = Dt.distance,
			} = {},
		) {
			;(this.query = null),
				(this.options = {
					isCaseSensitive: r,
					includeMatches: n,
					minMatchCharLength: i,
					findAllMatches: o,
					ignoreLocation: s,
					location: a,
					threshold: l,
					distance: c,
				}),
				(this.pattern = r ? t : t.toLowerCase()),
				(this.query = Vut(this.pattern, this.options))
		}
		static condition(t, r) {
			return r.useExtendedSearch
		}
		searchIn(t) {
			let r = this.query
			if (!r) return { isMatch: !1, score: 1 }
			let { includeMatches: n, isCaseSensitive: i } = this.options
			t = i ? t : t.toLowerCase()
			let s = 0,
				o = [],
				a = 0
			for (let l = 0, c = r.length; l < c; l += 1) {
				let u = r[l]
				;(o.length = 0), (s = 0)
				for (let f = 0, p = u.length; f < p; f += 1) {
					let g = u[f],
						{ isMatch: m, indices: y, score: C } = g.search(t)
					if (m) {
						if (((s += 1), (a += C), n)) {
							let v = g.constructor.type
							Hut.has(v) ? (o = [...o, ...y]) : o.push(y)
						}
					} else {
						;(a = 0), (s = 0), (o.length = 0)
						break
					}
				}
				if (s) {
					let f = { isMatch: !0, score: a / s }
					return n && (f.indices = o), f
				}
			}
			return { isMatch: !1, score: 1 }
		}
	},
	MW = []
function Wut(...e) {
	MW.push(...e)
}
function FW(e, t) {
	for (let r = 0, n = MW.length; r < n; r += 1) {
		let i = MW[r]
		if (i.condition(e, t)) return new i(e, t)
	}
	return new xk(e, t)
}
var Ik = { AND: "$and", OR: "$or" },
	QW = { PATH: "$path", PATTERN: "$val" },
	NW = (e) => !!(e[Ik.AND] || e[Ik.OR]),
	Gut = (e) => !!e[QW.PATH],
	$ut = (e) => !Jd(e) && Qme(e) && !NW(e),
	Mme = (e) => ({ [Ik.AND]: Object.keys(e).map((t) => ({ [t]: e[t] })) })
function Ume(e, t, { auto: r = !0 } = {}) {
	let n = (i) => {
		let s = Object.keys(i),
			o = Gut(i)
		if (!o && s.length > 1 && !NW(i)) return n(Mme(i))
		if ($ut(i)) {
			let l = o ? i[QW.PATH] : s[0],
				c = o ? i[QW.PATTERN] : i[l]
			if (!Ru(c)) throw new Error(wut(l))
			let u = { keyId: _W(l), pattern: c }
			return r && (u.searcher = FW(c, t)), u
		}
		let a = { children: [], operator: s[0] }
		return (
			s.forEach((l) => {
				let c = i[l]
				Jd(c) &&
					c.forEach((u) => {
						a.children.push(n(u))
					})
			}),
			a
		)
	}
	return NW(e) || (e = Mme(e)), n(e)
}
function Yut(e, { ignoreFieldNorm: t = Dt.ignoreFieldNorm }) {
	e.forEach((r) => {
		let n = 1
		r.matches.forEach(({ key: i, norm: s, score: o }) => {
			let a = i ? i.weight : null
			n *= Math.pow(o === 0 && a ? Number.EPSILON : o, (a || 1) * (t ? 1 : s))
		}),
			(r.score = n)
	})
}
function Kut(e, t) {
	let r = e.matches
	;(t.matches = []),
		Sa(r) &&
			r.forEach((n) => {
				if (!Sa(n.indices) || !n.indices.length) return
				let { indices: i, value: s } = n,
					o = { indices: i, value: s }
				n.key && (o.key = n.key.src), n.idx > -1 && (o.refIndex = n.idx), t.matches.push(o)
			})
}
function Jut(e, t) {
	t.score = e.score
}
function zut(e, t, { includeMatches: r = Dt.includeMatches, includeScore: n = Dt.includeScore } = {}) {
	let i = []
	return (
		r && i.push(Kut),
		n && i.push(Jut),
		e.map((s) => {
			let { idx: o } = s,
				a = { item: t[o], refIndex: o }
			return (
				i.length &&
					i.forEach((l) => {
						l(s, a)
					}),
				a
			)
		})
	)
}
var go = class {
	constructor(t, r = {}, n) {
		;(this.options = { ...Dt, ...r }),
			this.options.useExtendedSearch,
			(this._keyStore = new xW(this.options.keys)),
			this.setCollection(t, n)
	}
	setCollection(t, r) {
		if (((this._docs = t), r && !(r instanceof Tx))) throw new Error(_ut)
		this._myIndex =
			r ||
			Lme(this.options.keys, this._docs, {
				getFn: this.options.getFn,
				fieldNormWeight: this.options.fieldNormWeight,
			})
	}
	add(t) {
		Sa(t) && (this._docs.push(t), this._myIndex.add(t))
	}
	remove(t = () => !1) {
		let r = []
		for (let n = 0, i = this._docs.length; n < i; n += 1) {
			let s = this._docs[n]
			t(s, n) && (this.removeAt(n), (n -= 1), (i -= 1), r.push(s))
		}
		return r
	}
	removeAt(t) {
		this._docs.splice(t, 1), this._myIndex.removeAt(t)
	}
	getIndex() {
		return this._myIndex
	}
	search(t, { limit: r = -1 } = {}) {
		let { includeMatches: n, includeScore: i, shouldSort: s, sortFn: o, ignoreFieldNorm: a } = this.options,
			l = Ru(t)
				? Ru(this._docs[0])
					? this._searchStringList(t)
					: this._searchObjectList(t)
				: this._searchLogical(t)
		return (
			Yut(l, { ignoreFieldNorm: a }),
			s && l.sort(o),
			Fme(r) && r > -1 && (l = l.slice(0, r)),
			zut(l, this._docs, { includeMatches: n, includeScore: i })
		)
	}
	_searchStringList(t) {
		let r = FW(t, this.options),
			{ records: n } = this._myIndex,
			i = []
		return (
			n.forEach(({ v: s, i: o, n: a }) => {
				if (!Sa(s)) return
				let { isMatch: l, score: c, indices: u } = r.searchIn(s)
				l &&
					i.push({
						item: s,
						idx: o,
						matches: [{ score: c, value: s, norm: a, indices: u }],
					})
			}),
			i
		)
	}
	_searchLogical(t) {
		let r = Ume(t, this.options),
			n = (a, l, c) => {
				if (!a.children) {
					let { keyId: f, searcher: p } = a,
						g = this._findMatches({
							key: this._keyStore.get(f),
							value: this._myIndex.getValueForItemAtKeyId(l, f),
							searcher: p,
						})
					return g && g.length ? [{ idx: c, item: l, matches: g }] : []
				}
				let u = []
				for (let f = 0, p = a.children.length; f < p; f += 1) {
					let g = a.children[f],
						m = n(g, l, c)
					if (m.length) u.push(...m)
					else if (a.operator === Ik.AND) return []
				}
				return u
			},
			i = this._myIndex.records,
			s = {},
			o = []
		return (
			i.forEach(({ $: a, i: l }) => {
				if (Sa(a)) {
					let c = n(r, a, l)
					c.length &&
						(s[l] || ((s[l] = { idx: l, item: a, matches: [] }), o.push(s[l])),
						c.forEach(({ matches: u }) => {
							s[l].matches.push(...u)
						}))
				}
			}),
			o
		)
	}
	_searchObjectList(t) {
		let r = FW(t, this.options),
			{ keys: n, records: i } = this._myIndex,
			s = []
		return (
			i.forEach(({ $: o, i: a }) => {
				if (!Sa(o)) return
				let l = []
				n.forEach((c, u) => {
					l.push(...this._findMatches({ key: c, value: o[u], searcher: r }))
				}),
					l.length && s.push({ idx: a, item: o, matches: l })
			}),
			s
		)
	}
	_findMatches({ key: t, value: r, searcher: n }) {
		if (!Sa(r)) return []
		let i = []
		if (Jd(r))
			r.forEach(({ v: s, i: o, n: a }) => {
				if (!Sa(s)) return
				let { isMatch: l, score: c, indices: u } = n.searchIn(s)
				l && i.push({ score: c, key: t, value: s, idx: o, norm: a, indices: u })
			})
		else {
			let { v: s, n: o } = r,
				{ isMatch: a, score: l, indices: c } = n.searchIn(s)
			a && i.push({ score: l, key: t, value: s, norm: o, indices: c })
		}
		return i
	}
}
go.version = "7.0.0"
go.createIndex = Lme
go.parseIndex = Nut
go.config = Dt
go.parseQuery = Ume
Wut(kW)
var e0e = W(gs()),
	Fx = W(require("path")),
	Ba = W(require("vscode"))
function Bs(e) {
	return e.rootPath + "/" + e.relPath
}
function Sk(e) {
	return Bs({ rootPath: e.repoRoot, relPath: e.pathName })
}
var Ome = W(require("vscode"))
function qme(e, t) {
	let r = { type: "file-ranges-selected", data: [] }
	if (!e || !t) return r
	let n = jut(e.document.uri, t),
		i = e.selections
	return (
		n &&
			i.some((s) => !s.isEmpty) &&
			(r.data = i.map((s) => ({
				repoRoot: n.repoRoot,
				pathName: n.pathName,
				fullRange: {
					startLineNumber: s.start.line,
					startColumn: s.start.character,
					endLineNumber: s.end.line,
					endColumn: s.end.character,
				},
				originalCode: e.document.getText(s),
			}))),
		r
	)
}
function Rx(e) {
	return {
		startLineNumber: e.start.line,
		startColumn: e.start.character,
		endLineNumber: e.end.line,
		endColumn: e.end.character,
	}
}
function kx(e) {
	return new Ome.Range(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn)
}
function jut(e, t) {
	let r = t.safeResolvePathName(e)
	if (r !== void 0) return Ph(r)
}
function Ph(e) {
	return { repoRoot: e.rootPath, pathName: e.relPath }
}
var $me = W(jA())
var Dy = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date,
	Hme = new Set(),
	PW = typeof process == "object" && process ? process : {},
	Wme = (e, t, r, n) => {
		typeof PW.emitWarning == "function" ? PW.emitWarning(e, t, r, n) : console.error(`[${r}] ${t}: ${e}`)
	},
	Bk = globalThis.AbortController,
	Vme = globalThis.AbortSignal
if (typeof Bk > "u") {
	;(Vme = class {
		onabort
		_onabort = []
		reason
		aborted = !1
		addEventListener(n, i) {
			this._onabort.push(i)
		}
	}),
		(Bk = class {
			constructor() {
				t()
			}
			signal = new Vme()
			abort(n) {
				if (!this.signal.aborted) {
					;(this.signal.reason = n), (this.signal.aborted = !0)
					for (let i of this.signal._onabort) i(n)
					this.signal.onabort?.(n)
				}
			}
		})
	let e = PW.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1",
		t = () => {
			e &&
				((e = !1),
				Wme(
					"AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.",
					"NO_ABORT_CONTROLLER",
					"ENOTSUP",
					t,
				))
		}
}
var Zut = (e) => !Hme.has(e),
	WMt = Symbol("type"),
	Lh = (e) => e && e === Math.floor(e) && e > 0 && isFinite(e),
	Gme = (e) =>
		Lh(e)
			? e <= Math.pow(2, 8)
				? Uint8Array
				: e <= Math.pow(2, 16)
					? Uint16Array
					: e <= Math.pow(2, 32)
						? Uint32Array
						: e <= Number.MAX_SAFE_INTEGER
							? Ty
							: null
			: null,
	Ty = class extends Array {
		constructor(t) {
			super(t), this.fill(0)
		}
	},
	LW = class e {
		heap
		length
		static #e = !1
		static create(t) {
			let r = Gme(t)
			if (!r) return []
			e.#e = !0
			let n = new e(t, r)
			return (e.#e = !1), n
		}
		constructor(t, r) {
			if (!e.#e) throw new TypeError("instantiate Stack using Stack.create(n)")
			;(this.heap = new r(t)), (this.length = 0)
		}
		push(t) {
			this.heap[this.length++] = t
		}
		pop() {
			return this.heap[--this.length]
		}
	},
	Ry = class e {
		#e
		#t
		#i
		#n
		#r
		#l
		ttl
		ttlResolution
		ttlAutopurge
		updateAgeOnGet
		updateAgeOnHas
		allowStale
		noDisposeOnSet
		noUpdateTTL
		maxEntrySize
		sizeCalculation
		noDeleteOnFetchRejection
		noDeleteOnStaleGet
		allowStaleOnFetchAbort
		allowStaleOnFetchRejection
		ignoreFetchAbort
		#o
		#u
		#d
		#a
		#s
		#p
		#m
		#g
		#f
		#v
		#h
		#E
		#b
		#y
		#x
		#B
		#A
		static unsafeExposeInternals(t) {
			return {
				starts: t.#b,
				ttls: t.#y,
				sizes: t.#E,
				keyMap: t.#d,
				keyList: t.#a,
				valList: t.#s,
				next: t.#p,
				prev: t.#m,
				get head() {
					return t.#g
				},
				get tail() {
					return t.#f
				},
				free: t.#v,
				isBackgroundFetch: (r) => t.#c(r),
				backgroundFetch: (r, n, i, s) => t.#F(r, n, i, s),
				moveToTail: (r) => t.#R(r),
				indexes: (r) => t.#_(r),
				rindexes: (r) => t.#w(r),
				isStale: (r) => t.#C(r),
			}
		}
		get max() {
			return this.#e
		}
		get maxSize() {
			return this.#t
		}
		get calculatedSize() {
			return this.#u
		}
		get size() {
			return this.#o
		}
		get fetchMethod() {
			return this.#r
		}
		get memoMethod() {
			return this.#l
		}
		get dispose() {
			return this.#i
		}
		get disposeAfter() {
			return this.#n
		}
		constructor(t) {
			let {
				max: r = 0,
				ttl: n,
				ttlResolution: i = 1,
				ttlAutopurge: s,
				updateAgeOnGet: o,
				updateAgeOnHas: a,
				allowStale: l,
				dispose: c,
				disposeAfter: u,
				noDisposeOnSet: f,
				noUpdateTTL: p,
				maxSize: g = 0,
				maxEntrySize: m = 0,
				sizeCalculation: y,
				fetchMethod: C,
				memoMethod: v,
				noDeleteOnFetchRejection: b,
				noDeleteOnStaleGet: w,
				allowStaleOnFetchRejection: B,
				allowStaleOnFetchAbort: M,
				ignoreFetchAbort: Q,
			} = t
			if (r !== 0 && !Lh(r)) throw new TypeError("max option must be a nonnegative integer")
			let O = r ? Gme(r) : Array
			if (!O) throw new Error("invalid max value: " + r)
			if (
				((this.#e = r),
				(this.#t = g),
				(this.maxEntrySize = m || this.#t),
				(this.sizeCalculation = y),
				this.sizeCalculation)
			) {
				if (!this.#t && !this.maxEntrySize)
					throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize")
				if (typeof this.sizeCalculation != "function")
					throw new TypeError("sizeCalculation set to non-function")
			}
			if (v !== void 0 && typeof v != "function") throw new TypeError("memoMethod must be a function if defined")
			if (((this.#l = v), C !== void 0 && typeof C != "function"))
				throw new TypeError("fetchMethod must be a function if specified")
			if (
				((this.#r = C),
				(this.#B = !!C),
				(this.#d = new Map()),
				(this.#a = new Array(r).fill(void 0)),
				(this.#s = new Array(r).fill(void 0)),
				(this.#p = new O(r)),
				(this.#m = new O(r)),
				(this.#g = 0),
				(this.#f = 0),
				(this.#v = LW.create(r)),
				(this.#o = 0),
				(this.#u = 0),
				typeof c == "function" && (this.#i = c),
				typeof u == "function" ? ((this.#n = u), (this.#h = [])) : ((this.#n = void 0), (this.#h = void 0)),
				(this.#x = !!this.#i),
				(this.#A = !!this.#n),
				(this.noDisposeOnSet = !!f),
				(this.noUpdateTTL = !!p),
				(this.noDeleteOnFetchRejection = !!b),
				(this.allowStaleOnFetchRejection = !!B),
				(this.allowStaleOnFetchAbort = !!M),
				(this.ignoreFetchAbort = !!Q),
				this.maxEntrySize !== 0)
			) {
				if (this.#t !== 0 && !Lh(this.#t))
					throw new TypeError("maxSize must be a positive integer if specified")
				if (!Lh(this.maxEntrySize)) throw new TypeError("maxEntrySize must be a positive integer if specified")
				this.#q()
			}
			if (
				((this.allowStale = !!l),
				(this.noDeleteOnStaleGet = !!w),
				(this.updateAgeOnGet = !!o),
				(this.updateAgeOnHas = !!a),
				(this.ttlResolution = Lh(i) || i === 0 ? i : 1),
				(this.ttlAutopurge = !!s),
				(this.ttl = n || 0),
				this.ttl)
			) {
				if (!Lh(this.ttl)) throw new TypeError("ttl must be a positive integer if specified")
				this.#Q()
			}
			if (this.#e === 0 && this.ttl === 0 && this.#t === 0)
				throw new TypeError("At least one of max, maxSize, or ttl is required")
			if (!this.ttlAutopurge && !this.#e && !this.#t) {
				let Y = "LRU_CACHE_UNBOUNDED"
				Zut(Y) &&
					(Hme.add(Y),
					Wme(
						"TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.",
						"UnboundedCacheWarning",
						Y,
						e,
					))
			}
		}
		getRemainingTTL(t) {
			return this.#d.has(t) ? 1 / 0 : 0
		}
		#Q() {
			let t = new Ty(this.#e),
				r = new Ty(this.#e)
			;(this.#y = t),
				(this.#b = r),
				(this.#N = (s, o, a = Dy.now()) => {
					if (((r[s] = o !== 0 ? a : 0), (t[s] = o), o !== 0 && this.ttlAutopurge)) {
						let l = setTimeout(() => {
							this.#C(s) && this.#I(this.#a[s], "expire")
						}, o + 1)
						l.unref && l.unref()
					}
				}),
				(this.#D = (s) => {
					r[s] = t[s] !== 0 ? Dy.now() : 0
				}),
				(this.#S = (s, o) => {
					if (t[o]) {
						let a = t[o],
							l = r[o]
						if (!a || !l) return
						;(s.ttl = a), (s.start = l), (s.now = n || i())
						let c = s.now - l
						s.remainingTTL = a - c
					}
				})
			let n = 0,
				i = () => {
					let s = Dy.now()
					if (this.ttlResolution > 0) {
						n = s
						let o = setTimeout(() => (n = 0), this.ttlResolution)
						o.unref && o.unref()
					}
					return s
				}
			;(this.getRemainingTTL = (s) => {
				let o = this.#d.get(s)
				if (o === void 0) return 0
				let a = t[o],
					l = r[o]
				if (!a || !l) return 1 / 0
				let c = (n || i()) - l
				return a - c
			}),
				(this.#C = (s) => {
					let o = r[s],
						a = t[s]
					return !!a && !!o && (n || i()) - o > a
				})
		}
		#D = () => {}
		#S = () => {}
		#N = () => {}
		#C = () => !1
		#q() {
			let t = new Ty(this.#e)
			;(this.#u = 0),
				(this.#E = t),
				(this.#T = (r) => {
					;(this.#u -= t[r]), (t[r] = 0)
				}),
				(this.#P = (r, n, i, s) => {
					if (this.#c(n)) return 0
					if (!Lh(i))
						if (s) {
							if (typeof s != "function") throw new TypeError("sizeCalculation must be a function")
							if (((i = s(n, r)), !Lh(i)))
								throw new TypeError("sizeCalculation return invalid (expect positive integer)")
						} else
							throw new TypeError(
								"invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.",
							)
					return i
				}),
				(this.#k = (r, n, i) => {
					if (((t[r] = n), this.#t)) {
						let s = this.#t - t[r]
						for (; this.#u > s; ) this.#M(!0)
					}
					;(this.#u += t[r]), i && ((i.entrySize = n), (i.totalCalculatedSize = this.#u))
				})
		}
		#T = (t) => {}
		#k = (t, r, n) => {}
		#P = (t, r, n, i) => {
			if (n || i) throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache")
			return 0
		};
		*#_({ allowStale: t = this.allowStale } = {}) {
			if (this.#o)
				for (let r = this.#f; !(!this.#L(r) || ((t || !this.#C(r)) && (yield r), r === this.#g)); )
					r = this.#m[r]
		}
		*#w({ allowStale: t = this.allowStale } = {}) {
			if (this.#o)
				for (let r = this.#g; !(!this.#L(r) || ((t || !this.#C(r)) && (yield r), r === this.#f)); )
					r = this.#p[r]
		}
		#L(t) {
			return t !== void 0 && this.#d.get(this.#a[t]) === t
		}
		*entries() {
			for (let t of this.#_())
				this.#s[t] !== void 0 &&
					this.#a[t] !== void 0 &&
					!this.#c(this.#s[t]) &&
					(yield [this.#a[t], this.#s[t]])
		}
		*rentries() {
			for (let t of this.#w())
				this.#s[t] !== void 0 &&
					this.#a[t] !== void 0 &&
					!this.#c(this.#s[t]) &&
					(yield [this.#a[t], this.#s[t]])
		}
		*keys() {
			for (let t of this.#_()) {
				let r = this.#a[t]
				r !== void 0 && !this.#c(this.#s[t]) && (yield r)
			}
		}
		*rkeys() {
			for (let t of this.#w()) {
				let r = this.#a[t]
				r !== void 0 && !this.#c(this.#s[t]) && (yield r)
			}
		}
		*values() {
			for (let t of this.#_()) this.#s[t] !== void 0 && !this.#c(this.#s[t]) && (yield this.#s[t])
		}
		*rvalues() {
			for (let t of this.#w()) this.#s[t] !== void 0 && !this.#c(this.#s[t]) && (yield this.#s[t])
		}
		[Symbol.iterator]() {
			return this.entries()
		}
		[Symbol.toStringTag] = "LRUCache"
		find(t, r = {}) {
			for (let n of this.#_()) {
				let i = this.#s[n],
					s = this.#c(i) ? i.__staleWhileFetching : i
				if (s !== void 0 && t(s, this.#a[n], this)) return this.get(this.#a[n], r)
			}
		}
		forEach(t, r = this) {
			for (let n of this.#_()) {
				let i = this.#s[n],
					s = this.#c(i) ? i.__staleWhileFetching : i
				s !== void 0 && t.call(r, s, this.#a[n], this)
			}
		}
		rforEach(t, r = this) {
			for (let n of this.#w()) {
				let i = this.#s[n],
					s = this.#c(i) ? i.__staleWhileFetching : i
				s !== void 0 && t.call(r, s, this.#a[n], this)
			}
		}
		purgeStale() {
			let t = !1
			for (let r of this.#w({ allowStale: !0 })) this.#C(r) && (this.#I(this.#a[r], "expire"), (t = !0))
			return t
		}
		info(t) {
			let r = this.#d.get(t)
			if (r === void 0) return
			let n = this.#s[r],
				i = this.#c(n) ? n.__staleWhileFetching : n
			if (i === void 0) return
			let s = { value: i }
			if (this.#y && this.#b) {
				let o = this.#y[r],
					a = this.#b[r]
				if (o && a) {
					let l = o - (Dy.now() - a)
					;(s.ttl = l), (s.start = Date.now())
				}
			}
			return this.#E && (s.size = this.#E[r]), s
		}
		dump() {
			let t = []
			for (let r of this.#_({ allowStale: !0 })) {
				let n = this.#a[r],
					i = this.#s[r],
					s = this.#c(i) ? i.__staleWhileFetching : i
				if (s === void 0 || n === void 0) continue
				let o = { value: s }
				if (this.#y && this.#b) {
					o.ttl = this.#y[r]
					let a = Dy.now() - this.#b[r]
					o.start = Math.floor(Date.now() - a)
				}
				this.#E && (o.size = this.#E[r]), t.unshift([n, o])
			}
			return t
		}
		load(t) {
			this.clear()
			for (let [r, n] of t) {
				if (n.start) {
					let i = Date.now() - n.start
					n.start = Dy.now() - i
				}
				this.set(r, n.value, n)
			}
		}
		set(t, r, n = {}) {
			if (r === void 0) return this.delete(t), this
			let {
					ttl: i = this.ttl,
					start: s,
					noDisposeOnSet: o = this.noDisposeOnSet,
					sizeCalculation: a = this.sizeCalculation,
					status: l,
				} = n,
				{ noUpdateTTL: c = this.noUpdateTTL } = n,
				u = this.#P(t, r, n.size || 0, a)
			if (this.maxEntrySize && u > this.maxEntrySize)
				return l && ((l.set = "miss"), (l.maxEntrySizeExceeded = !0)), this.#I(t, "set"), this
			let f = this.#o === 0 ? void 0 : this.#d.get(t)
			if (f === void 0)
				(f =
					this.#o === 0
						? this.#f
						: this.#v.length !== 0
							? this.#v.pop()
							: this.#o === this.#e
								? this.#M(!1)
								: this.#o),
					(this.#a[f] = t),
					(this.#s[f] = r),
					this.#d.set(t, f),
					(this.#p[this.#f] = f),
					(this.#m[f] = this.#f),
					(this.#f = f),
					this.#o++,
					this.#k(f, u, l),
					l && (l.set = "add"),
					(c = !1)
			else {
				this.#R(f)
				let p = this.#s[f]
				if (r !== p) {
					if (this.#B && this.#c(p)) {
						p.__abortController.abort(new Error("replaced"))
						let { __staleWhileFetching: g } = p
						g !== void 0 &&
							!o &&
							(this.#x && this.#i?.(g, t, "set"), this.#A && this.#h?.push([g, t, "set"]))
					} else o || (this.#x && this.#i?.(p, t, "set"), this.#A && this.#h?.push([p, t, "set"]))
					if ((this.#T(f), this.#k(f, u, l), (this.#s[f] = r), l)) {
						l.set = "replace"
						let g = p && this.#c(p) ? p.__staleWhileFetching : p
						g !== void 0 && (l.oldValue = g)
					}
				} else l && (l.set = "update")
			}
			if (
				(i !== 0 && !this.#y && this.#Q(),
				this.#y && (c || this.#N(f, i, s), l && this.#S(l, f)),
				!o && this.#A && this.#h)
			) {
				let p = this.#h,
					g
				for (; (g = p?.shift()); ) this.#n?.(...g)
			}
			return this
		}
		pop() {
			try {
				for (; this.#o; ) {
					let t = this.#s[this.#g]
					if ((this.#M(!0), this.#c(t))) {
						if (t.__staleWhileFetching) return t.__staleWhileFetching
					} else if (t !== void 0) return t
				}
			} finally {
				if (this.#A && this.#h) {
					let t = this.#h,
						r
					for (; (r = t?.shift()); ) this.#n?.(...r)
				}
			}
		}
		#M(t) {
			let r = this.#g,
				n = this.#a[r],
				i = this.#s[r]
			return (
				this.#B && this.#c(i)
					? i.__abortController.abort(new Error("evicted"))
					: (this.#x || this.#A) &&
						(this.#x && this.#i?.(i, n, "evict"), this.#A && this.#h?.push([i, n, "evict"])),
				this.#T(r),
				t && ((this.#a[r] = void 0), (this.#s[r] = void 0), this.#v.push(r)),
				this.#o === 1 ? ((this.#g = this.#f = 0), (this.#v.length = 0)) : (this.#g = this.#p[r]),
				this.#d.delete(n),
				this.#o--,
				r
			)
		}
		has(t, r = {}) {
			let { updateAgeOnHas: n = this.updateAgeOnHas, status: i } = r,
				s = this.#d.get(t)
			if (s !== void 0) {
				let o = this.#s[s]
				if (this.#c(o) && o.__staleWhileFetching === void 0) return !1
				if (this.#C(s)) i && ((i.has = "stale"), this.#S(i, s))
				else return n && this.#D(s), i && ((i.has = "hit"), this.#S(i, s)), !0
			} else i && (i.has = "miss")
			return !1
		}
		peek(t, r = {}) {
			let { allowStale: n = this.allowStale } = r,
				i = this.#d.get(t)
			if (i === void 0 || (!n && this.#C(i))) return
			let s = this.#s[i]
			return this.#c(s) ? s.__staleWhileFetching : s
		}
		#F(t, r, n, i) {
			let s = r === void 0 ? void 0 : this.#s[r]
			if (this.#c(s)) return s
			let o = new Bk(),
				{ signal: a } = n
			a?.addEventListener("abort", () => o.abort(a.reason), {
				signal: o.signal,
			})
			let l = { signal: o.signal, options: n, context: i },
				c = (y, C = !1) => {
					let { aborted: v } = o.signal,
						b = n.ignoreFetchAbort && y !== void 0
					if (
						(n.status &&
							(v && !C
								? ((n.status.fetchAborted = !0),
									(n.status.fetchError = o.signal.reason),
									b && (n.status.fetchAbortIgnored = !0))
								: (n.status.fetchResolved = !0)),
						v && !b && !C)
					)
						return f(o.signal.reason)
					let w = g
					return (
						this.#s[r] === g &&
							(y === void 0
								? w.__staleWhileFetching
									? (this.#s[r] = w.__staleWhileFetching)
									: this.#I(t, "fetch")
								: (n.status && (n.status.fetchUpdated = !0), this.set(t, y, l.options))),
						y
					)
				},
				u = (y) => (n.status && ((n.status.fetchRejected = !0), (n.status.fetchError = y)), f(y)),
				f = (y) => {
					let { aborted: C } = o.signal,
						v = C && n.allowStaleOnFetchAbort,
						b = v || n.allowStaleOnFetchRejection,
						w = b || n.noDeleteOnFetchRejection,
						B = g
					if (
						(this.#s[r] === g &&
							(!w || B.__staleWhileFetching === void 0
								? this.#I(t, "fetch")
								: v || (this.#s[r] = B.__staleWhileFetching)),
						b)
					)
						return (
							n.status && B.__staleWhileFetching !== void 0 && (n.status.returnedStale = !0),
							B.__staleWhileFetching
						)
					if (B.__returned === B) throw y
				},
				p = (y, C) => {
					let v = this.#r?.(t, s, l)
					v && v instanceof Promise && v.then((b) => y(b === void 0 ? void 0 : b), C),
						o.signal.addEventListener("abort", () => {
							;(!n.ignoreFetchAbort || n.allowStaleOnFetchAbort) &&
								(y(void 0), n.allowStaleOnFetchAbort && (y = (b) => c(b, !0)))
						})
				}
			n.status && (n.status.fetchDispatched = !0)
			let g = new Promise(p).then(c, u),
				m = Object.assign(g, {
					__abortController: o,
					__staleWhileFetching: s,
					__returned: void 0,
				})
			return (
				r === void 0
					? (this.set(t, m, { ...l.options, status: void 0 }), (r = this.#d.get(t)))
					: (this.#s[r] = m),
				m
			)
		}
		#c(t) {
			if (!this.#B) return !1
			let r = t
			return (
				!!r &&
				r instanceof Promise &&
				r.hasOwnProperty("__staleWhileFetching") &&
				r.__abortController instanceof Bk
			)
		}
		async fetch(t, r = {}) {
			let {
				allowStale: n = this.allowStale,
				updateAgeOnGet: i = this.updateAgeOnGet,
				noDeleteOnStaleGet: s = this.noDeleteOnStaleGet,
				ttl: o = this.ttl,
				noDisposeOnSet: a = this.noDisposeOnSet,
				size: l = 0,
				sizeCalculation: c = this.sizeCalculation,
				noUpdateTTL: u = this.noUpdateTTL,
				noDeleteOnFetchRejection: f = this.noDeleteOnFetchRejection,
				allowStaleOnFetchRejection: p = this.allowStaleOnFetchRejection,
				ignoreFetchAbort: g = this.ignoreFetchAbort,
				allowStaleOnFetchAbort: m = this.allowStaleOnFetchAbort,
				context: y,
				forceRefresh: C = !1,
				status: v,
				signal: b,
			} = r
			if (!this.#B)
				return (
					v && (v.fetch = "get"),
					this.get(t, {
						allowStale: n,
						updateAgeOnGet: i,
						noDeleteOnStaleGet: s,
						status: v,
					})
				)
			let w = {
					allowStale: n,
					updateAgeOnGet: i,
					noDeleteOnStaleGet: s,
					ttl: o,
					noDisposeOnSet: a,
					size: l,
					sizeCalculation: c,
					noUpdateTTL: u,
					noDeleteOnFetchRejection: f,
					allowStaleOnFetchRejection: p,
					allowStaleOnFetchAbort: m,
					ignoreFetchAbort: g,
					status: v,
					signal: b,
				},
				B = this.#d.get(t)
			if (B === void 0) {
				v && (v.fetch = "miss")
				let M = this.#F(t, B, w, y)
				return (M.__returned = M)
			} else {
				let M = this.#s[B]
				if (this.#c(M)) {
					let ne = n && M.__staleWhileFetching !== void 0
					return (
						v && ((v.fetch = "inflight"), ne && (v.returnedStale = !0)),
						ne ? M.__staleWhileFetching : (M.__returned = M)
					)
				}
				let Q = this.#C(B)
				if (!C && !Q) return v && (v.fetch = "hit"), this.#R(B), i && this.#D(B), v && this.#S(v, B), M
				let O = this.#F(t, B, w, y),
					j = O.__staleWhileFetching !== void 0 && n
				return (
					v && ((v.fetch = Q ? "stale" : "refresh"), j && Q && (v.returnedStale = !0)),
					j ? O.__staleWhileFetching : (O.__returned = O)
				)
			}
		}
		async forceFetch(t, r = {}) {
			let n = await this.fetch(t, r)
			if (n === void 0) throw new Error("fetch() returned undefined")
			return n
		}
		memo(t, r = {}) {
			let n = this.#l
			if (!n) throw new Error("no memoMethod provided to constructor")
			let { context: i, forceRefresh: s, ...o } = r,
				a = this.get(t, o)
			if (!s && a !== void 0) return a
			let l = n(t, a, { options: o, context: i })
			return this.set(t, l, o), l
		}
		get(t, r = {}) {
			let {
					allowStale: n = this.allowStale,
					updateAgeOnGet: i = this.updateAgeOnGet,
					noDeleteOnStaleGet: s = this.noDeleteOnStaleGet,
					status: o,
				} = r,
				a = this.#d.get(t)
			if (a !== void 0) {
				let l = this.#s[a],
					c = this.#c(l)
				return (
					o && this.#S(o, a),
					this.#C(a)
						? (o && (o.get = "stale"),
							c
								? (o && n && l.__staleWhileFetching !== void 0 && (o.returnedStale = !0),
									n ? l.__staleWhileFetching : void 0)
								: (s || this.#I(t, "expire"), o && n && (o.returnedStale = !0), n ? l : void 0))
						: (o && (o.get = "hit"), c ? l.__staleWhileFetching : (this.#R(a), i && this.#D(a), l))
				)
			} else o && (o.get = "miss")
		}
		#U(t, r) {
			;(this.#m[r] = t), (this.#p[t] = r)
		}
		#R(t) {
			t !== this.#f &&
				(t === this.#g ? (this.#g = this.#p[t]) : this.#U(this.#m[t], this.#p[t]),
				this.#U(this.#f, t),
				(this.#f = t))
		}
		delete(t) {
			return this.#I(t, "delete")
		}
		#I(t, r) {
			let n = !1
			if (this.#o !== 0) {
				let i = this.#d.get(t)
				if (i !== void 0)
					if (((n = !0), this.#o === 1)) this.#O(r)
					else {
						this.#T(i)
						let s = this.#s[i]
						if (
							(this.#c(s)
								? s.__abortController.abort(new Error("deleted"))
								: (this.#x || this.#A) &&
									(this.#x && this.#i?.(s, t, r), this.#A && this.#h?.push([s, t, r])),
							this.#d.delete(t),
							(this.#a[i] = void 0),
							(this.#s[i] = void 0),
							i === this.#f)
						)
							this.#f = this.#m[i]
						else if (i === this.#g) this.#g = this.#p[i]
						else {
							let o = this.#m[i]
							this.#p[o] = this.#p[i]
							let a = this.#p[i]
							this.#m[a] = this.#m[i]
						}
						this.#o--, this.#v.push(i)
					}
			}
			if (this.#A && this.#h?.length) {
				let i = this.#h,
					s
				for (; (s = i?.shift()); ) this.#n?.(...s)
			}
			return n
		}
		clear() {
			return this.#O("delete")
		}
		#O(t) {
			for (let r of this.#w({ allowStale: !0 })) {
				let n = this.#s[r]
				if (this.#c(n)) n.__abortController.abort(new Error("deleted"))
				else {
					let i = this.#a[r]
					this.#x && this.#i?.(n, i, t), this.#A && this.#h?.push([n, i, t])
				}
			}
			if (
				(this.#d.clear(),
				this.#s.fill(void 0),
				this.#a.fill(void 0),
				this.#y && this.#b && (this.#y.fill(0), this.#b.fill(0)),
				this.#E && this.#E.fill(0),
				(this.#g = 0),
				(this.#f = 0),
				(this.#v.length = 0),
				(this.#u = 0),
				(this.#o = 0),
				this.#A && this.#h)
			) {
				let r = this.#h,
					n
				for (; (n = r?.shift()); ) this.#n?.(...n)
			}
		}
	}
var Yme = W(require("vscode"))
var Uh = class extends z {
	constructor(r, n, i) {
		super()
		this._globalState = r
		this._cacheBackKey = n
		this._options = i
		;(this._cache = new Ry({ max: 1e3, ...this._options?.lru })),
			this.loadContext(),
			this.addDisposable(new Yme.Disposable(() => this.dumpContext.cancel()))
	}
	_cache
	dumpContext = (0, $me.default)(
		async () => {
			let r = this._cache.dump()
			await this._globalState.save(this._cacheBackKey, r, {
				uniquePerWorkspace: !0,
			}),
				this._globalState.update(this._cacheBackKey, void 0)
		},
		60 * 1e3,
		{ leading: !0, trailing: !0 },
	)
	loadContext = async () => {
		let r = await this._globalState.load(this._cacheBackKey, {
			uniquePerWorkspace: !0,
		})
		if (r) {
			this._cache.load(r)
			return
		}
		let n = this._globalState.get(this._cacheBackKey)
		n && this._cache.load(n)
	}
	set = async (r, n) => {
		this._cache.set(r, n), await this.dumpContext()
	}
	get = (r) => (this.dumpContext(), this._cache.get(r))
	get cache() {
		return this._cache
	}
	remove = (r) => {
		this._cache.delete(r)
	}
	clear = () => {
		this._cache.clear()
	}
	getItems = () => [...this._cache.values()]
}
var Kme = W(jA()),
	Jme = W(require("vscode"))
var Mx = class extends z {
	constructor(r, n, i) {
		super()
		this._globalState = r
		this._indexBackKey = n
		this._opts = i
		;(this._maxKeysBeforeRemoval = i.maxKeysBeforeRemoval ?? this._maxKeysBeforeRemoval),
			(this._flushDelay = i.maxDelayBeforeRemovalMs ?? this._flushDelay),
			(this._index = new go(Object.values(this._items), {
				...this._opts.fuse,
			})),
			(this._revalidationQueue = new $o(this._revalidateEntry.bind(this))),
			this.addDisposables(this._revalidationQueue, new Jme.Disposable(() => this.dumpContext.cancel())),
			this.loadContext()
	}
	_index
	_items = {}
	_revalidationQueue
	_keysToRemove = new Set()
	_maxKeysBeforeRemoval = 100
	_flushTimer = null
	_flushDelay = 15e3
	dumpContext = (0, Kme.default)(
		async () => {
			await this._globalState.save(this._indexBackKey, this._items, {
				uniquePerWorkspace: !0,
			}),
				this._globalState.update(this._indexBackKey, void 0)
		},
		60 * 1e3,
		{ leading: !0, trailing: !0 },
	)
	loadContext = async () => {
		let r = await this._globalState.load(this._indexBackKey, {
			uniquePerWorkspace: !0,
		})
		if (r) {
			;(this._items = { ...this._items, ...r }),
				(this._index = new go(Object.values(this._items), this._opts.fuse)),
				this.markForRevalidation(Object.values(this._items))
			return
		}
		let n = this._globalState.get(this._indexBackKey)
		n &&
			((this._items = { ...this._items, ...n }),
			(this._index = new go(Object.values(this._items), this._opts.fuse)),
			this.markForRevalidation(Object.values(this._items)))
	}
	set = (r) => {
		let n = this._opts.keyFn(r)
		return (
			this._cancelQueuedWork(n),
			this._items[n] ? !1 : ((this._items[n] = r), this._index.add(r), this.dumpContext(), !0)
		)
	}
	markForRevalidation = (r) => {
		r.forEach((n) => {
			let i = this._opts.keyFn(n)
			this._revalidationQueue.insert(i, n)
		}),
			this._revalidationQueue.kick()
	}
	search = (r, n) => this._index.search(r, n)
	remove = (r) => {
		this._queueKeyRemoval(this._opts.keyFn(r))
	}
	clear = () => {
		;(this._items = {}), this._index.setCollection([])
	}
	get items() {
		return { ...this._items }
	}
	_cancelQueuedWork = (r) => {
		this._revalidationQueue.cancel(r), this._keysToRemove.delete(r)
	}
	_checkValidity = async (r) => (this._opts.validator ? await this._opts.validator(r) : !0)
	async _revalidateEntry(r) {
		if (r === void 0) return
		let [n, i] = r
		;(await this._checkValidity(i)) || this._queueKeyRemoval(n)
	}
	_queueKeyRemoval = (r) => {
		this._keysToRemove.add(r),
			this._keysToRemove.size >= this._maxKeysBeforeRemoval
				? this._flushToRemove()
				: this._flushTimer || (this._flushTimer = setTimeout(() => this._flushToRemove(), this._flushDelay))
	}
	_flushToRemove = () => {
		this._flushTimer && (clearTimeout(this._flushTimer), (this._flushTimer = null))
		for (let r of this._keysToRemove) delete this._items[r]
		this._index.remove((r) => this._keysToRemove.has(this._opts.keyFn(r))), this._keysToRemove.clear()
	}
}
var Mu = {
		keys: ["relPath"],
		minMatchCharLength: 1,
		minExactMatchCharLength: 3,
		threshold: 0.25,
		ignoreLocation: !0,
		includeScore: !0,
		useExtendedSearch: !0,
		shouldSort: !0,
		findAllMatches: !0,
		sortFn: edt,
	},
	Dk = class extends z {
		constructor(r, n, i) {
			super()
			this._globalState = r
			this._workspaceManager = n
			this._onDidChangeSyncingStatus = i
			;(this._filesIndex = new Mx(this._globalState, "fuzzyFsFilesIndex", {
				fuse: Mu,
				validator: this.validatePath,
				keyFn: jme,
			})),
				(this._foldersIndex = new Mx(this._globalState, "fuzzyFsFoldersIndex", {
					fuse: Mu,
					validator: this.validatePath,
					keyFn: jme,
				})),
				(this._recentFiles = new Uh(this._globalState, "recentlyOpenedFiles", {
					lru: { max: 64 },
				})),
				this.addDisposables(
					...this.trackFilesAndFolders(),
					this._recentFiles,
					Ba.window.onDidChangeActiveTextEditor(this.trackRecentTextEditor),
					Ba.window.onDidChangeVisibleTextEditors(this.onDidChangeVisibleTextEditors),
					Ba.window.tabGroups.onDidChangeTabs((s) => {
						s.changed.forEach(this.trackRecentTab), s.opened.forEach(this.trackRecentTab)
					}),
				)
		}
		_foldersIndex
		_filesIndex
		_recentFiles
		dispose = () => {
			super.dispose(), this._filesIndex.clear(), this._foldersIndex.clear()
		}
		get files() {
			return Object.values(this._filesIndex.items)
		}
		get folders() {
			return Object.values(this._foldersIndex.items)
		}
		setFiles = (r) => {
			let n = this._filesIndex.items
			r.forEach((a) => this._filesIndex.set(a))
			let i = this._filesIndex.items,
				o = Object.keys(n)
					.filter((a) => !i[a])
					.map((a) => n[a])
			this._filesIndex.markForRevalidation(o)
		}
		setFolders = (r) => {
			let n = this._foldersIndex.items
			r.forEach((a) => this._foldersIndex.set(a))
			let i = this._foldersIndex.items,
				o = Object.keys(n)
					.filter((a) => !i[a])
					.map((a) => n[a])
			this._foldersIndex.markForRevalidation(o)
		}
		trackRecentAbsPath = (r) => {
			let n = this._workspaceManager.resolvePathName(r)
			n === void 0 || this._workspaceManager.getBlobName(n) === void 0 || this._recentFiles.set(r, n)
		}
		trackRecentTab = (r) => {
			if (r.input instanceof Ba.TabInputText) {
				let n = r.input.uri.fsPath
				this.trackRecentAbsPath(n)
			} else return
		}
		trackRecentTextEditor = (r) => {
			r !== void 0 && this.trackRecentAbsPath(r.document.uri.fsPath)
		}
		onDidChangeVisibleTextEditors = () => {
			let r = Ba.window.visibleTextEditors
			for (let n of r) this.trackRecentTextEditor(n)
		}
		trackFilesAndFolders = () => {
			let r = (0, e0e.throttle)(
					() => {
						let { files: i, folders: s } = Xut(this._workspaceManager)
						this.setFiles(i), this.setFolders(s)
					},
					15e3,
					{ leading: !0, trailing: !0 },
				),
				n = (i) => {
					if (!i?.relPath) return
					this._workspaceManager.getAllQualifiedPathNames(i.relPath).forEach((o) => {
						this._filesIndex.set(o)
					})
				}
			return [
				new Ba.Disposable(() => r.cancel()),
				this._workspaceManager.onDidChangeFile(r),
				this._workspaceManager.onDidChangeFile(n),
				this._onDidChangeSyncingStatus(r),
			]
		}
		findRecentFiles = (r) => {
			let n = r.data.relPath,
				i = r.data.maxResults || 12,
				s = this._recentFiles.getItems().map((a) => ({ repoRoot: a.rootPath, pathName: a.relPath }))
			if (n.length < Mu.minMatchCharLength)
				return {
					type: "find-recently-opened-files-response",
					data: s.slice(0, i),
				}
			let o = zme(s, n, { fuseSearch: { limit: i }, fuseInit: Mu })
			return { type: "find-recently-opened-files-response", data: o }
		}
		findInScope = (r) => {
			let n = r.data.relPath,
				i = r.data.maxResults || 12
			return r.data.searchScope?.files
				? zme(r.data.searchScope.files, n, {
						fuseSearch: { limit: i },
						fuseInit: Mu,
					})
				: []
		}
		findFiles = (r) => {
			let n = r.data.exactMatch ?? !1,
				i = r.data.relPath,
				s = n ? `${i}$` : i,
				o = r.data.maxResults || 12
			if (n && (i.length < Mu.minExactMatchCharLength || i.length < Mu.minMatchCharLength))
				return { type: "find-file-response", data: [] }
			if (i.length < Mu.minMatchCharLength) {
				let u = Object.values(this._filesIndex.items).slice(0, 100)
				return { type: "find-file-response", data: u.map(Ph) }
			}
			let a = { type: "find-file-response", data: [] },
				l = this.findInScope(r)
			return (
				(a.data = UW([...a.data, ...l])),
				n && (a.data = Zme(a.data, i)),
				a.data.length >= o ||
					((a.data = UW([
						...a.data,
						...this._filesIndex.search(s, { limit: o - a.data.length }).map((c) => ({
							repoRoot: c.item.rootPath,
							pathName: c.item.relPath,
						})),
					])),
					n && (a.data = Zme(a.data, i))),
				a
			)
		}
		findFolders = (r) => {
			let n = r.data.exactMatch ?? !1,
				i = r.data.relPath,
				s = n ? `${i}$` : i,
				o = r.data.maxResults || 12
			if (i.length < Mu.minMatchCharLength) {
				let u = Object.values(this._foldersIndex.items).slice(0, 100)
				return { type: "find-folder-response", data: u.map(Ph) }
			}
			let a = { type: "find-folder-response", data: [] },
				l = this._foldersIndex.search(s, { limit: o }).map((c) => Ph(c.item))
			return (a.data = UW([...a.data, ...l])), a
		}
		validatePath = async (r) => this.statPath(r).then((n) => n !== void 0)
		statPath = async (r) => {
			if (
				(await this._workspaceManager.awaitInitialFoldersEnumerated(),
				!!this._workspaceManager.getFolderRoot(Bs(r)))
			)
				try {
					return await xy(Bs(r))
				} catch {
					return
				}
		}
	}
function Xut(e) {
	let t = (o) => e.getAllPathNames(o)[0],
		n = e
			.getContextWithBlobNames()
			.blobNames.map(t)
			.filter((o) => o !== void 0),
		i = new Map(
			n.map((o) => {
				let a = { rootPath: o.rootPath, relPath: _c(o.relPath) }
				return [Bs(a), a]
			}),
		),
		s = Array.from(i.values())
	return { files: n, folders: s }
}
async function t0e(e, t) {
	let r = await ho(Ba.Uri.file(Bs(e))),
		n = new Ba.Range(r.positionAt(t.charStart), r.positionAt(t.charEnd))
	return {
		repoRoot: e.rootPath,
		pathName: e.relPath,
		fullRange: {
			startLineNumber: n.start.line,
			startColumn: n.start.character,
			endLineNumber: n.end.line,
			endColumn: n.end.character,
		},
	}
}
function zme(e, t, r) {
	return new go(e, { ...Mu, ...r.fuseInit, keys: ["relPath"] }).search(t, r.fuseSearch).map((s) => s.item)
}
function UW(e) {
	let t = new Map()
	return (
		e.forEach((r) => {
			let n = Bs({ rootPath: r.repoRoot, relPath: r.pathName })
			t.set(n, r)
		}),
		Array.from(t.values())
	)
}
function jme(e) {
	return Bs(e)
}
function edt(e, t) {
	if (e.score !== t.score) return e.score - t.score
	let r = e.matches?.[0].value,
		n = t.matches?.[0].value
	return r && n ? (r.length === n.length ? r.localeCompare(n) : r.length - n.length) : e.score - t.score
}
function tdt(e, t) {
	let r = Fx.normalize(e),
		n = Fx.normalize(t)
	if (n.length > r.length) return !1
	if (r.endsWith(n)) {
		let i = r.length - n.length
		return i === 0 || r[i - 1] === Fx.sep
	}
	return !1
}
function Zme(e, t) {
	return e.filter((r) => tdt(r.pathName, t))
}
var rdt = 8e5,
	Qx = class {
		_selectedCodeReferenceRequestId = void 0
		_selectedCodeReferenceRequestIdOptionB = void 0
		_selectedCode = void 0
		_filePath = void 0
		_maybeUpdateSelectedCodeReferenceRequestId(t, r, n) {
			let i = n ? this._selectedCodeReferenceRequestIdOptionB : this._selectedCodeReferenceRequestId
			return (
				i === void 0 &&
					r &&
					(n
						? (this._selectedCodeReferenceRequestIdOptionB = t.requestId)
						: (this._selectedCodeReferenceRequestId = t.requestId),
					(i = ky._newRequestReferenceId)),
				i
			)
		}
	},
	ky = class e extends z {
		constructor(r, n, i, s, o, a) {
			super()
			this._globalState = r
			this._apiServer = n
			this._workspaceManager = i
			this._recentChats = s
			this._fuzzySymbolSearcher = o
			this._assetManager = a
			;(this.selectionCache = new Uh(this._globalState, "requestIdSelectionMetadata", { lru: { max: 1e3 } })),
				this.addDisposables(
					r0e.window.onDidChangeTextEditorSelection(() => {
						this._selectedCodeReferenceRequestId = void 0
					}),
					{ dispose: () => this._chatStreams.clear() },
					this.selectionCache,
				)
		}
		_chatStreams = new Map()
		static _newRequestReferenceId = "new"
		_selectedCodeReferenceRequestId
		_preferenceState = new Qx()
		selectionCache
		getDiagnostics = (r) => ({ type: "get-diagnostics-response", data: Bme() })
		_maybeUpdateSelectedCodeReferenceRequestId(r, n) {
			let i = this._selectedCodeReferenceRequestId
			return (
				i === void 0 &&
					n &&
					((this._selectedCodeReferenceRequestId = r.requestId),
					(i = e._newRequestReferenceId),
					this.selectionCache.set(r.requestId, n)),
				i
			)
		}
		async _getVCSChange() {
			return this._workspaceManager !== void 0
				? await this._workspaceManager.getVCSChange()
				: { commits: [], workingDirectory: [] }
		}
		async chat(r, n, i) {
			this._recentChats.addItem(r), X("ChatModel").debug(`Sending chat request with ID: ${r.requestId}`)
			let o
			i === void 0
				? (o = this._maybeUpdateSelectedCodeReferenceRequestId(r, n))
				: ((o = this._preferenceState._maybeUpdateSelectedCodeReferenceRequestId(r, n, i.useOptionB)),
					n?.selectedCode &&
						((this._preferenceState._selectedCode = n.selectedCode),
						(this._preferenceState._filePath = n.path)),
					r.selectedCode &&
						((this._preferenceState._selectedCode = r.selectedCode),
						(this._preferenceState._filePath = r.pathName)))
			let a = await this._getVCSChange(),
				l = this._getRecentChanges(),
				c = await this._apiServer.chat(
					r.requestId,
					r.message,
					r.chatHistory,
					r.blobs,
					r.userGuidedBlobs,
					r.externalSourceIds,
					r.modelId,
					a,
					l,
					o,
					n?.selectedCode || r.selectedCode,
					n?.prefix || r.prefix,
					n?.suffix || r.suffix,
					n?.path || r.pathName,
					n?.language || r.language,
				)
			return (c.workspaceFileChunks = OW(c.workspaceFileChunks || [])), c
		}
		getReferenceReqId() {
			return this._selectedCodeReferenceRequestId
		}
		cancelChatStream = (r) => {
			this._chatStreams.get(r)?.cancel()
		}
		async *getChatStream(r) {
			let n = this._chatStreams.get(r.data.requestId)
			if (n) yield* n.copy()
			else throw new Error(`Chat stream with ID ${r.data.requestId} not found`)
		}
		deleteChatStream = (r) => {
			this._chatStreams.get(r)?.cancel(), this._chatStreams.delete(r)
		}
		async *chatStream(r, n, i) {
			this._recentChats.addItem(r),
				yield* this._chatStreams.get(r.requestId)?.copy() ?? this.startChatStream(r, n, i)
		}
		_getRecentChanges() {
			let r = this._workspaceManager.getContext()
			return By(r.recentChunks)
		}
		resolveWorkspaceFileChunk = async (r) => {
			let n = r.data,
				i = this._workspaceManager.getAllPathNames(n.blobName)[0]
			if (!i) throw new Error(`File chunk with blobName=${n.blobName} not found`)
			return {
				type: "resolve-workspace-file-chunk-response",
				data: await t0e(i, n),
			}
		}
		async *startChatStream(r, n, i) {
			let s = r.requestId,
				o = this._chatStreams.get(s)
			if (o) throw new Error(`Chat stream with ID ${s} already exists`)
			{
				X("ChatModel").debug(`Sending chat stream request with ID: ${r.requestId}`)
				let l
				i === void 0
					? (l = this._maybeUpdateSelectedCodeReferenceRequestId(r, n))
					: ((l = this._preferenceState._maybeUpdateSelectedCodeReferenceRequestId(r, n, i.useOptionB)),
						n?.selectedCode &&
							((this._preferenceState._selectedCode = n.selectedCode),
							(this._preferenceState._filePath = n.path)),
						r.selectedCode &&
							((this._preferenceState._selectedCode = r.selectedCode),
							(this._preferenceState._filePath = r.pathName)))
				let c = await this._getVCSChange(),
					u = this._getRecentChanges(),
					f = n?.path || r.pathName,
					p = f ? this._workspaceManager.getAllQualifiedPathNames(f)[0] : void 0,
					g = n?.prefix || r.prefix,
					m = n?.suffix || r.suffix,
					y = n?.language || r.language,
					C = n?.selectedCode || r.selectedCode,
					v = await this.hydrateChatHistory(r.chatHistory),
					b = this.limitChatHistory(v),
					w = r.nodes ? await this.hydrateRequestNodes(r.nodes) : [],
					B = p
						? this._workspaceManager.getFolderRoot(p?.absPath)
						: this._workspaceManager.getMostRecentlyChangedFolderRoot(),
					M = B ? this._workspaceManager.getRepoRootForFolderRoot(B) : void 0,
					Q = vl(M ?? "", B ?? "")
				Q !== "" && Q !== "." && (r = sdt(r, Q))
				let O = await this._apiServer.chatStream(
						r.requestId,
						r.message,
						b,
						r.blobs,
						r.userGuidedBlobs,
						r.externalSourceIds,
						r.modelId,
						c,
						u,
						l,
						C,
						g,
						m,
						f,
						y,
						i && i.useOptionB ? this._apiServer.sessionId + "-B" : void 0,
						i?.disableAutoExternalSources,
						r.userGuidelines,
						r.workspaceGuidelines,
						r.toolDefinitions,
						w,
						r.mode,
						r.agentMemories,
					),
					Y
				n?.path && p
					? (Y = {
							charStart: g?.length ?? 0,
							charEnd: (g?.length ?? 0) + (C?.length ?? 0),
							blobName: this._workspaceManager.getBlobName(p) ?? "",
						})
					: (Y = void 0),
					(o = new Jp(
						ndt(s, Y, O, async (j) => {
							try {
								let ne = await this.resolveWorkspaceFileChunk({
									type: "resolve-workspace-file-chunk",
									data: j,
								})
								return this._fuzzySymbolSearcher.warmupCache(j.blobName), { ...j, file: ne.data }
							} catch {
								return j
							}
						}),
					)),
					this._chatStreams.set(s, o),
					yield* o.copy()
			}
		}
		sendFeedback = async (r) => (
			await this._apiServer.chatFeedback(r.data), { type: "chat-rating-done", data: r.data }
		)
		saveConversation = async (r) => {
			let n = X("ChatModel"),
				i = await this._apiServer.saveChat(r.data.conversationId, r.data.chatHistory, r.data.title)
			return n.debug(`Saved chat with api server: ${i.url}`), { type: "save-chat-done", data: i }
		}
		hydrateRequestNodes = (r) => {
			let n = X("ChatModel")
			return Promise.all(
				r.map(async (i) => {
					if (i.type === $c.IMAGE_ID) {
						if (!i.image_id_node) return n.error("Invalid image_id_node: missing image_id_node"), i
						let s = i.image_id_node.image_id,
							o = await this._assetManager.loadAsset(s ?? "")
						if (!o) return n.error(`Failed to load asset ${s}`), i
						let a = Buffer.from(o)
							.toString("base64")
							.replace(/^data:.*?;base64,/, "")
						return {
							type: $c.IMAGE,
							id: i.id,
							image_node: { image_data: a, format: _I.PNG },
						}
					}
					return i
				}),
			)
		}
		hydrateChatHistory = async (r) =>
			Promise.all(
				r.map(
					async (n) => (
						n.request_nodes && (n.request_nodes = await this.hydrateRequestNodes(n.request_nodes)), n
					),
				),
			)
		limitChatHistory = (r) => {
			let n = r.length - 1,
				i = 0
			for (; n >= 0; ) {
				let s = r[n]
				if (((i += JSON.stringify(s).length), i > rdt)) break
				n--
			}
			return r.slice(n + 1)
		}
	}
async function* ndt(e, t, r, n) {
	let i = new Set(),
		s = [],
		o = new Ia(async (l) => {
			if (l === void 0) return
			let c = [l, await n(l)]
			s.push(c)
		})
	t && (i.add(t), o.insert(t)), o.kick()
	for await (let l of r) {
		OW(l.workspaceFileChunks ?? []).forEach((f) => {
			i.add(f), o.insert(f)
		}),
			o.kick()
		let u = [...s]
		u.forEach(([f, p]) => {
			i.delete(f)
		}),
			(s = []),
			yield {
				type: "chat-model-reply",
				data: {
					text: l.text,
					requestId: e,
					streaming: !0,
					workspaceFileChunks: u.map(([f, p]) => p),
					nodes: l.nodes,
				},
			}
	}
	let a = await Promise.all([...OW([...i]).map(n)])
	yield {
		type: "chat-model-reply",
		data: { text: "", requestId: e, streaming: !0, workspaceFileChunks: a },
	}
}
function OW(e) {
	let t = new Map()
	for (let n of e) {
		if (n.charStart >= n.charEnd) continue
		let i = t.get(n.blobName) ?? []
		i.push(n), t.set(n.blobName, i)
	}
	let r = []
	for (let [n, i] of t) {
		let s = i
			.sort((o, a) => o.charStart - a.charStart)
			.reduce((o, a) => {
				let l = o[o.length - 1]
				return l && l.charEnd + 1 >= a.charStart ? (l.charEnd = a.charEnd) : o.push(a), o
			}, [])
		r.push(...s)
	}
	return r
}
var idt =
	"- The user is working from the directory `${relPath}`.\n- When the user mentions a file name or when viewing output from shell commands, it is likely relative to `${relPath}`.\n- When creating, deleting, viewing or editing files, first try prepending `${relPath}` to the path.\n- When running shell commands, do not prepend `${relPath}` to the path.\n"
function sdt(e, t) {
	return (
		e.agentMemories
			? (e.agentMemories += `
`)
			: (e.agentMemories = ""),
		(e.agentMemories += idt.replaceAll("${relPath}", t)),
		e
	)
}
var Rk = W(require("vscode"))
var Da = W(require("vscode"))
async function n0e(e) {
	let [t, r, n] = await Promise.all([
		Da.commands.executeCommand("vscode.provideDocumentSemanticTokensLegend", e),
		Da.commands.executeCommand("vscode.provideDocumentSemanticTokens", e),
		ho(e),
	])
	if (!t || !r || !n) return []
	let i = [],
		s = r.data
	for (let o = 0; o < s.length; o += 5) {
		let a = i[i.length - 1],
			l = s[o],
			c = s[o + 1],
			u = s[o + 2],
			f = (a?.range.startLineNumber ?? 0) + l,
			g = (l === 0 ? (a?.range.startColumn ?? 0) : 0) + c,
			m = new Da.Position(f, g),
			C = n.offsetAt(m) + u,
			v = n.positionAt(C),
			b = new Da.Range(m, v),
			w = n.getText(b)
		i.push({
			name: w,
			kind: Da.SymbolKind.String,
			range: Rx(b),
			selectionRange: Rx(b),
			detail: "",
			tags: [],
			children: [],
		})
	}
	return i
}
async function i0e(e, t) {
	let r = Da.Uri.file(Sk(e)),
		n = await ho(r)
	if (!n) return Promise.resolve([])
	let i = e.fullRange ? kx(e.fullRange) : void 0,
		s = i ? n.offsetAt(i.start) : 0,
		o = n.getText(i),
		a = new RegExp(`\\b${t}\\b`, "g"),
		l = o.search(a)
	if (l >= 0) {
		let c = n.positionAt(s + l),
			u = n.positionAt(s + l + t.length),
			f = new Da.Range(c, u)
		return Promise.resolve([
			{
				name: n.getText(f),
				kind: Da.SymbolKind.String,
				range: Rx(f),
				selectionRange: Rx(f),
				detail: "",
				tags: [],
				children: [],
			},
		])
	}
	return Promise.resolve([])
}
var qW = {
		keys: ["name"],
		threshold: 0.05,
		includeScore: !0,
		useExtendedSearch: !0,
		isCaseSensitive: !0,
	},
	odt = 2e4,
	Tk = class extends z {
		constructor(r, n, i, s) {
			super()
			this._globalState = r
			this._config = n
			this._fuzzyFsSearcher = i
			this._workspaceManager = s
			;(this._logger = X("FuzzySymbolSearcher")),
				(this._fileTokensCache = new Uh(this._globalState, "fuzzyBlobNamesToSymbols", {
					lru: { max: 1e3, fetchMethod: this._loadFileDetailSymbols },
				})),
				this.addDisposables(
					Rk.window.onDidChangeActiveTextEditor(async (o) => {
						if (!o) return
						let a = this._workspaceManager.resolvePathName(o.document.uri.fsPath)
						if (!a) return
						let l = this._workspaceManager.getBlobName(a)
						l && (await this.warmupCache(l))
					}),
				)
		}
		_fileTokensCache
		_logger
		findSymbolsRegex = async (r) => {
			if (!this._config.config.enableDebugFeatures) return { type: "find-symbol-response", data: [] }
			let n = r.data.searchScope.files,
				i = (
					await Promise.all(
						n.map(async (o) =>
							(await i0e(o, r.data.query)).map((l) => ({
								...l,
								file: { ...o, range: void 0, fullRange: l.range },
							})),
						),
					)
				).flat(),
				s = s0e(i, r.data.query, { fuseSearch: { limit: 1 }, fuseInit: qW })
			return { type: "find-symbol-response", data: s }
		}
		findSymbols = async (r) => {
			if (!adt(r.data.query)) return { type: "find-symbol-response", data: [] }
			let n = await this.getAllFilteredTokens(r.data.searchScope.files ?? [], {
					filter: !0,
					forceRefresh: !1,
				}),
				i = s0e(n, r.data.query, { fuseSearch: { limit: 1 }, fuseInit: qW })
			return { type: "find-symbol-response", data: i }
		}
		warmupCache = async (r) => {
			let n = this._workspaceManager.getAllPathNames(r)[0]
			if (!n) return
			let i = { repoRoot: n.rootPath, pathName: n.relPath }
			await this._getAllFileTokens(i)
		}
		getAllFilteredTokens = async (r, n) => {
			let i = async (s) => {
				let o = await this._getAllFileTokens(s, n.forceRefresh)
				if (!o) return []
				if (!n.filter || !s.fullRange) return o
				let a = kx(s.fullRange)
				return o.filter((l) => {
					let c = kx(l.range)
					return a.contains(c)
				})
			}
			return (await Promise.all(r.map(i))).flat()
		}
		_loadFileDetailSymbols = async (r, n, { context: i }) => {
			let s = Rk.Uri.file(i.absPath),
				o = !0,
				a = new Promise((l) =>
					setTimeout(() => {
						l(void 0), (o = !1)
					}, i.timeoutMs),
				)
			for (; o; )
				try {
					let l = new Promise((u) => setTimeout(u, 4e3)),
						c = await Promise.race([n0e(s), a])
					if (c === void 0 || c.length > 0) return c ?? []
					await l
				} catch (l) {
					return (
						this._logger.error(
							`Failed to load symbols for ${i.absPath}: ${l instanceof Error ? l.message : String(l)}`,
						),
						[]
					)
				}
			return []
		}
		_getAllFileTokens = async (r, n = !1) => {
			let i = this._getCurrFileDetails(r)
			if (i === void 0) return []
			let s = this._getCurrBlobName(i)
			if (!s) return []
			try {
				let o = await this._fileTokensCache.cache.fetch(s, {
					context: { absPath: Sk(i), blobName: s, timeoutMs: odt },
					forceRefresh: n,
				})
				return o
					? o.map((a) => ({
							name: a.name,
							kind: a.kind,
							range: a.range,
							selectionRange: a.selectionRange,
							detail: a.detail,
							tags: a.tags || [],
							children: [],
							file: { ...r, range: void 0, fullRange: a.range },
						}))
					: []
			} catch (o) {
				let a = o instanceof Error ? o.message : String(o)
				return this._logger.error(`Failed to read file tokens for ${s}: ${a}`), []
			}
		}
		_getCurrBlobName = (r) => {
			let n = new Je(r.repoRoot, r.pathName)
			return this._workspaceManager.getBlobName(n)
		}
		_getCurrFileDetails = (r) => {
			let n = this._workspaceManager.getAllQualifiedPathNames(r.pathName)
			return n.length ? { ...r, repoRoot: n[0].rootPath, pathName: n[0].relPath } : void 0
		}
	}
function s0e(e, t, r) {
	return new go(e, { ...qW, ...r.fuseInit, keys: ["name"] }).search(`${t}$`, r.fuseSearch).map((s) => s.item)
}
function adt(e) {
	return e.length > 0 && !e.match(/[/.\s]/)
}
var o0e = W(require("fs")),
	a0e = W(ZA()),
	VW = W(require("path")),
	Fu = W(require("vscode"))
var kk = class extends z {
	constructor(r, n, i) {
		super()
		this._config = r
		this._flags = n
		this._clientMetricsReporter = i
		this._initializeWorkspaceWatchers(),
			this.addDisposable(
				Fu.workspace.onDidChangeWorkspaceFolders((s) => {
					s.removed.forEach((o) => {
						let a = this._workspaceWatchers.get(o.uri.fsPath)
						a &&
							(a.dispose(),
							this._workspaceWatchers.delete(o.uri.fsPath),
							this._workspaceGuidelinesContent.delete(o.uri.fsPath))
					}),
						s.added.forEach((o) => {
							this._initializeWorkspaceWatcher(o.uri.fsPath)
						})
				}),
			),
			(this._userGuidelinesContent = this._config?.config?.chat.userGuidelines || ""),
			this.addDisposable(
				this._config.onDidChange(() => {
					let s = this._userGuidelinesContent
					;(this._userGuidelinesContent = this._config?.config?.chat.userGuidelines || ""),
						this._guidelinesChangedEmitter.fire(),
						s === "" && this._userGuidelinesContent !== ""
							? this._reportMetric("chat-set-user-guidelines")
							: s !== "" &&
								this._userGuidelinesContent === "" &&
								this._reportMetric("chat-clear-user-guidelines")
				}),
			)
	}
	_workspaceGuidelinesContent = new Map()
	_workspaceWatchers = new Map()
	_userGuidelinesContent = ""
	_guidelinesChangedEmitter = new Fu.EventEmitter()
	get onDidChange() {
		return this._guidelinesChangedEmitter.event
	}
	_initializeWorkspaceWatchers() {
		Fu.workspace.workspaceFolders &&
			Fu.workspace.workspaceFolders.forEach((r) => {
				this._initializeWorkspaceWatcher(r.uri.fsPath)
			})
	}
	_initializeWorkspaceWatcher(r) {
		let n = VW.join(r, ".augment-guidelines")
		this._updateWorkspaceContent(r)
		let i = Fu.workspace.createFileSystemWatcher(n)
		this.addDisposable(i)
		let s = () => this._updateWorkspaceContent(r)
		i.onDidChange(s),
			i.onDidCreate(s),
			i.onDidDelete(() => {
				this._workspaceGuidelinesContent.set(r, "")
			}),
			this._workspaceWatchers.set(r, i)
	}
	_updateWorkspaceContent(r) {
		try {
			let n = VW.join(r, ".augment-guidelines"),
				i = this._workspaceGuidelinesContent.get(r) || "",
				s = o0e.readFileSync(n, "utf8")
			this._workspaceGuidelinesContent.set(r, s),
				this._guidelinesChangedEmitter.fire(),
				i === "" && s !== ""
					? this._reportMetric("chat-set-workspace-guidelines")
					: i !== "" && s === "" && this._reportMetric("chat-clear-workspace-guidelines")
		} catch {
			let n = this._workspaceGuidelinesContent.get(r) || ""
			this._workspaceGuidelinesContent.set(r, ""),
				n !== "" && this._reportMetric("chat-clear-workspace-guidelines")
		}
	}
	getWorkspaceGuidelinesContent(r) {
		return (this._flags.currentFlags.enableGuidelines && this._workspaceGuidelinesContent.get(r)) || ""
	}
	getActiveWorkspacePath(r) {
		let n = Fu.window.activeTextEditor
		if (!n) return
		let i = n.document.uri.fsPath
		return r.safeResolvePathName(i)?.rootPath
	}
	getCurrentWorkspaceGuidelinesContent(r) {
		let n = Fu.workspace.workspaceFolders
		if (!n || n.length === 0) return ""
		if (n.length === 1) return this.getWorkspaceGuidelinesContent(n[0].uri.fsPath)
		let i = this.getActiveWorkspacePath(r)
		return i ? this.getWorkspaceGuidelinesContent(i) : ""
	}
	getUserGuidelinesContent() {
		return this._flags.currentFlags.enableGuidelines ? this._userGuidelinesContent : ""
	}
	getGuidelinesStates() {
		return this._flags.currentFlags.enableGuidelines
			? {
					userGuidelines: {
						enabled: this._userGuidelinesContent.length > 0,
						overLimit:
							this._userGuidelinesContent.length > this._flags.currentFlags.userGuidelinesLengthLimit,
						contents: this._userGuidelinesContent,
						lengthLimit: this._flags.currentFlags.userGuidelinesLengthLimit,
					},
					workspaceGuidelines: Array.from(this._workspaceGuidelinesContent.entries()).map(([r, n]) => ({
						workspaceFolder: r,
						enabled: n.length > 0,
						overLimit: n.length > this._flags.currentFlags.workspaceGuidelinesLengthLimit,
						lengthLimit: this._flags.currentFlags.workspaceGuidelinesLengthLimit,
					})),
				}
			: {
					userGuidelines: {
						enabled: !1,
						overLimit: !1,
						contents: "",
						lengthLimit: this._flags.currentFlags.userGuidelinesLengthLimit,
					},
				}
	}
	_reportMetric = (0, a0e.default)(
		(r) => {
			this._clientMetricsReporter.reportWebviewClientMetric({
				webviewName: "chat",
				client_metric: r,
				value: 1,
			})
		},
		1e3,
		{ leading: !0, trailing: !1 },
	)
}
var Mk = class extends hi {
	constructor(t, r, n, i) {
		super(t, r, n, { ...i }), this.addDisposable(this.onModifiedUpdated(() => void this.writeDocumentToFile()))
	}
	async writeDocumentToFile() {
		await Do().writeFile(this.filePath, this.modifiedCode)
	}
}
var Zk = require("child_process"),
	Wx = W(require("os")),
	Py = W(require("vscode"))
var l0e = ((l) => (
		(l.webSearchV1 = "google_search"),
		(l.webSearch = "web-search"),
		(l.gitHub = "github-api"),
		(l.linear = "linear"),
		(l.notion = "notion"),
		(l.jira = "jira"),
		(l.confluence = "confluence"),
		(l.supabase = "supabase"),
		l
	))(l0e || {}),
	udt = new Set(Object.values(On))
var ddt = new Set(Object.values(l0e))
var fdt = new Set(Object.values(ja))
var E1t = new Set([...udt, ...ddt, ...fdt])
var yi = W(require("vscode"))
var c4 = W(require("fs")),
	Oh = W(require("os")),
	Zp = W(require("path")),
	Wk = W(Xye()),
	Hx = W(require("vscode"))
var a4 = Oh.default.platform(),
	agt = X("AugmentEnvironment")
function eCe() {
	let e
	return (
		a4 === "win32" && process.env.APPDATA
			? (e = Zp.default.join(process.env.APPDATA, "Code", "User"))
			: a4 === "darwin"
				? (e = Zp.default.join(Oh.default.homedir(), "Library", "Application Support", "Code", "User"))
				: a4 === "linux" && (e = Zp.default.join(Oh.default.homedir(), ".config", "Code", "User")),
		e && c4.default.existsSync(e) ? e : null
	)
}
function tCe() {
	let e = Oh.default.homedir(),
		t
	return (
		Oh.default.platform() === "win32"
			? (t = Zp.default.join(e, "Documents"))
			: Oh.default.platform() === "darwin"
				? (t = Zp.default.join(e, "Documents"))
				: Oh.default.platform() === "linux" && (t = Zp.default.join(e, "Documents")),
		t && c4.default.existsSync(t) ? t : null
	)
}
var l4
function Qy() {
	return l4 === void 0 && (l4 = Hx.extensions.getExtension("Augment.vscode-augment")?.packageJSON ?? null), l4
}
var rCe = "0.0.3141592"
function Gr(e, t = Qy()?.version) {
	return !t || e === "" ? !1 : Wk.default.gte(t, e) || t === rCe
}
function u4(e, t = Qy()?.version) {
	return t ? (e === "" ? !1 : Wk.default.lte(t, e) && t !== rCe) : !0
}
function Ko(e) {
	try {
		return Wk.default.gte(Hx.version, e)
	} catch {
		return agt.error(`Failed to parse vscode version: ${Hx.version}`), !1
	}
}
var Gk = class extends z {
		constructor(r, n, i) {
			super()
			this._shellName = r
			this._extensionRoot = n
			this._agentSessionEventReporter = i
			let s = yi.window
			s.onDidEndTerminalShellExecution && Ko("1.93.0")
				? ((this._hasShellIntegration = !0),
					(this._shellExecutionListener = s.onDidEndTerminalShellExecution(async (o) => {
						for (let [a, l] of Array.from(this._processes).reverse())
							if (
								l.terminal === o.terminal &&
								o.execution.commandLine.value === l.command &&
								!l.killed &&
								l.exitCode === null
							) {
								if (((l.exitCode = o.exitCode ?? null), l.readStream)) {
									await Kl(1), this._logger.debug(`Reading exact output for process ${a}`)
									let u = ""
									for await (let f of l.readStream) u += f
									this._isBuggyOutput(u)
										? (this._logger.debug(
												`Buggy output detected for process ${a}. Please upgrade VSCode.`,
											),
											this._agentSessionEventReporter.reportEvent({
												eventName: Is.vsCodeTerminalBuggyOutput,
												conversationId: "",
											}),
											(l.output = await this._getOutputFromClipboard(a)))
										: (l.output = this._stripControlCodes($I(u, this._maxOutputLength)))
								} else l.output = await this._getOutputFromClipboard(a)
								l.terminal !== this._longRunningTerminal && l.terminal.dispose(), (l.killed = !0)
								let c = this._waitResolvers.get(a)
								c && c({ output: l.output, returnCode: l.exitCode })
								break
							}
					})))
				: this._agentSessionEventReporter.reportEvent({
						eventName: Is.vsCodeTerminalShellIntegrationNotAvailable,
						conversationId: "",
					}),
				this.addDisposable(
					yi.window.onDidCloseTerminal(async (o) => {
						for (let [a, l] of this._processes)
							if (l.terminal === o) {
								l.readStream && (l.output = await this._getOutputFromPossiblyIncompleteProcess(l, a)),
									(l.killed = !0),
									(l.exitCode = o.exitStatus?.code ?? -1)
								let c = this._waitResolvers.get(a)
								c && c({ output: l.output, returnCode: l.exitCode })
								break
							}
					}),
				)
		}
		_processes = new Map()
		_waitResolvers = new Map()
		_nextId = 1
		_shellExecutionListener
		_longRunningTerminal
		_hasShellIntegration = !1
		_logger = X("TerminalProcessTools")
		_maxOutputLength = 64 * 1024
		async launch(r, n, i, s) {
			let o = this._nextId++,
				a
			if (
				(s
					? ((!this._longRunningTerminal || this._longRunningTerminal.exitStatus) &&
							(this._longRunningTerminal = this._createTerminal("Augment", n)),
						(a = this._longRunningTerminal))
					: (a = this._createTerminal(`Augment - ${r}`, n)),
				s &&
					Array.from(this._processes.values()).some(
						(c) => c.terminal === a && c.exitCode === null && !c.killed,
					))
			)
				return `Cannot launch another waiting process while another waiting process is running. The id of the existing waiting process is ${o}.
Please wait until this process is complete (you can use a tool for this purpose), or launch the new process as a background process with \`wait=false\`.`
			if (
				(a.show(),
				(this._shellName === "bash" || this._shellName === "powershell") &&
					a === this._longRunningTerminal &&
					(await this._getLastCommand()) === r)
			) {
				let c = this._shellName === "bash" ? ":" : "#"
				this._hasShellIntegration && a.shellIntegration ? a.shellIntegration.executeCommand(c) : a.sendText(c)
				let u = null,
					f = !1
				await yx(
					new Promise((p) => {
						u = setInterval(() => {
							f ||
								((f = !0),
								(async () => {
									try {
										;(await this._getLastCommand()) === c &&
											(u && (clearInterval(u), (u = null)),
											this._logger.debug("Successfully got noop command result."),
											p(void 0))
									} finally {
										f = !1
									}
								})())
						}, 100)
					}),
					1e3,
				)
					.catch(() => {
						this._logger.debug("Timed out waiting for noop command to complete"),
							this._agentSessionEventReporter.reportEvent({
								eventName: Is.vsCodeTerminalTimedOutWaitingForNoopCommand,
								conversationId: "",
							})
					})
					.finally(() => {
						u && (clearInterval(u), (u = null))
					})
			}
			let l = {
				terminal: a,
				command: r,
				lastCommand: await this._getLastCommand(),
				output: "",
				killed: !1,
				readStream: void 0,
				exitCode: null,
			}
			if ((this._processes.set(o, l), this._hasShellIntegration && a.shellIntegration)) {
				let c = a.shellIntegration.executeCommand(r)
				;(l.readStream = c.read()), this._logger.debug(`Using existing shell integration for command: ${r}`)
			} else if (this._hasShellIntegration && yi.window.onDidChangeTerminalShellIntegration) {
				let c
				;(c = yi.window.onDidChangeTerminalShellIntegration((u) => {
					if (u.terminal === a && u.shellIntegration && !l.readStream) {
						let f = u.shellIntegration.executeCommand(r)
						;(l.readStream = f.read()),
							this._logger.debug(`Using shell integration for command: ${r}`),
							c && (c.dispose(), (c = void 0))
					}
				})),
					setTimeout(() => {
						l.readStream ||
							(a.sendText(r),
							this._logger.debug(`Failed to use shell integration for command: ${r}`),
							this._agentSessionEventReporter.reportEvent({
								eventName: Is.vsCodeTerminalFailedToUseShellIntegration,
								conversationId: "",
							})),
							c && (c.dispose(), (c = void 0))
					}, 2e3)
			} else this._logger.debug(`Not using shell integration for command: ${r}`), a.sendText(r)
			return (
				i.addEventListener("abort", () => {
					this.kill(o)
				}),
				o
			)
		}
		_createTerminal(r, n) {
			let i = this._shellName === "bash" ? { PAGER: "cat", LESS: "-FX", GIT_PAGER: "cat" } : void 0
			return yi.window.createTerminal({
				name: r,
				shellPath: this._shellName,
				cwd: n,
				env: i,
				iconPath: {
					light: yi.Uri.joinPath(this._extensionRoot, "media", "panel-icon-light.svg"),
					dark: yi.Uri.joinPath(this._extensionRoot, "media", "panel-icon-dark.svg"),
				},
				isTransient: !0,
			})
		}
		async kill(r) {
			let n = this._processes.get(r)
			if (!(!n || n.killed))
				return (
					n.terminal === this._longRunningTerminal ? n.terminal.sendText("", !1) : n.terminal.dispose(),
					(n.killed = !0),
					(n.exitCode = -1),
					(n.output = await this._getOutputFromPossiblyIncompleteProcess(n, r)),
					n.output
				)
		}
		isInLongRunningTerminal(r) {
			let n = this._processes.get(r)
			return !!n && n.terminal === this._longRunningTerminal
		}
		async readOutput(r) {
			let n = this._processes.get(r)
			return n
				? n.exitCode !== null
					? { output: n.output, returnCode: n.exitCode }
					: (n.terminal.show(),
						{
							output: await this._getOutputFromPossiblyIncompleteProcess(n, r),
							returnCode: n.exitCode,
						})
				: void 0
		}
		writeInput(r, n) {
			let i = this._processes.get(r)
			return !i || i.killed ? !1 : (i.terminal.sendText(n), !0)
		}
		listProcesses() {
			let r = []
			for (let [n, i] of this._processes.entries()) {
				let s = i.killed ? "killed" : "running"
				r.push({ id: n, command: i.command, state: s, returnCode: i.exitCode })
			}
			return r
		}
		waitForProcess(r, n, i) {
			return new Promise((s) => {
				;(async () => {
					let o = this._processes.get(r)
					if (!o) {
						s({ output: "", returnCode: null })
						return
					}
					if (o.exitCode !== null) {
						s({ output: o.output, returnCode: o.exitCode })
						return
					}
					let a = setTimeout(
							() => {
								this._waitResolvers.delete(r),
									this.readOutput(r).then((u) => {
										s({ output: u?.output ?? "", returnCode: null })
									})
							},
							n !== void 0 ? n * 1e3 : 999999,
						),
						l
					if (o.lastCommand === o.command) {
						this._logger.debug("Last command is the same as the current one."),
							this._agentSessionEventReporter.reportEvent({
								eventName: Is.vsCodeTerminalLastCommandIsSameAsCurrent,
								conversationId: "",
							})
						let u = await this.readOutput(r)
						u
							? s(u)
							: (this._logger.debug(`Failed to read output for process ${r}`),
								this._agentSessionEventReporter.reportEvent({
									eventName: Is.vsCodeTerminalFailedToReadOutput,
									conversationId: "",
								}),
								s({ output: "", returnCode: null }))
					} else
						(l = setInterval(() => {
							;(async () => {
								if ((await this._getLastCommand()) === o.command) {
									this._logger.debug(`Polling determined process ${r} is done.`),
										this._agentSessionEventReporter.reportEvent({
											eventName: Is.vsCodeTerminalPollingDeterminedProcessIsDone,
											conversationId: "",
										}),
										clearInterval(l)
									let f = await this.readOutput(r)
									;(o.output = f?.output ?? ""),
										(o.exitCode = f?.returnCode ?? null),
										(o.killed = !0),
										f
											? s(f)
											: (this._logger.debug(`Failed to read output for process ${r}`),
												this._agentSessionEventReporter.reportEvent({
													eventName: Is.vsCodeTerminalFailedToReadOutput,
													conversationId: "",
												}),
												s({ output: "", returnCode: null }))
								}
							})()
						}, 1e3)),
							this._waitResolvers.set(r, (u) => {
								clearTimeout(a), clearInterval(l), this._waitResolvers.delete(r), s(u)
							})
					let c = () => {
						clearTimeout(a),
							clearInterval(l),
							this._waitResolvers.delete(r),
							s({ output: "", returnCode: null })
					}
					i.addEventListener("abort", c)
				})()
			})
		}
		async _getOutputFromPossiblyIncompleteProcess(r, n) {
			if (r.readStream) {
				this._logger.debug(`Reading exact intermediate output for process ${n}`)
				let i = ""
				try {
					let s = async (l) => {
							let c = new Promise((u) => {
								setTimeout(() => u({ done: !0, value: void 0 }), 100)
							})
							return Promise.race([l.next(), c])
						},
						o = r.readStream[Symbol.asyncIterator](),
						a = await s(o)
					for (; !a.done; ) a.value !== void 0 && (i += a.value), (a = await s(o))
				} catch (s) {
					this._logger.debug(`Error reading stream for process ${n}: ${s.message ?? ""}`),
						this._agentSessionEventReporter.reportEvent({
							eventName: Is.vsCodeTerminalFailedToReadOutput,
							conversationId: "",
						})
				}
				return this._stripControlCodes($I(i, this._maxOutputLength))
			} else return await this._getOutputFromClipboard(n)
		}
		async _getOutputFromClipboard(r) {
			this._logger.debug(`Reading approximate output for process ${r}`),
				this._agentSessionEventReporter.reportEvent({
					eventName: Is.vsCodeTerminalReadingApproximateOutput,
					conversationId: "",
				})
			let n = await yi.env.clipboard.readText()
			await yi.env.clipboard.writeText(""),
				await yi.commands.executeCommand("workbench.action.terminal.copyLastCommandOutput")
			let i = await yi.env.clipboard.readText()
			return await yi.env.clipboard.writeText(n), $I(i, this._maxOutputLength)
		}
		async _getLastCommand() {
			let r = await yi.env.clipboard.readText()
			await yi.env.clipboard.writeText(""),
				await yi.commands.executeCommand("workbench.action.terminal.copyLastCommand")
			let n = await yi.env.clipboard.readText()
			return await yi.env.clipboard.writeText(r), n
		}
		closeAllProcesses() {
			for (let r of this._processes.values())
				!r.killed && r.terminal !== this._longRunningTerminal && r.terminal.dispose()
			this._processes.clear(),
				this._longRunningTerminal && (this._longRunningTerminal.dispose(), (this._longRunningTerminal = void 0))
		}
		cleanup() {
			this.closeAllProcesses(),
				this._shellExecutionListener &&
					(this._shellExecutionListener.dispose(), (this._shellExecutionListener = void 0)),
				this.dispose()
		}
		getLongRunningTerminalInfo() {
			if (!(!this._hasShellIntegration || !this._longRunningTerminal))
				return {
					terminal_id: 0,
					current_working_directory: this._longRunningTerminal.shellIntegration?.cwd?.fsPath,
				}
		}
		_stripControlCodes(r) {
			return r
				.replace(/\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])/g, "")
				.replace(/(?:\x1b\])?(\d+;[^\x07\x1b]*(?:\x07|\x1b\\))/g, "")
		}
		_isBuggyOutput(r) {
			return !Ko("1.98.0") && !r.includes("\x1B]633;D") && !r.includes("\x1B]133;D")
		}
	},
	Ny = class e extends rn {
		constructor(r, n, i, s) {
			super(On.launchProcess, n().shellCommandsAlwaysSafe ? xt.Safe : xt.Check)
			this._workspaceManager = r
			this._getAgentConfig = n
			this.processTools = i
			this._shellName = s
			this._allowlist = ym(process.platform, this._shellName)
		}
		static defaultWaitSeconds = 60
		_allowlist
		version = 2
		get description() {
			return `Launch a new process with a shell command. A process can be waiting (\`wait=true\`) or non-waiting (\`wait=false\`, which is default).

If \`wait=true\`, launches the process in an interactive terminal, and waits for the process to complete up to
\`wait_seconds\` seconds (default: ${e.defaultWaitSeconds}). If the process ends
during this period, the tool call returns. If the timeout expires, the process will continue running in the
background but the tool call will return. You can then interact with the process using the other process tools.

Note: Only one waiting process can be running at a time. If you try to launch a process with \`wait=true\`
while another is running, the tool will return an error.

If \`wait=false\`, launches a background process in a separate terminal. This returns immediately, while the
process keeps running in the background.

Notes:
- Use \`wait=true\` processes when the command is expected to be short, or when you can't
proceed with your task until the process is complete. Use \`wait=false\` for processes that are
expected to run in the background, such as starting a server you'll need to interact with, or a
long-running process that does not need to complete before proceeding with the task.
- If this tool returns while the process is still running, you can continue to interact with the process
using the other available tools. You can wait for the process, read from it, write to it, kill it, etc.
- You can use this tool to interact with the user's local version control system. Do not use the
retrieval tool for that purpose.
- If there is a more specific tool available that can perform the function, use that tool instead of
this one.

The OS is ${process.platform}. The shell is '${this._shellName}'.`
		}
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				command: {
					type: "string",
					description: "The shell command to execute.",
				},
				wait: {
					type: "boolean",
					description: "Optional: whether to wait for the command to complete (default false).",
				},
				wait_seconds: {
					type: "number",
					description: `Optional: number of seconds to wait for the command to complete (default is ${e.defaultWaitSeconds}). Only relevant when wait=true.`,
				},
				cwd: {
					type: "string",
					description:
						"Working directory for the command. If not supplied, uses the current working directory.",
				},
			},
			required: ["command"],
		})
		checkToolCallSafe(r) {
			if (this._getAgentConfig().shellCommandsAlwaysSafe) return !0
			let n = r.command
			return Cm(this._allowlist, n, this._shellName)
		}
		async call(r, n, i) {
			try {
				let s = r.wait,
					o = r.wait_seconds
				if (s === void 0 && o !== void 0) return ut("wait_seconds is specified but wait is not.")
				let a = r.cwd ?? Kd(this._workspaceManager),
					l = !!s,
					c = await this.processTools.launch(r.command, a, i, l)
				if (typeof c == "string") return ut(c)
				if (!s) return Zt(`Process launched with terminal ID ${c}`)
				let u = await this.processTools.waitForProcess(c, o ?? e.defaultWaitSeconds, i),
					f = iCe(c, this.processTools, this._workspaceManager)
				return u.returnCode === null
					? Zt(`Command may still be running. You can use read_process to get more output
and kill_process to terminate it if needed.
Terminal ID ${c}
Output so far:
<output>
${u.output}
</output>
${f}`)
					: {
							text: `Here are the results from executing the command.
<return-code>
${u.returnCode}
</return-code>
<output>
${u.output}
</output>
${f}`,
							isError: u.returnCode !== 0,
						}
			} catch (s) {
				return ut(`Failed to launch process: ${s.message ?? ""}`)
			}
		}
	},
	$k = class extends rn {
		constructor(r) {
			super(On.killProcess, xt.Safe)
			this._processTools = r
		}
		description = "Kill a process by its terminal ID."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				terminal_id: { type: "integer", description: "Terminal ID to kill." },
			},
			required: ["terminal_id"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		async call(r, n, i) {
			let s = r.terminal_id,
				o = await this._processTools.kill(s)
			return o
				? Zt(`Terminal ${s} killed
<output>${o}</output>`)
				: ut(`Terminal ${s} not found`)
		}
	},
	Yk = class extends rn {
		constructor(r, n) {
			super(On.readProcess, xt.Safe)
			this._processTools = r
			this._workspaceManager = n
		}
		description = "Read output from a terminal."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				terminal_id: {
					type: "integer",
					description: "Terminal ID to read from.",
				},
			},
			required: ["terminal_id"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		async call(r, n, i) {
			let s = r.terminal_id,
				o = await this._processTools.readOutput(s)
			if (!o) return ut(`Terminal ${s} not found`)
			let a = iCe(s, this._processTools, this._workspaceManager),
				l = o.returnCode !== null ? "completed" : "still running",
				c = `Here is the output from terminal ${s} (status: ${l}):
<output>${o.output}</output>
`
			return (
				o.returnCode !== null &&
					(c += `<return-code>
${o.returnCode}
</return-code>
`),
				a && (c += a),
				Zt(c)
			)
		}
	},
	Kk = class extends rn {
		constructor(r) {
			super(On.writeProcess, xt.Safe)
			this._processTools = r
		}
		description = "Write input to a terminal."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				terminal_id: {
					type: "integer",
					description: "Terminal ID to write to.",
				},
				input_text: {
					type: "string",
					description: "Text to write to the process's stdin.",
				},
			},
			required: ["terminal_id", "input_text"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		call(r, n, i) {
			let s = r.terminal_id,
				o = r.input_text
			return this._processTools.writeInput(s, o)
				? Promise.resolve(Zt(`Input written to terminal ${s}`))
				: Promise.resolve(ut(`Terminal ${s} not found or write failed`))
		}
	},
	Jk = class extends rn {
		constructor(r) {
			super(On.listProcesses, xt.Safe)
			this._processTools = r
		}
		description = "List all known terminals and their states."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {},
			required: [],
		})
		checkToolCallSafe(r) {
			return !0
		}
		call(r, n, i) {
			let s = this._processTools.listProcesses()
			if (s.length === 0) return Promise.resolve(Zt("No processes found"))
			let o = s.map((a) => {
				let l = a.state
				return (
					a.returnCode !== null && (l += ` (return code: ${a.returnCode})`),
					`Terminal ${a.id}: ${a.command} - ${l}`
				)
			})
			return Promise.resolve(
				Zt(
					`Here are all known processes:

` +
						o.join(`
`),
				),
			)
		}
	},
	zk = class extends rn {
		constructor(r) {
			super(On.waitProcess, xt.Safe)
			this._processTools = r
		}
		description = "Wait for a process to complete or timeout."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				process_id: { type: "integer", description: "Process ID to wait for." },
				wait: {
					type: "number",
					description: "Number of seconds to wait for the process to complete.",
				},
			},
			required: ["process_id", "wait"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		async call(r, n, i) {
			let s = r.process_id,
				o = r.wait,
				a = await this._processTools.waitForProcess(s, o, i)
			return a.returnCode === null
				? Zt(`Command still running after ${o} seconds.`)
				: Zt(`Process ${s} completed with return code ${a.returnCode}.`)
		}
	}
function iCe(e, t, r) {
	let n = t.getLongRunningTerminalInfo()?.current_working_directory
	if (!t.isInLongRunningTerminal(e) || !n) return
	let i = r.safeResolvePathName(n)?.relPath
	return (
		i != null && !Qh(i) && (i = `//${i}`),
		`The terminal's current working directory is now \`${i ?? n}\`.
`
	)
}
var sCe = (e, t, r, n, i, s) => (o, a) => new d4(o, t, e, a, r, n, i, s),
	d4 = class e extends hm {
		constructor(r, n, i, s, o, a, l, c) {
			let u = [],
				f = process.platform === "win32" ? "powershell" : "bash",
				p,
				g
			r === Mn.agent
				? (u.push(new f4(n, o, i)),
					a.currentFlags?.vscodeAgentEditTool !== YI.strReplaceEditor &&
						(u.push(new jk(n)), u.push(new h4(n, i, o))),
					u.push(new g4(i, o, a, c)),
					u.push(new p4()),
					s().useIDETerminalForShellCommands
						? ((g = new Gk(f, l, c)),
							u.push(new Ny(n, s, g, f)),
							u.push(new $k(g)),
							u.push(new Yk(g, n)),
							u.push(new Kk(g)),
							u.push(new Jk(g)),
							u.push(new zk(g)))
						: ((p = new A4()),
							u.push(new m4(n, s, p, f)),
							u.push(new y4(p)),
							u.push(new C4(p)),
							u.push(new v4(p)),
							u.push(new E4(p)),
							u.push(new b4(p))))
				: u.push(new jk(n))
			super(u, Ro.localToolHost)
			this._chatMode = r
			this._workspaceManager = n
			this._apiServer = i
			this._getAgentConfig = s
			this._checkpointManager = o
			this._featureFlagManager = a
			this._extensionRoot = l
			this._agentSessionEventReporter = c
			;(this._processTools = p), (this._terminalProcessTools = g)
		}
		_processTools
		_terminalProcessTools
		async close(r = !1) {
			await super.close(),
				this._processTools !== void 0 && this._processTools.close(),
				this._terminalProcessTools !== void 0 && this._terminalProcessTools.cleanup()
		}
		closeAllToolProcesses() {
			return (
				this._processTools !== void 0 && this._processTools.close(),
				this._terminalProcessTools !== void 0 && this._terminalProcessTools.closeAllProcesses(),
				Promise.resolve()
			)
		}
		factory(r) {
			return new e(
				this._chatMode,
				this._workspaceManager,
				this._apiServer,
				this._getAgentConfig,
				this._checkpointManager,
				this._featureFlagManager,
				this._extensionRoot,
				this._agentSessionEventReporter,
			)
		}
	},
	jk = class extends rn {
		constructor(r) {
			super(On.readFile, xt.Safe)
			this._workspaceManager = r
		}
		description = "Read a file."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				file_path: {
					type: "string",
					description: "The path of the file to read.",
				},
			},
			required: ["file_path"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		async call(r, n, i) {
			let s = r.file_path
			try {
				let o = await Sy(s, this._workspaceManager)
				return o === void 0 ? ut(`Cannot read file: ${s}`) : Zt(o)
			} catch (o) {
				return ut(`Failed to read file: ${s}: ${o.message ?? ""}`)
			}
		}
	},
	f4 = class extends rn {
		constructor(r, n, i) {
			super(On.saveFile, xt.Safe)
			this._workspaceManager = r
			this._checkpointManager = n
			this._requestIdCreator = i
		}
		description =
			"Save a new file. Use this tool to write new files with the attached content. It CANNOT modify existing files. Do NOT use this tool to edit an existing file by overwriting it entirely. Use the str-replace-editor tool to edit existing files instead."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				file_path: {
					type: "string",
					description: "The path of the file to save.",
				},
				file_content: {
					type: "string",
					description: "The content of the file.",
				},
				add_last_line_newline: {
					type: "boolean",
					description: "Whether to add a newline at the end of the file (default: true).",
				},
			},
			required: ["file_path", "file_content"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		async call(r, n, i) {
			let s = r.file_path
			try {
				let o = r.file_content,
					a = r.add_last_line_newline ?? !0,
					l =
						o +
						(a
							? `
`
							: ""),
					c = (await Sy(s, this._workspaceManager)) ?? "",
					u = Du(s, this._workspaceManager)
				if (u === void 0) return ut(`Cannot resolve path: ${s}`)
				if (Pn(u.absPath)) return ut(`File already exists: ${u.absPath}`)
				let f = new hi(u, c, l, {})
				if (c === l) return f.dispose(), Zt(`No changes made to file {${s}}`)
				let p = n.at(-1)?.request_id ?? this._requestIdCreator.createRequestId(),
					g = this._checkpointManager.currentConversationId ?? ""
				return (
					await this._checkpointManager.addCheckpoint(
						{ conversationId: g, path: u },
						{
							sourceToolCallRequestId: p,
							timestamp: Date.now(),
							document: f,
							conversationId: g,
						},
					),
					Zt(`File saved.  Saved file {${s}}`)
				)
			} catch (o) {
				return ut(`Failed to save file: ${s}: ${o.message ?? ""}`)
			}
		}
	},
	h4 = class extends rn {
		constructor(r, n, i) {
			super(On.editFile, xt.Safe)
			this._workspaceManager = r
			this._apiServer = n
			this._checkpointManager = i
		}
		_maxDiagnosticDelayMs = 5e3
		description = `
Edit a file. Accepts a file path and a description of the edit.
This tool can edit whole files.
The description should be detailed and precise, and include all required information to perform the edit.
It can include both natural language and code. It can include multiple code snippets to described different
edits in the file. It can include descriptions of how to perform these edits precisely.

All the contents that should go in a file should be placed in a markdown code block, like this:

<begin-example>
Add a function called foo.

\`\`\`
def foo():
    ...
\`\`\`
</end-example>

This includes all contents, even if it's not code.

Be precise or I will take away your toys.

Prefer to use this tool when editing parts of a file.
`
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				file_path: {
					type: "string",
					description: "The path of the file to edit.",
				},
				edit_summary: {
					type: "string",
					description: "A brief description of the edit to be made. 1-2 sentences.",
				},
				detailed_edit_description: {
					type: "string",
					description:
						"A detailed and precise description of the edit. Can include natural language and code snippets.",
				},
			},
			required: ["file_path", "edit_summary", "detailed_edit_description"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		async call(r, n, i) {
			let s = r.file_path,
				o
			try {
				let a = r.edit_summary,
					l = r.detailed_edit_description,
					c = await Sy(s, this._workspaceManager)
				if (c === void 0) return ut(`Cannot read file: ${s}`)
				let u = Du(s, this._workspaceManager)
				if (u === void 0) return ut(`Cannot resolve path: ${s}`)
				let f = this._getDiagnostics()
				o = this._apiServer.createRequestId()
				let p = await this._apiServer.agentEditFile(o, s, a, l, c, i)
				if (p.isError) return ut(`Failed to edit file: ${s}`, o)
				let g = new hi(u, c, p.modifiedFileContents, {})
				if (c === p.modifiedFileContents) return g.dispose(), Zt(`No changes made to file {${s}}`, o)
				let m = n.at(-1)?.request_id ?? o,
					y = this._checkpointManager.currentConversationId ?? ""
				await this._checkpointManager.addCheckpoint(
					{ conversationId: y, path: u },
					{
						sourceToolCallRequestId: m,
						timestamp: Date.now(),
						document: g,
						conversationId: y,
					},
				)
				let C = await this._waitForNewDiagnostics(f),
					v = this._filterDiagnosticsMap(C, f),
					b = Array.from(v.entries()).map(
						([Q, O]) => `${Q}
${O.map((Y) => `${Y.range.start.line}-${Y.range.end.line}: ${Y.message}`).join(`
`)}`,
					).join(`

`),
					w = C.get(u.absPath) ?? [],
					M = this._filterDiagnostics(w, v.get(u.absPath) ?? []).map(
						(Q) => `${Q.range.start.line}-${Q.range.end.line}: ${Q.message}`,
					).join(`
`)
				return Zt(
					`File edited successfully.  Saved file {${s}}.  New diagnostics:
${b}

Additional ${s} diagnostics:
${M}`,
					o,
				)
			} catch (a) {
				return ut(`Failed to edit file: ${s}: ${a.message ?? ""}`, o)
			}
		}
		_getDiagnostics() {
			let r = new Map()
			return (
				Py.languages.getDiagnostics().forEach(([n, i]) => {
					i.length > 0 && r.set(n.fsPath, i)
				}),
				r
			)
		}
		_filterDiagnosticsMap(r, n) {
			let i = new Map()
			return (
				r.forEach((s, o) => {
					let a = n.get(o) ?? [],
						l = this._filterDiagnostics(s, a)
					l.length > 0 && i.set(o, l)
				}),
				i
			)
		}
		_filterDiagnostics(r, n) {
			return r.filter(
				(i) =>
					!n.some(
						(s) =>
							i.range.start.line === s.range.start.line &&
							i.range.end.line === s.range.end.line &&
							i.message === s.message &&
							i.severity === s.severity,
					),
			)
		}
		async _waitForNewDiagnostics(r) {
			let n = Date.now(),
				i = this._getDiagnostics()
			for (; Date.now() - n < this._maxDiagnosticDelayMs; ) {
				let s = this._getDiagnostics(),
					o = this._filterDiagnosticsMap(s, r)
				if (this._hasDifferentDiagnostics(o, this._filterDiagnosticsMap(i, r))) return s
				;(i = s), await Kl(1e3)
			}
			return i
		}
		_hasDifferentDiagnostics(r, n) {
			if (r.size !== n.size) return !0
			for (let [i, s] of r) {
				let o = n.get(i)
				if (!o || s.length !== o.length) return !0
				for (let a = 0; a < s.length; a++) {
					let l = s[a],
						c = o[a]
					if (
						l.range.start.line !== c.range.start.line ||
						l.range.end.line !== c.range.end.line ||
						l.message !== c.message ||
						l.severity !== c.severity
					)
						return !0
				}
			}
			return !1
		}
	},
	g4 = class extends rn {
		constructor(r, n, i, s) {
			super(On.remember, xt.Safe)
			this._apiServer = r
			this._checkpointManager = n
			this._featureFlagManager = i
			this._agentSessionEventReporter = s
			this.memoryRingBuffer = new Gc(this.maxMemoryBufferSize)
		}
		modelName = void 0
		memoryRingBuffer
		maxMemoryBufferSize = 1e3
		description = `Call this tool when user asks you:
- to remember something
- to create memory/memories

Use this tool only with information that can be useful in the long-term.
Do not use this tool for temporary information.
`
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				memory: {
					type: "string",
					description: "The concise (1 sentence) memory to remember.",
				},
			},
			required: ["memory"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		async call(r, n, i) {
			let s = r.memory
			this.memoryRingBuffer.addItem(s)
			let o = r.isComplexNewMemory ?? !1,
				a = r.caller ?? fk.unspecified,
				l = r.memoriesRequestId,
				c = hk.create(a, o)
			if (
				((this.modelName = this._featureFlagManager.currentFlags.memoriesParams?.remember_tool_model_name),
				!this.modelName)
			)
				return c.setFlag(Wr.rememberToolModelNameMissing), ut("Failed to save memory.")
			this.modelName === "default" && (this.modelName = void 0), l && c.setRequestId(Wr.memoriesRequestId, l)
			let u
			try {
				u = await this.injectMemories(s, o, c)
			} catch {
				c.setFlag(Wr.exceptionThrown)
			} finally {
				u === void 0 && (u = ut("Failed to save memory.")),
					c.setFlag(Wr.toolOutputIsError, u.isError),
					this._agentSessionEventReporter.reportEvent({
						eventName: Is.rememberToolCall,
						conversationId: "",
						eventData: { rememberToolCallData: c },
					})
			}
			return u
		}
		async injectMemories(r, n, i) {
			i.setFlag(Wr.injectionStarted)
			let s = await vk(this._checkpointManager.getAgentMemoriesAbsPath)
			if ((i.setStringStats(Wr.injectionCurrentMemoriesStats, s), !s))
				return (
					r.trim().split(`
`).length === 1 && (r = `- ${r}`),
					this._setMemories(r, "", i)
				)
			let o
			if (
				(n
					? (o = this._featureFlagManager.currentFlags.memoriesParams.complex_injection_prompt)
					: (o = this._featureFlagManager.currentFlags.memoriesParams.injection_prompt),
				!o)
			)
				return i.setFlag(Wr.injectionPromptMissing), ut("Failed to save memory.")
			;(o = o.replace("{currentMemories}", s).replace("{newMemory}", r)),
				i.setStringStats(Wr.injectionPromptStats, o)
			try {
				let a = this._apiServer.createRequestId()
				i.setRequestId(Wr.injectionRequestId, a)
				let l = await this._callModel(o, a, i)
				return i.setStringStats(Wr.injectionUpdatedMemoriesStats, l), this._setMemories(l, s, i)
			} catch {
				return i.setFlag(Wr.injectionFailed), ut("Failed to save memory.")
			}
		}
		async _callModel(r, n, i) {
			let s = await Kp(r, n, [], [], [], Mn.chat, this.modelName)
			for await (let { nodes: o = [] } of s) {
				let a = o.find((l) => l.type === Jl.RAW_RESPONSE)?.content
				if (a) {
					let l = a.indexOf("```"),
						c = a.lastIndexOf("```")
					return l !== -1 && c !== -1 && c > l + 3
						? a.substring(l + 3, c).trim()
						: (i.setFlag(Wr.injectionNoCodeWrapper),
							a
								.trim()
								.replace(/^`+|`+$/g, "")
								.trim())
				}
			}
			throw new Error("Model call failed")
		}
		async _setMemories(r, n, i) {
			i.setFlag(Wr.setMemoriesStart)
			let s = this._featureFlagManager.currentFlags.memoriesParams.upper_bound_size
			if (!s)
				return (
					i.setFlag(Wr.setMemoriesUpperBoundSizeMissing),
					Promise.resolve(ut("Failed to save memories: upper bound size missing"))
				)
			let o = r
				.split(
					`
`,
				)
				.filter((u) => u.trim()).length
			i.setNum(Wr.setMemoriesNonEmptyLines, o), o >= s && (r = await this._compressMemories(r, i))
			let a = this._checkpointManager.getAgentMemoriesAbsPath()
			if (!a)
				return (
					i.setFlag(Wr.setMemoriesNoMemoriesFile),
					Promise.resolve(ut("Failed to save memories: no memories file available"))
				)
			let l = new Mk(new Je("", a), n, n, {}),
				c = l.updateBuffer(r)
			return (
				i.setFlag(Wr.setMemoriesUpdateBufferFailed, !c),
				r === n
					? (i.setFlag(Wr.setMemoriesNoChangesMade),
						l.dispose(),
						Promise.resolve(Zt("No changes made to memories")))
					: (l.dispose(),
						Promise.resolve(c ? Zt("Memories saved successfully.") : ut("Failed to update buffer")))
			)
		}
		async _compressMemories(r, n) {
			n.setFlag(Wr.compressionStarted)
			let i = this._featureFlagManager.currentFlags.memoriesParams.compression_target
			if (!i) return n.setFlag(Wr.compressionTargetMissing), r
			let s = this._featureFlagManager.currentFlags.memoriesParams.compression_prompt
			if (!s) return n.setFlag(Wr.compressionPromptMissing), r
			let o = this._featureFlagManager.currentFlags.memoriesParams.num_recent_memories_to_keep
			if (o === void 0) return n.setFlag(Wr.compressionNumRecentMemoriesToKeepMissing), r
			if (
				(n.setNum(Wr.compressionMemoriesQueueSize, this.memoryRingBuffer.length),
				o > 0 && s.includes("{recentMemoriesSubprompt}") && this.memoryRingBuffer.length > 0)
			) {
				let a = this._featureFlagManager.currentFlags.memoriesParams.recent_memories_subprompt
				if (a === void 0) return n.setFlag(Wr.compressionRecentMemoriesSubpromptMissing), r
				let l = this.memoryRingBuffer.slice(-o).map((c) => `- ${c}`).join(`
`)
				;(a = a.replace("{recentMemories}", l)), (s = s.replace("{recentMemoriesSubprompt}", a))
			}
			;(s = s.replace("{memories}", r).replace("{compressionTarget}", i.toString())),
				n.setStringStats(Wr.compressionPromptStats, s)
			try {
				let a = this._apiServer.createRequestId()
				n.setRequestId(Wr.compressionRequestId, a)
				let l = await this._callModel(s, a, n)
				return n.setStringStats(Wr.compressionMemoriesStats, l), l
			} catch {
				return n.setFlag(Wr.compressionFailed), r
			}
		}
	},
	p4 = class extends rn {
		constructor() {
			super(On.openBrowser, xt.Safe)
		}
		description = `Open a URL in the default browser.

1. The tool takes in a URL and opens it in the default browser.
2. The tool does not return any content. It is intended for the user to visually inspect and interact with the page. You will not have access to it.`
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				url: { type: "string", description: "The URL to open in the browser." },
			},
			required: ["url"],
		})
		checkToolCallSafe(t) {
			return !0
		}
		async call(t, r, n) {
			try {
				let i = t.url,
					s = Py.Uri.parse(i)
				return (await Py.env.openExternal(s))
					? Zt(`Opened ${i} in browser`)
					: ut(`Failed to open ${i} in browser: system denied the request`)
			} catch (i) {
				return ut(`Failed to open URL in browser: ${i.message ?? ""}`)
			}
		}
	},
	A4 = class {
		_processes = new Map()
		_stdoutBuffers = new Map()
		_stderrBuffers = new Map()
		_lastReadStdout = new Map()
		_lastReadStderr = new Map()
		_charBudget
		constructor(t = 1e5) {
			this._charBudget = t
		}
		launch(t, r, n, i) {
			let s = { cwd: r, shell: i, stdio: ["pipe", "pipe", "pipe"], signal: n }
			;(Wx.default.platform() === "linux" || Wx.default.platform() === "darwin") && (s.detached = !0)
			let o = (0, Zk.spawn)(t, [], s)
			if (o.pid == null) return
			let a = o.pid
			return (
				this._processes.set(a, o),
				this._stdoutBuffers.set(a, []),
				this._stderrBuffers.set(a, []),
				this._lastReadStdout.set(a, 0),
				this._lastReadStderr.set(a, 0),
				o.stdout?.on("data", (l) => {
					let c = this._stdoutBuffers.get(a)
					for (c.push(l.toString("utf8")); c.join("").length > this._charBudget; ) c.shift()
				}),
				o.stderr?.on("data", (l) => {
					let c = this._stderrBuffers.get(a)
					for (c.push(l.toString("utf8")); c.join("").length > this._charBudget; ) c.shift()
				}),
				o.on("close", () => {}),
				a
			)
		}
		kill(t) {
			let r = this._processes.get(t)
			try {
				return Wx.default.platform() === "linux" || Wx.default.platform() === "darwin"
					? ((0, Zk.execSync)(`kill -9 -${t}`), !0)
					: (r && r.kill(), !0)
			} catch {
				return !1
			}
		}
		readOutput(t) {
			let r = this._processes.get(t)
			if (!r) return
			let n = this._stdoutBuffers.get(t),
				i = this._stderrBuffers.get(t),
				s = this._lastReadStdout.get(t),
				o = this._lastReadStderr.get(t),
				a = n.slice(s).join(""),
				l = i.slice(o).join("")
			return (
				this._lastReadStdout.set(t, n.length),
				this._lastReadStderr.set(t, i.length),
				{ stdout: a, stderr: l, returnCode: r.exitCode }
			)
		}
		writeInput(t, r) {
			let n = this._processes.get(t)
			return !n || !n.stdin ? !1 : n.stdin.write(r)
		}
		listProcesses() {
			let t = []
			for (let [r, n] of this._processes.entries()) {
				let i = n.killed ? "killed" : n.exitCode !== null ? "completed" : "running"
				t.push({
					pid: r,
					command: n.spawnargs.join(" "),
					state: i,
					returnCode: n.exitCode,
				})
			}
			return t
		}
		waitForProcess(t, r, n) {
			return new Promise((i) => {
				let s = this._processes.get(t)
				if (!s) {
					i({ stdout: "", stderr: "", returnCode: null })
					return
				}
				let o = setTimeout(() => {
					let a = this.readOutput(t)
					i({
						stdout: a?.stdout ?? "",
						stderr: a?.stderr ?? "",
						returnCode: null,
					})
				}, r * 1e3)
				n.addEventListener("abort", () => {
					clearTimeout(o), i({ stdout: "", stderr: "", returnCode: null })
				}),
					s.on("close", (a) => {
						clearTimeout(o)
						let l = this.readOutput(t)
						i({
							stdout: l?.stdout ?? "",
							stderr: l?.stderr ?? "",
							returnCode: a,
						})
					})
			})
		}
		close() {
			for (let t of this._processes.values()) !t.killed && t.exitCode === null && t.pid && this.kill(t.pid)
			this._processes.clear(),
				this._stdoutBuffers.clear(),
				this._stderrBuffers.clear(),
				this._lastReadStdout.clear(),
				this._lastReadStderr.clear()
		}
	},
	m4 = class e extends rn {
		constructor(r, n, i, s) {
			super(On.launchProcess, n().shellCommandsAlwaysSafe ? xt.Safe : xt.Check)
			this._workspaceManager = r
			this._getAgentConfig = n
			this._processTools = i
			this._shellName = s
			this._allowlist = ym(process.platform, this._shellName)
		}
		static defaultWaitSeconds = 60
		_allowlist
		version = 2
		description = `Launch a new process with a shell command. A process can be waiting (\`wait=true\`) or non-waiting (\`wait=false\`, which is default).

If \`wait=true\`, launches the process in an interactive terminal, and waits for the process to complete up to
\`wait_seconds\` seconds (default: ${e.defaultWaitSeconds}). If the process ends
during this period, the tool call returns. If the timeout expires, the process will continue running in the
background but the tool call will return. You can then interact with the process using the other process tools.

Note: Only one waiting process can be running at a time. If you try to launch a process with \`wait=true\`
while another is running, the tool will return an error.

If \`wait=false\`, launches a background process in a separate terminal. This returns immediately, while the
process keeps running in the background.

Notes:
- Use \`wait=true\` processes when the command is expected to be short, or when you can't
proceed with your task until the process is complete. Use \`wait=false\` for processes that are
expected to run in the background, such as starting a server you'll need to interact with, or a
long-running process that does not need to complete before proceeding with the task.
- If this tool returns while the process is still running, you can continue to interact with the process
using the other available tools. You can wait for the process, read from it, write to it, kill it, etc.
- You can use this tool to interact with the user's local version control system. Do not use the
retrieval tool for that purpose.
- If there is a more specific tool available that can perform the function, use that tool instead of
this one.

The OS is ${process.platform}.`
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				command: {
					type: "string",
					description: "The shell command to execute",
				},
				wait: {
					type: "boolean",
					description: "Optional: whether to wait for the command to complete (default false)",
				},
				wait_seconds: {
					type: "number",
					description:
						"Optional: number of seconds to wait for the command to complete (default 60). Only relevant when wait=true.",
				},
				cwd: {
					type: "string",
					description:
						"Working directory for the command. If not supplied, uses the current working directory.",
				},
			},
			required: ["command"],
		})
		checkToolCallSafe(r) {
			if (this._getAgentConfig().shellCommandsAlwaysSafe) return !0
			let n = r.command
			return Cm(this._allowlist, n, this._shellName)
		}
		async call(r, n, i) {
			try {
				let s = r.command,
					o = r.wait ?? !1,
					a = r.wait_seconds ?? e.defaultWaitSeconds
				if (!o && a !== void 0) return ut("You cannot set wait_seconds without wait=true.")
				let l = r.cwd ?? Kd(this._workspaceManager),
					c = this._processTools.launch(s, l, i, this._shellName)
				if (c === void 0) return ut("Failed to launch process")
				if (!o) return Zt(`Process launched with PID ${c}`)
				let u = await this._processTools.waitForProcess(c, a, i)
				return u.returnCode === null
					? Zt(`Command is still running after ${o} seconds. You can use read_process to get more output
and kill_process to terminate it if needed.
PID ${c}
Output so far:
<stdout>
${u.stdout}
</stdout>
<stderr>
${u.stderr}
</stderr>`)
					: Zt(`Here are the results from executing the command.
<return-code>
${u.returnCode}
</return-code>
<stdout>
${u.stdout}
</stdout>
<stderr>
${u.stderr}
</stderr>`)
			} catch (s) {
				return ut(`Failed to launch process: ${s.message ?? ""}`)
			}
		}
	},
	y4 = class extends rn {
		constructor(r) {
			super(On.killProcess, xt.Safe)
			this._processTools = r
		}
		description = "Kill a process by its process ID."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				process_id: { type: "integer", description: "Process ID to kill." },
			},
			required: ["process_id"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		call(r, n, i) {
			let s = r.process_id
			return this._processTools.kill(s)
				? Promise.resolve(Zt(`Process ${s} killed`))
				: Promise.resolve(ut(`Process ${s} not found`))
		}
	},
	C4 = class extends rn {
		constructor(r) {
			super(On.readProcess, xt.Safe)
			this._processTools = r
		}
		description = "Read output from a running process."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				process_id: {
					type: "integer",
					description: "Process ID to read from.",
				},
			},
			required: ["process_id"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		call(r, n, i) {
			let s = r.process_id,
				o = this._processTools.readOutput(s)
			if (!o) return Promise.resolve(ut(`Process ${s} not found`))
			let a = o.returnCode !== null ? "completed" : "still running",
				l = `Here is the output from process ${s} (status: ${a}):
<stdout>
${o.stdout}
</stdout>
<stderr>
${o.stderr}
</stderr>`
			return (
				o.returnCode !== null &&
					(l += `
<return-code>
${o.returnCode}
</return-code>`),
				Promise.resolve(Zt(l))
			)
		}
	},
	v4 = class extends rn {
		constructor(r) {
			super(On.writeProcess, xt.Safe)
			this._processTools = r
		}
		description = "Write input to a process's stdin."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				process_id: { type: "integer", description: "Process ID to write to." },
				input_text: {
					type: "string",
					description: "Text to write to the process's stdin.",
				},
			},
			required: ["process_id", "input_text"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		call(r, n, i) {
			let s = r.process_id,
				o = r.input_text
			return this._processTools.writeInput(s, o)
				? Promise.resolve(Zt(`Input written to process ${s}`))
				: Promise.resolve(ut(`Process ${s} not found or write failed`))
		}
	},
	E4 = class extends rn {
		constructor(r) {
			super(On.listProcesses, xt.Safe)
			this._processTools = r
		}
		description = "List all known processes and their states."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {},
			required: [],
		})
		checkToolCallSafe(r) {
			return !0
		}
		call(r, n, i) {
			let s = this._processTools.listProcesses()
			if (s.length === 0) return Promise.resolve(Zt("No processes found"))
			let o = s.map((a) => {
				let l = a.state
				return (
					a.returnCode !== null && (l += ` (return code: ${a.returnCode})`),
					`PID ${a.pid}: ${a.command} - ${l}`
				)
			})
			return Promise.resolve(
				Zt(
					`Here are all known processes:

` +
						o.join(`
`),
				),
			)
		}
	},
	b4 = class extends rn {
		constructor(r) {
			super(On.waitProcess, xt.Safe)
			this._processTools = r
		}
		description = "Wait for a process to complete or timeout."
		inputSchemaJson = JSON.stringify({
			type: "object",
			properties: {
				process_id: { type: "integer", description: "Process ID to wait for." },
				wait: {
					type: "number",
					description: "Number of seconds to wait for the process to complete.",
				},
			},
			required: ["process_id", "wait"],
		})
		checkToolCallSafe(r) {
			return !0
		}
		async call(r, n, i) {
			let s = r.process_id,
				o = r.wait,
				a = await this._processTools.waitForProcess(s, o, i)
			return a.returnCode === null
				? Zt(`Command still running after ${o} seconds.`)
				: Zt(`Process ${s} completed with return code ${a.returnCode}.`)
		}
	}
var Xk = class {
	constructor(t, r) {
		this._apiServer = t
		this._configListener = r
	}
	_logger = X("VSCodeRemoteInfo")
	async retrieveRemoteTools(t) {
		try {
			return (await this._apiServer.listRemoteTools(t)).tools
		} catch (r) {
			return this._logger.error("Failed to list remote tools", r), []
		}
	}
	filterToolsWithExtraInput(t) {
		let r = new Set()
		for (let n of t) this._getExtraToolInput(n) !== void 0 && r.add(n)
		return Promise.resolve(r)
	}
	async runRemoteTool(t, r, n, i, s) {
		return await this._apiServer.runRemoteTool(t, r, n, i, this._getExtraToolInput(i), s)
	}
	async checkToolSafety(t, r) {
		return await this._apiServer.checkToolSafety(t, r)
	}
	_getExtraToolInput(t) {
		switch (t) {
			case Li.Jira:
			case Li.Confluence:
				return this._configListener.config.integrations.atlassian
			case Li.Notion:
				return this._configListener.config.integrations.notion
			case Li.Linear:
				return this._configListener.config.integrations.linear
			case Li.GitHubApi:
				return this._configListener.config.integrations.github
			default:
				return
		}
	}
}
var oCe = W(require("vscode"))
var eM = class e {
	constructor(t) {
		this._extensionContext = t
	}
	static assetSubdirectory = "augment-user-assets"
	async saveAsset(t, r) {
		let n = await this._getUri(t)
		await ame(n.fsPath, r)
	}
	async loadAsset(t) {
		let r = await this._getUri(t)
		try {
			return await Ak(r.fsPath)
		} catch {
			return
		}
	}
	async deleteAsset(t) {
		let r = await this._getUri(t)
		return await cme(r.fsPath)
	}
	async _getUri(t) {
		let r = this._extensionContext.storageUri ?? this._extensionContext.globalStorageUri,
			n = $t(r.fsPath, e.assetSubdirectory)
		;(await $d(n)) || (await Su(n))
		let i = _c(t)
		if (i) {
			let s = $t(n, i)
			;(await $d(s)) || (await Su(s))
		}
		return oCe.Uri.file($t(n, t))
	}
}
var Gx = class {
	constructor(t) {
		this._featureFlagManager = t
	}
	get flags() {
		return {
			enableAgentMode: Gr(this._featureFlagManager.currentFlags.vscodeAgentModeMinVersion ?? ""),
			enableChatWithTools: Gr(this._featureFlagManager.currentFlags.vscodeChatWithToolsMinVersion ?? ""),
			agentEditTool: this._featureFlagManager.currentFlags.vscodeAgentEditTool ?? "",
			memoriesParams: this._featureFlagManager.currentFlags.memoriesParams ?? {},
		}
	}
}
var Ic = W(require("vscode"))
var aCe = W(require("vscode"))
function lCe(e) {
	return e.absPath.startsWith("Untitled-")
}
function tM(e) {
	return aCe.workspace.textDocuments.find((r) => r.isUntitled && r.uri.path === e.absPath)
}
var rM = class {
	constructor(t) {
		this._workspaceManager = t
	}
	getCwd() {
		return Promise.resolve(Kd(this._workspaceManager))
	}
	async readFile(t) {
		await this._workspaceManager.awaitInitialFoldersEnumerated()
		let r = await Sy(t, this._workspaceManager),
			n = Du(t, this._workspaceManager)
		return { contents: r, filepath: n }
	}
	async writeFile(t, r) {
		let n = await lgt(t)
		if (!n || n.getText() === r) return
		let i = new Ic.WorkspaceEdit()
		i.replace(n.uri, new Ic.Range(0, 0, n.lineCount, 0), r), await Ic.workspace.applyEdit(i), await n.save()
	}
}
async function lgt(e) {
	try {
		let t
		if (lCe(e)) t = tM(e)
		else if (Pn(e.absPath)) t = await Ic.workspace.openTextDocument(e.absPath)
		else {
			let r = Ic.Uri.file(e.absPath)
			await Ic.workspace.fs.writeFile(r, Buffer.from("")), (t = await Ic.workspace.openTextDocument(r))
		}
		if (t === void 0) throw new Error(`Failed to open document ${e.absPath}`)
		return t
	} catch {
		return
	}
}
var nM = class {
	constructor(t, r) {
		this._apiServer = t
		this._workspaceManager = r
	}
	async chatStream(t, r, n, i, s, o, a) {
		return await this._apiServer.chatStream(
			r,
			t,
			n,
			{ checkpointId: void 0, addedBlobs: [], deletedBlobs: [] },
			[],
			[],
			a ?? void 0,
			{ workingDirectory: [], commits: [] },
			[],
			void 0,
			void 0,
			void 0,
			void 0,
			void 0,
			void 0,
			void 0,
			void 0,
			void 0,
			void 0,
			i,
			s,
			o,
		)
	}
	agentCodebaseRetrieval(t, r, n, i, s) {
		return this._apiServer.agentCodebaseRetrieval(t, r, this._workspaceManager.getContext().blobs, n, i, s)
	}
	logToolUseRequestEvent(t) {
		return this._apiServer.logToolUseRequestEvent(t)
	}
	logAgentSessionEvent(t) {
		return this._apiServer.logAgentSessionEvent(t)
	}
}
var fF = W(require("vscode"))
var $h = W(require("vscode"))
var cCe = W(require("assert")),
	sM = W(require("vscode"))
var iM = class extends z {
		constructor(r) {
			super()
			this._config = r
			;(this._logger = X("CommandManager")),
				this.addDisposable(
					new sM.Disposable(() => {
						this._commands.forEach((n, i) => {
							n.unregister(), this._commands.delete(i)
						})
					}),
				),
				this.addDisposable(
					this._config.onDidChange(() => {
						this.register(this.allCommands)
					}),
				)
		}
		_commands = new Map()
		_groups = []
		_logger
		register(r) {
			for (let n of r) {
				if (this._commands.has(n.commandID)) {
					this._commands.get(n.commandID)?.update(this._config)
					continue
				}
				n.register(this._config), this._commands.set(n.commandID, n)
			}
		}
		registerGroup(r, n) {
			this._logger.debug(`Registering group '${r}' with ${n.length} commands.`),
				this._groups.push({ name: r, commands: n }),
				this.register(n)
		}
		get availableCommands() {
			return Array.from(this._commands.values()).filter((r) => r.isRegistered && r.canRun())
		}
		get availableCommandGroups() {
			let r = []
			for (let n = 0; n < this._groups.length; n++) {
				let { name: i, commands: s } = this._groups[n],
					o = s.filter((a) => a.isRegistered && a.canRun())
				o.length !== 0 &&
					(r.length > 0 && r[r.length - 1].name === i
						? r[r.length - 1].commands.push(...o)
						: r.push({ name: i, commands: o }))
			}
			return r
		}
		get allCommands() {
			return Array.from(this._commands.values())
		}
	},
	lt = class extends z {
		constructor(r = void 0, n = !0) {
			super()
			this._title = r
			this._showInActionPanel = n
			let i = this.constructor
			typeof i.commandID == "string" && (this._commandID = i.commandID),
				this.addDisposable({ dispose: () => this.unregister() })
		}
		_registration
		_logger = X("AugmentCommand")
		static commandID
		_commandID
		get commandID() {
			return (
				(0, cCe.default)(
					typeof this._commandID == "string",
					`commandID must be defined on subclass ${this.constructor.name}`,
				),
				this._commandID
			)
		}
		get title() {
			if (typeof this._title == "string") return this._title
			if (typeof this._title == "function") return this._title()
		}
		get showInActionPanel() {
			return this._showInActionPanel
		}
		get isRegistered() {
			return this._registration !== void 0
		}
		canRun() {
			return !0
		}
		register(r) {
			this._registration === void 0 &&
				((this.type === "debug" && !r.config.enableDebugFeatures) ||
					(this._registration = sM.commands.registerCommand(this.commandID, (...n) => {
						if (!this.canRun()) {
							this._logger.debug(`Not running '${this.commandID}' command with type ${this.type}.`)
							return
						}
						this.run(...n)
					})))
		}
		update(r) {
			this.type === "debug" && (r.config.enableDebugFeatures ? this.register(r) : this.dispose())
		}
		unregister() {
			this._registration?.dispose(), (this._registration = void 0)
		}
	}
var Jo = class extends lt {
	constructor(r, n = void 0, i = !0) {
		super(n, i)
		this._syncingEnabledTracker = r
	}
	_syncingEnabled() {
		return (
			this._syncingEnabledTracker.syncingEnabledState === "enabled" ||
			this._syncingEnabledTracker.syncingEnabledState === "partial"
		)
	}
	canRun() {
		return this._syncingEnabled()
	}
}
var aM = class extends Error {
		constructor() {
			super("Invalid source folder uri")
		}
	},
	lM = class extends Error {
		constructor(t) {
			super(`cannot access source folder: ${t}`)
		}
	},
	cM = class extends Error {
		constructor() {
			super("source folder is not a directory")
		}
	},
	uM = class extends Error {
		constructor() {
			super("source folder already exists")
		}
	},
	dM = class extends Error {
		constructor() {
			super("source folder is home directory")
		}
	},
	fM = class extends Error {
		constructor() {
			super("source folder is not an external source folder")
		}
	},
	hM = class extends Error {
		constructor() {
			super("source folder does not exist in workspace")
		}
	}
var gM = class extends Error {
		constructor() {
			super("source folder enumeration is not complete")
		}
	},
	Ly = ((s) => (
		(s[(s.vscodeWorkspaceFolder = 0)] = "vscodeWorkspaceFolder"),
		(s[(s.externalFolder = 1)] = "externalFolder"),
		(s[(s.nestedWorkspaceFolder = 2)] = "nestedWorkspaceFolder"),
		(s[(s.nestedExternalFolder = 3)] = "nestedExternalFolder"),
		(s[(s.untrackedFolder = 4)] = "untrackedFolder"),
		s
	))(Ly || {})
var Nbe = require("child_process"),
	Pbe = W(jA()),
	Wh = W(ZA()),
	Lbe = W(require("path")),
	Lt = W(require("vscode"))
var pM = W(require("vscode"))
async function cgt(e, t, r) {
	let i = (await Fr(e)).split(`
`),
		s = t - 1,
		o = r - 1,
		a = i.slice(0, s).reduce((c, u) => c + u.length + 1, 0),
		l = i.slice(0, o + 1).reduce((c, u) => c + u.length + 1, 0) - 1
	return { charStart: a, charEnd: l }
}
async function uCe(e, t) {
	let r = pM.workspace.workspaceFolders?.[0]
	if (!r) throw new Error("No workspace folder found")
	let n = pM.Uri.joinPath(r.uri, t.path).fsPath,
		i = e.resolvePathName(n)
	if (!i) throw new Error(`Could not resolve path: ${t.path}`)
	let { charStart: s, charEnd: o } = await cgt(i.absPath, t.startLine, t.endLine)
	return {
		requestId: Eh(),
		mode: "BACKGROUND",
		scope: "FILE",
		result: {
			suggestionId: Eh(),
			path: t.path,
			blobName: t.oldBlobName ?? "",
			charStart: s,
			charEnd: o,
			existingCode: t.oldText,
			suggestedCode: t.text,
			changeDescription: t.description,
			diffSpans: [],
			editingScore: 1,
			localizationScore: 1,
			editingScoreThreshold: 1,
		},
		qualifiedPathName: i,
		lineRange: { start: t.startLine - 1, stop: t.endLine - 1 },
		uriScheme: "file",
		occurredAt: new Date(),
		state: "fresh",
		changeType: "modification",
	}
}
var x4 = "augment://sign-in",
	dCe = `Augment is only available to signed in users. [Please sign in](${x4}).`,
	fCe =
		"Augment works best when it has access to your entire codebase. Please grant permission to sync your workspace.",
	$x = class {
		constructor(t, r) {
			this.message = t
			this.response = r
			this.occuredAt = new Date()
		}
		occuredAt
	}
var AM = class extends z {
	constructor(r) {
		super()
		this._getter = r
		;(this._cache = new Ry({
			max: 1e3,
			ttl: 1e3 * 60 * 60,
			fetchMethod: this._fetchSmartPasteResults,
		})),
			this.addDisposable({
				dispose: () => {
					this._cache.clear()
				},
			})
	}
	_cache
	_fetchSmartPasteResults = async (r, n, { context: i }) => {
		let s = await this._getter(i)
		return Promise.resolve({
			generator: new Jp(s.generator),
			requestId: s.requestId,
		})
	}
	get = async (r, n, i, s) => {
		let o = ugt(r, n, i),
			a = this._cache.get(o)
		;(!a || a.generator.hasErrored) && this._cache.delete(o)
		let l = await this._cache.fetch(o, { context: s, forceRefresh: !1 })
		if (l) return { generator: l.generator.copy(), requestId: l.requestId }
	}
	getDirect = async (r) => {
		let n = await Promise.resolve(this._getter(r))
		if (!n) return
		let i = new Jp(n.generator)
		if (i) return { generator: i.copy(), requestId: n.requestId }
	}
}
function ugt(e, t, r) {
	return `${e}--${t}--${r}`
}
var hCe = W(require("vscode"))
var Hi = class extends lt {
	static commandID = "vscode-augment.focusAugmentPanel"
	type = "public"
	constructor() {
		super()
	}
	async run() {
		await hCe.commands.executeCommand("augment-chat.focus")
	}
}
var Gs = W(require("vscode"))
var dgt = "GitHub.copilot",
	fgt = "Codeium.codeium"
var Xp = class e extends z {
	constructor(r, n) {
		super()
		this._config = r
		this._actionsModel = n
		this.addDisposable(
			Gs.workspace.onDidChangeConfiguration((i) => {
				;(i.affectsConfiguration("github.copilot") || i.affectsConfiguration("codeium")) &&
					this.checkAndUpdateState()
			}),
		),
			this.addDisposable(
				Gs.extensions.onDidChange(() => {
					this.checkAndUpdateState()
				}),
			)
	}
	logger = X("ConflictingExtensions")
	checkAndUpdateState() {
		if (this._config.config.conflictingCodingAssistantCheck === !1) {
			this._actionsModel.setSystemStateStatus("disabledGithubCopilot", "complete"),
				this._actionsModel.setSystemStateStatus("disabledCodeium", "complete")
			return
		}
		let n = [
			{
				check: () => e._checkGitHubCopilot(),
				stateName: "disabledGithubCopilot",
			},
			{ check: () => e._checkCodeium(), stateName: "disabledCodeium" },
		]
		for (let { check: i, stateName: s } of n) {
			let a = i().isConflicting ? "incomplete" : "complete"
			this._actionsModel.setSystemStateStatus(s, a)
		}
	}
	static _checkGitHubCopilot() {
		if (!Gs.extensions.getExtension(dgt)) return { extension: "copilot", isConflicting: !1 }
		let n = Gs.workspace.getConfiguration("github.copilot")
		return {
			extension: "copilot",
			isConflicting: (n.enable && n.enable["*"]) || !1,
		}
	}
	static async disableGitHubCopilot() {
		try {
			let r = Gs.workspace.getConfiguration("github.copilot")
			await r.update("enable", { "*": !1 }, this.targetForConfig(r.inspect("enable")))
		} catch {
			Gs.commands.executeCommand("workbench.extensions.search", "@enabled GitHub Copilot")
		}
	}
	static _checkCodeium() {
		if (!Gs.extensions.getExtension(fgt)) return { extension: "codeium", isConflicting: !1 }
		let n = Gs.workspace.getConfiguration("codeium")
		return {
			extension: "codeium",
			isConflicting: (n.enableConfig && n.enableConfig["*"]) || !1,
		}
	}
	static async disableCodeium() {
		try {
			let r = Gs.workspace.getConfiguration("codeium")
			await r.update("enableConfig", { "*": !1 }, this.targetForConfig(r.inspect("enableConfig")))
		} catch {
			Gs.commands.executeCommand("workbench.extensions.search", "@enabled Codeium")
		}
	}
	static packageName(r, n) {
		return r.packageJSON.displayName || r.packageJSON.name || n
	}
	static targetForConfig(r) {
		return r && r.workspaceValue !== void 0 ? Gs.ConfigurationTarget.Workspace : Gs.ConfigurationTarget.Global
	}
}
var gCe = W(require("os")),
	qh = W(require("vscode"))
var Qu = class e extends hi {
	_instance = crypto.randomUUID()
	constructor(t, r, n, i) {
		let s = gCe.default.EOL
		;(n = n.endsWith(s) ? n : n + s),
			(r = r.endsWith(s) ? r : r + s),
			super(t, r, n, { ...i }),
			this.addDisposable(qh.workspace.onDidChangeTextDocument(this._onBaseDocUpdated)),
			this.addDisposable(this.onOriginalUpdated(() => void this._write()))
	}
	static fromPathName = async (t, r, n) => {
		let i = new e(t, "", "", { logger: n }),
			s = await i._read()
		return i.updateCodeVersions(s, r ?? s), i
	}
	_read = async () => {
		let t = await this._getVsCodeTextDocument()
		return t ? t.getText() : ""
	}
	_write = async () => {
		let t = await this._getVsCodeTextDocument()
		if (t && t.getText() !== this.originalCode) {
			this._opts.logger?.debug(`Writing to doc ${this._instance}`)
			let r = new qh.WorkspaceEdit()
			r.replace(t.uri, new qh.Range(0, 0, Number.MAX_SAFE_INTEGER, 0), this.originalCode),
				await qh.workspace.applyEdit(r)
		}
	}
	_getVsCodeTextDocument = async () => {
		try {
			let t
			if (
				(this.isUntitled
					? (t = tM(this.filePath))
					: (t = await qh.workspace.openTextDocument(this.filePath.absPath)),
				t === void 0)
			)
				throw new Error(`Failed to open document ${this.filePath.absPath}`)
			return t
		} catch (t) {
			this._opts.logger?.error(`Failed to read file ${this.filePath.absPath}: ${String(t)}`)
			return
		}
	}
	_onBaseDocUpdated = (t) => {
		if (t.document.uri.fsPath === this.absPath) {
			let r = t.document.getText()
			if (r === this.originalCode) return
			this.updateOriginal(r)
		}
	}
}
function mM(e) {
	let t = Math.floor(e / 1e3),
		r = (e % 1e3) * 1e6
	return [t, r]
}
var yM = class extends z {
	constructor(r) {
		super()
		this._apiServer = r
		this.addDisposable({ dispose: this._logDiffPanelResolution })
	}
	chunkResolveByStartLine = new Map()
	isAcceptAll = !1
	isRejectAll = !1
	requestId
	sessionOrigin
	initialRequestTime
	streamFinishTime
	applyTime
	_logger = X("DiffViewSessionReporter")
	reset = () => {
		this.chunkResolveByStartLine.clear(),
			(this.isAcceptAll = !1),
			(this.isRejectAll = !1),
			(this.requestId = void 0),
			(this.sessionOrigin = void 0),
			(this.initialRequestTime = void 0),
			(this.streamFinishTime = void 0),
			(this.applyTime = void 0)
	}
	reportResolution = (r) => {
		let { resolveType: n, changes: i, shouldApplyToAll: s } = r.data
		s && !this.chunkResolveByStartLine.size && (n === "accept" ? (this.isAcceptAll = !0) : (this.isRejectAll = !0))
		for (let o of i) {
			let a = o.lineChanges?.lineChanges || []
			for (let l of a) {
				let c = l.originalStart
				this.chunkResolveByStartLine.set(c, n === "accept")
			}
		}
	}
	_logDiffPanelResolution = () => {
		if ((this._logger.debug("Logging diff panel resolution"), !this.requestId)) {
			this.reset(), this._logger.warn("No request id found for diff panel resolution")
			return
		}
		let n = Array.from(this.chunkResolveByStartLine.keys())
				.sort()
				.map((f) => this.chunkResolveByStartLine.get(f))
				.filter((f) => f !== void 0),
			[i, s] = this.initialRequestTime ? mM(this.initialRequestTime) : [0, 0],
			o = Date.now(),
			[a, l] = mM(o),
			[c, u] = mM(this.streamFinishTime || o)
		if (this.sessionOrigin === "instruction")
			this._apiServer.logInstructionResolution({
				request_id: this.requestId,
				is_accepted_chunks: n,
				is_accept_all: this.isAcceptAll,
				is_reject_all: this.isRejectAll,
				emit_time_sec: c,
				emit_time_nsec: u,
				resolve_time_sec: a,
				resolve_time_nsec: l,
			}),
				this._logger.debug("Logged instruction resolution")
		else if (this.sessionOrigin === "smart-paste") {
			let [f, p] = this.applyTime ? mM(this.applyTime) : [0, 0]
			this._apiServer.logSmartPasteResolution({
				request_id: this.requestId,
				is_accepted_chunks: n,
				is_accept_all: this.isAcceptAll,
				is_reject_all: this.isRejectAll,
				initial_request_time_sec: i,
				initial_request_time_nsec: s,
				stream_finish_time_sec: c,
				stream_finish_time_nsec: u,
				apply_time_sec: f,
				apply_time_nsec: p,
				resolve_time_sec: a,
				resolve_time_nsec: l,
			}),
				this._logger.debug("Logged smart paste resolution")
		} else this._logger.warn(`Unknown session origin: ${this.sessionOrigin}`)
		this.reset()
	}
}
var OM = W(xCe()),
	NM = W(BCe()),
	eEe = require("child_process"),
	PEe = W(M4()),
	Oy = W(M4()),
	cbe = require("events"),
	LM = Object.defineProperty,
	ept = Object.defineProperties,
	tpt = Object.getOwnPropertyDescriptor,
	rpt = Object.getOwnPropertyDescriptors,
	X4 = Object.getOwnPropertyNames,
	DCe = Object.getOwnPropertySymbols,
	lve = Object.prototype.hasOwnProperty,
	npt = Object.prototype.propertyIsEnumerable,
	TCe = (e, t, r) => (t in e ? LM(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r)),
	_l = (e, t) => {
		for (var r in t || (t = {})) lve.call(t, r) && TCe(e, r, t[r])
		if (DCe) for (var r of DCe(t)) npt.call(t, r) && TCe(e, r, t[r])
		return e
	},
	Jx = (e, t) => ept(e, rpt(t)),
	Se = (e, t) =>
		function () {
			return e && (t = (0, e[X4(e)[0]])((e = 0))), t
		},
	ipt = (e, t) =>
		function () {
			return t || (0, e[X4(e)[0]])((t = { exports: {} }).exports, t), t.exports
		},
	vi = (e, t) => {
		for (var r in t) LM(e, r, { get: t[r], enumerable: !0 })
	},
	spt = (e, t, r, n) => {
		if ((t && typeof t == "object") || typeof t == "function")
			for (let i of X4(t))
				!lve.call(e, i) &&
					i !== r &&
					LM(e, i, {
						get: () => t[i],
						enumerable: !(n = tpt(t, i)) || n.enumerable,
					})
		return e
	},
	li = (e) => spt(LM({}, "__esModule", { value: !0 }), e),
	Kx = (e, t, r) =>
		new Promise((n, i) => {
			var s = (l) => {
					try {
						a(r.next(l))
					} catch (c) {
						i(c)
					}
				},
				o = (l) => {
					try {
						a(r.throw(l))
					} catch (c) {
						i(c)
					}
				},
				a = (l) => (l.done ? n(l.value) : Promise.resolve(l.value).then(s, o))
			a((r = r.apply(e, t)).next())
		})
function opt(...e) {
	let t = new String(e)
	return UM.set(t, e), t
}
function FM(e) {
	return e instanceof String && UM.has(e)
}
function RCe(e) {
	return UM.get(e) || []
}
var UM,
	Xx = Se({
		"src/lib/args/pathspec.ts"() {
			"use strict"
			UM = new WeakMap()
		},
	}),
	ef,
	Hh = Se({
		"src/lib/errors/git-error.ts"() {
			"use strict"
			ef = class extends Error {
				constructor(e, t) {
					super(t), (this.task = e), Object.setPrototypeOf(this, new.target.prototype)
				}
			}
		},
	}),
	e_,
	Vy = Se({
		"src/lib/errors/git-response-error.ts"() {
			"use strict"
			Hh(),
				(e_ = class extends ef {
					constructor(e, t) {
						super(void 0, t || String(e)), (this.git = e)
					}
				})
		},
	}),
	cve,
	uve = Se({
		"src/lib/errors/task-configuration-error.ts"() {
			"use strict"
			Hh(),
				(cve = class extends ef {
					constructor(e) {
						super(void 0, e)
					}
				})
		},
	})
function dve(e) {
	return typeof e == "function" ? e : nA
}
function fve(e) {
	return typeof e == "function" && e !== nA
}
function hve(e, t) {
	let r = e.indexOf(t)
	return r <= 0 ? [e, ""] : [e.substr(0, r), e.substr(r + 1)]
}
function gve(e, t = 0) {
	return pve(e) && e.length > t ? e[t] : void 0
}
function rA(e, t = 0) {
	if (pve(e) && e.length > t) return e[e.length - 1 - t]
}
function pve(e) {
	return !!(e && typeof e.length == "number")
}
function t_(
	e = "",
	t = !0,
	r = `
`,
) {
	return e.split(r).reduce((n, i) => {
		let s = t ? i.trim() : i
		return s && n.push(s), n
	}, [])
}
function eG(e, t) {
	return t_(e, !0).map((r) => t(r))
}
function tG(e) {
	return (0, OM.exists)(e, OM.FOLDER)
}
function Qr(e, t) {
	return Array.isArray(e) ? e.includes(t) || e.push(t) : e.add(t), t
}
function Ave(e, t) {
	return Array.isArray(e) && !e.includes(t) && e.push(t), e
}
function qM(e, t) {
	if (Array.isArray(e)) {
		let r = e.indexOf(t)
		r >= 0 && e.splice(r, 1)
	} else e.delete(t)
	return t
}
function Nu(e) {
	return Array.isArray(e) ? e : [e]
}
function mve(e) {
	return e.replace(/[\s-]+(.)/g, (t, r) => r.toUpperCase())
}
function yve(e) {
	return Nu(e).map(String)
}
function mn(e, t = 0) {
	if (e == null) return t
	let r = parseInt(e, 10)
	return isNaN(r) ? t : r
}
function zx(e, t) {
	let r = []
	for (let n = 0, i = e.length; n < i; n++) r.push(t, e[n])
	return r
}
function jx(e) {
	return (Array.isArray(e) ? Buffer.concat(e) : e).toString("utf-8")
}
function Cve(e, t) {
	return Object.assign({}, ...t.map((r) => (r in e ? { [r]: e[r] } : {})))
}
function O4(e = 0) {
	return new Promise((t) => setTimeout(t, e))
}
function q4(e) {
	if (e !== !1) return e
}
var qy,
	nA,
	r_,
	VM = Se({
		"src/lib/utils/util.ts"() {
			"use strict"
			;(qy = "\0"), (nA = () => {}), (r_ = Object.prototype.toString.call.bind(Object.prototype.toString))
		},
	})
function Pu(e, t, r) {
	return t(e) ? e : arguments.length > 2 ? r : void 0
}
function rG(e, t) {
	let r = FM(e) ? "string" : typeof e
	return /number|string|boolean/.test(r) && (!t || !t.includes(r))
}
function nG(e) {
	return !!e && r_(e) === "[object Object]"
}
function vve(e) {
	return typeof e == "function"
}
var n_,
	$s,
	Eve,
	QM,
	iG,
	bve = Se({
		"src/lib/utils/argument-filters.ts"() {
			"use strict"
			VM(),
				Xx(),
				(n_ = (e) => Array.isArray(e)),
				($s = (e) => typeof e == "string"),
				(Eve = (e) => Array.isArray(e) && e.every($s)),
				(QM = (e) => $s(e) || (Array.isArray(e) && e.every($s))),
				(iG = (e) =>
					e == null || "number|boolean|function".includes(typeof e)
						? !1
						: Array.isArray(e) || typeof e == "string" || typeof e.length == "number")
		},
	}),
	V4,
	apt = Se({
		"src/lib/utils/exit-codes.ts"() {
			"use strict"
			V4 = ((e) => (
				(e[(e.SUCCESS = 0)] = "SUCCESS"),
				(e[(e.ERROR = 1)] = "ERROR"),
				(e[(e.NOT_FOUND = -2)] = "NOT_FOUND"),
				(e[(e.UNCLEAN = 128)] = "UNCLEAN"),
				e
			))(V4 || {})
		},
	}),
	Zx,
	lpt = Se({
		"src/lib/utils/git-output-streams.ts"() {
			"use strict"
			Zx = class {
				constructor(e, t) {
					;(this.stdOut = e), (this.stdErr = t)
				}
				asStrings() {
					return new Zx(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"))
				}
			}
		},
	}),
	Ft,
	Vh,
	cpt = Se({
		"src/lib/utils/line-parser.ts"() {
			"use strict"
			;(Ft = class {
				constructor(e, t) {
					;(this.matches = []),
						(this.parse = (r, n) => (
							this.resetMatches(),
							this._regExp.every((i, s) => this.addMatch(i, s, r(s)))
								? this.useMatches(n, this.prepareMatches()) !== !1
								: !1
						)),
						(this._regExp = Array.isArray(e) ? e : [e]),
						t && (this.useMatches = t)
				}
				useMatches(e, t) {
					throw new Error("LineParser:useMatches not implemented")
				}
				resetMatches() {
					this.matches.length = 0
				}
				prepareMatches() {
					return this.matches
				}
				addMatch(e, t, r) {
					let n = r && e.exec(r)
					return n && this.pushMatch(t, n), !!n
				}
				pushMatch(e, t) {
					this.matches.push(...t.slice(1))
				}
			}),
				(Vh = class extends Ft {
					addMatch(e, t, r) {
						return /^remote:\s/.test(String(r)) && super.addMatch(e, t, r)
					}
					pushMatch(e, t) {
						;(e > 0 || t.length > 1) && super.pushMatch(e, t)
					}
				})
		},
	})
function xve(...e) {
	let t = process.cwd(),
		r = Object.assign(_l({ baseDir: t }, _ve), ...e.filter((n) => typeof n == "object" && n))
	return (r.baseDir = r.baseDir || t), (r.trimmed = r.trimmed === !0), r
}
var _ve,
	upt = Se({
		"src/lib/utils/simple-git-options.ts"() {
			"use strict"
			_ve = {
				binary: "git",
				maxConcurrentProcesses: 5,
				config: [],
				trimmed: !1,
			}
		},
	})
function sG(e, t = []) {
	return nG(e)
		? Object.keys(e).reduce((r, n) => {
				let i = e[n]
				return FM(i) ? r.push(i) : rG(i, ["boolean"]) ? r.push(n + "=" + i) : r.push(n), r
			}, t)
		: t
}
function zo(e, t = 0, r = !1) {
	let n = []
	for (let i = 0, s = t < 0 ? e.length : t; i < s; i++) "string|number".includes(typeof e[i]) && n.push(String(e[i]))
	return sG(oG(e), n), r || n.push(...dpt(e)), n
}
function dpt(e) {
	let t = typeof rA(e) == "function"
	return Pu(rA(e, t ? 1 : 0), n_, [])
}
function oG(e) {
	let t = vve(rA(e))
	return Pu(rA(e, t ? 1 : 0), nG)
}
function ci(e, t = !0) {
	let r = dve(rA(e))
	return t || fve(r) ? r : void 0
}
var fpt = Se({
	"src/lib/utils/task-options.ts"() {
		"use strict"
		bve(), VM(), Xx()
	},
})
function H4(e, t) {
	return e(t.stdOut, t.stdErr)
}
function Zo(e, t, r, n = !0) {
	return (
		Nu(r).forEach((i) => {
			for (let s = t_(i, n), o = 0, a = s.length; o < a; o++) {
				let l = (c = 0) => {
					if (!(o + c >= a)) return s[o + c]
				}
				t.some(({ parse: c }) => c(l, e))
			}
		}),
		e
	)
}
var hpt = Se({
		"src/lib/utils/task-parser.ts"() {
			"use strict"
			VM()
		},
	}),
	wve = {}
vi(wve, {
	ExitCodes: () => V4,
	GitOutputStreams: () => Zx,
	LineParser: () => Ft,
	NOOP: () => nA,
	NULL: () => qy,
	RemoteLineParser: () => Vh,
	append: () => Qr,
	appendTaskOptions: () => sG,
	asArray: () => Nu,
	asCamelCase: () => mve,
	asFunction: () => dve,
	asNumber: () => mn,
	asStringArray: () => yve,
	bufferToString: () => jx,
	callTaskParser: () => H4,
	createInstanceConfig: () => xve,
	delay: () => O4,
	filterArray: () => n_,
	filterFunction: () => vve,
	filterHasLength: () => iG,
	filterPlainObject: () => nG,
	filterPrimitives: () => rG,
	filterString: () => $s,
	filterStringArray: () => Eve,
	filterStringOrStringArray: () => QM,
	filterType: () => Pu,
	first: () => gve,
	folderExists: () => tG,
	forEachLineWithContent: () => eG,
	getTrailingOptions: () => zo,
	including: () => Ave,
	isUserFunction: () => fve,
	last: () => rA,
	objectToString: () => r_,
	orVoid: () => q4,
	parseStringResponse: () => Zo,
	pick: () => Cve,
	prefixedArray: () => zx,
	remove: () => qM,
	splitOn: () => hve,
	toLinesWithContent: () => t_,
	trailingFunctionArgument: () => ci,
	trailingOptionsArgument: () => oG,
})
var wt = Se({
		"src/lib/utils/index.ts"() {
			"use strict"
			bve(), apt(), lpt(), cpt(), upt(), fpt(), hpt(), VM()
		},
	}),
	Ive = {}
vi(Ive, {
	CheckRepoActions: () => W4,
	checkIsBareRepoTask: () => Bve,
	checkIsRepoRootTask: () => Sve,
	checkIsRepoTask: () => gpt,
})
function gpt(e) {
	switch (e) {
		case "bare":
			return Bve()
		case "root":
			return Sve()
	}
	return {
		commands: ["rev-parse", "--is-inside-work-tree"],
		format: "utf-8",
		onError: HM,
		parser: aG,
	}
}
function Sve() {
	return {
		commands: ["rev-parse", "--git-dir"],
		format: "utf-8",
		onError: HM,
		parser(t) {
			return /^\.(git)?$/.test(t.trim())
		},
	}
}
function Bve() {
	return {
		commands: ["rev-parse", "--is-bare-repository"],
		format: "utf-8",
		onError: HM,
		parser: aG,
	}
}
function ppt(e) {
	return /(Not a git repository|Kein Git-Repository)/i.test(String(e))
}
var W4,
	HM,
	aG,
	Dve = Se({
		"src/lib/tasks/check-is-repo.ts"() {
			"use strict"
			wt(),
				(W4 = ((e) => ((e.BARE = "bare"), (e.IN_TREE = "tree"), (e.IS_REPO_ROOT = "root"), e))(W4 || {})),
				(HM = ({ exitCode: e }, t, r, n) => {
					if (e === 128 && ppt(t)) return r(Buffer.from("false"))
					n(t)
				}),
				(aG = (e) => e.trim() === "true")
		},
	})
function Apt(e, t) {
	let r = new Tve(e),
		n = e ? kve : Rve
	return (
		t_(t).forEach((i) => {
			let s = i.replace(n, "")
			r.paths.push(s), (Mve.test(s) ? r.folders : r.files).push(s)
		}),
		r
	)
}
var Tve,
	Rve,
	kve,
	Mve,
	mpt = Se({
		"src/lib/responses/CleanSummary.ts"() {
			"use strict"
			wt(),
				(Tve = class {
					constructor(e) {
						;(this.dryRun = e), (this.paths = []), (this.files = []), (this.folders = [])
					}
				}),
				(Rve = /^[a-z]+\s*/i),
				(kve = /^[a-z]+\s+[a-z]+\s*/i),
				(Mve = /\/$/)
		},
	}),
	G4 = {}
vi(G4, {
	EMPTY_COMMANDS: () => WM,
	adhocExecTask: () => Fve,
	configurationErrorTask: () => jo,
	isBufferTask: () => Nve,
	isEmptyTask: () => Pve,
	straightThroughBufferTask: () => Qve,
	straightThroughStringTask: () => mo,
})
function Fve(e) {
	return { commands: WM, format: "empty", parser: e }
}
function jo(e) {
	return {
		commands: WM,
		format: "empty",
		parser() {
			throw typeof e == "string" ? new cve(e) : e
		},
	}
}
function mo(e, t = !1) {
	return {
		commands: e,
		format: "utf-8",
		parser(r) {
			return t ? String(r).trim() : r
		},
	}
}
function Qve(e) {
	return {
		commands: e,
		format: "buffer",
		parser(t) {
			return t
		},
	}
}
function Nve(e) {
	return e.format === "buffer"
}
function Pve(e) {
	return e.format === "empty" || !e.commands.length
}
var WM,
	Ci = Se({
		"src/lib/tasks/task.ts"() {
			"use strict"
			uve(), (WM = [])
		},
	}),
	Lve = {}
vi(Lve, {
	CONFIG_ERROR_INTERACTIVE_MODE: () => lG,
	CONFIG_ERROR_MODE_REQUIRED: () => cG,
	CONFIG_ERROR_UNKNOWN_OPTION: () => uG,
	CleanOptions: () => TM,
	cleanTask: () => Uve,
	cleanWithOptionsTask: () => ypt,
	isCleanOptionsArray: () => Cpt,
})
function ypt(e, t) {
	let { cleanMode: r, options: n, valid: i } = vpt(e)
	return r ? (i.options ? (n.push(...t), n.some(xpt) ? jo(lG) : Uve(r, n)) : jo(uG + JSON.stringify(e))) : jo(cG)
}
function Uve(e, t) {
	return {
		commands: ["clean", `-${e}`, ...t],
		format: "utf-8",
		parser(n) {
			return Apt(e === "n", n)
		},
	}
}
function Cpt(e) {
	return Array.isArray(e) && e.every((t) => dG.has(t))
}
function vpt(e) {
	let t,
		r = [],
		n = { cleanMode: !1, options: !0 }
	return (
		e
			.replace(/[^a-z]i/g, "")
			.split("")
			.forEach((i) => {
				Ept(i) ? ((t = i), (n.cleanMode = !0)) : (n.options = n.options && bpt((r[r.length] = `-${i}`)))
			}),
		{ cleanMode: t, options: r, valid: n }
	)
}
function Ept(e) {
	return e === "f" || e === "n"
}
function bpt(e) {
	return /^-[a-z]$/i.test(e) && dG.has(e.charAt(1))
}
function xpt(e) {
	return /^-[^\-]/.test(e) ? e.indexOf("i") > 0 : e === "--interactive"
}
var lG,
	cG,
	uG,
	TM,
	dG,
	Ove = Se({
		"src/lib/tasks/clean.ts"() {
			"use strict"
			mpt(),
				wt(),
				Ci(),
				(lG = "Git clean interactive mode is not supported"),
				(cG = 'Git clean mode parameter ("n" or "f") is required'),
				(uG = "Git clean unknown option found in: "),
				(TM = ((e) => (
					(e.DRY_RUN = "n"),
					(e.FORCE = "f"),
					(e.IGNORED_INCLUDED = "x"),
					(e.IGNORED_ONLY = "X"),
					(e.EXCLUDING = "e"),
					(e.QUIET = "q"),
					(e.RECURSIVE = "d"),
					e
				))(TM || {})),
				(dG = new Set(["i", ...yve(Object.values(TM))]))
		},
	})
function _pt(e) {
	let t = new Vve()
	for (let r of qve(e)) t.addValue(r.file, String(r.key), r.value)
	return t
}
function wpt(e, t) {
	let r = null,
		n = [],
		i = new Map()
	for (let s of qve(e, t))
		s.key === t && (n.push((r = s.value)), i.has(s.file) || i.set(s.file, []), i.get(s.file).push(r))
	return {
		key: t,
		paths: Array.from(i.keys()),
		scopes: i,
		value: r,
		values: n,
	}
}
function Ipt(e) {
	return e.replace(/^(file):/, "")
}
function* qve(e, t = null) {
	let r = e.split("\0")
	for (let n = 0, i = r.length - 1; n < i; ) {
		let s = Ipt(r[n++]),
			o = r[n++],
			a = t
		if (
			o.includes(`
`)
		) {
			let l = hve(
				o,
				`
`,
			)
			;(a = l[0]), (o = l[1])
		}
		yield { file: s, key: a, value: o }
	}
}
var Vve,
	Spt = Se({
		"src/lib/responses/ConfigList.ts"() {
			"use strict"
			wt(),
				(Vve = class {
					constructor() {
						;(this.files = []), (this.values = Object.create(null))
					}
					get all() {
						return (
							this._all ||
								(this._all = this.files.reduce((e, t) => Object.assign(e, this.values[t]), {})),
							this._all
						)
					}
					addFile(e) {
						if (!(e in this.values)) {
							let t = rA(this.files)
							;(this.values[e] = t ? Object.create(this.values[t]) : {}), this.files.push(e)
						}
						return this.values[e]
					}
					addValue(e, t, r) {
						let n = this.addFile(e)
						n.hasOwnProperty(t) ? (Array.isArray(n[t]) ? n[t].push(r) : (n[t] = [n[t], r])) : (n[t] = r),
							(this._all = void 0)
					}
				})
		},
	})
function F4(e, t) {
	return typeof e == "string" && $4.hasOwnProperty(e) ? e : t
}
function Bpt(e, t, r, n) {
	let i = ["config", `--${n}`]
	return (
		r && i.push("--add"),
		i.push(e, t),
		{
			commands: i,
			format: "utf-8",
			parser(s) {
				return s
			},
		}
	)
}
function Dpt(e, t) {
	let r = ["config", "--null", "--show-origin", "--get-all", e]
	return (
		t && r.splice(1, 0, `--${t}`),
		{
			commands: r,
			format: "utf-8",
			parser(n) {
				return wpt(n, e)
			},
		}
	)
}
function Tpt(e) {
	let t = ["config", "--list", "--show-origin", "--null"]
	return (
		e && t.push(`--${e}`),
		{
			commands: t,
			format: "utf-8",
			parser(r) {
				return _pt(r)
			},
		}
	)
}
function Rpt() {
	return {
		addConfig(e, t, ...r) {
			return this._runTask(Bpt(e, t, r[0] === !0, F4(r[1], "local")), ci(arguments))
		},
		getConfig(e, t) {
			return this._runTask(Dpt(e, F4(t, void 0)), ci(arguments))
		},
		listConfig(...e) {
			return this._runTask(Tpt(F4(e[0], void 0)), ci(arguments))
		},
	}
}
var $4,
	Hve = Se({
		"src/lib/tasks/config.ts"() {
			"use strict"
			Spt(),
				wt(),
				($4 = ((e) => (
					(e.system = "system"), (e.global = "global"), (e.local = "local"), (e.worktree = "worktree"), e
				))($4 || {}))
		},
	})
function kpt(e) {
	return Wve.has(e)
}
var Q4,
	Wve,
	Gve = Se({
		"src/lib/tasks/diff-name-status.ts"() {
			"use strict"
			;(Q4 = ((e) => (
				(e.ADDED = "A"),
				(e.COPIED = "C"),
				(e.DELETED = "D"),
				(e.MODIFIED = "M"),
				(e.RENAMED = "R"),
				(e.CHANGED = "T"),
				(e.UNMERGED = "U"),
				(e.UNKNOWN = "X"),
				(e.BROKEN = "B"),
				e
			))(Q4 || {})),
				(Wve = new Set(Object.values(Q4)))
		},
	})
function Mpt(...e) {
	return new Yve().param(...e)
}
function Fpt(e) {
	let t = new Set(),
		r = {}
	return (
		eG(e, (n) => {
			let [i, s, o] = n.split(qy)
			t.add(i), (r[i] = r[i] || []).push({ line: mn(s), path: i, preview: o })
		}),
		{ paths: t, results: r }
	)
}
function Qpt() {
	return {
		grep(e) {
			let t = ci(arguments),
				r = zo(arguments)
			for (let i of $ve)
				if (r.includes(i)) return this._runTask(jo(`git.grep: use of "${i}" is not supported.`), t)
			typeof e == "string" && (e = Mpt().param(e))
			let n = ["grep", "--null", "-n", "--full-name", ...r, ...e]
			return this._runTask(
				{
					commands: n,
					format: "utf-8",
					parser(i) {
						return Fpt(i)
					},
				},
				t,
			)
		},
	}
}
var $ve,
	Yx,
	kCe,
	Yve,
	Kve = Se({
		"src/lib/tasks/grep.ts"() {
			"use strict"
			wt(),
				Ci(),
				($ve = ["-h"]),
				(Yx = Symbol("grepQuery")),
				(Yve = class {
					constructor() {
						this[kCe] = []
					}
					*[((kCe = Yx), Symbol.iterator)]() {
						for (let e of this[Yx]) yield e
					}
					and(...e) {
						return e.length && this[Yx].push("--and", "(", ...zx(e, "-e"), ")"), this
					}
					param(...e) {
						return this[Yx].push(...zx(e, "-e")), this
					}
				})
		},
	}),
	Jve = {}
vi(Jve, { ResetMode: () => RM, getResetMode: () => Ppt, resetTask: () => Npt })
function Npt(e, t) {
	let r = ["reset"]
	return zve(e) && r.push(`--${e}`), r.push(...t), mo(r)
}
function Ppt(e) {
	if (zve(e)) return e
	switch (typeof e) {
		case "string":
		case "undefined":
			return "soft"
	}
}
function zve(e) {
	return jve.includes(e)
}
var RM,
	jve,
	Zve = Se({
		"src/lib/tasks/reset.ts"() {
			"use strict"
			Ci(),
				(RM = ((e) => (
					(e.MIXED = "mixed"), (e.SOFT = "soft"), (e.HARD = "hard"), (e.MERGE = "merge"), (e.KEEP = "keep"), e
				))(RM || {})),
				(jve = Array.from(Object.values(RM)))
		},
	})
function Lpt() {
	return (0, NM.default)("simple-git")
}
function MCe(e, t, r) {
	return !t || !String(t).replace(/\s*/, "")
		? r
			? (n, ...i) => {
					e(n, ...i), r(n, ...i)
				}
			: e
		: (n, ...i) => {
				e(`%s ${n}`, t, ...i), r && r(n, ...i)
			}
}
function Upt(e, t, { namespace: r }) {
	if (typeof e == "string") return e
	let n = (t && t.namespace) || ""
	return n.startsWith(r) ? n.substr(r.length + 1) : n || r
}
function fG(e, t, r, n = Lpt()) {
	let i = (e && `[${e}]`) || "",
		s = [],
		o = typeof t == "string" ? n.extend(t) : t,
		a = Upt(Pu(t, $s), o, n)
	return c(r)
	function l(u, f) {
		return Qr(s, fG(e, a.replace(/^[^:]+/, u), f, n))
	}
	function c(u) {
		let f = (u && `[${u}]`) || "",
			p = (o && MCe(o, f)) || nA,
			g = MCe(n, `${i} ${f}`, p)
		return Object.assign(o ? p : g, { label: e, sibling: l, info: g, step: c })
	}
}
var Xve = Se({
		"src/lib/git-logger.ts"() {
			"use strict"
			wt(),
				(NM.default.formatters.L = (e) => String(iG(e) ? e.length : "-")),
				(NM.default.formatters.B = (e) => (Buffer.isBuffer(e) ? e.toString("utf8") : r_(e)))
		},
	}),
	BM,
	Y4,
	Opt = Se({
		"src/lib/runners/tasks-pending-queue.ts"() {
			"use strict"
			Hh(),
				Xve(),
				(BM = class {
					constructor(e = "GitExecutor") {
						;(this.logLabel = e), (this._queue = new Map())
					}
					withProgress(e) {
						return this._queue.get(e)
					}
					createProgress(e) {
						let t = BM.getName(e.commands[0]),
							r = fG(this.logLabel, t)
						return { task: e, logger: r, name: t }
					}
					push(e) {
						let t = this.createProgress(e)
						return t.logger("Adding task to the queue, commands = %o", e.commands), this._queue.set(e, t), t
					}
					fatal(e) {
						for (let [t, { logger: r }] of Array.from(this._queue.entries()))
							t === e.task
								? (r.info("Failed %o", e),
									r(
										"Fatal exception, any as-yet un-started tasks run through this executor will not be attempted",
									))
								: r.info(
										"A fatal exception occurred in a previous task, the queue has been purged: %o",
										e.message,
									),
								this.complete(t)
						if (this._queue.size !== 0)
							throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`)
					}
					complete(e) {
						this.withProgress(e) && this._queue.delete(e)
					}
					attempt(e) {
						let t = this.withProgress(e)
						if (!t) throw new ef(void 0, "TasksPendingQueue: attempt called for an unknown task")
						return t.logger("Starting task"), t
					}
					static getName(e = "empty") {
						return `task:${e}:${++BM.counter}`
					}
				}),
				(Y4 = BM),
				(Y4.counter = 0)
		},
	})
function tA(e, t) {
	return { method: gve(e.commands) || "", commands: t }
}
function qpt(e, t) {
	return (r) => {
		t("[ERROR] child process exception %o", r), e.push(Buffer.from(String(r.stack), "ascii"))
	}
}
function FCe(e, t, r, n) {
	return (i) => {
		r("%s received %L bytes", t, i), n("%B", i), e.push(i)
	}
}
var K4,
	Vpt = Se({
		"src/lib/runners/git-executor-chain.ts"() {
			"use strict"
			Hh(),
				Ci(),
				wt(),
				Opt(),
				(K4 = class {
					constructor(e, t, r) {
						;(this._executor = e),
							(this._scheduler = t),
							(this._plugins = r),
							(this._chain = Promise.resolve()),
							(this._queue = new Y4())
					}
					get cwd() {
						return this._cwd || this._executor.cwd
					}
					set cwd(e) {
						this._cwd = e
					}
					get env() {
						return this._executor.env
					}
					get outputHandler() {
						return this._executor.outputHandler
					}
					chain() {
						return this
					}
					push(e) {
						return this._queue.push(e), (this._chain = this._chain.then(() => this.attemptTask(e)))
					}
					attemptTask(e) {
						return Kx(this, null, function* () {
							let t = yield this._scheduler.next(),
								r = () => this._queue.complete(e)
							try {
								let { logger: n } = this._queue.attempt(e)
								return yield Pve(e) ? this.attemptEmptyTask(e, n) : this.attemptRemoteTask(e, n)
							} catch (n) {
								throw this.onFatalException(e, n)
							} finally {
								r(), t()
							}
						})
					}
					onFatalException(e, t) {
						let r = t instanceof ef ? Object.assign(t, { task: e }) : new ef(e, t && String(t))
						return (this._chain = Promise.resolve()), this._queue.fatal(r), r
					}
					attemptRemoteTask(e, t) {
						return Kx(this, null, function* () {
							let r = this._plugins.exec("spawn.binary", "", tA(e, e.commands)),
								n = this._plugins.exec("spawn.args", [...e.commands], tA(e, e.commands)),
								i = yield this.gitResponse(e, r, n, this.outputHandler, t.step("SPAWN")),
								s = yield this.handleTaskData(e, n, i, t.step("HANDLE"))
							return (
								t("passing response to task's parser as a %s", e.format),
								Nve(e) ? H4(e.parser, s) : H4(e.parser, s.asStrings())
							)
						})
					}
					attemptEmptyTask(e, t) {
						return Kx(this, null, function* () {
							return t("empty task bypassing child process to call to task's parser"), e.parser(this)
						})
					}
					handleTaskData(e, t, r, n) {
						let { exitCode: i, rejection: s, stdOut: o, stdErr: a } = r
						return new Promise((l, c) => {
							n("Preparing to handle process response exitCode=%d stdOut=", i)
							let { error: u } = this._plugins.exec("task.error", { error: s }, _l(_l({}, tA(e, t)), r))
							if (u && e.onError)
								return (
									n.info("exitCode=%s handling with custom error handler"),
									e.onError(
										r,
										u,
										(f) => {
											n.info("custom error handler treated as success"),
												n("custom error returned a %s", r_(f)),
												l(new Zx(Array.isArray(f) ? Buffer.concat(f) : f, Buffer.concat(a)))
										},
										c,
									)
								)
							if (u)
								return (
									n.info("handling as error: exitCode=%s stdErr=%s rejection=%o", i, a.length, s),
									c(u)
								)
							n.info("retrieving task output complete"), l(new Zx(Buffer.concat(o), Buffer.concat(a)))
						})
					}
					gitResponse(e, t, r, n, i) {
						return Kx(this, null, function* () {
							let s = i.sibling("output"),
								o = this._plugins.exec(
									"spawn.options",
									{ cwd: this.cwd, env: this.env, windowsHide: !0 },
									tA(e, e.commands),
								)
							return new Promise((a) => {
								let l = [],
									c = []
								i.info("%s %o", t, r), i("%O", o)
								let u = this._beforeSpawn(e, r)
								if (u)
									return a({
										stdOut: l,
										stdErr: c,
										exitCode: 9901,
										rejection: u,
									})
								this._plugins.exec(
									"spawn.before",
									void 0,
									Jx(_l({}, tA(e, r)), {
										kill(p) {
											u = p || u
										},
									}),
								)
								let f = (0, eEe.spawn)(t, r, o)
								f.stdout.on("data", FCe(l, "stdOut", i, s.step("stdOut"))),
									f.stderr.on("data", FCe(c, "stdErr", i, s.step("stdErr"))),
									f.on("error", qpt(c, i)),
									n &&
										(i("Passing child process stdOut/stdErr to custom outputHandler"),
										n(t, f.stdout, f.stderr, [...r])),
									this._plugins.exec(
										"spawn.after",
										void 0,
										Jx(_l({}, tA(e, r)), {
											spawned: f,
											close(p, g) {
												a({
													stdOut: l,
													stdErr: c,
													exitCode: p,
													rejection: u || g,
												})
											},
											kill(p) {
												f.killed || ((u = p), f.kill("SIGINT"))
											},
										}),
									)
							})
						})
					}
					_beforeSpawn(e, t) {
						let r
						return (
							this._plugins.exec(
								"spawn.before",
								void 0,
								Jx(_l({}, tA(e, t)), {
									kill(n) {
										r = n || r
									},
								}),
							),
							r
						)
					}
				})
		},
	}),
	tEe = {}
vi(tEe, { GitExecutor: () => rEe })
var rEe,
	Hpt = Se({
		"src/lib/runners/git-executor.ts"() {
			"use strict"
			Vpt(),
				(rEe = class {
					constructor(e, t, r) {
						;(this.cwd = e),
							(this._scheduler = t),
							(this._plugins = r),
							(this._chain = new K4(this, this._scheduler, this._plugins))
					}
					chain() {
						return new K4(this, this._scheduler, this._plugins)
					}
					push(e) {
						return this._chain.push(e)
					}
				})
		},
	})
function Wpt(e, t, r = nA) {
	let n = (s) => {
			r(null, s)
		},
		i = (s) => {
			s?.task === e && r(s instanceof e_ ? Gpt(s) : s, void 0)
		}
	t.then(n, i)
}
function Gpt(e) {
	let t = (n) => {
		console.warn(
			`simple-git deprecation notice: accessing GitResponseError.${n} should be GitResponseError.git.${n}, this will no longer be available in version 3`,
		),
			(t = nA)
	}
	return Object.create(e, Object.getOwnPropertyNames(e.git).reduce(r, {}))
	function r(n, i) {
		return (
			i in e ||
				(n[i] = {
					enumerable: !1,
					configurable: !1,
					get() {
						return t(i), e.git[i]
					},
				}),
			n
		)
	}
}
var $pt = Se({
	"src/lib/task-callback.ts"() {
		"use strict"
		Vy(), wt()
	},
})
function QCe(e, t) {
	return Fve((r) => {
		if (!tG(e)) throw new Error(`Git.cwd: cannot change to non-directory "${e}"`)
		return ((t || r).cwd = e)
	})
}
var Ypt = Se({
	"src/lib/tasks/change-working-directory.ts"() {
		"use strict"
		wt(), Ci()
	},
})
function N4(e) {
	let t = ["checkout", ...e]
	return t[1] === "-b" && t.includes("-B") && (t[1] = qM(t, "-B")), mo(t)
}
function Kpt() {
	return {
		checkout() {
			return this._runTask(N4(zo(arguments, 1)), ci(arguments))
		},
		checkoutBranch(e, t) {
			return this._runTask(N4(["-b", e, t, ...zo(arguments)]), ci(arguments))
		},
		checkoutLocalBranch(e) {
			return this._runTask(N4(["-b", e, ...zo(arguments)]), ci(arguments))
		},
	}
}
var Jpt = Se({
	"src/lib/tasks/checkout.ts"() {
		"use strict"
		wt(), Ci()
	},
})
function zpt() {
	return {
		count: 0,
		garbage: 0,
		inPack: 0,
		packs: 0,
		prunePackable: 0,
		size: 0,
		sizeGarbage: 0,
		sizePack: 0,
	}
}
function jpt() {
	return {
		countObjects() {
			return this._runTask({
				commands: ["count-objects", "--verbose"],
				format: "utf-8",
				parser(e) {
					return Zo(zpt(), [nEe], e)
				},
			})
		},
	}
}
var nEe,
	Zpt = Se({
		"src/lib/tasks/count-objects.ts"() {
			"use strict"
			wt(),
				(nEe = new Ft(/([a-z-]+): (\d+)$/, (e, [t, r]) => {
					let n = mve(t)
					e.hasOwnProperty(n) && (e[n] = mn(r))
				}))
		},
	})
function Xpt(e) {
	return Zo(
		{
			author: null,
			branch: "",
			commit: "",
			root: !1,
			summary: { changes: 0, insertions: 0, deletions: 0 },
		},
		iEe,
		e,
	)
}
var iEe,
	eAt = Se({
		"src/lib/parsers/parse-commit.ts"() {
			"use strict"
			wt(),
				(iEe = [
					new Ft(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (e, [t, r, n]) => {
						;(e.branch = t), (e.commit = n), (e.root = !!r)
					}),
					new Ft(/\s*Author:\s(.+)/i, (e, [t]) => {
						let r = t.split("<"),
							n = r.pop()
						!n ||
							!n.includes("@") ||
							(e.author = {
								email: n.substr(0, n.length - 1),
								name: r.join("<").trim(),
							})
					}),
					new Ft(/(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g, (e, [t, r, n]) => {
						;(e.summary.changes = parseInt(t, 10) || 0),
							(e.summary.insertions = parseInt(r, 10) || 0),
							(e.summary.deletions = parseInt(n, 10) || 0)
					}),
					new Ft(/^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/, (e, [t, r, n]) => {
						e.summary.changes = parseInt(t, 10) || 0
						let i = parseInt(r, 10) || 0
						n === "-" ? (e.summary.deletions = i) : n === "+" && (e.summary.insertions = i)
					}),
				])
		},
	})
function tAt(e, t, r) {
	return {
		commands: ["-c", "core.abbrev=40", "commit", ...zx(e, "-m"), ...t, ...r],
		format: "utf-8",
		parser: Xpt,
	}
}
function rAt() {
	return {
		commit(t, ...r) {
			let n = ci(arguments),
				i = e(t) || tAt(Nu(t), Nu(Pu(r[0], QM, [])), [...Pu(r[1], n_, []), ...zo(arguments, 0, !0)])
			return this._runTask(i, n)
		},
	}
	function e(t) {
		return !QM(t) && jo("git.commit: requires the commit message to be supplied as a string/string[]")
	}
}
var nAt = Se({
	"src/lib/tasks/commit.ts"() {
		"use strict"
		eAt(), wt(), Ci()
	},
})
function iAt() {
	return {
		firstCommit() {
			return this._runTask(mo(["rev-list", "--max-parents=0", "HEAD"], !0), ci(arguments))
		},
	}
}
var sAt = Se({
	"src/lib/tasks/first-commit.ts"() {
		"use strict"
		wt(), Ci()
	},
})
function oAt(e, t) {
	let r = ["hash-object", e]
	return t && r.push("-w"), mo(r, !0)
}
var aAt = Se({
	"src/lib/tasks/hash-object.ts"() {
		"use strict"
		Ci()
	},
})
function lAt(e, t, r) {
	let n = String(r).trim(),
		i
	if ((i = sEe.exec(n))) return new kM(e, t, !1, i[1])
	if ((i = oEe.exec(n))) return new kM(e, t, !0, i[1])
	let s = "",
		o = n.split(" ")
	for (; o.length; )
		if (o.shift() === "in") {
			s = o.join(" ")
			break
		}
	return new kM(e, t, /^re/i.test(n), s)
}
var kM,
	sEe,
	oEe,
	cAt = Se({
		"src/lib/responses/InitSummary.ts"() {
			"use strict"
			;(kM = class {
				constructor(e, t, r, n) {
					;(this.bare = e), (this.path = t), (this.existing = r), (this.gitDir = n)
				}
			}),
				(sEe = /^Init.+ repository in (.+)$/),
				(oEe = /^Rein.+ in (.+)$/)
		},
	})
function uAt(e) {
	return e.includes(hG)
}
function dAt(e = !1, t, r) {
	let n = ["init", ...r]
	return (
		e && !uAt(n) && n.splice(1, 0, hG),
		{
			commands: n,
			format: "utf-8",
			parser(i) {
				return lAt(n.includes("--bare"), t, i)
			},
		}
	)
}
var hG,
	fAt = Se({
		"src/lib/tasks/init.ts"() {
			"use strict"
			cAt(), (hG = "--bare")
		},
	})
function gG(e) {
	for (let t = 0; t < e.length; t++) {
		let r = pG.exec(e[t])
		if (r) return `--${r[1]}`
	}
	return ""
}
function hAt(e) {
	return pG.test(e)
}
var pG,
	i_ = Se({
		"src/lib/args/log-format.ts"() {
			"use strict"
			pG = /^--(stat|numstat|name-only|name-status)(=|$)/
		},
	}),
	aEe,
	gAt = Se({
		"src/lib/responses/DiffSummary.ts"() {
			"use strict"
			aEe = class {
				constructor() {
					;(this.changed = 0), (this.deletions = 0), (this.insertions = 0), (this.files = [])
				}
			}
		},
	})
function lEe(e = "") {
	let t = cEe[e]
	return (r) => Zo(new aEe(), t, r, !1)
}
var P4,
	NCe,
	PCe,
	LCe,
	cEe,
	uEe = Se({
		"src/lib/parsers/parse-diff-summary.ts"() {
			"use strict"
			i_(),
				gAt(),
				Gve(),
				wt(),
				(P4 = [
					new Ft(/^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/, (e, [t, r, n = ""]) => {
						e.files.push({
							file: t.trim(),
							changes: mn(r),
							insertions: n.replace(/[^+]/g, "").length,
							deletions: n.replace(/[^-]/g, "").length,
							binary: !1,
						})
					}),
					new Ft(/^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (e, [t, r, n]) => {
						e.files.push({
							file: t.trim(),
							before: mn(r),
							after: mn(n),
							binary: !0,
						})
					}),
					new Ft(/(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/, (e, [t, r]) => {
						let n = /(\d+) i/.exec(r),
							i = /(\d+) d/.exec(r)
						;(e.changed = mn(t)), (e.insertions = mn(n?.[1])), (e.deletions = mn(i?.[1]))
					}),
				]),
				(NCe = [
					new Ft(/(\d+)\t(\d+)\t(.+)$/, (e, [t, r, n]) => {
						let i = mn(t),
							s = mn(r)
						e.changed++,
							(e.insertions += i),
							(e.deletions += s),
							e.files.push({
								file: n,
								changes: i + s,
								insertions: i,
								deletions: s,
								binary: !1,
							})
					}),
					new Ft(/-\t-\t(.+)$/, (e, [t]) => {
						e.changed++, e.files.push({ file: t, after: 0, before: 0, binary: !0 })
					}),
				]),
				(PCe = [
					new Ft(/(.+)$/, (e, [t]) => {
						e.changed++,
							e.files.push({
								file: t,
								changes: 0,
								insertions: 0,
								deletions: 0,
								binary: !1,
							})
					}),
				]),
				(LCe = [
					new Ft(/([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/, (e, [t, r, n, i, s]) => {
						e.changed++,
							e.files.push({
								file: s ?? n,
								changes: 0,
								insertions: 0,
								deletions: 0,
								binary: !1,
								status: q4(kpt(t) && t),
								from: q4(!!s && n !== s && n),
								similarity: mn(r),
							})
					}),
				]),
				(cEe = {
					"": P4,
					"--stat": P4,
					"--numstat": NCe,
					"--name-status": LCe,
					"--name-only": PCe,
				})
		},
	})
function pAt(e, t) {
	return t.reduce((r, n, i) => ((r[n] = e[i] || ""), r), Object.create({ diff: null }))
}
function dEe(e = yG, t = fEe, r = "") {
	let n = lEe(r)
	return function (i) {
		let s = t_(i.trim(), !1, AG).map(function (o) {
			let a = o.split(mG),
				l = pAt(a[0].split(e), t)
			return a.length > 1 && a[1].trim() && (l.diff = n(a[1])), l
		})
		return { all: s, latest: (s.length && s[0]) || null, total: s.length }
	}
}
var AG,
	mG,
	yG,
	fEe,
	hEe = Se({
		"src/lib/parsers/parse-list-log-summary.ts"() {
			"use strict"
			wt(),
				uEe(),
				i_(),
				(AG = "\xF2\xF2\xF2\xF2\xF2\xF2 "),
				(mG = " \xF2\xF2"),
				(yG = " \xF2 "),
				(fEe = ["hash", "date", "message", "refs", "author_name", "author_email"])
		},
	}),
	gEe = {}
vi(gEe, { diffSummaryTask: () => AAt, validateLogFormatConfig: () => GM })
function AAt(e) {
	let t = gG(e),
		r = ["diff"]
	return (
		t === "" && ((t = "--stat"), r.push("--stat=4096")),
		r.push(...e),
		GM(r) || { commands: r, format: "utf-8", parser: lEe(t) }
	)
}
function GM(e) {
	let t = e.filter(hAt)
	if (t.length > 1) return jo(`Summary flags are mutually exclusive - pick one of ${t.join(",")}`)
	if (t.length && e.includes("-z"))
		return jo(`Summary flag ${t} parsing is not compatible with null termination option '-z'`)
}
var CG = Se({
	"src/lib/tasks/diff.ts"() {
		"use strict"
		i_(), uEe(), Ci()
	},
})
function mAt(e, t) {
	let r = [],
		n = []
	return (
		Object.keys(e).forEach((i) => {
			r.push(i), n.push(String(e[i]))
		}),
		[r, n.join(t)]
	)
}
function yAt(e) {
	return Object.keys(e).reduce((t, r) => (r in J4 || (t[r] = e[r]), t), {})
}
function pEe(e = {}, t = []) {
	let r = Pu(e.splitter, $s, yG),
		n =
			!rG(e.format) && e.format
				? e.format
				: {
						hash: "%H",
						date: e.strictDate === !1 ? "%ai" : "%aI",
						message: "%s",
						refs: "%D",
						body: e.multiLine ? "%B" : "%b",
						author_name: e.mailMap !== !1 ? "%aN" : "%an",
						author_email: e.mailMap !== !1 ? "%aE" : "%ae",
					},
		[i, s] = mAt(n, r),
		o = [],
		a = [`--pretty=format:${AG}${s}${mG}`, ...t],
		l = e.n || e["max-count"] || e.maxCount
	if ((l && a.push(`--max-count=${l}`), e.from || e.to)) {
		let c = e.symmetric !== !1 ? "..." : ".."
		o.push(`${e.from || ""}${c}${e.to || ""}`)
	}
	return (
		$s(e.file) && a.push("--follow", opt(e.file)), sG(yAt(e), a), { fields: i, splitter: r, commands: [...a, ...o] }
	)
}
function CAt(e, t, r) {
	let n = dEe(e, t, gG(r))
	return { commands: ["log", ...r], format: "utf-8", parser: n }
}
function vAt() {
	return {
		log(...r) {
			let n = ci(arguments),
				i = pEe(oG(arguments), Pu(arguments[0], n_)),
				s = t(...r) || GM(i.commands) || e(i)
			return this._runTask(s, n)
		},
	}
	function e(r) {
		return CAt(r.splitter, r.fields, r.commands)
	}
	function t(r, n) {
		return (
			$s(r) &&
			$s(n) &&
			jo("git.log(string, string) should be replaced with git.log({ from: string, to: string })")
		)
	}
}
var J4,
	AEe = Se({
		"src/lib/tasks/log.ts"() {
			"use strict"
			i_(),
				Xx(),
				hEe(),
				wt(),
				Ci(),
				CG(),
				(J4 = ((e) => (
					(e[(e["--pretty"] = 0)] = "--pretty"),
					(e[(e["max-count"] = 1)] = "max-count"),
					(e[(e.maxCount = 2)] = "maxCount"),
					(e[(e.n = 3)] = "n"),
					(e[(e.file = 4)] = "file"),
					(e[(e.format = 5)] = "format"),
					(e[(e.from = 6)] = "from"),
					(e[(e.to = 7)] = "to"),
					(e[(e.splitter = 8)] = "splitter"),
					(e[(e.symmetric = 9)] = "symmetric"),
					(e[(e.mailMap = 10)] = "mailMap"),
					(e[(e.multiLine = 11)] = "multiLine"),
					(e[(e.strictDate = 12)] = "strictDate"),
					e
				))(J4 || {}))
		},
	}),
	MM,
	mEe,
	EAt = Se({
		"src/lib/responses/MergeSummary.ts"() {
			"use strict"
			;(MM = class {
				constructor(e, t = null, r) {
					;(this.reason = e), (this.file = t), (this.meta = r)
				}
				toString() {
					return `${this.file}:${this.reason}`
				}
			}),
				(mEe = class {
					constructor() {
						;(this.conflicts = []), (this.merges = []), (this.result = "success")
					}
					get failed() {
						return this.conflicts.length > 0
					}
					get reason() {
						return this.result
					}
					toString() {
						return this.conflicts.length ? `CONFLICTS: ${this.conflicts.join(", ")}` : "OK"
					}
				})
		},
	}),
	z4,
	yEe,
	bAt = Se({
		"src/lib/responses/PullSummary.ts"() {
			"use strict"
			;(z4 = class {
				constructor() {
					;(this.remoteMessages = { all: [] }),
						(this.created = []),
						(this.deleted = []),
						(this.files = []),
						(this.deletions = {}),
						(this.insertions = {}),
						(this.summary = { changes: 0, deletions: 0, insertions: 0 })
				}
			}),
				(yEe = class {
					constructor() {
						;(this.remote = ""),
							(this.hash = { local: "", remote: "" }),
							(this.branch = { local: "", remote: "" }),
							(this.message = "")
					}
					toString() {
						return this.message
					}
				})
		},
	})
function L4(e) {
	return (e.objects = e.objects || {
		compressing: 0,
		counting: 0,
		enumerating: 0,
		packReused: 0,
		reused: { count: 0, delta: 0 },
		total: { count: 0, delta: 0 },
	})
}
function UCe(e) {
	let t = /^\s*(\d+)/.exec(e),
		r = /delta (\d+)/i.exec(e)
	return { count: mn((t && t[1]) || "0"), delta: mn((r && r[1]) || "0") }
}
var CEe,
	xAt = Se({
		"src/lib/parsers/parse-remote-objects.ts"() {
			"use strict"
			wt(),
				(CEe = [
					new Vh(/^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i, (e, [t, r]) => {
						let n = t.toLowerCase(),
							i = L4(e.remoteMessages)
						Object.assign(i, { [n]: mn(r) })
					}),
					new Vh(
						/^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i,
						(e, [t, r]) => {
							let n = t.toLowerCase(),
								i = L4(e.remoteMessages)
							Object.assign(i, { [n]: mn(r) })
						},
					),
					new Vh(/total ([^,]+), reused ([^,]+), pack-reused (\d+)/i, (e, [t, r, n]) => {
						let i = L4(e.remoteMessages)
						;(i.total = UCe(t)), (i.reused = UCe(r)), (i.packReused = mn(n))
					}),
				])
		},
	})
function vEe(e, t) {
	return Zo({ remoteMessages: new bEe() }, EEe, t)
}
var EEe,
	bEe,
	xEe = Se({
		"src/lib/parsers/parse-remote-messages.ts"() {
			"use strict"
			wt(),
				xAt(),
				(EEe = [
					new Vh(/^remote:\s*(.+)$/, (e, [t]) => (e.remoteMessages.all.push(t.trim()), !1)),
					...CEe,
					new Vh([/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/], (e, [t]) => {
						e.remoteMessages.pullRequestUrl = t
					}),
					new Vh([/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/], (e, [t, r, n]) => {
						e.remoteMessages.vulnerabilities = {
							count: mn(t),
							summary: r,
							url: n,
						}
					}),
				]),
				(bEe = class {
					constructor() {
						this.all = []
					}
				})
		},
	})
function _At(e, t) {
	let r = Zo(new yEe(), _Ee, [e, t])
	return r.message && r
}
var OCe,
	qCe,
	VCe,
	HCe,
	_Ee,
	WCe,
	vG,
	wEe = Se({
		"src/lib/parsers/parse-pull.ts"() {
			"use strict"
			bAt(),
				wt(),
				xEe(),
				(OCe = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/),
				(qCe = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/),
				(VCe = /^(create|delete) mode \d+ (.+)/),
				(HCe = [
					new Ft(OCe, (e, [t, r, n]) => {
						e.files.push(t), r && (e.insertions[t] = r.length), n && (e.deletions[t] = n.length)
					}),
					new Ft(qCe, (e, [t, , r, , n]) =>
						r !== void 0 || n !== void 0
							? ((e.summary.changes = +t || 0),
								(e.summary.insertions = +r || 0),
								(e.summary.deletions = +n || 0),
								!0)
							: !1,
					),
					new Ft(VCe, (e, [t, r]) => {
						Qr(e.files, r), Qr(t === "create" ? e.created : e.deleted, r)
					}),
				]),
				(_Ee = [
					new Ft(/^from\s(.+)$/i, (e, [t]) => void (e.remote = t)),
					new Ft(/^fatal:\s(.+)$/, (e, [t]) => void (e.message = t)),
					new Ft(/([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/, (e, [t, r, n, i]) => {
						;(e.branch.local = n), (e.hash.local = t), (e.branch.remote = i), (e.hash.remote = r)
					}),
				]),
				(WCe = (e, t) => Zo(new z4(), HCe, [e, t])),
				(vG = (e, t) => Object.assign(new z4(), WCe(e, t), vEe(e, t)))
		},
	}),
	GCe,
	IEe,
	$Ce,
	wAt = Se({
		"src/lib/parsers/parse-merge.ts"() {
			"use strict"
			EAt(),
				wt(),
				wEe(),
				(GCe = [
					new Ft(/^Auto-merging\s+(.+)$/, (e, [t]) => {
						e.merges.push(t)
					}),
					new Ft(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (e, [t, r]) => {
						e.conflicts.push(new MM(t, r))
					}),
					new Ft(/^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/, (e, [t, r, n]) => {
						e.conflicts.push(new MM(t, r, { deleteRef: n }))
					}),
					new Ft(/^CONFLICT\s+\((.+)\):/, (e, [t]) => {
						e.conflicts.push(new MM(t, null))
					}),
					new Ft(/^Automatic merge failed;\s+(.+)$/, (e, [t]) => {
						e.result = t
					}),
				]),
				(IEe = (e, t) => Object.assign($Ce(e, t), vG(e, t))),
				($Ce = (e) => Zo(new mEe(), GCe, e))
		},
	})
function YCe(e) {
	return e.length
		? {
				commands: ["merge", ...e],
				format: "utf-8",
				parser(t, r) {
					let n = IEe(t, r)
					if (n.failed) throw new e_(n)
					return n
				},
			}
		: jo("Git.merge requires at least one option")
}
var IAt = Se({
	"src/lib/tasks/merge.ts"() {
		"use strict"
		Vy(), wAt(), Ci()
	},
})
function SAt(e, t, r) {
	let n = r.includes("deleted"),
		i = r.includes("tag") || /^refs\/tags/.test(e),
		s = !r.includes("new")
	return {
		deleted: n,
		tag: i,
		branch: !i,
		new: !s,
		alreadyUpdated: s,
		local: e,
		remote: t,
	}
}
var KCe,
	SEe,
	JCe,
	BAt = Se({
		"src/lib/parsers/parse-push.ts"() {
			"use strict"
			wt(),
				xEe(),
				(KCe = [
					new Ft(/^Pushing to (.+)$/, (e, [t]) => {
						e.repo = t
					}),
					new Ft(/^updating local tracking ref '(.+)'/, (e, [t]) => {
						e.ref = Jx(_l({}, e.ref || {}), { local: t })
					}),
					new Ft(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (e, [t, r, n]) => {
						e.pushed.push(SAt(t, r, n))
					}),
					new Ft(
						/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,
						(e, [t, r, n]) => {
							e.branch = Jx(_l({}, e.branch || {}), {
								local: t,
								remote: r,
								remoteName: n,
							})
						},
					),
					new Ft(/^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/, (e, [t, r, n, i]) => {
						e.update = {
							head: { local: t, remote: r },
							hash: { from: n, to: i },
						}
					}),
				]),
				(SEe = (e, t) => {
					let r = JCe(e, t),
						n = vEe(e, t)
					return _l(_l({}, r), n)
				}),
				(JCe = (e, t) => Zo({ pushed: [] }, KCe, [e, t]))
		},
	}),
	BEe = {}
vi(BEe, { pushTagsTask: () => DAt, pushTask: () => EG })
function DAt(e = {}, t) {
	return Qr(t, "--tags"), EG(e, t)
}
function EG(e = {}, t) {
	let r = ["push", ...t]
	return (
		e.branch && r.splice(1, 0, e.branch),
		e.remote && r.splice(1, 0, e.remote),
		qM(r, "-v"),
		Qr(r, "--verbose"),
		Qr(r, "--porcelain"),
		{ commands: r, format: "utf-8", parser: SEe }
	)
}
var DEe = Se({
	"src/lib/tasks/push.ts"() {
		"use strict"
		BAt(), wt()
	},
})
function TAt() {
	return {
		showBuffer() {
			let e = ["show", ...zo(arguments, 1)]
			return e.includes("--binary") || e.splice(1, 0, "--binary"), this._runTask(Qve(e), ci(arguments))
		},
		show() {
			let e = ["show", ...zo(arguments, 1)]
			return this._runTask(mo(e), ci(arguments))
		},
	}
}
var RAt = Se({
		"src/lib/tasks/show.ts"() {
			"use strict"
			wt(), Ci()
		},
	}),
	zCe,
	TEe,
	kAt = Se({
		"src/lib/responses/FileStatusSummary.ts"() {
			"use strict"
			;(zCe = /^(.+)\0(.+)$/),
				(TEe = class {
					constructor(e, t, r) {
						if (((this.path = e), (this.index = t), (this.working_dir = r), t === "R" || r === "R")) {
							let n = zCe.exec(e) || [null, e, e]
							;(this.from = n[2] || ""), (this.path = n[1] || "")
						}
					}
				})
		},
	})
function jCe(e) {
	let [t, r] = e.split(qy)
	return { from: r || t, to: t }
}
function Ma(e, t, r) {
	return [`${e}${t}`, r]
}
function U4(e, ...t) {
	return t.map((r) => Ma(e, r, (n, i) => Qr(n.conflicted, i)))
}
function MAt(e, t) {
	let r = t.trim()
	switch (" ") {
		case r.charAt(2):
			return n(r.charAt(0), r.charAt(1), r.substr(3))
		case r.charAt(1):
			return n(" ", r.charAt(0), r.substr(2))
		default:
			return
	}
	function n(i, s, o) {
		let a = `${i}${s}`,
			l = REe.get(a)
		l && l(e, o), a !== "##" && a !== "!!" && e.files.push(new TEe(o, i, s))
	}
}
var ZCe,
	REe,
	kEe,
	FAt = Se({
		"src/lib/responses/StatusSummary.ts"() {
			"use strict"
			wt(),
				kAt(),
				(ZCe = class {
					constructor() {
						;(this.not_added = []),
							(this.conflicted = []),
							(this.created = []),
							(this.deleted = []),
							(this.ignored = void 0),
							(this.modified = []),
							(this.renamed = []),
							(this.files = []),
							(this.staged = []),
							(this.ahead = 0),
							(this.behind = 0),
							(this.current = null),
							(this.tracking = null),
							(this.detached = !1),
							(this.isClean = () => !this.files.length)
					}
				}),
				(REe = new Map([
					Ma(" ", "A", (e, t) => Qr(e.created, t)),
					Ma(" ", "D", (e, t) => Qr(e.deleted, t)),
					Ma(" ", "M", (e, t) => Qr(e.modified, t)),
					Ma("A", " ", (e, t) => Qr(e.created, t) && Qr(e.staged, t)),
					Ma("A", "M", (e, t) => Qr(e.created, t) && Qr(e.staged, t) && Qr(e.modified, t)),
					Ma("D", " ", (e, t) => Qr(e.deleted, t) && Qr(e.staged, t)),
					Ma("M", " ", (e, t) => Qr(e.modified, t) && Qr(e.staged, t)),
					Ma("M", "M", (e, t) => Qr(e.modified, t) && Qr(e.staged, t)),
					Ma("R", " ", (e, t) => {
						Qr(e.renamed, jCe(t))
					}),
					Ma("R", "M", (e, t) => {
						let r = jCe(t)
						Qr(e.renamed, r), Qr(e.modified, r.to)
					}),
					Ma("!", "!", (e, t) => {
						Qr((e.ignored = e.ignored || []), t)
					}),
					Ma("?", "?", (e, t) => Qr(e.not_added, t)),
					...U4("A", "A", "U"),
					...U4("D", "D", "U"),
					...U4("U", "A", "D", "U"),
					[
						"##",
						(e, t) => {
							let r = /ahead (\d+)/,
								n = /behind (\d+)/,
								i = /^(.+?(?=(?:\.{3}|\s|$)))/,
								s = /\.{3}(\S*)/,
								o = /\son\s([\S]+)$/,
								a
							;(a = r.exec(t)),
								(e.ahead = (a && +a[1]) || 0),
								(a = n.exec(t)),
								(e.behind = (a && +a[1]) || 0),
								(a = i.exec(t)),
								(e.current = a && a[1]),
								(a = s.exec(t)),
								(e.tracking = a && a[1]),
								(a = o.exec(t)),
								(e.current = (a && a[1]) || e.current),
								(e.detached = /\(no branch\)/.test(t))
						},
					],
				])),
				(kEe = function (e) {
					let t = e.split(qy),
						r = new ZCe()
					for (let n = 0, i = t.length; n < i; ) {
						let s = t[n++].trim()
						s && (s.charAt(0) === "R" && (s += qy + (t[n++] || "")), MAt(r, s))
					}
					return r
				})
		},
	})
function QAt(e) {
	return {
		format: "utf-8",
		commands: ["status", "--porcelain", "-b", "-u", "--null", ...e.filter((r) => !MEe.includes(r))],
		parser(r) {
			return kEe(r)
		},
	}
}
var MEe,
	NAt = Se({
		"src/lib/tasks/status.ts"() {
			"use strict"
			FAt(), (MEe = ["--null", "-z"])
		},
	})
function PM(e = 0, t = 0, r = 0, n = "", i = !0) {
	return Object.defineProperty({ major: e, minor: t, patch: r, agent: n, installed: i }, "toString", {
		value() {
			return `${this.major}.${this.minor}.${this.patch}`
		},
		configurable: !1,
		enumerable: !1,
	})
}
function PAt() {
	return PM(0, 0, 0, "", !1)
}
function LAt() {
	return {
		version() {
			return this._runTask({
				commands: ["--version"],
				format: "utf-8",
				parser: UAt,
				onError(e, t, r, n) {
					if (e.exitCode === -2) return r(Buffer.from(bG))
					n(t)
				},
			})
		},
	}
}
function UAt(e) {
	return e === bG ? PAt() : Zo(PM(0, 0, 0, e), FEe, e)
}
var bG,
	FEe,
	OAt = Se({
		"src/lib/tasks/version.ts"() {
			"use strict"
			wt(),
				(bG = "installed=false"),
				(FEe = [
					new Ft(/version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/, (e, [t, r, n, i = ""]) => {
						Object.assign(e, PM(mn(t), mn(r), mn(n), i))
					}),
					new Ft(/version (\d+)\.(\d+)\.(\D+)(.+)?$/, (e, [t, r, n, i = ""]) => {
						Object.assign(e, PM(mn(t), mn(r), n, i))
					}),
				])
		},
	}),
	QEe = {}
vi(QEe, { SimpleGitApi: () => j4 })
var j4,
	qAt = Se({
		"src/lib/simple-git-api.ts"() {
			"use strict"
			$pt(),
				Ypt(),
				Jpt(),
				Zpt(),
				nAt(),
				Hve(),
				sAt(),
				Kve(),
				aAt(),
				fAt(),
				AEe(),
				IAt(),
				DEe(),
				RAt(),
				NAt(),
				Ci(),
				OAt(),
				wt(),
				(j4 = class {
					constructor(e) {
						this._executor = e
					}
					_runTask(e, t) {
						let r = this._executor.chain(),
							n = r.push(e)
						return (
							t && Wpt(e, n, t),
							Object.create(this, {
								then: { value: n.then.bind(n) },
								catch: { value: n.catch.bind(n) },
								_executor: { value: r },
							})
						)
					}
					add(e) {
						return this._runTask(mo(["add", ...Nu(e)]), ci(arguments))
					}
					cwd(e) {
						let t = ci(arguments)
						return typeof e == "string"
							? this._runTask(QCe(e, this._executor), t)
							: typeof e?.path == "string"
								? this._runTask(QCe(e.path, (e.root && this._executor) || void 0), t)
								: this._runTask(jo("Git.cwd: workingDirectory must be supplied as a string"), t)
					}
					hashObject(e, t) {
						return this._runTask(oAt(e, t === !0), ci(arguments))
					}
					init(e) {
						return this._runTask(dAt(e === !0, this._executor.cwd, zo(arguments)), ci(arguments))
					}
					merge() {
						return this._runTask(YCe(zo(arguments)), ci(arguments))
					}
					mergeFromTo(e, t) {
						return $s(e) && $s(t)
							? this._runTask(YCe([e, t, ...zo(arguments)]), ci(arguments, !1))
							: this._runTask(
									jo(
										"Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings",
									),
								)
					}
					outputHandler(e) {
						return (this._executor.outputHandler = e), this
					}
					push() {
						let e = EG({ remote: Pu(arguments[0], $s), branch: Pu(arguments[1], $s) }, zo(arguments))
						return this._runTask(e, ci(arguments))
					}
					stash() {
						return this._runTask(mo(["stash", ...zo(arguments)]), ci(arguments))
					}
					status() {
						return this._runTask(QAt(zo(arguments)), ci(arguments))
					}
				}),
				Object.assign(j4.prototype, Kpt(), rAt(), Rpt(), jpt(), iAt(), Qpt(), vAt(), TAt(), LAt())
		},
	}),
	NEe = {}
vi(NEe, { Scheduler: () => LEe })
var XCe,
	LEe,
	VAt = Se({
		"src/lib/runners/scheduler.ts"() {
			"use strict"
			wt(),
				Xve(),
				(XCe = (() => {
					let e = 0
					return () => {
						e++
						let { promise: t, done: r } = (0, PEe.createDeferred)()
						return { promise: t, done: r, id: e }
					}
				})()),
				(LEe = class {
					constructor(e = 2) {
						;(this.concurrency = e),
							(this.logger = fG("", "scheduler")),
							(this.pending = []),
							(this.running = []),
							this.logger("Constructed, concurrency=%s", e)
					}
					schedule() {
						if (!this.pending.length || this.running.length >= this.concurrency) {
							this.logger(
								"Schedule attempt ignored, pending=%s running=%s concurrency=%s",
								this.pending.length,
								this.running.length,
								this.concurrency,
							)
							return
						}
						let e = Qr(this.running, this.pending.shift())
						this.logger("Attempting id=%s", e.id),
							e.done(() => {
								this.logger("Completing id=", e.id), qM(this.running, e), this.schedule()
							})
					}
					next() {
						let { promise: e, id: t } = Qr(this.pending, XCe())
						return this.logger("Scheduling id=%s", t), this.schedule(), e
					}
				})
		},
	}),
	UEe = {}
vi(UEe, { applyPatchTask: () => HAt })
function HAt(e, t) {
	return mo(["apply", ...t, ...e])
}
var WAt = Se({
	"src/lib/tasks/apply-patch.ts"() {
		"use strict"
		Ci()
	},
})
function GAt(e, t) {
	return { branch: e, hash: t, success: !0 }
}
function $At(e) {
	return { branch: e, hash: null, success: !1 }
}
var OEe,
	YAt = Se({
		"src/lib/responses/BranchDeleteSummary.ts"() {
			"use strict"
			OEe = class {
				constructor() {
					;(this.all = []), (this.branches = {}), (this.errors = [])
				}
				get success() {
					return !this.errors.length
				}
			}
		},
	})
function qEe(e, t) {
	return t === 1 && Z4.test(e)
}
var eve,
	Z4,
	tve,
	$M,
	KAt = Se({
		"src/lib/parsers/parse-branch-delete.ts"() {
			"use strict"
			YAt(),
				wt(),
				(eve = /(\S+)\s+\(\S+\s([^)]+)\)/),
				(Z4 = /^error[^']+'([^']+)'/m),
				(tve = [
					new Ft(eve, (e, [t, r]) => {
						let n = GAt(t, r)
						e.all.push(n), (e.branches[t] = n)
					}),
					new Ft(Z4, (e, [t]) => {
						let r = $At(t)
						e.errors.push(r), e.all.push(r), (e.branches[t] = r)
					}),
				]),
				($M = (e, t) => Zo(new OEe(), tve, [e, t]))
		},
	}),
	VEe,
	JAt = Se({
		"src/lib/responses/BranchSummary.ts"() {
			"use strict"
			VEe = class {
				constructor() {
					;(this.all = []), (this.branches = {}), (this.current = ""), (this.detached = !1)
				}
				push(e, t, r, n, i) {
					e === "*" && ((this.detached = t), (this.current = r)),
						this.all.push(r),
						(this.branches[r] = {
							current: e === "*",
							linkedWorkTree: e === "+",
							name: r,
							commit: n,
							label: i,
						})
				}
			}
		},
	})
function rve(e) {
	return e ? e.charAt(0) : ""
}
function HEe(e) {
	return Zo(new VEe(), WEe, e)
}
var WEe,
	zAt = Se({
		"src/lib/parsers/parse-branch.ts"() {
			"use strict"
			JAt(),
				wt(),
				(WEe = [
					new Ft(
						/^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/,
						(e, [t, r, n, i]) => {
							e.push(rve(t), !0, r, n, i)
						},
					),
					new Ft(new RegExp("^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$", "s"), (e, [t, r, n, i]) => {
						e.push(rve(t), !1, r, n, i)
					}),
				])
		},
	}),
	GEe = {}
vi(GEe, {
	branchLocalTask: () => ZAt,
	branchTask: () => jAt,
	containsDeleteBranchCommand: () => $Ee,
	deleteBranchTask: () => emt,
	deleteBranchesTask: () => XAt,
})
function $Ee(e) {
	let t = ["-d", "-D", "--delete"]
	return e.some((r) => t.includes(r))
}
function jAt(e) {
	let t = $Ee(e),
		r = ["branch", ...e]
	return (
		r.length === 1 && r.push("-a"),
		r.includes("-v") || r.splice(1, 0, "-v"),
		{
			format: "utf-8",
			commands: r,
			parser(n, i) {
				return t ? $M(n, i).all[0] : HEe(n)
			},
		}
	)
}
function ZAt() {
	return { format: "utf-8", commands: ["branch", "-v"], parser: HEe }
}
function XAt(e, t = !1) {
	return {
		format: "utf-8",
		commands: ["branch", "-v", t ? "-D" : "-d", ...e],
		parser(r, n) {
			return $M(r, n)
		},
		onError({ exitCode: r, stdOut: n }, i, s, o) {
			if (!qEe(String(i), r)) return o(i)
			s(n)
		},
	}
}
function emt(e, t = !1) {
	let r = {
		format: "utf-8",
		commands: ["branch", "-v", t ? "-D" : "-d", e],
		parser(n, i) {
			return $M(n, i).branches[e]
		},
		onError({ exitCode: n, stdErr: i, stdOut: s }, o, a, l) {
			if (!qEe(String(o), n)) return l(o)
			throw new e_(r.parser(jx(s), jx(i)), String(o))
		},
	}
	return r
}
var tmt = Se({
		"src/lib/tasks/branch.ts"() {
			"use strict"
			Vy(), KAt(), zAt(), wt()
		},
	}),
	YEe,
	rmt = Se({
		"src/lib/responses/CheckIgnore.ts"() {
			"use strict"
			YEe = (e) =>
				e
					.split(/\n/g)
					.map((t) => t.trim())
					.filter((t) => !!t)
		},
	}),
	KEe = {}
vi(KEe, { checkIgnoreTask: () => nmt })
function nmt(e) {
	return { commands: ["check-ignore", ...e], format: "utf-8", parser: YEe }
}
var imt = Se({
		"src/lib/tasks/check-ignore.ts"() {
			"use strict"
			rmt()
		},
	}),
	JEe = {}
vi(JEe, { cloneMirrorTask: () => omt, cloneTask: () => zEe })
function smt(e) {
	return /^--upload-pack(=|$)/.test(e)
}
function zEe(e, t, r) {
	let n = ["clone", ...r]
	return (
		$s(e) && n.push(e),
		$s(t) && n.push(t),
		n.find(smt) ? jo("git.fetch: potential exploit argument blocked.") : mo(n)
	)
}
function omt(e, t, r) {
	return Qr(r, "--mirror"), zEe(e, t, r)
}
var amt = Se({
	"src/lib/tasks/clone.ts"() {
		"use strict"
		Ci(), wt()
	},
})
function lmt(e, t) {
	return Zo({ raw: e, remote: null, branches: [], tags: [], updated: [], deleted: [] }, jEe, [e, t])
}
var jEe,
	cmt = Se({
		"src/lib/parsers/parse-fetch.ts"() {
			"use strict"
			wt(),
				(jEe = [
					new Ft(/From (.+)$/, (e, [t]) => {
						e.remote = t
					}),
					new Ft(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (e, [t, r]) => {
						e.branches.push({ name: t, tracking: r })
					}),
					new Ft(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (e, [t, r]) => {
						e.tags.push({ name: t, tracking: r })
					}),
					new Ft(/- \[deleted]\s+\S+\s*-> (.+)$/, (e, [t]) => {
						e.deleted.push({ tracking: t })
					}),
					new Ft(/\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/, (e, [t, r, n, i]) => {
						e.updated.push({ name: n, tracking: i, to: r, from: t })
					}),
				])
		},
	}),
	ZEe = {}
vi(ZEe, { fetchTask: () => dmt })
function umt(e) {
	return /^--upload-pack(=|$)/.test(e)
}
function dmt(e, t, r) {
	let n = ["fetch", ...r]
	return (
		e && t && n.push(e, t),
		n.find(umt)
			? jo("git.fetch: potential exploit argument blocked.")
			: { commands: n, format: "utf-8", parser: lmt }
	)
}
var fmt = Se({
	"src/lib/tasks/fetch.ts"() {
		"use strict"
		cmt(), Ci()
	},
})
function hmt(e) {
	return Zo({ moves: [] }, XEe, e)
}
var XEe,
	gmt = Se({
		"src/lib/parsers/parse-move.ts"() {
			"use strict"
			wt(),
				(XEe = [
					new Ft(/^Renaming (.+) to (.+)$/, (e, [t, r]) => {
						e.moves.push({ from: t, to: r })
					}),
				])
		},
	}),
	ebe = {}
vi(ebe, { moveTask: () => pmt })
function pmt(e, t) {
	return { commands: ["mv", "-v", ...Nu(e), t], format: "utf-8", parser: hmt }
}
var Amt = Se({
		"src/lib/tasks/move.ts"() {
			"use strict"
			gmt(), wt()
		},
	}),
	tbe = {}
vi(tbe, { pullTask: () => mmt })
function mmt(e, t, r) {
	let n = ["pull", ...r]
	return (
		e && t && n.splice(1, 0, e, t),
		{
			commands: n,
			format: "utf-8",
			parser(i, s) {
				return vG(i, s)
			},
			onError(i, s, o, a) {
				let l = _At(jx(i.stdOut), jx(i.stdErr))
				if (l) return a(new e_(l))
				a(s)
			},
		}
	)
}
var ymt = Se({
	"src/lib/tasks/pull.ts"() {
		"use strict"
		Vy(), wEe(), wt()
	},
})
function Cmt(e) {
	let t = {}
	return rbe(e, ([r]) => (t[r] = { name: r })), Object.values(t)
}
function vmt(e) {
	let t = {}
	return (
		rbe(e, ([r, n, i]) => {
			t.hasOwnProperty(r) || (t[r] = { name: r, refs: { fetch: "", push: "" } }),
				i && n && (t[r].refs[i.replace(/[^a-z]/g, "")] = n)
		}),
		Object.values(t)
	)
}
function rbe(e, t) {
	eG(e, (r) => t(r.split(/\s+/)))
}
var Emt = Se({
		"src/lib/responses/GetRemoteSummary.ts"() {
			"use strict"
			wt()
		},
	}),
	nbe = {}
vi(nbe, {
	addRemoteTask: () => bmt,
	getRemotesTask: () => xmt,
	listRemotesTask: () => _mt,
	remoteTask: () => wmt,
	removeRemoteTask: () => Imt,
})
function bmt(e, t, r) {
	return mo(["remote", "add", ...r, e, t])
}
function xmt(e) {
	let t = ["remote"]
	return e && t.push("-v"), { commands: t, format: "utf-8", parser: e ? vmt : Cmt }
}
function _mt(e) {
	let t = [...e]
	return t[0] !== "ls-remote" && t.unshift("ls-remote"), mo(t)
}
function wmt(e) {
	let t = [...e]
	return t[0] !== "remote" && t.unshift("remote"), mo(t)
}
function Imt(e) {
	return mo(["remote", "remove", e])
}
var Smt = Se({
		"src/lib/tasks/remote.ts"() {
			"use strict"
			Emt(), Ci()
		},
	}),
	ibe = {}
vi(ibe, { stashListTask: () => Bmt })
function Bmt(e = {}, t) {
	let r = pEe(e),
		n = ["stash", "list", ...r.commands, ...t],
		i = dEe(r.splitter, r.fields, gG(n))
	return GM(n) || { commands: n, format: "utf-8", parser: i }
}
var Dmt = Se({
		"src/lib/tasks/stash-list.ts"() {
			"use strict"
			i_(), hEe(), CG(), AEe()
		},
	}),
	sbe = {}
vi(sbe, {
	addSubModuleTask: () => Tmt,
	initSubModuleTask: () => Rmt,
	subModuleTask: () => YM,
	updateSubModuleTask: () => kmt,
})
function Tmt(e, t) {
	return YM(["add", e, t])
}
function Rmt(e) {
	return YM(["init", ...e])
}
function YM(e) {
	let t = [...e]
	return t[0] !== "submodule" && t.unshift("submodule"), mo(t)
}
function kmt(e) {
	return YM(["update", ...e])
}
var Mmt = Se({
	"src/lib/tasks/sub-module.ts"() {
		"use strict"
		Ci()
	},
})
function Fmt(e, t) {
	let r = isNaN(e),
		n = isNaN(t)
	return r !== n ? (r ? 1 : -1) : r ? obe(e, t) : 0
}
function obe(e, t) {
	return e === t ? 0 : e > t ? 1 : -1
}
function Qmt(e) {
	return e.trim()
}
function DM(e) {
	return (typeof e == "string" && parseInt(e.replace(/^\D+/g, ""), 10)) || 0
}
var nve,
	abe,
	Nmt = Se({
		"src/lib/responses/TagList.ts"() {
			"use strict"
			;(nve = class {
				constructor(e, t) {
					;(this.all = e), (this.latest = t)
				}
			}),
				(abe = function (e, t = !1) {
					let r = e
						.split(
							`
`,
						)
						.map(Qmt)
						.filter(Boolean)
					t ||
						r.sort(function (i, s) {
							let o = i.split("."),
								a = s.split(".")
							if (o.length === 1 || a.length === 1) return Fmt(DM(o[0]), DM(a[0]))
							for (let l = 0, c = Math.max(o.length, a.length); l < c; l++) {
								let u = obe(DM(o[l]), DM(a[l]))
								if (u) return u
							}
							return 0
						})
					let n = t ? r[0] : [...r].reverse().find((i) => i.indexOf(".") >= 0)
					return new nve(r, n)
				})
		},
	}),
	lbe = {}
vi(lbe, {
	addAnnotatedTagTask: () => Umt,
	addTagTask: () => Lmt,
	tagListTask: () => Pmt,
})
function Pmt(e = []) {
	let t = e.some((r) => /^--sort=/.test(r))
	return {
		format: "utf-8",
		commands: ["tag", "-l", ...e],
		parser(r) {
			return abe(r, t)
		},
	}
}
function Lmt(e) {
	return {
		format: "utf-8",
		commands: ["tag", e],
		parser() {
			return { name: e }
		},
	}
}
function Umt(e, t) {
	return {
		format: "utf-8",
		commands: ["tag", "-a", "-m", t, e],
		parser() {
			return { name: e }
		},
	}
}
var Omt = Se({
		"src/lib/tasks/tag.ts"() {
			"use strict"
			Nmt()
		},
	}),
	qmt = ipt({
		"src/git.js"(e, t) {
			"use strict"
			var { GitExecutor: r } = (Hpt(), li(tEe)),
				{ SimpleGitApi: n } = (qAt(), li(QEe)),
				{ Scheduler: i } = (VAt(), li(NEe)),
				{ configurationErrorTask: s } = (Ci(), li(G4)),
				{
					asArray: o,
					filterArray: a,
					filterPrimitives: l,
					filterString: c,
					filterStringOrStringArray: u,
					filterType: f,
					getTrailingOptions: p,
					trailingFunctionArgument: g,
					trailingOptionsArgument: m,
				} = (wt(), li(wve)),
				{ applyPatchTask: y } = (WAt(), li(UEe)),
				{ branchTask: C, branchLocalTask: v, deleteBranchesTask: b, deleteBranchTask: w } = (tmt(), li(GEe)),
				{ checkIgnoreTask: B } = (imt(), li(KEe)),
				{ checkIsRepoTask: M } = (Dve(), li(Ive)),
				{ cloneTask: Q, cloneMirrorTask: O } = (amt(), li(JEe)),
				{ cleanWithOptionsTask: Y, isCleanOptionsArray: j } = (Ove(), li(Lve)),
				{ diffSummaryTask: ne } = (CG(), li(gEe)),
				{ fetchTask: q } = (fmt(), li(ZEe)),
				{ moveTask: me } = (Amt(), li(ebe)),
				{ pullTask: Qe } = (ymt(), li(tbe)),
				{ pushTagsTask: N } = (DEe(), li(BEe)),
				{
					addRemoteTask: re,
					getRemotesTask: K,
					listRemotesTask: se,
					remoteTask: Ze,
					removeRemoteTask: It,
				} = (Smt(), li(nbe)),
				{ getResetMode: Ce, resetTask: Et } = (Zve(), li(Jve)),
				{ stashListTask: jt } = (Dmt(), li(ibe)),
				{
					addSubModuleTask: Ar,
					initSubModuleTask: de,
					subModuleTask: Tr,
					updateSubModuleTask: tr,
				} = (Mmt(), li(sbe)),
				{ addAnnotatedTagTask: Nr, addTagTask: Ve, tagListTask: en } = (Omt(), li(lbe)),
				{ straightThroughBufferTask: Pr, straightThroughStringTask: cr } = (Ci(), li(G4))
			function be(fe, Ee) {
				;(this._plugins = Ee),
					(this._executor = new r(fe.baseDir, new i(fe.maxConcurrentProcesses), Ee)),
					(this._trimmed = fe.trimmed)
			}
			;((be.prototype = Object.create(n.prototype)).constructor = be),
				(be.prototype.customBinary = function (fe) {
					return this._plugins.reconfigure("binary", fe), this
				}),
				(be.prototype.env = function (fe, Ee) {
					return (
						arguments.length === 1 && typeof fe == "object"
							? (this._executor.env = fe)
							: ((this._executor.env = this._executor.env || {})[fe] = Ee),
						this
					)
				}),
				(be.prototype.stashList = function (fe) {
					return this._runTask(jt(m(arguments) || {}, (a(fe) && fe) || []), g(arguments))
				})
			function Rr(fe, Ee, bt, sn) {
				return typeof bt != "string"
					? s(`git.${fe}() requires a string 'repoPath'`)
					: Ee(bt, f(sn, c), p(arguments))
			}
			;(be.prototype.clone = function () {
				return this._runTask(Rr("clone", Q, ...arguments), g(arguments))
			}),
				(be.prototype.mirror = function () {
					return this._runTask(Rr("mirror", O, ...arguments), g(arguments))
				}),
				(be.prototype.mv = function (fe, Ee) {
					return this._runTask(me(fe, Ee), g(arguments))
				}),
				(be.prototype.checkoutLatestTag = function (fe) {
					var Ee = this
					return this.pull(function () {
						Ee.tags(function (bt, sn) {
							Ee.checkout(sn.latest, fe)
						})
					})
				}),
				(be.prototype.pull = function (fe, Ee, bt, sn) {
					return this._runTask(Qe(f(fe, c), f(Ee, c), p(arguments)), g(arguments))
				}),
				(be.prototype.fetch = function (fe, Ee) {
					return this._runTask(q(f(fe, c), f(Ee, c), p(arguments)), g(arguments))
				}),
				(be.prototype.silent = function (fe) {
					return (
						console.warn(
							"simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3",
						),
						this
					)
				}),
				(be.prototype.tags = function (fe, Ee) {
					return this._runTask(en(p(arguments)), g(arguments))
				}),
				(be.prototype.rebase = function () {
					return this._runTask(cr(["rebase", ...p(arguments)]), g(arguments))
				}),
				(be.prototype.reset = function (fe) {
					return this._runTask(Et(Ce(fe), p(arguments)), g(arguments))
				}),
				(be.prototype.revert = function (fe) {
					let Ee = g(arguments)
					return typeof fe != "string"
						? this._runTask(s("Commit must be a string"), Ee)
						: this._runTask(cr(["revert", ...p(arguments, 0, !0), fe]), Ee)
				}),
				(be.prototype.addTag = function (fe) {
					let Ee = typeof fe == "string" ? Ve(fe) : s("Git.addTag requires a tag name")
					return this._runTask(Ee, g(arguments))
				}),
				(be.prototype.addAnnotatedTag = function (fe, Ee) {
					return this._runTask(Nr(fe, Ee), g(arguments))
				}),
				(be.prototype.deleteLocalBranch = function (fe, Ee, bt) {
					return this._runTask(w(fe, typeof Ee == "boolean" ? Ee : !1), g(arguments))
				}),
				(be.prototype.deleteLocalBranches = function (fe, Ee, bt) {
					return this._runTask(b(fe, typeof Ee == "boolean" ? Ee : !1), g(arguments))
				}),
				(be.prototype.branch = function (fe, Ee) {
					return this._runTask(C(p(arguments)), g(arguments))
				}),
				(be.prototype.branchLocal = function (fe) {
					return this._runTask(v(), g(arguments))
				}),
				(be.prototype.raw = function (fe) {
					let Ee = !Array.isArray(fe),
						bt = [].slice.call(Ee ? arguments : fe, 0)
					for (let yn = 0; yn < bt.length && Ee; yn++)
						if (!l(bt[yn])) {
							bt.splice(yn, bt.length - yn)
							break
						}
					bt.push(...p(arguments, 0, !0))
					var sn = g(arguments)
					return bt.length
						? this._runTask(cr(bt, this._trimmed), sn)
						: this._runTask(s("Raw: must supply one or more command to execute"), sn)
				}),
				(be.prototype.submoduleAdd = function (fe, Ee, bt) {
					return this._runTask(Ar(fe, Ee), g(arguments))
				}),
				(be.prototype.submoduleUpdate = function (fe, Ee) {
					return this._runTask(tr(p(arguments, !0)), g(arguments))
				}),
				(be.prototype.submoduleInit = function (fe, Ee) {
					return this._runTask(de(p(arguments, !0)), g(arguments))
				}),
				(be.prototype.subModule = function (fe, Ee) {
					return this._runTask(Tr(p(arguments)), g(arguments))
				}),
				(be.prototype.listRemote = function () {
					return this._runTask(se(p(arguments)), g(arguments))
				}),
				(be.prototype.addRemote = function (fe, Ee, bt) {
					return this._runTask(re(fe, Ee, p(arguments)), g(arguments))
				}),
				(be.prototype.removeRemote = function (fe, Ee) {
					return this._runTask(It(fe), g(arguments))
				}),
				(be.prototype.getRemotes = function (fe, Ee) {
					return this._runTask(K(fe === !0), g(arguments))
				}),
				(be.prototype.remote = function (fe, Ee) {
					return this._runTask(Ze(p(arguments)), g(arguments))
				}),
				(be.prototype.tag = function (fe, Ee) {
					let bt = p(arguments)
					return bt[0] !== "tag" && bt.unshift("tag"), this._runTask(cr(bt), g(arguments))
				}),
				(be.prototype.updateServerInfo = function (fe) {
					return this._runTask(cr(["update-server-info"]), g(arguments))
				}),
				(be.prototype.pushTags = function (fe, Ee) {
					let bt = N({ remote: f(fe, c) }, p(arguments))
					return this._runTask(bt, g(arguments))
				}),
				(be.prototype.rm = function (fe) {
					return this._runTask(cr(["rm", "-f", ...o(fe)]), g(arguments))
				}),
				(be.prototype.rmKeepLocal = function (fe) {
					return this._runTask(cr(["rm", "--cached", ...o(fe)]), g(arguments))
				}),
				(be.prototype.catFile = function (fe, Ee) {
					return this._catFile("utf-8", arguments)
				}),
				(be.prototype.binaryCatFile = function () {
					return this._catFile("buffer", arguments)
				}),
				(be.prototype._catFile = function (fe, Ee) {
					var bt = g(Ee),
						sn = ["cat-file"],
						yn = Ee[0]
					if (typeof yn == "string")
						return this._runTask(s("Git.catFile: options must be supplied as an array of strings"), bt)
					Array.isArray(yn) && sn.push.apply(sn, yn)
					let Ei = fe === "buffer" ? Pr(sn) : cr(sn)
					return this._runTask(Ei, bt)
				}),
				(be.prototype.diff = function (fe, Ee) {
					let bt = c(fe)
						? s(
								"git.diff: supplying options as a single string is no longer supported, switch to an array of strings",
							)
						: cr(["diff", ...p(arguments)])
					return this._runTask(bt, g(arguments))
				}),
				(be.prototype.diffSummary = function () {
					return this._runTask(ne(p(arguments, 1)), g(arguments))
				}),
				(be.prototype.applyPatch = function (fe) {
					let Ee = u(fe)
						? y(o(fe), p([].slice.call(arguments, 1)))
						: s("git.applyPatch requires one or more string patches as the first argument")
					return this._runTask(Ee, g(arguments))
				}),
				(be.prototype.revparse = function () {
					let fe = ["rev-parse", ...p(arguments, !0)]
					return this._runTask(cr(fe, !0), g(arguments))
				}),
				(be.prototype.clean = function (fe, Ee, bt) {
					let sn = j(fe),
						yn = (sn && fe.join("")) || f(fe, c) || "",
						Ei = p([].slice.call(arguments, sn ? 1 : 0))
					return this._runTask(Y(yn, Ei), g(arguments))
				}),
				(be.prototype.exec = function (fe) {
					let Ee = {
						commands: [],
						format: "utf-8",
						parser() {
							typeof fe == "function" && fe()
						},
					}
					return this._runTask(Ee)
				}),
				(be.prototype.clearQueue = function () {
					return this
				}),
				(be.prototype.checkIgnore = function (fe, Ee) {
					return this._runTask(B(o(f(fe, u, []))), g(arguments))
				}),
				(be.prototype.checkIsRepo = function (fe, Ee) {
					return this._runTask(M(f(fe, c)), g(arguments))
				}),
				(t.exports = be)
		},
	})
Xx()
Hh()
var Vmt = class extends ef {
	constructor(e, t) {
		super(void 0, t), (this.config = e)
	}
}
Hh()
Hh()
var Xd = class extends ef {
	constructor(e, t, r) {
		super(e, r), (this.task = e), (this.plugin = t), Object.setPrototypeOf(this, new.target.prototype)
	}
}
Vy()
uve()
Dve()
Ove()
Hve()
Gve()
Kve()
Zve()
function Hmt(e) {
	return e
		? [
				{
					type: "spawn.before",
					action(n, i) {
						e.aborted && i.kill(new Xd(void 0, "abort", "Abort already signaled"))
					},
				},
				{
					type: "spawn.after",
					action(n, i) {
						function s() {
							i.kill(new Xd(void 0, "abort", "Abort signal received"))
						}
						e.addEventListener("abort", s), i.spawned.on("close", () => e.removeEventListener("abort", s))
					},
				},
			]
		: void 0
}
function Wmt(e) {
	return typeof e == "string" && e.trim().toLowerCase() === "-c"
}
function Gmt(e, t) {
	if (Wmt(e) && /^\s*protocol(.[a-z]+)?.allow/.test(t))
		throw new Xd(
			void 0,
			"unsafe",
			"Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol",
		)
}
function $mt(e, t) {
	if (/^\s*--(upload|receive)-pack/.test(e))
		throw new Xd(
			void 0,
			"unsafe",
			"Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack",
		)
	if (t === "clone" && /^\s*-u\b/.test(e))
		throw new Xd(void 0, "unsafe", "Use of clone with option -u is not permitted without enabling allowUnsafePack")
	if (t === "push" && /^\s*--exec\b/.test(e))
		throw new Xd(
			void 0,
			"unsafe",
			"Use of push with option --exec is not permitted without enabling allowUnsafePack",
		)
}
function Ymt({ allowUnsafeProtocolOverride: e = !1, allowUnsafePack: t = !1 } = {}) {
	return {
		type: "spawn.args",
		action(r, n) {
			return (
				r.forEach((i, s) => {
					let o = s < r.length ? r[s + 1] : ""
					e || Gmt(i, o), t || $mt(i, n.method)
				}),
				r
			)
		},
	}
}
wt()
function Kmt(e) {
	let t = zx(e, "-c")
	return {
		type: "spawn.args",
		action(r) {
			return [...t, ...r]
		},
	}
}
wt()
var ive = (0, Oy.deferred)().promise
function Jmt({ onClose: e = !0, onExit: t = 50 } = {}) {
	function r() {
		let i = -1,
			s = {
				close: (0, Oy.deferred)(),
				closeTimeout: (0, Oy.deferred)(),
				exit: (0, Oy.deferred)(),
				exitTimeout: (0, Oy.deferred)(),
			},
			o = Promise.race([e === !1 ? ive : s.closeTimeout.promise, t === !1 ? ive : s.exitTimeout.promise])
		return (
			n(e, s.close, s.closeTimeout),
			n(t, s.exit, s.exitTimeout),
			{
				close(a) {
					;(i = a), s.close.done()
				},
				exit(a) {
					;(i = a), s.exit.done()
				},
				get exitCode() {
					return i
				},
				result: o,
			}
		)
	}
	function n(i, s, o) {
		i !== !1 && (i === !0 ? s.promise : s.promise.then(() => O4(i))).then(o.done)
	}
	return {
		type: "spawn.after",
		action(i, s) {
			return Kx(this, arguments, function* (o, { spawned: a, close: l }) {
				var c, u
				let f = r(),
					p = !0,
					g = () => void (p = !1)
				;(c = a.stdout) == null || c.on("data", g),
					(u = a.stderr) == null || u.on("data", g),
					a.on("error", g),
					a.on("close", (m) => f.close(m)),
					a.on("exit", (m) => f.exit(m))
				try {
					yield f.result, p && (yield O4(50)), l(f.exitCode)
				} catch (m) {
					l(f.exitCode, m)
				}
			})
		},
	}
}
wt()
var zmt =
		"Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings",
	sve =
		"Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option"
function jmt(e) {
	return !e || !/^([a-z]:)?([a-z0-9/.\\_-]+)$/i.test(e)
}
function ove(e, t) {
	if (e.length < 1 || e.length > 2) throw new Xd(void 0, "binary", zmt)
	if (e.some(jmt))
		if (t) console.warn(sve)
		else throw new Xd(void 0, "binary", sve)
	let [n, i] = e
	return { binary: n, prefix: i }
}
function Zmt(e, t = ["git"], r = !1) {
	let n = ove(Nu(t), r)
	e.on("binary", (i) => {
		n = ove(Nu(i), r)
	}),
		e.append("spawn.binary", () => n.binary),
		e.append("spawn.args", (i) => (n.prefix ? [n.prefix, ...i] : i))
}
Hh()
function Xmt(e) {
	return !!(e.exitCode && e.stdErr.length)
}
function e0t(e) {
	return Buffer.concat([...e.stdOut, ...e.stdErr])
}
function t0t(e = !1, t = Xmt, r = e0t) {
	return (n, i) => ((!e && n) || !t(i) ? n : r(i))
}
function ave(e) {
	return {
		type: "task.error",
		action(t, r) {
			let n = e(t.error, {
				stdErr: r.stdErr,
				stdOut: r.stdOut,
				exitCode: r.exitCode,
			})
			return Buffer.isBuffer(n) ? { error: new ef(void 0, n.toString("utf-8")) } : { error: n }
		},
	}
}
wt()
var r0t = class {
	constructor() {
		;(this.plugins = new Set()), (this.events = new cbe.EventEmitter())
	}
	on(e, t) {
		this.events.on(e, t)
	}
	reconfigure(e, t) {
		this.events.emit(e, t)
	}
	append(e, t) {
		let r = Qr(this.plugins, { type: e, action: t })
		return () => this.plugins.delete(r)
	}
	add(e) {
		let t = []
		return (
			Nu(e).forEach((r) => r && this.plugins.add(Qr(t, r))),
			() => {
				t.forEach((r) => this.plugins.delete(r))
			}
		)
	}
	exec(e, t, r) {
		let n = t,
			i = Object.freeze(Object.create(r))
		for (let s of this.plugins) s.type === e && (n = s.action(n, i))
		return n
	}
}
wt()
function n0t(e) {
	let t = "--progress",
		r = ["checkout", "clone", "fetch", "pull", "push"]
	return [
		{
			type: "spawn.args",
			action(s, o) {
				return r.includes(o.method) ? Ave(s, t) : s
			},
		},
		{
			type: "spawn.after",
			action(s, o) {
				var a
				o.commands.includes(t) &&
					((a = o.spawned.stderr) == null ||
						a.on("data", (l) => {
							let c = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(l.toString("utf8"))
							c &&
								e({
									method: o.method,
									stage: i0t(c[1]),
									progress: mn(c[2]),
									processed: mn(c[3]),
									total: mn(c[4]),
								})
						}))
			},
		},
	]
}
function i0t(e) {
	return String(e.toLowerCase().split(" ", 1)) || "unknown"
}
wt()
function s0t(e) {
	let t = Cve(e, ["uid", "gid"])
	return {
		type: "spawn.options",
		action(r) {
			return _l(_l({}, t), r)
		},
	}
}
function o0t({ block: e, stdErr: t = !0, stdOut: r = !0 }) {
	if (e > 0)
		return {
			type: "spawn.after",
			action(n, i) {
				var s, o
				let a
				function l() {
					a && clearTimeout(a), (a = setTimeout(u, e))
				}
				function c() {
					var f, p
					;(f = i.spawned.stdout) == null || f.off("data", l),
						(p = i.spawned.stderr) == null || p.off("data", l),
						i.spawned.off("exit", c),
						i.spawned.off("close", c),
						a && clearTimeout(a)
				}
				function u() {
					c(), i.kill(new Xd(void 0, "timeout", "block timeout reached"))
				}
				r && ((s = i.spawned.stdout) == null || s.on("data", l)),
					t && ((o = i.spawned.stderr) == null || o.on("data", l)),
					i.spawned.on("exit", c),
					i.spawned.on("close", c),
					l()
			},
		}
}
Xx()
function a0t() {
	return {
		type: "spawn.args",
		action(e) {
			let t = [],
				r
			function n(i) {
				;(r = r || []).push(...i)
			}
			for (let i = 0; i < e.length; i++) {
				let s = e[i]
				if (FM(s)) {
					n(RCe(s))
					continue
				}
				if (s === "--") {
					n(e.slice(i + 1).flatMap((o) => (FM(o) && RCe(o)) || o))
					break
				}
				t.push(s)
			}
			return r ? [...t, "--", ...r.map(String)] : t
		},
	}
}
wt()
var l0t = qmt()
function c0t(e, t) {
	var r
	let n = new r0t(),
		i = xve((e && (typeof e == "string" ? { baseDir: e } : e)) || {}, t)
	if (!tG(i.baseDir)) throw new Vmt(i, "Cannot use simple-git on a directory that does not exist")
	return (
		Array.isArray(i.config) && n.add(Kmt(i.config)),
		n.add(Ymt(i.unsafe)),
		n.add(a0t()),
		n.add(Jmt(i.completion)),
		i.abort && n.add(Hmt(i.abort)),
		i.progress && n.add(n0t(i.progress)),
		i.timeout && n.add(o0t(i.timeout)),
		i.spawnOptions && n.add(s0t(i.spawnOptions)),
		n.add(ave(t0t(!0))),
		i.errors && n.add(ave(i.errors)),
		Zmt(n, i.binary, (r = i.unsafe) == null ? void 0 : r.allowUnsafeCustomBinary),
		new l0t(i, n)
	)
}
Vy()
var ube = c0t
var dbe = {
		added_file_stats: {
			changed_file_count: 0,
			per_file_change_stats_head: [],
			per_file_change_stats_tail: [],
		},
		broken_file_stats: {
			changed_file_count: 0,
			per_file_change_stats_head: [],
			per_file_change_stats_tail: [],
		},
		copied_file_stats: {
			changed_file_count: 0,
			per_file_change_stats_head: [],
			per_file_change_stats_tail: [],
		},
		deleted_file_stats: {
			changed_file_count: 0,
			per_file_change_stats_head: [],
			per_file_change_stats_tail: [],
		},
		modified_file_stats: {
			changed_file_count: 0,
			per_file_change_stats_head: [],
			per_file_change_stats_tail: [],
		},
		renamed_file_stats: {
			changed_file_count: 0,
			per_file_change_stats_head: [],
			per_file_change_stats_tail: [],
		},
		unmerged_file_stats: {
			changed_file_count: 0,
			per_file_change_stats_head: [],
			per_file_change_stats_tail: [],
		},
		unknown_file_stats: {
			changed_file_count: 0,
			per_file_change_stats_head: [],
			per_file_change_stats_tail: [],
		},
	},
	Hy = class {
		git
		constructor(t) {
			try {
				this.git = ube({
					baseDir: t,
					binary: "git",
					maxConcurrentProcesses: 6,
					trimmed: !1,
				})
			} catch {
				this.git = void 0
			}
		}
		countTokens(t) {
			return Math.ceil(t.length / 3)
		}
		async getChangedFileStats(t) {
			let r = await this.git.status(),
				n = ["created", "deleted", "modified", "renamed"],
				i = dbe,
				s = new Set(r.staged)
			for (let o of n) {
				let a = []
				if (
					(o === "renamed" ? (a = r.renamed.map((l) => l.to)) : (a = r[o]),
					t.onlyUseStagedChanges && (a = a.filter((l) => s.has(l))),
					a.length > 0)
				) {
					let l = o
					o === "created" && (l = "added")
					let c = `${l}_file_stats`
					i[c].changed_file_count = a.length
					let u = await Promise.all(
							a.map(async (g) => {
								let { insertions: m, deletions: y } = await this.getInsertionDeletionStats(
									t.onlyUseStagedChanges,
									[g],
								)
								return {
									file_path: g,
									insertion_count: m,
									deletion_count: y,
									old_file_path: (o === "renamed" && r.renamed.find((C) => C.to === g)?.from) || g,
								}
							}),
						),
						f = u.slice(0, 5),
						p = u.slice(-5)
					;(i[c].per_file_change_stats_head = f),
						(i[c].per_file_change_stats_tail = p.filter((g) => !f.find((m) => m.file_path === g.file_path)))
				}
			}
			return i
		}
		async getInsertionDeletionStats(t, r) {
			let n = ["--staged", "--shortstat"].concat(r),
				i = await this.git.diff(n)
			if (!t) {
				let l = ["--shortstat"].concat(r)
				i += await this.git.diff(l)
			}
			let s = i.split(",").map((l) => l.trim()),
				o = parseInt(s.find((l) => l.includes("insertion"))?.split(" ")[0] || "0"),
				a = parseInt(s.find((l) => l.includes("deletion"))?.split(" ")[0] || "0")
			return { insertions: o, deletions: a }
		}
		async getTruncatedDiffs(t, r) {
			let { insertions: n, deletions: i } = await this.getInsertionDeletionStats(t.onlyUseStagedChanges, [])
			if (n + i <= t.diffNoopLineLimit) {
				let o = await this.git.diff(["--staged", "--name-only"])
				t.onlyUseStagedChanges || (o += await this.git.diff(["--name-only"]))
				let a = o
						.split(
							`
`,
						)
						.filter(Boolean),
					l = await Promise.all(
						a.map(async (f) => {
							let p = await this.git.diff(["--staged", f])
							return (
								t.onlyUseStagedChanges || (p += await this.git.diff([f])),
								{ fileName: f, diff: p, tokens: this.countTokens(p) }
							)
						}),
					)
				l.sort((f, p) => f.tokens - p.tokens)
				let c = "",
					u = r
				for (let f of l)
					if (u + f.tokens <= t.diffBudget)
						(c +=
							f.diff +
							`
`),
							(u += f.tokens)
					else break
				return c.trim()
			} else {
				let o = await this.git.diff(["--staged"])
				return (
					t.onlyUseStagedChanges || (o += await this.git.diff([])),
					o
						.split(
							`
`,
						)
						.slice(0, t.diffNoopLineLimit)
						.join(
							`
`,
						)
						.slice(0, t.diffBudget - r)
				)
			}
		}
		async getCommitMessages(t) {
			return (await this.git.log({ maxCount: t })).all.map((n) => n.message)
		}
		async getCurrentAuthor() {
			let r = (await this.git.listConfig()).all["user.email"]
			return Array.isArray(r) ? r[0] || void 0 : r || void 0
		}
		getExampleCommitMessages(t, r, n, i) {
			let s = [],
				o = 0
			for (let a of t.slice(r.length)) {
				if (s.length >= i - r.length) break
				let l = this.countTokens(a)
				if (o + l <= n) s.push(a), (o += l)
				else break
			}
			return s
		}
		async getRelevantCommitMessages(t, r) {
			return this.git.log({ maxCount: 3 }).then((n) =>
				n.all
					.filter((i) => i.author_email === t.trim())
					.map((i) => i.message)
					.reduce((i, s) => {
						let o = this.countTokens(s)
						return (
							this.countTokens(
								i.join(`
`),
							) +
								o <=
								r && i.push(s),
							i
						)
					}, []),
			)
		}
		async getCommitMessagePromptData(t) {
			if (!this.git)
				return {
					changedFileStats: dbe,
					diff: "",
					generatedCommitMessageSubrequest: {
						relevant_commit_messages: [],
						example_commit_messages: [],
					},
				}
			let r = await this.getChangedFileStats(t),
				n = this.countTokens(JSON.stringify(r)),
				i = await this.getTruncatedDiffs(t, n),
				s = await this.getCommitMessages(32),
				o = await this.getCurrentAuthor(),
				a = [],
				l = []
			if (o) {
				a = await this.getRelevantCommitMessages(o, t.relevantMessageSubbudget)
				let c = this.countTokens(
						a.join(`
`),
					),
					u = t.messageBudget - c
				l = this.getExampleCommitMessages(s, a, u, t.maxExampleCommitMessages)
			}
			return {
				changedFileStats: r,
				diff: i,
				generatedCommitMessageSubrequest: {
					relevant_commit_messages: a,
					example_commit_messages: l,
				},
			}
		}
	}
function KM() {
	return {
		startLineNumber: null,
		endLineNumber: null,
		newText: "",
		oldText: "",
		hasYieldedNewChunk: !1,
		currOffset: null,
		startRefined: !1,
		endRefined: !1,
		newTextBuffer: "",
		prefixOverlapChecked: !1,
	}
}
function JM(e) {
	return !Wn(e.startLineNumber) && !Wn(e.endLineNumber) && !Wn(e.newText)
}
function Abe(e) {
	return !e.startRefined && !Wn(e.startLineNumber) && e.oldText.trim().length > 0
}
function mbe(e) {
	return !e.endRefined && !Wn(e.endLineNumber) && e.oldText.trim().length > 0
}
function u0t(e, t) {
	if (Abe(e)) {
		let { isPureInsertion: r, lineBefore: n } = fbe(e)
		if (r) e.startLineNumber = s_(t, e.startLineNumber, n, 20) + 1
		else {
			let s = e.oldText.replaceAll(/\n$/g, "").split(`
`)[0]
			e.startLineNumber = s_(t, e.startLineNumber, s, 20)
		}
		e.startRefined = !0
	}
	if (mbe(e)) {
		let { isPureInsertion: r } = fbe(e)
		if (r) e.endLineNumber = e.startLineNumber
		else {
			let n = e.oldText.replaceAll(/\n$/g, "").split(`
`),
				i = n[n.length - 1]
			e.endLineNumber = s_(t, e.endLineNumber - 1, i, 20) + 1
		}
		e.endRefined = !0
	}
}
function zM(e) {
	let t = (e.newText.match(/\n/g) || []).length
	return {
		lineChange: {
			originalStartLineNumber: e.startLineNumber,
			originalEndLineNumber: e.endLineNumber ? e.endLineNumber : e.startLineNumber,
			modifiedStartLineNumber: e.startLineNumber,
			modifiedEndLineNumber: e.startLineNumber + t,
		},
		newText: e.newText,
	}
}
function ybe(e, t) {
	let { replacementStartLine: r, replacementEndLine: n, replacementText: i, replacementOldText: s } = t
	return (
		Wn(r) || (e.startLineNumber = r),
		Wn(n) || (e.endLineNumber = n),
		Wn(i) || (e.newText += i),
		Wn(s) || (e.oldText += s),
		e
	)
}
async function* Cbe(e, t) {
	let r = [],
		n = KM(),
		i = e.split(`
`)
	for await (let s of Ebe(t)) {
		let { replacementStartLine: o, replacementOldText: a } = s
		if ((!Wn(o) || !Wn(a)) && JM(n)) {
			let l = zM(n),
				c = n.currOffset ?? ZM(l, r)
			r.push(l)
			let u = jM(l, c)
			;(i = gbe([...i], u)), (n = KM())
		}
		if (((n = ybe(n, s)), Abe(n))) {
			let c = n.oldText.replaceAll(/\n$/g, "").split(`
`)[0]
			n.startLineNumber = s_(e, n.startLineNumber, c, 20)
		}
		if (mbe(n)) {
			let l = n.oldText.replaceAll(/\n$/g, "").split(`
`),
				c = l[l.length - 1]
			n.endLineNumber = s_(e, n.endLineNumber, c, 20) + 1
		}
		if (JM(n)) {
			let l = zM(n)
			n.currOffset = n.currOffset ?? ZM(l, r)
			let c = jM(l, n.currOffset)
			yield gbe([...i], c).join(`
`)
		}
	}
}
function s_(e, t, r, n) {
	let i = e
		.split(
			`
`,
		)
		.map((s) => s.trimEnd())
	if (((r = r.trimEnd()), i[t - 1] === r)) return t
	for (let s = 1; s <= n; s++) {
		if (t > s && i[t - s - 1] === r) return t - s
		if (t + s <= i.length && i[t + s - 1] === r) return t + s
	}
	return t
}
function d0t(e) {
	return !Wn(e.startLineNumber) && !e.hasYieldedNewChunk
}
function vbe(e, t, r, n) {
	let i = ""
	if (Wn(e.startLineNumber)) throw new Error("Start line should be already set when replacement text is set")
	let s = e.newTextBuffer.split(/(?<=\n)/),
		o = t.split(/(?<=\n)/).slice(0, e.startLineNumber - 1)
	if (!e.prefixOverlapChecked) {
		let c = Math.min(r, o.length)
		if (s.length <= c && !n) return i
		for (let u = c; u >= 1; u--) {
			let f = !0
			for (let p = 0; p < u; p++)
				if (s[p] !== o[o.length - u + p]) {
					f = !1
					break
				}
			if (f) {
				;(s = s.slice(u)),
					(e.newText = e.newText
						.split(/(?<=\n)/)
						.slice(u)
						.join(""))
				break
			}
		}
		e.prefixOverlapChecked = !0
	}
	if (((i = s.slice(0, -r).join("")), (s = s.slice(-r)), !n)) return (e.newTextBuffer = s.join("")), i
	if (Wn(e.endLineNumber)) throw new Error("End line should be already set when edit is completed.")
	let a = t.split(/(?<=\n)/).slice(e.endLineNumber - 1),
		l = Math.min(r, a.length)
	for (let c = l; c >= 1; c--) {
		let u = !0
		for (let f = 0; f < c; f++)
			if (s[s.length - c + f] !== a[f]) {
				u = !1
				break
			}
		if (u) {
			;(s = s.slice(0, -c)),
				(e.newText = e.newText
					.split(/(?<=\n)/)
					.slice(0, -c)
					.join(""))
			break
		}
	}
	return (
		(e.newTextBuffer = ""),
		(i += s.join("")),
		i.length > 0 &&
			!i.endsWith(`
`) &&
			(i += `
`),
		i
	)
}
function fbe(e) {
	if (e.oldText.length === 0) return { isPureInsertion: !1, lineBefore: "" }
	let t = e.oldText.split(`
`),
		r = t[t.length - 1],
		n = "PURE INSERTION AFTER LINE:"
	return r.startsWith(n)
		? { isPureInsertion: !0, lineBefore: r.substring(n.length) }
		: { isPureInsertion: !1, lineBefore: "" }
}
function* hbe(e, t, r) {
	let n = vbe(e, r, 3, !0)
	n.length > 0 && (yield { chunkContinue: { newText: n } })
	let i = zM(e),
		s = ZM(i, t),
		o = jM(i, s)
	yield {
		chunkEnd: {
			originalStartLine: e.startLineNumber,
			originalEndLine: e.endLineNumber,
			stagedStartLine: o.lineChange.originalStartLineNumber,
			stagedEndLine: o.lineChange.originalEndLineNumber,
		},
	},
		t.push(f0t(i, r))
}
function f0t(e, t) {
	let r = t.split(/(?<=\n)/),
		n = {
			originalStartLineNumber: e.lineChange.originalStartLineNumber,
			originalEndLineNumber: e.lineChange.originalEndLineNumber,
			modifiedStartLineNumber: e.lineChange.modifiedStartLineNumber,
			modifiedEndLineNumber: e.lineChange.modifiedEndLineNumber,
		},
		i = e.newText.split(/(?<=\n)/)
	for (; n.originalStartLineNumber < n.originalEndLineNumber && i.length > 0; ) {
		let s = i[0]
		if (r[n.originalStartLineNumber - 1] !== s) break
		n.originalStartLineNumber++, n.modifiedStartLineNumber++, (i = i.slice(1))
	}
	for (; n.originalStartLineNumber < n.originalEndLineNumber && i.length > 0; ) {
		let s = i[i.length - 1]
		if (r[n.originalEndLineNumber - 2] !== s) break
		n.originalEndLineNumber--, n.modifiedEndLineNumber--, (i = i.slice(0, -1))
	}
	return {
		lineChange: {
			originalStartLineNumber: n.originalStartLineNumber,
			originalEndLineNumber: n.originalEndLineNumber,
			modifiedStartLineNumber: n.modifiedStartLineNumber,
			modifiedEndLineNumber: n.modifiedEndLineNumber,
		},
		newText: i.join(""),
	}
}
async function* XM(e, t) {
	let r = [],
		n = KM()
	for await (let i of Ebe(t)) {
		let { text: s, replacementStartLine: o, replacementOldText: a } = i
		if (
			((!Wn(o) || !Wn(a) || !Wn(s)) && JM(n) && (yield* hbe(n, r, e), (n = KM())),
			(n = ybe(n, i)),
			u0t(n, e),
			d0t(n))
		) {
			let l = zM(n),
				c = ZM(l, r),
				u = jM(l, c)
			yield {
				newChunkStart: {
					originalStartLine: n.startLineNumber,
					stagedStartLine: u.lineChange.originalStartLineNumber,
				},
			},
				(n.hasYieldedNewChunk = !0)
		}
		Wn(i.replacementText) ||
			((n.newTextBuffer += i.replacementText), yield { chunkContinue: { newText: vbe(n, e, 3, !1) } })
	}
	JM(n) && (yield* hbe(n, r, e))
}
async function* Ebe(e) {
	for await (let t of e)
		Wn(t.replacementOldText) || (yield { text: "", replacementOldText: t.replacementOldText }),
			Wn(t.replacementStartLine) || (yield { text: "", replacementStartLine: t.replacementStartLine }),
			Wn(t.replacementText) || (yield { text: "", replacementText: t.replacementText }),
			Wn(t.replacementEndLine) || (yield { text: "", replacementEndLine: t.replacementEndLine })
}
function gbe(e, t) {
	let r = t.newText
			? t.newText.replaceAll(/\n$/g, "").split(`
`)
			: [],
		n = t.lineChange.originalStartLineNumber - 1,
		i = t.lineChange.originalEndLineNumber - t.lineChange.originalStartLineNumber
	return e.splice(n, i, ...r), e
}
function jM(e, t) {
	return {
		lineChange: {
			originalStartLineNumber: e.lineChange.originalStartLineNumber + t,
			originalEndLineNumber: e.lineChange.originalEndLineNumber + t,
			modifiedStartLineNumber: e.lineChange.modifiedStartLineNumber + t,
			modifiedEndLineNumber: e.lineChange.modifiedEndLineNumber + t,
		},
		newText: e.newText,
	}
}
function ZM(e, t) {
	let r = 0
	for (let n of t) r += h0t(e, n)
	return r
}
function h0t(e, t) {
	if (pbe(e, t)) return 0
	if (pbe(t, e)) {
		let r = t.lineChange.originalEndLineNumber - t.lineChange.originalStartLineNumber
		return t.lineChange.modifiedEndLineNumber - t.lineChange.modifiedStartLineNumber - r
	} else throw new Error("Edits overlap, which is not supported")
}
function pbe(e, t) {
	return e.lineChange.originalEndLineNumber <= t.lineChange.originalStartLineNumber
}
function o_(e, t = null, r = null) {
	if (!t && !r) throw new Error("Must provide either a response or an error")
	if (t && r) throw new Error("Must provide either a response or an error, not both")
	return { type: "async-wrapper", requestId: e, error: r, baseMsg: t }
}
var eF = class {
	constructor(t, r) {
		this._postMessage = t
		this._addMsgHandler = r
	}
	_disposers = new Array()
	createWrappedHandler = (t, r) => (n) =>
		n.type !== "async-wrapper" || n.baseMsg?.type !== t
			? !1
			: ((async (s) => {
					try {
						let o = await s
						if (o instanceof Error) throw o
						let a = o_(n.requestId, o)
						this._postMessage(a)
					} catch (o) {
						if (o instanceof Error) {
							let a = o_(n.requestId, null, o.message)
							this._postMessage(a)
						}
					}
				})(r(n.baseMsg)),
				!0)
	registerHandler = (t, r) => {
		let n = this.createWrappedHandler(t, r),
			i = this._addMsgHandler(n)
		this._disposers.push(i)
	}
	registerSidecarHandler = (t) => {
		let r = this.createWrappedSidecarHandler(t),
			n = this._addMsgHandler(r)
		this._disposers.push(n)
	}
	createWrappedSidecarHandler = (t) => (r) => {
		if (r.type !== "async-wrapper") return
		let n = (i) => {
			let s = o_(r.requestId, i)
			this._postMessage(s)
		}
		try {
			t(r.baseMsg, n)
		} catch (i) {
			if (i instanceof Error) {
				let s = o_(r.requestId, null, i.message)
				this._postMessage(s)
			}
		}
	}
	registerStreamHandler = (t, r) => {
		let n = this.createWrappedStreamHandler(t, r),
			i = this._addMsgHandler(n)
		this._disposers.push(i)
	}
	createWrappedStreamHandler = (t, r) => (n) =>
		n.type !== "async-wrapper" || n.baseMsg?.type !== t
			? !1
			: ((async () => {
					let i = n.requestId,
						s = { streamMsgIdx: 0, streamNextRequestId: `${n.requestId}-0` }
					try {
						for await (let o of r(n.baseMsg)) {
							if (o instanceof Error) throw o
							let a = o_(i, o)
							;(a.streamCtx = { ...s }), (i = s.streamNextRequestId)
							let l = s.streamMsgIdx + 1
							;(s = {
								streamMsgIdx: l,
								streamNextRequestId: `${n.requestId}-${l}`,
							}),
								this._postMessage(a)
						}
						this._postMessage({
							type: "async-wrapper",
							requestId: i,
							error: null,
							baseMsg: { type: "empty" },
							streamCtx: { ...s, isStreamComplete: !0 },
						})
					} catch (o) {
						let a = o
						this._postMessage({
							type: "async-wrapper",
							requestId: i,
							error: a.message,
							baseMsg: null,
							streamCtx: { ...s, isStreamComplete: !0 },
						})
					}
				})(),
				!0)
	dispose = () => {
		for (let t of this._disposers) t()
	}
}
function Ti(e) {
	return new eF(
		(t) => void e.postMessage(t),
		(t) => {
			let r = e.onDidReceiveMessage(t)
			return () => void r.dispose()
		},
	)
}
function bbe(e, t = !1) {
	let r = 2166136261,
		n = t ? e.length - e.trimLeft().length : 0
	for (let i = n; i < e.length; i++) (r ^= e.charCodeAt(i)), (r *= 16777619)
	return r >>> 0
}
function g0t(e, t) {
	let r = e.length,
		n = t.length,
		i = Array(n + 1)
			.fill(null)
			.map(() => ({ lcsLength: 0, minSubstringLength: 1 / 0 })),
		s = Array(n + 1)
			.fill(null)
			.map(() => ({ lcsLength: 0, minSubstringLength: 1 / 0 }))
	i[0].minSubstringLength = 0
	let o = 0,
		a = 1 / 0,
		l = -1
	for (let c = 1; c <= r; c++) {
		s[0] = { lcsLength: 0, minSubstringLength: 0 }
		for (let u = 1; u <= n; u++) {
			if (e[c - 1] === t[u - 1]) {
				let f = i[u - 1].lcsLength + 1,
					p = i[u - 1].minSubstringLength + 1
				s[u] = { lcsLength: f, minSubstringLength: p }
			} else {
				let f = i[u],
					p = s[u - 1]
				if (f.lcsLength > p.lcsLength) {
					let g = f.lcsLength,
						m = f.minSubstringLength + 1
					s[u] = { lcsLength: g, minSubstringLength: m }
				} else if (f.lcsLength < p.lcsLength) {
					let g = p.lcsLength,
						m = p.minSubstringLength
					s[u] = { lcsLength: g, minSubstringLength: m }
				} else {
					let g = f.lcsLength,
						m = Math.min(f.minSubstringLength + 1, p.minSubstringLength)
					s[u] = { lcsLength: g, minSubstringLength: m }
				}
			}
			if (u === n) {
				let f = s[u]
				;(f.lcsLength > o || (f.lcsLength === o && f.minSubstringLength < a)) &&
					((o = f.lcsLength), (a = f.minSubstringLength), (l = c))
			}
		}
		;[i, s] = [s, i]
	}
	return { maxLCSLength: o, minSubstringLength: a, endIndex: l }
}
function xbe(e, t) {
	let r = e.split(`
`),
		n = t.trim().split(`
`)
	function i(p) {
		let g = r.map((y) => bbe(y, p)),
			m = n.map((y) => bbe(y, p))
		return g0t(g, m)
	}
	let s = i(!1),
		o = i(!0),
		{ maxLCSLength: a, minSubstringLength: l, endIndex: c } = s.maxLCSLength >= o.maxLCSLength ? s : o
	if (a === 0) return null
	let u = c - l,
		f = c - 1
	return { start: u, end: f }
}
var _be = require("path"),
	$r = W(require("vscode"))
async function iA(e, t = void 0) {
	let r = (0, _be.resolve)(e.repoRoot, e.pathName)
	e.differentTab
		? t === void 0 || $r.window.tabGroups.all.length === 1
			? await $r.commands.executeCommand("vscode.openWith", $r.Uri.file(r), "default", $r.ViewColumn.Beside)
			: await $r.commands.executeCommand(
					"vscode.openWith",
					$r.Uri.file(r),
					"default",
					t === $r.ViewColumn.One ? t + 1 : t - 1,
				)
		: await $r.commands.executeCommand("vscode.open", $r.Uri.file(r))
	let n
	if (!(!$r.window.activeTextEditor || $r.window.activeTextEditor.document.uri.fsPath !== r)) {
		if (e.fullRange) {
			let i = e.fullRange
			n = $r.window.activeTextEditor.document.validateRange(
				new $r.Range(i.startLineNumber, i.startColumn, i.endLineNumber, i.endColumn),
			)
		} else if (e.range) {
			let i = e.range
			n = $r.window.activeTextEditor.document.validateRange(new $r.Range(i.start - 1, 0, i.stop - 1, 999))
		} else if (e.snippet) {
			let s = (await $r.workspace.openTextDocument(r)).getText(),
				o = xbe(s, e.snippet)
			if (o === null) {
				let a = $r.window.activeTextEditor.selection.active
				n = $r.window.activeTextEditor.document.validateRange(new $r.Range(a, a))
			} else n = $r.window.activeTextEditor.document.validateRange(new $r.Range(o.start, 0, o.end, 999))
		} else return
		$r.window.activeTextEditor?.revealRange(n),
			($r.window.activeTextEditor.selection = new $r.Selection(n.end, n.start))
	}
}
var Bbe = W(require("path")),
	Sc = W(require("vscode"))
function p0t(e) {
	return e.endsWith(`
`)
		? e.slice(0, -1)
		: e
}
function wbe(e, t) {
	let r = e.split(`
`)
	for (let n of [...t].sort(({ result: { charEnd: i } }, { result: { charEnd: s } }) => s - i))
		r.splice(n.lineRange.start, n.lineRange.stop - n.lineRange.start, p0t(n.result.suggestedCode))
	return r.join(`
`)
}
async function Ibe(e, t, r) {
	if (!a_()) throw new Error("Not in HMR mode")
	let n = await fetch(`${e}/${t}`)
	if (!n.ok) throw new Error(`Failed to load ${t} from ${e}: ${n.statusText}`)
	let i = await n.text()
	if (!i?.trim()) throw new Error(`Empty response when loading ${t} from ${e}: ${n.statusText}`)
	return xG(i, e, r)
}
function xG(e, t, r) {
	return e.replace("<head>", `<head><base href="${t}" /><meta http-equiv="Content-Security-Policy" content="${r}" />`)
}
function a_() {
	return !!process.env.AUGMENT_HMR && process.env.AUGMENT_JS_ENV !== "production"
}
function wl(...e) {
	let t = {
		scripts: new Set(),
		styles: new Set(["'unsafe-inline'"]),
		fonts: new Set(),
		images: new Set(),
		media: new Set(),
		workers: new Set(),
		connects: new Set(),
	}
	for (let i of e) i(t)
	let r = ["default-src 'none';"],
		n = {
			"font-src": t.fonts,
			"style-src": t.styles,
			"script-src": t.scripts,
			"img-src": t.images,
			"media-src": t.media,
			"worker-src": t.workers,
			"connect-src": t.connects,
		}
	for (let [i, s] of Object.entries(n)) {
		let o = Array.from(s).sort()
		o.length !== 0 && r.push(`${i} ${o.join(" ")};`)
	}
	return r.join(" ")
}
function Il() {
	return (e) => {
		e.fonts.add("https://fonts.gstatic.com"), e.styles.add("https://fonts.googleapis.com")
	}
}
function Sbe() {
	return (e) => {
		e.images.add("https://www.google.com"),
			e.images.add("https://*.gstatic.com"),
			e.images.add("https://s2.googleusercontent.com")
	}
}
function Sl(e) {
	return (t) => {
		t.scripts.add(e.cspSource),
			t.styles.add(e.cspSource),
			t.images.add(e.cspSource),
			t.fonts.add(e.cspSource),
			t.media.add(e.cspSource)
	}
}
function Bl() {
	return (e) => {
		e.images.add("data:"), e.images.add("blob:")
	}
}
function tF(e) {
	return (t) => {
		t.scripts.add(`'nonce-${e}'`)
	}
}
function Dl() {
	return (e) => {
		e.styles.add("'unsafe-inline'"), e.fonts.add("data:"), e.workers.add("blob:")
	}
}
function Wy() {
	return (e) => {
		e.fonts.add("https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/"),
			e.styles.add("https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/"),
			e.scripts.add("https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/"),
			e.scripts.add("'unsafe-inline'")
	}
}
function rF() {
	if (!a_()) return () => {}
	let e = process.env.AUGMENT_HMR ?? "",
		t = e.replace(/^https?:/, "ws:")
	return (r) => {
		;["fonts", "styles", "scripts", "workers", "media", "images", "connects"].forEach((n) => {
			r[n].add(e).add(t)
		})
	}
}
var sA = class e extends z {
	constructor(r, n, i, s, o, a) {
		super()
		this._extensionUri = r
		this._conversationId = n
		this._initialIterationId = i
		this._initialStage = s
		this._chatApp = o
		this._resolveFileService = a
		;(this._panel = Sc.window.createWebviewPanel(e.viewType, "Augment", Sc.ViewColumn.One, {
			retainContextWhenHidden: !0,
			enableScripts: !0,
		})),
			(this._detailsPanelAsyncMsgHandler = Ti(this._panel.webview)),
			this._detailsPanelAsyncMsgHandler.registerHandler(
				"autofix-panel-details-init-request",
				this.handleAutofixInitMessage,
			),
			this._detailsPanelAsyncMsgHandler.registerHandler(
				"autofix-panel-apply-and-retest-request",
				this.handleAutofixApplyAndRetestRequest.bind(this),
			),
			this._resolveFileService.register(this._detailsPanelAsyncMsgHandler),
			(this._panel.iconPath = {
				light: Sc.Uri.joinPath(this._extensionUri, "media", "panel-icon-light.svg"),
				dark: Sc.Uri.joinPath(this._extensionUri, "media", "panel-icon-dark.svg"),
			}),
			this.addDisposables(
				this._panel,
				new Sc.Disposable(() => {
					e.currentPanel = void 0
				}),
			),
			this._panel.onDidDispose(() => {
				this.dispose(), (e.currentPanel = void 0)
			}),
			this._setHTML()
	}
	static viewType = "augmentAutofixPanel"
	_logger = X("AutofixWebviewPanel")
	static currentPanel
	_panel
	_detailsPanelAsyncMsgHandler
	get logger() {
		return this._logger
	}
	async _setHTML() {
		let r = this._panel.webview,
			n = Sc.Uri.joinPath(this._extensionUri, "common-webviews")
		r.options = { enableScripts: !0, localResourceRoots: [n] }
		let i = r.asWebviewUri(Sc.Uri.joinPath(n, "/")),
			s = wl(Sl(r), Il(), Bl(), Dl(), Wy()),
			o = await Fr(Bbe.default.join(n.fsPath, "autofix.html"))
		;(o = o.replace(
			/<head>/i,
			`<head>
            <base href="${i.toString()}" />
            <meta http-equiv="Content-Security-Policy" content="${s}">
        `,
		)),
			(r.html = o)
	}
	static launchAutofixPanel(r, n, i, s, o, a) {
		if (e.currentPanel)
			if (e.currentPanel._conversationId === n) {
				e.currentPanel.openSpecificStage(i, s), e.currentPanel._panel.reveal()
				return
			} else e.currentPanel.dispose()
		e.currentPanel = new e(r, n, i, s, o, a)
	}
	handleAutofixStateUpdate = async (r) => {
		await this._panel.webview.postMessage({
			type: "autofix-panel-state-update",
			data: r.data,
		})
	}
	handleCommandPartialOutput = async (r) => {
		await this._panel.webview.postMessage(r)
	}
	handleAutofixInitMessage = async (r) => (
		await this._chatApp.sendAutofixUpdateRequestMessage(),
		{
			type: "autofix-panel-open-specific-stage",
			data: {
				iterationId: this._initialIterationId,
				stage: this._initialStage,
			},
		}
	)
	handleAutofixApplyAndRetestRequest = async (r) => (
		await this._applyAllAutofixChanges(r.data.selectedSolutions),
		await this._chatApp.sendAutofixSuggestionsAppliedMessage(r.data.selectedSolutions),
		{ type: "empty" }
	)
	async openSpecificStage(r, n) {
		await this._panel.webview.postMessage({
			type: "autofix-panel-open-specific-stage",
			data: { iterationId: r, stage: n },
		})
	}
	async _applyAutofixChanges(r, n) {
		let i = await Fr(r),
			s = wbe(i, n)
		await Bu(r, s)
	}
	async _applyAllAutofixChanges(r) {
		let n = new Map()
		for (let i of r) {
			let s = Bs(i.qualifiedPathName)
			n.has(s) ? n.get(s).push(i) : n.set(s, [i])
		}
		for (let [i, s] of n.entries()) await this._applyAutofixChanges(i, s)
	}
}
var wG = W(require("path")),
	Wi = W(require("vscode"))
var Tl = W(require("vscode"))
var rf = W(require("vscode"))
var oA = W(require("vscode")),
	l_ = `

`
function yo(e) {
	return e.scheme === "vscode-notebook-cell"
}
function Dbe(e) {
	let t = oA.window.activeNotebookEditor?.notebook
	return t ? (A0t(e, t) ? [_G(t), m0t(t, e)] : [void 0, 0]) : [void 0, 0]
}
function Tbe(e) {
	if (yo(e.uri)) {
		for (let t of oA.workspace.notebookDocuments) for (let r of t.getCells()) if (r.document === e) return t
	}
}
function _G(e) {
	return Gy(e.getCells())
}
function A0t(e, t) {
	let r = t.getCells().find((n) => n.document === e)
	return r ? r.kind === oA.NotebookCellKind.Code : !1
}
function m0t(e, t) {
	let n = e.getCells().findIndex((i) => i.document === t)
	return n === -1 ? 0 : y0t(e, n, !0)
}
function y0t(e, t, r) {
	let n = Gy(e.getCells().slice(0, t))
	return r && n ? n.length + l_.length : n.length
}
function Gy(e) {
	return e
		.filter((n) => n.kind === oA.NotebookCellKind.Code)
		.map((n) => n.document.getText())
		.join(l_)
}
function tf(e) {
	return e.getCells !== void 0
}
var nF = class extends lt {
		constructor(r, n, i) {
			super()
			this._extension = r
			this._extensionUri = n
			this._apiServer = i
		}
		static commandID = "vscode-augment.internal-dv.o"
		type = "public"
		run = async (...r) => {
			if (!this._extension.workspaceManager) throw new Error("No workspace manager")
			if (!this._extension.keybindingWatcher) throw new Error("No keybinding watcher")
			let [n, i, s] = r,
				o = Rbe(n)
			if (o === void 0) return
			if (o === null) return
			let a = _x(o),
				l = o.fsPath.replace(a.fsPath, ""),
				c = new Je(a.fsPath, l)
			Bn.createOrShow(
				{
					extensionUri: this._extensionUri,
					workspaceManager: this._extension.workspaceManager,
					apiServer: this._apiServer,
					keybindingWatcher: this._extension.keybindingWatcher,
					fuzzyFsSearcher: this._extension.fuzzyFsSearcher,
					fuzzySymbolSearcher: this._extension.fuzzySymbolSearcher,
				},
				{ document: await Qu.fromPathName(c, i), ...s },
			)
		}
		canRun() {
			return !0
		}
	},
	$y = class extends Jo {
		constructor(r, n, i, s, o) {
			super(o)
			this._extension = r
			this._extensionUri = n
			this._apiServer = i
			this._guidelinesWatcher = s
		}
		static commandID = "vscode-augment.internal-dv.i"
		type = "public"
		run = async (...r) => {
			if (!this._extension.workspaceManager) throw new Error("No workspace manager")
			if (!this._extension.keybindingWatcher) throw new Error("No keybinding watcher")
			let n = rf.window.activeTextEditor
			if (!n) {
				rf.window.showInformationMessage("No active editor.")
				return
			}
			if (yo(n.document.uri)) {
				rf.window.showInformationMessage("Code instructions are not supported in notebooks.")
				return
			}
			let [i, s, o] = r,
				a = Rbe(i)
			if (a === void 0) return
			if (a === null) return
			let l = _x(a),
				c = a.fsPath.replace(l.fsPath, ""),
				u = new Je(l.fsPath, c),
				f = await Qu.fromPathName(u, s),
				p = { ...o, document: f, guidelinesWatcher: this._guidelinesWatcher },
				g = n.selection
			;(p.instruction = {
				selection: {
					start: { line: g.start.line, character: g.start.character },
					end: { line: g.end.line, character: g.end.character },
				},
			}),
				Bn.createOrShow(
					{
						extensionUri: this._extensionUri,
						workspaceManager: this._extension.workspaceManager,
						apiServer: this._apiServer,
						keybindingWatcher: this._extension.keybindingWatcher,
						fuzzyFsSearcher: this._extension.fuzzyFsSearcher,
						fuzzySymbolSearcher: this._extension.fuzzySymbolSearcher,
					},
					p,
				)
		}
		canRun() {
			let r = this._extension.featureFlagManager.currentFlags,
				n = rf.window.activeTextEditor
			return !!(r.enableInstructions && n && !yo(n.document.uri))
		}
	},
	Yy = class extends lt {
		static commandID = "vscode-augment.internal-dv.aac"
		type = "public"
		constructor() {
			super()
		}
		run() {
			Bn.currentPanel && Bn.controller?.diffViewMessageHandler.acceptAllChunks()
		}
		canRun() {
			return !0
		}
	},
	Ky = class extends lt {
		static commandID = "vscode-augment.internal-dv.afc"
		type = "public"
		constructor() {
			super()
		}
		run() {
			Bn.currentPanel && Bn.controller?.diffViewMessageHandler.acceptFocusedChunk()
		}
		canRun() {
			return !0
		}
	},
	Jy = class extends lt {
		static commandID = "vscode-augment.internal-dv.rfc"
		type = "public"
		constructor() {
			super()
		}
		run() {
			Bn.currentPanel && Bn.controller?.diffViewMessageHandler.rejectFocusedChunk()
		}
		canRun() {
			return !0
		}
	},
	zy = class extends lt {
		static commandID = "vscode-augment.internal-dv.fpc"
		type = "public"
		constructor() {
			super()
		}
		run() {
			Bn.currentPanel && Bn.controller?.diffViewMessageHandler.focusPreviousChunk()
		}
		canRun() {
			return !0
		}
	},
	jy = class extends lt {
		static commandID = "vscode-augment.internal-dv.fnc"
		type = "public"
		constructor() {
			super()
		}
		run() {
			Bn.currentPanel && Bn.controller?.diffViewMessageHandler.focusNextChunk()
		}
		canRun() {
			return !0
		}
	},
	Zy = class extends lt {
		static commandID = "vscode-augment.internal-dv.c"
		type = "public"
		constructor() {
			super()
		}
		run() {
			Bn.currentPanel && Bn.currentPanel.dispose()
		}
		canRun() {
			return !0
		}
	}
function Rbe(e) {
	return e === void 0
		? rf.window.activeTextEditor?.document.uri
		: e === null
			? null
			: e instanceof rf.Uri
				? e
				: rf.Uri.parse(e)
}
var sF = W(require("vscode"))
var iF = class extends z {
	constructor(r, n, i, s) {
		super()
		this._webview = r
		this._sessionReporter = n
		this._deps = i
		this._opts = s
		;(this._workspaceManager = this._deps.workspaceManager),
			(this._asyncMsgHandler = Ti(this._webview)),
			this._registerMessageHandlers(),
			this.addDisposable(this._asyncMsgHandler)
	}
	_asyncMsgHandler
	_workspaceManager
	_registerMessageHandlers() {
		this._deps.fuzzyFsSearcher &&
			(this._asyncMsgHandler.registerHandler("find-file-request", this._deps.fuzzyFsSearcher.findFiles),
			this._asyncMsgHandler.registerHandler("find-folder-request", this._deps.fuzzyFsSearcher.findFolders),
			this._asyncMsgHandler.registerHandler(
				"find-recently-opened-files",
				this._deps.fuzzyFsSearcher.findRecentFiles,
			)),
			this._asyncMsgHandler.registerStreamHandler(
				"diff-view-fetch-pending-stream",
				() => this._opts.getCurrentStream() ?? (async function* () {})(),
			),
			this._asyncMsgHandler.registerHandler("diff-view-resolve-chunk", this._opts.resolveDiff),
			this._asyncMsgHandler.registerHandler("diff-view-window-focus-change", this._onDiffViewFocusChange),
			this._asyncMsgHandler.registerHandler(
				"dispose-diff-view",
				async () => (this._opts.onUserTriggeredClose?.(), Promise.resolve({})),
			),
			this._asyncMsgHandler.registerHandler("diff-view-loaded", () => this._opts.getInitData()),
			this._asyncMsgHandler.registerHandler("chat-instruction-message", this._onUserSendInstruction.bind(this))
	}
	notifyReinit() {
		this._webview.postMessage({ type: "diff-view-notify-reinit" })
	}
	acceptAllChunks() {
		this._sessionReporter.chunkResolveByStartLine.size || (this._sessionReporter.isAcceptAll = !0),
			this._webview.postMessage({ type: "diff-view-accept-all-chunks" })
	}
	acceptFocusedChunk() {
		this._webview.postMessage({ type: "diff-view-accept-selected-chunk" })
	}
	rejectFocusedChunk() {
		this._webview.postMessage({ type: "diff-view-reject-focused-chunk" })
	}
	focusPreviousChunk() {
		this._webview.postMessage({ type: "diff-view-focus-prev-chunk" })
	}
	focusNextChunk() {
		this._webview.postMessage({ type: "diff-view-focus-next-chunk" })
	}
	_onDiffViewFocusChange = (r) => {
		let n = r.data
		return xc("vscode-augment.internal-dv.panel-focused", n), { type: "empty" }
	}
	async _onUserSendInstruction(r) {
		if (
			(this._deps.logger.info(`onUserSendInstruction: ${JSON.stringify(r)}`),
			r.type !== "chat-instruction-message" ||
				!("data" in r) ||
				typeof r.data != "object" ||
				!("instruction" in r.data))
		)
			throw new Error("Invalid message type or data for instruction")
		let n = this._deps.apiServer.createRequestId()
		try {
			let i = this._runChatInstructionStream(r, n)
			Bn.createOrShow(this._deps, {
				...this._opts,
				viewOptions: sF.ViewColumn.Active,
				document: await Qu.fromPathName(this._opts.document.filePath),
			}),
				Bn.startStream(XM(this._opts.document.originalCode, i), n, "instruction")
		} catch (i) {
			throw (sF.window.showErrorMessage(`Failed to send instruction: ${i}`), i)
		}
		return { type: "empty" }
	}
	async *_runChatInstructionStream(r, n) {
		if (!this._opts.guidelinesWatcher) {
			this._deps.logger.error("Guidelines watcher not initialized")
			return
		}
		let { instruction: i, selectedCodeDetails: s } = r.data,
			{ selectedCode: o, prefix: a, suffix: l, path: c, language: u, prefixBegin: f, suffixEnd: p } = s
		this._deps.logger.info(`Sending request to the instruction model: ${n}`)
		let g = this._workspaceManager.getContext(),
			m
		!this._opts.document.isEmptyDocument && !this._opts.document.isUntitled
			? (m = this._workspaceManager.getBlobName(this._opts.document.filePath))
			: (m = g.blobs.checkpointId)
		try {
			let y = this._opts.guidelinesWatcher.getUserGuidelinesContent(),
				C = this._opts.guidelinesWatcher.getCurrentWorkspaceGuidelinesContent(this._workspaceManager),
				v = await this._deps.apiServer.chatInstructionStream(n, i, g.blobs, [], o, a, l, c, m, f, p, u, y, C)
			for await (let b of v) yield b
		} catch (y) {
			throw (this._deps.logger.error(`Error in runChatInstructionStream: ${Ye(y)}`), y)
		}
	}
}
var c_ = W(require("vscode"))
function Xy() {
	let e = "",
		t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
	for (let r = 0; r < 32; r++) e += t.charAt(Math.floor(Math.random() * t.length))
	return e
}
var oF = class extends z {
	constructor(r, n, i, s) {
		super()
		this.streamId = r
		this.requestId = n
		this._stream = i
		this._logger = s
		;(this._copyableGenerator = new Jp(this._stream)),
			this.addDisposable({ dispose: () => this._cancelToken?.dispose() })
	}
	_cancelToken = new c_.CancellationTokenSource()
	_copyableGenerator
	get stream() {
		return this._formatStream(this._copyableGenerator.copy())
	}
	cancel = () => {
		this._cancelToken?.cancel(), this._copyableGenerator.cancel(), this.dispose()
	}
	_resetStream = () => {
		this._cancelToken?.cancel(),
			this._cancelToken?.dispose(),
			(this._cancelToken = new c_.CancellationTokenSource())
	}
	async *_formatStream(r) {
		this._resetStream()
		let n = this._cancelToken.token,
			i = `${this.streamId}-${Xy()}`
		try {
			yield this._streamStartedMsg(i)
			for await (let s of r) {
				if (n.isCancellationRequested) break
				yield this._streamDataMsg(i, s)
			}
		} catch (s) {
			this._notifyStreamError(s)
		} finally {
			yield this._streamEndedMsg(i)
		}
	}
	_notifyStreamError(r) {
		c_.window.showWarningMessage("Error streaming in changes to Augment Diff. Please try again."),
			this._logger.error(`Error streaming in changes to Augment Diff: ${r.message}`)
	}
	_streamStartedMsg = (r) => ({
		data: { streamId: r, requestId: this.requestId },
		type: "diff-view-diff-stream-started",
	})
	_streamDataMsg = (r, n) => ({
		data: { ...n, streamId: r, requestId: this.requestId },
		type: "diff-view-diff-stream-chunk",
	})
	_streamEndedMsg = (r) => ({
		data: { streamId: r, requestId: this.requestId },
		type: "diff-view-diff-stream-ended",
	})
}
var aF = class extends z {
	constructor(r, n, i, s) {
		super()
		this._panel = r
		this._deps = n
		this._opts = i
		;(this._sessionReporter = new yM(this._deps.apiServer)),
			s && (this._sessionReporter.applyTime = s.applyTime),
			(this._diffViewMessageHandler = new iF(this._panel.webview, this._sessionReporter, this._deps, {
				...this._opts,
				getInitData: this.getInitData,
				resolveDiff: this.resolveDiff,
				getCurrentStream: () => this._stream?.stream,
			})),
			this.addDisposable(this._diffViewMessageHandler),
			this.addDisposable(this._sessionReporter),
			this.addDisposable(this._opts.document),
			this._diffViewMessageHandler.notifyReinit()
	}
	_sessionReporter
	_diffViewMessageHandler
	_currentSelection
	_stream
	get diffViewMessageHandler() {
		return this._diffViewMessageHandler
	}
	get sessionReporter() {
		return this._sessionReporter
	}
	startStream(r, n, i) {
		;(this._sessionReporter.requestId = n),
			(this._sessionReporter.sessionOrigin = i),
			(this._sessionReporter.initialRequestTime = Date.now()),
			this._cleanupStream(),
			(this._stream = new oF(this._deps.apiServer.createRequestId(), n, r, this._deps.logger))
	}
	_cleanupStream = () => {
		this._stream?.cancel(), (this._stream = void 0)
	}
	getInitData = () => {
		let r = this._opts?.instruction?.selection,
			n = {
				type: "diff-view-initialize",
				data: {
					file: {
						repoRoot: "",
						pathName: "",
						originalCode: "",
						modifiedCode: "",
					},
					keybindings: this.keybindings,
					instruction: r && {
						selection: {
							start: { line: r?.start.line, character: r?.start.character },
							end: { line: r?.end.line, character: r?.end.character },
						},
					},
					editable: this._opts.editable,
					disableResolution: this._opts.disableResolution,
					disableApply: this._opts.disableApply,
				},
			}
		if (this._opts?.instruction) {
			let { selection: i } = this._opts.instruction,
				{ start: s, end: o } = i
			this._currentSelection = new Tl.Selection(
				new Tl.Position(s.line, s.character),
				new Tl.Position(o.line, o.character),
			)
		}
		return (
			this._opts.document.isEmptyDocument ||
				((n.data.file.pathName = this._opts.document.absPath),
				(n.data.file.originalCode = this._opts.document.originalCode),
				(n.data.file.modifiedCode = this._opts.document.modifiedCode)),
			Promise.resolve(n)
		)
	}
	resolveDiff = async (r) => {
		let { file: n, resolveType: i, changes: s } = r.data
		this._sessionReporter.reportResolution(r)
		let o = Tl.Uri.file(this._opts.document?.absPath ?? "").fsPath,
			a = Tl.Uri.file(n.pathName).fsPath,
			l = n.modifiedCode === void 0
		if (!this._opts.document || o !== a || l) return { type: "empty" }
		if (
			(i === "accept" || i === "reject") &&
			this._opts.document.updateCodeVersions(n.originalCode, n.modifiedCode)
		) {
			let u = await Tl.workspace.openTextDocument(this._opts.document.absPath)
			s && s.length > 0 && u && this.updateChangeRange(u, s, i)
		}
		return { type: "empty" }
	}
	updateChangeRange = (r, n, i) => {
		if (!this._currentSelection) return
		let s = this._currentSelection.start.line,
			o = this._currentSelection.end.line,
			a = Number.MAX_SAFE_INTEGER,
			l = 0
		for (let u of n)
			if (u.lineChanges && u.lineChanges.lineChanges)
				for (let f of u.lineChanges.lineChanges)
					(a = Math.min(a, f.originalStart)), (l = Math.max(l, f.modifiedEnd))
		i === "accept" && ((s = Math.min(s, a - 1)), (o = Math.max(o, l - 1))),
			(s = Math.max(0, s)),
			(o = Math.min(r.lineCount - 1, o))
		let c = r.lineAt(o).range.end
		this._currentSelection = new Tl.Selection(new Tl.Position(s, 0), c)
	}
	get keybindings() {
		return {
			acceptAllChunks: this._deps.keybindingWatcher.getKeybindingForCommand(Yy.commandID, !0) ?? "",
			rejectAllChunks: this._deps.keybindingWatcher.getKeybindingForCommand(Zy.commandID, !0) ?? "",
			acceptFocusedChunk: this._deps.keybindingWatcher.getKeybindingForCommand(Ky.commandID, !0) ?? "",
			rejectFocusedChunk: this._deps.keybindingWatcher.getKeybindingForCommand(Jy.commandID, !0) ?? "",
			focusPrevChunk: this._deps.keybindingWatcher.getKeybindingForCommand(zy.commandID, !0) ?? "",
			focusNextChunk: this._deps.keybindingWatcher.getKeybindingForCommand(jy.commandID, !0) ?? "",
		}
	}
}
var Ri = W(require("vscode"))
function v0t() {
	let e =
		Ri.window.activeColorTheme.kind === Ri.ColorThemeKind.Dark ||
		Ri.window.activeColorTheme.kind === Ri.ColorThemeKind.HighContrast
	return {
		added: {
			background: e ? "rgba(0, 255, 0, 0.1)" : "rgba(0, 200, 0, 0.05)",
			text: e ? "rgba(150, 255, 150, 0.9)" : "rgba(0, 100, 0, 0.8)",
		},
		removed: {
			background: "rgba(255, 0, 0, 0.05)",
			text: e ? "rgba(255, 200, 200, 0.9)" : "rgba(150, 0, 0, 0.8)",
			border: "rgba(150, 0, 0, 0.3)",
		},
	}
}
function kbe(e, t, r) {
	let n = v0t(),
		i = Ri.window.createTextEditorDecorationType({
			backgroundColor: n.added.background,
			isWholeLine: !0,
			after: { color: n.added.text, margin: "0 0 0 1em" },
		}),
		s = Ri.window.createTextEditorDecorationType({
			isWholeLine: !0,
			before: {
				color: n.removed.text,
				border: `1px solid ${n.removed.border}`,
				backgroundColor: n.removed.background,
				margin: "0 5px 0 0",
			},
		}),
		o = mI("original", "modified", t, r, "", "", { context: 0 }),
		a = [],
		l = []
	for (let u of o.hunks) {
		let f = u.newStart - 1,
			p = !1,
			g = 0,
			m = ""
		for (let y of u.lines)
			if (y.startsWith("+")) {
				if (f < e.document.lineCount) {
					let C = new Ri.Range(new Ri.Position(f, 0), new Ri.Position(f, e.document.lineAt(f).text.length))
					a.push(C)
				}
				f++
			} else
				y.startsWith("-") &&
					((p = !0),
					g++,
					(m +=
						y.substring(1) +
						`
`))
		if (p) {
			let y = Math.max(0, u.newStart - 2)
			if (y < e.document.lineCount) {
				let C = new Ri.Range(new Ri.Position(y, 0), new Ri.Position(y, e.document.lineAt(y).text.length))
				l.push({ range: C, count: g, removedContent: m.trim() })
			}
		}
	}
	e.setDecorations(i, a)
	let c = l.map((u) => {
		let f = new Ri.MarkdownString()
		return (
			f.appendMarkdown(`**Removed content:**

`),
			f.appendCodeblock(u.removedContent, "diff"),
			(f.isTrusted = !0),
			(f.supportHtml = !0),
			{
				range: u.range,
				renderOptions: {
					before: {
						contentText: `\u2296 ${u.count} line${u.count === 1 ? "" : "s"} removed`,
						color: n.removed.text,
						border: `1px solid ${n.removed.border}`,
						backgroundColor: n.removed.background,
						margin: "0 5px 0 0",
					},
				},
				hoverMessage: f,
			}
		)
	})
	return e.setDecorations(s, c), [i, s]
}
function Mbe(e, t) {
	let n = 1e4 * (Math.log(e.length + 1) / Math.log(4)),
		{ minDelayMs: i = 1e4, maxDelayMs: s = 3e4 } = t,
		o = Math.min(Math.max(n, i), s)
	setTimeout(() => {
		e.forEach((a) => a.dispose())
	}, o)
}
function Fbe(e, t) {
	let r = [],
		n = Ri.workspace.onDidChangeTextDocument((i) => {
			i.document.uri.toString() === e.document.uri.toString() &&
				(t.forEach((s) => s.dispose()), r.forEach((s) => void s.dispose()))
		})
	return (
		r.push(n),
		{
			dispose: () => {
				r.forEach((i) => void i.dispose())
			},
		}
	)
}
var Bn = class e extends z {
	constructor(r, n) {
		super()
		this._deps = r
		this._opts = n
		;(this._panel = Wi.window.createWebviewPanel(
			e.viewType,
			"Augment",
			this._opts.viewOptions ?? Wi.ViewColumn.Active,
			{ retainContextWhenHidden: !0, enableScripts: !0 },
		)),
			(this._panel.iconPath = {
				light: Wi.Uri.joinPath(this._deps.extensionUri, "media", "panel-icon-light.svg"),
				dark: Wi.Uri.joinPath(this._deps.extensionUri, "media", "panel-icon-dark.svg"),
			}),
			(this._controller = this._updateOpts(this._opts)),
			this._panel.onDidDispose(() => {
				this.dispose()
			}),
			this.addDisposables(
				this._controller,
				this._panel,
				new Wi.Disposable(() => {
					e.currentPanel = void 0
				}),
			),
			this._setHTML()
	}
	static viewType = "augmentDiffView"
	_logger = X("DiffViewWebviewPanel")
	static currentPanel
	_panel
	_controller
	get diffViewController() {
		return this._controller
	}
	dispose = () => {
		this._opts.onDispose?.(),
			this._controller.dispose(),
			this._panel.dispose(),
			(e.currentPanel = void 0),
			super.dispose()
	}
	_updateOpts = (r) => (
		(this._opts = r),
		this._controller?.dispose(),
		(this._controller = new aF(
			this._panel,
			{ ...this._deps, panel: this._panel, logger: this._logger },
			{ ...this._opts, onUserTriggeredClose: () => this.dispose() },
		)),
		this._controller
	)
	get logger() {
		return this._logger
	}
	static get controller() {
		return this.currentPanel?.diffViewController
	}
	static get currentDocument() {
		return this.currentPanel?._opts.document
	}
	static get isVisible() {
		return this.currentPanel?._panel.visible
	}
	async _setHTML() {
		let r = this._panel.webview,
			n = Wi.Uri.joinPath(this._deps.extensionUri, "common-webviews")
		r.options = { enableScripts: !0, localResourceRoots: [n] }
		let i = r.asWebviewUri(Wi.Uri.joinPath(n, "/")),
			s = wl(Sl(r), Il(), Bl(), Dl(), Wy()),
			o = await Fr(wG.default.join(n.fsPath, "diff-view.html"))
		;(o = o.replace(
			/<head>/i,
			`<head>
            <base href="${i.toString()}" />
            <meta http-equiv="Content-Security-Policy" content="${s}">
        `,
		)),
			(r.html = o)
	}
	static startStream = (r, n, i) => {
		this.currentPanel?.diffViewController.startStream(r, n, i)
	}
	static async instantApply(r, n, i) {
		let s = n.document,
			o = s.originalCode,
			a = i,
			l = s.absPath,
			c = ""
		for await (let v of Cbe(o, a)) c = v
		let u = await Wi.workspace.openTextDocument(l),
			f = new Wi.WorkspaceEdit()
		f.replace(u.uri, new Wi.Range(0, 0, u.lineCount, 0), c), await Wi.workspace.applyEdit(f)
		let p = await Wi.window.showTextDocument(u),
			g = kbe(p, o, c)
		Mbe(g, { minDelayMs: 3e4 }), Fbe(p, g)
		let y = XA(o, c).map((v) => ({
				repoRoot: s.filePath.rootPath,
				pathName: s.filePath.relPath,
				originalCode: v.removed ? v.value : "",
				modifiedCode: v.added ? v.value : "",
			})),
			C = {
				file: {
					repoRoot: s.filePath.rootPath,
					pathName: s.filePath.relPath,
					originalCode: o,
					modifiedCode: c,
				},
				changes: y,
				resolveType: "accept",
				shouldApplyToAll: !0,
			}
		return (
			this.controller?.sessionReporter.reportResolution({
				type: "diff-view-resolve-chunk",
				data: C,
			}),
			c
		)
	}
	static createOrShow(r, n) {
		if (n.document.isEmptyDocument) return
		e.currentPanel ? e.currentPanel._updateOpts(n) : (e.currentPanel = new e(r, n))
		let i = e.currentPanel,
			s = n.document.filePath,
			o = wG.default.basename(s.absPath)
		;(i._panel.title = `Augment Diff - ${o}`), i._panel.reveal()
	}
}
var Bc = W(require("vscode"))
var Qbe = W(require("path")),
	lF = W(require("vscode"))
var Lu = class extends z {
	constructor(r, n) {
		super()
		this.filename = r
		this._webview = n
	}
	_logger = X("PanelWebviewBase")
	generateCSPPolicy() {
		return wl(Sl(this._webview), Il(), Sbe(), Bl(), Dl(), rF())
	}
	async loadHTML(r) {
		if (a_()) {
			let o = process.env.AUGMENT_HMR
			this._logger.debug("Loading '%s' from dev server on '%s'", this.filename, o),
				(this._webview.options = {
					enableScripts: !0,
					localResourceRoots: [lF.Uri.parse(o)],
				})
			try {
				this._webview.html = await Ibe(o, this.filename, this.generateCSPPolicy())
				return
			} catch (a) {
				this._logger.error(`Failed to load '%s' from dev server: ${String(a)}`, this.filename)
			}
		}
		let n = lF.Uri.joinPath(r, "common-webviews"),
			i = this._webview.asWebviewUri(lF.Uri.joinPath(n, "/"))
		this._webview.options = { enableScripts: !0, localResourceRoots: [n] }
		let s = await Fr(Qbe.join(n.fsPath, this.filename))
		this._webview.html = xG(s, i.toString(), this.generateCSPPolicy())
	}
}
function E0t(e) {
	if (e.startsWith("A") || e.startsWith("=")) return !0
	if (e.startsWith("B")) return !1
	throw new Error(`Incorrect rating: ${e}`)
}
function IG(e) {
	let t
	if (e.startsWith("A")) t = -1 * parseInt(e.charAt(1), 10)
	else if (e.startsWith("B")) t = parseInt(e.charAt(1), 10)
	else if (e.startsWith("=")) t = 0
	else throw new Error(`Incorrect rating: ${e}`)
	return t
}
var eC = class e extends Lu {
	constructor(r, n, i, s, o, a, l) {
		super("preference.html", r.webview)
		this._extensionUri = n
		this._fuzzyFsSearcher = i
		this.inputData = o
		this._externalSources = a
		this._userSpecifiedExternalSources = l
		;(this._asyncMsgHandler = Ti(r.webview)),
			this.addDisposable(this._asyncMsgHandler),
			this._asyncMsgHandler.registerHandler("find-file-request", this._fuzzyFsSearcher.findFiles),
			this._asyncMsgHandler.registerHandler("chat-loaded", (c) =>
				Promise.resolve({ type: "chat-initialize", data: {} }),
			),
			(this._panel = r),
			(this._inputData = o)
	}
	static currentPanel
	_panel
	static _logger = X("PreferenceWebviewPanel")
	_inputData
	_asyncMsgHandler
	_resolvePreference
	handleMessage = (r) => {
		if (r.type === "preference-result-message") {
			let n = r.data
			this._resolvePreference(n), this._panel.dispose()
		}
		r.type === "preference-notify" && Bc.window.showInformationMessage(r.data),
			r.type === "preference-panel-loaded" &&
				(e._logger.info("Preference panel loaded, sending input data"),
				this._panel.webview.postMessage({
					type: "preference-init",
					data: this._inputData,
				})),
			r.type === "open-file" && iA(r.data)
	}
	static async launchStandalonePreferencePanel(r, n, i, s, o = [], a = []) {
		e.currentPanel && (e.currentPanel.dispose(), (e.currentPanel = void 0))
		let c = (Bc.window.activeTextEditor ? Bc.window.activeTextEditor.viewColumn : void 0) || Bc.ViewColumn.One,
			u = { type: "Chat", data: n, enableRetrievalDataCollection: i },
			f = Bc.window.createWebviewPanel("preference", "Augment Preference", c, {
				enableScripts: !0,
				retainContextWhenHidden: !0,
				localResourceRoots: [Bc.Uri.joinPath(r, "/common-webviews")],
			}),
			p = (e.currentPanel = new e(f, r, s, c, u, o, a))
		return (
			await p.loadHTML(r),
			f.onDidDispose(() => {
				p._resolvePreference && p._resolvePreference(null), p.dispose()
			}),
			p.addDisposables(
				f,
				new Bc.Disposable(() => {
					e.currentPanel = void 0
				}),
			),
			f.webview.onDidReceiveMessage(p.handleMessage),
			e.currentPanel
		)
	}
	async postStreamChunk(r, n) {
		await this._panel.webview.postMessage({ ...r, stream: n })
	}
	async postStreamDone() {
		await this._panel.webview.postMessage({ type: "chat-stream-done" })
	}
	async getResult(r, n, i) {
		let s = await new Promise((o) => {
			this._resolvePreference = o
		})
		return s ? (await this.sendResultToBackend(r, n, i, s), E0t(s.overallRating)) : !0
	}
	/**
	 * Send the user's preference result to the backend.
	 * @param {String} r the id of the request
	 * @param {Object} n the function to call on the backend
	 * @param {Object} i the model ids to pass to the backend
	 * @param {Object} s the user's preference result
	 * @returns {Promise<Boolean>} whether the request was successful
	 */
	async sendResultToBackend(r, n, i, s) {
		let o = `${s.textFeedback}
MODEL_IDS_START_LABEL
${i?.a}
${i?.b}
MODEL_IDS_END_LABEL
IMPLICIT_EXTERNAL_SOURCES_START_LABEL
${this._externalSources?.map((a) => a.name).join(", ") ?? ""}
IMPLICIT_EXTERNAL_SOURCES_END_LABEL
USER_SPECIFIED_EXTERNAL_SOURCES_START_LABEL
${this._userSpecifiedExternalSources?.join(", ") ?? ""}
USER_SPECIFIED_EXTERNAL_SOURCES_END_LABEL
`
		await xi(async () => {
			try {
				return await n.recordPreferenceSample({
					request_ids: [r.a, r.b],
					scores: {
						overallRating: IG(s.overallRating),
						formattingRating: IG(s.formattingRating),
						instructionFollowingRating: IG(s.instructionFollowingRating),
						isHighQuality: s.isHighQuality ? 1 : 0,
					},
					feedback: o,
				})
			} catch (a) {
				throw (e._logger.error(`Error reporting preference sample: ${a}`), a)
			}
		}, e._logger)
	}
}
var cF = 2e5
var u_ = class extends z {
	constructor(r, n, i, s, o, a, l, c, u, f, p, g, m, y, C, v, b, w, B, M, Q, O, Y, j) {
		super()
		this._chatModel = r
		this._chatModelConfigs = n
		this._apiServer = i
		this._workspaceManager = s
		this._keybindingWatcher = o
		this._config = a
		this._extensionUri = l
		this._featureFlagManager = c
		this._clientMetricsReporter = u
		this._actionsModel = f
		this._syncingEnabledTracker = p
		this._onboardingWorkspaceModel = g
		this._syncingStatus = m
		this._onboardingSessionEventReporter = y
		this._fuzzyFsSearcher = C
		this._fuzzySymbolSearcher = v
		this._toolsModel = b
		this._resolveFileService = w
		this._checkpointManager = B
		this._guidelinesWatcher = M
		this._assetManager = Q
		this._agentSessionEventReporter = O
		this._agentRequestEventReporter = Y
		this._globalState = j
		let ne = Lt.workspace.workspaceFolders?.at(0)?.uri.fsPath ?? ""
		;(this._commitMessagePromptPreparer = new Hy(ne)),
			(this._smartPasteCache = new AM(async (q) => {
				let me = this._apiServer.createRequestId()
				return Promise.resolve({
					generator: this._smartPasteWithChatInstruction(q, me),
					requestId: me,
				})
			})),
			this.addDisposables(
				this._actionsModel.onDerivedStatesSatisfied(this.handleDerivedStateChange.bind(this)),
				this._syncingEnabledTracker.onDidChangeSyncingEnabled(this.sendSyncEnabledStatus.bind(this)),
				this._guidelinesWatcher.onDidChange(this.sendCurrentGuidelinesState.bind(this)),
				this._smartPasteCache,
				this._checkpointManager.onAgentEditListHasUpdates(() => this._notifyAgentEditListHasUpdates()),
			)
	}
	_logger = X("ChatApp")
	_asyncMsgHandler
	_lastKnownSourceFolders = []
	_webview
	_smartPasteCache
	_commitMessagePromptPreparer
	appType() {
		return "chat"
	}
	title() {
		return "Chat"
	}
	/**
	 * Register the chat app.
	 *
	 * This method is called by the `roo-cline` extension when the chat app is
	 * created. It registers the chat app with the extension and sets up the
	 * necessary event handlers.
	 *
	 * @param {import("vscode").WebviewPanel} webview - The webview panel to
	 *   render the chat UI in.
	 */
	register(r) {
		;(this._webview = r),
			(this._asyncMsgHandler = Ti(this._webview)),
			this.addDisposable(this._asyncMsgHandler),
			this._asyncMsgHandler.registerHandler("find-file-request", this._fuzzyFsSearcher.findFiles),
			this._asyncMsgHandler.registerHandler("find-folder-request", this._fuzzyFsSearcher.findFolders),
			this._asyncMsgHandler.registerHandler("find-recently-opened-files", this._fuzzyFsSearcher.findRecentFiles),
			this._asyncMsgHandler.registerHandler("resolve-file-request", async (n) => ({
				type: "resolve-file-response",
				data: await this.resolveTargetPath(n.data.relPath, n.data.searchScope, n.data.exactMatch),
			})),
			this._asyncMsgHandler.registerStreamHandler("chat-user-message", this.onUserSendMessage.bind(this)),
			this._asyncMsgHandler.registerStreamHandler(
				"generate-commit-message",
				this.generateCommitMessage.bind(this),
			),
			this._asyncMsgHandler.registerStreamHandler(
				"chat-get-stream-request",
				this._chatModel.getChatStream.bind(this._chatModel),
			),
			this._asyncMsgHandler.registerHandler("chat-user-cancel", (n) => this.onUserCancel(n)),
			this._asyncMsgHandler.registerHandler("chat-rating", this._chatModel.sendFeedback),
			this._asyncMsgHandler.registerHandler("save-chat", this._chatModel.saveConversation),
			this._asyncMsgHandler.registerHandler("chat-launch-autofix-panel", (n) => this.onLaunchAutofixPanel(n)),
			this._asyncMsgHandler.registerHandler("chat-autofix-state-update", (n) => this.handleAutofixStateUpdate(n)),
			this._asyncMsgHandler.registerHandler("open-confirmation-modal", (n) => this.onOpenConfirmationModal(n)),
			this._asyncMsgHandler.registerHandler("find-external-sources-request", this.onExternalSourceSearch),
			this._asyncMsgHandler.registerHandler(
				"resolve-workspace-file-chunk",
				this._chatModel.resolveWorkspaceFileChunk,
			),
			this._asyncMsgHandler.registerHandler("find-symbol-request", this._fuzzySymbolSearcher.findSymbols),
			this._asyncMsgHandler.registerHandler(
				"chat-autofix-execute-command-request",
				this.onExecuteCommand.bind(this),
			),
			this._asyncMsgHandler.registerHandler("chat-autofix-plan-request", this.onAutofixPlan.bind(this)),
			this._asyncMsgHandler.registerHandler(
				"find-symbol-regex-request",
				this._fuzzySymbolSearcher.findSymbolsRegex,
			),
			this._asyncMsgHandler.registerHandler("get-diagnostics-request", this._chatModel.getDiagnostics),
			this._asyncMsgHandler.registerHandler(
				"report-webview-client-metric",
				(n) => (
					this._clientMetricsReporter.reportWebviewClientMetric(n.data), Promise.resolve({ type: "empty" })
				),
			),
			this._asyncMsgHandler.registerHandler(
				"report-agent-session-event",
				(n) => (this._agentSessionEventReporter.reportEvent(n.data), Promise.resolve({ type: "empty" })),
			),
			this._asyncMsgHandler.registerHandler(
				"report-agent-request-event",
				(n) => (this._agentRequestEventReporter.reportEvent(n.data), Promise.resolve({ type: "empty" })),
			),
			this._asyncMsgHandler.registerHandler("show-augment-panel", this.showAugmentPanel),
			this._asyncMsgHandler.registerHandler("call-tool", this.callTool),
			this._asyncMsgHandler.registerHandler("cancel-tool-run", this.cancelToolRun),
			this._asyncMsgHandler.registerHandler("check-safe", this.toolCheckSafe),
			this._asyncMsgHandler.registerHandler("checkToolExists", this.checkToolExists),
			this._asyncMsgHandler.registerHandler("chat-review-agent-file", this._showAgentReview),
			this._asyncMsgHandler.registerHandler("get-ide-state-node-request", this._getChatRequestIdeState),
			this._asyncMsgHandler.registerHandler(
				"getAgentEditContentsByRequestId",
				this._getAgentEditContentsByRequestId,
			),
			this._asyncMsgHandler.registerHandler("chat-save-image-request", this._saveImage),
			this._asyncMsgHandler.registerHandler("chat-load-image-request", this._loadImage),
			this._asyncMsgHandler.registerHandler("chat-delete-image-request", this._deleteImage),
			this._asyncMsgHandler.registerHandler(
				"chat-mode-changed",
				(n) => (this._toolsModel.setMode(n.data.mode), Promise.resolve({ type: "empty" })),
			),
			this._asyncMsgHandler.registerHandler("chat-get-agent-onboarding-prompt-request", async () => {
				let n = process.platform === "win32" ? "powershell" : "bash",
					i = new vm(() => this._config.config.agent, Mn.agent, process.platform, n),
					s = new Ck(i, this._workspaceManager)
				return Promise.resolve({
					type: "chat-get-agent-onboarding-prompt-response",
					data: { prompt: await s.getOnboardingInstructions() },
				})
			}),
			this._asyncMsgHandler.registerHandler("check-agent-auto-mode-approval", () => {
				let n = this._globalState.get("agentAutoModeApproved")
				return Promise.resolve({
					type: "check-agent-auto-mode-approval-response",
					data: n ?? !1,
				})
			}),
			this._asyncMsgHandler.registerHandler(
				"set-agent-auto-mode-approved",
				async (n) => (await this._globalState.update("agentAutoModeApproved", n.data), { type: "empty" }),
			),
			this._asyncMsgHandler.registerHandler("open-agent-checkpoint", async (n) => {
				let { requestId: i, retainFocus: s } = n.data,
					o = await this._checkpointManager.getCheckpointByRequestId(i),
					a = o?.files.at(0)
				return o === void 0 || a === void 0 || o.files.length !== 1
					? Promise.resolve({
							type: "getAgentEditContentsByRequestId",
							data: void 0,
						})
					: (await this._showAgentReview({
							type: "chat-review-agent-file",
							data: {
								qualifiedPathName: a.changeDocument.filePath,
								fromTimestamp: o.fromTimestamp,
								toTimestamp: o.toTimestamp,
								retainFocus: s,
							},
						}),
						{ type: "empty" })
			}),
			this._asyncMsgHandler.registerHandler("chat-loaded", (n) => {
				this.sendSourceFolders(),
					this.sendSyncStatus(),
					this.sendSyncEnabledStatus(),
					this.sendCurrentGuidelinesState(),
					this._onboardingWorkspaceModel.shouldShowSummary && this.sendShowSummary(),
					this._actionsModel.broadcastDerivedStates()
				let i = Lt.window.activeTextEditor
				i?.document.uri
					? (this.sendCurrentlyOpenFiles([i.document.uri]), this.sendFileSelections(i))
					: this.sendCurrentlyOpenFiles([]),
					this._notifyAgentEditListHasUpdates()
				let s = this._toolsModel.memoriesAbsPath
					? { rootPath: "", relPath: this._toolsModel.memoriesAbsPath }
					: void 0
				return Promise.resolve({
					type: "chat-initialize",
					data: {
						enablePreferenceCollection: this._config.config.preferenceCollection.enable,
						enableRetrievalDataCollection:
							this._config.config.preferenceCollection.enableRetrievalDataCollection,
						enableDebugFeatures: this._config.config.enableDebugFeatures,
						useRichTextHistory: this._config.config.chat.useRichTextHistory,
						modelDisplayNameToId: this.getMergedAdditionalChatModels(),
						fullFeatured: !0,
						enableExternalSourcesInChat: Gr(
							this._featureFlagManager.currentFlags.vscodeExternalSourcesInChatMinVersion ?? "",
						),
						smallSyncThreshold: this._featureFlagManager.currentFlags.smallSyncThreshold,
						bigSyncThreshold: this._featureFlagManager.currentFlags.bigSyncThreshold,
						enableSmartPaste: Gr(this._featureFlagManager.currentFlags.enableSmartPasteMinVersion ?? ""),
						enableDirectApply: !1,
						summaryTitles: this._featureFlagManager.currentFlags.enableSummaryTitles,
						suggestedEditsAvailable: Gr(
							this._featureFlagManager.currentFlags.vscodeNextEditMinVersion ?? "",
						),
						enableShareService: Gr(this._featureFlagManager.currentFlags.vscodeShareMinVersion ?? ""),
						maxTrackableFileCount: this._featureFlagManager.currentFlags.maxTrackableFileCount,
						enableDesignSystemRichTextEditor: Gr(
							this._featureFlagManager.currentFlags.vscodeDesignSystemRichTextEditorMinVersion ?? "",
						),
						enableSources: Gr(this._featureFlagManager.currentFlags.vscodeSourcesMinVersion ?? ""),
						enableChatMermaidDiagrams: this._featureFlagManager.currentFlags.enableChatMermaidDiagrams,
						smartPastePrecomputeMode: this._featureFlagManager.currentFlags.smartPastePrecomputeMode,
						useNewThreadsMenu: Gr(
							this._featureFlagManager.currentFlags.vscodeNewThreadsMenuMinVersion ?? "",
						),
						enableEditableHistory: Gr(
							this._featureFlagManager.currentFlags.vscodeEditableHistoryMinVersion ?? "",
						),
						enableChatMermaidDiagramsMinVersion: Gr(
							this._featureFlagManager.currentFlags.vscodeEnableChatMermaidDiagramsMinVersion ?? "",
						),
						enableChatMultimodal: Gr(
							this._featureFlagManager.currentFlags.vscodeChatMultimodalMinVersion ?? "",
						),
						enableAgentMode: Gr(this._featureFlagManager.currentFlags.vscodeAgentModeMinVersion ?? ""),
						enableRichCheckpointInfo: Gr(
							this._featureFlagManager.currentFlags.vscodeRichCheckpointInfoMinVersion ?? "",
						),
						agentMemoriesFilePathName: s,
						workspaceUnpopulated: this._actionsModel.isDerivedStateSatisfied("WorkspaceNotPopulated"),
						truncateChatHistory: this._featureFlagManager.currentFlags.truncateChatHistory,
					},
				})
			}),
			this._asyncMsgHandler.registerSidecarHandler((n, i) => {
				hY(n, i)
			}),
			this._resolveFileService.register(this._asyncMsgHandler),
			this.addDisposables(
				Lt.window.onDidChangeTextEditorSelection((n) => {
					!n ||
						n.textEditor.document.uri.scheme === "output" ||
						(this.sendSourceFolders(), this.sendFileSelections(n.textEditor))
				}),
				this._onboardingWorkspaceModel.onShouldShowSummary(this.sendShowSummary),
				this._webview.onDidReceiveMessage(this.onDidReceiveMessage),
				this._workspaceManager.onDidChangeSourceFolders(this.sendSourceFolders),
				Lt.window.onDidChangeActiveTextEditor((n) => {
					this.sendSourceFolders(),
						n
							? this.sendCurrentlyOpenFiles([n.document.uri])
							: (this.sendCurrentlyOpenFiles([]), this.sendFileSelections(void 0))
				}),
				this._syncingStatus.onDidChangeSyncingStatus(this.sendSyncStatus),
			),
			this.updateLastKnownSourceFolders()
	}
	async *generateCommitMessage(r) {
		let n
		try {
			n = await this._commitMessagePromptPreparer.getCommitMessagePromptData({
				diffBudget: 9216,
				messageBudget: 3072,
				relevantMessageSubbudget: 1024,
				diffNoopLineLimit: 5e3,
				onlyUseStagedChanges: !1,
				maxExampleCommitMessages: 3,
			})
		} catch (i) {
			let s = `Cannot generate commit message prompt: Failed to generate diff details. Error: ${
				i instanceof Error ? i.message : String(i)
			}`
			throw (Lt.window.showInformationMessage(s), new Error(s))
		}
		yield* this.onGenerateCommitMessage(n)
	}
	getMergedAdditionalChatModels = () => {
		let r = this._config.config.chat.modelDisplayNameToId || {},
			n = this._featureFlagManager.currentFlags.additionalChatModels
		n = n.replace(/'/g, '"')
		try {
			return { ...(n !== "" ? JSON.parse(n) : {}), ...r }
		} catch (i) {
			return this._logger.debug(`Failed to parse additional chat models: ${i.message}`), r
		}
	}
	onUserCancel = (r) => (
		this._logger.debug("onUserCancel"), this._chatModel.cancelChatStream(r.data.requestId), { type: "empty" }
	)
	isMemoriesFile(r) {
		let n = this._toolsModel.memoriesAbsPath
		if (!n) return !1
		let i = Je.from({
				rootPath: "rootPath" in r ? r.rootPath : r.repoRoot,
				relPath: "relPath" in r ? r.relPath : r.pathName,
			}),
			s = Je.from({ rootPath: "", relPath: n })
		return Je.equals(i, s)
	}
	filterMemoriesFromSelectedCode(r) {
		return r && (this.isMemoriesFile({ rootPath: "", relPath: r.path }) ? null : r)
	}
	sendCurrentlyOpenFiles = (0, Pbe.default)((r) => {
		let n = r
			.map((i) => this._resolvePathName(i))
			.filter((i) => i !== void 0)
			.filter((i) => !this.isMemoriesFile(i))
		this._webview?.postMessage({ type: "currently-open-files", data: n })
	}, 250)
	sendShowSummary = (0, Wh.default)(
		() => {
			this._webview?.postMessage({ type: "should-show-summary" }),
				this._onboardingWorkspaceModel.setShouldShowSummary(!1),
				this._onboardingSessionEventReporter.reportEvent("saw-summary")
		},
		250,
		{ leading: !0, trailing: !0 },
	)
	sendSyncStatus = (0, Wh.default)(
		() => {
			this._webview?.postMessage({
				type: "source-folders-sync-status",
				data: this._syncingStatus.status,
			})
		},
		250,
		{ leading: !0, trailing: !0 },
	)
	sendSyncEnabledStatus = (0, Wh.default)(
		() => {
			this._webview?.postMessage({
				type: "sync-enabled-state",
				data: this._syncingEnabledTracker.syncingEnabledState,
			})
		},
		250,
		{ leading: !0, trailing: !0 },
	)
	sendCurrentGuidelinesState = (0, Wh.default)(
		() => {
			this._webview?.postMessage({
				type: "update-guidelines-state",
				data: this._guidelinesWatcher.getGuidelinesStates(),
			})
		},
		250,
		{ leading: !0, trailing: !0 },
	)
	sendSourceFolders = (0, Wh.default)(
		() => {
			this.updateLastKnownSourceFolders(),
				this._webview?.postMessage({
					type: "source-folders-updated",
					data: { sourceFolders: this._lastKnownSourceFolders },
				})
		},
		250,
		{ leading: !0, trailing: !0 },
	)
	updateLastKnownSourceFolders() {
		this._lastKnownSourceFolders = this._workspaceManager.trackedSourceFolderNames()
	}
	sendFileSelections = (0, Wh.default)(
		(r) => {
			if (r?.document.uri) {
				let n = this._resolvePathName(r.document.uri)
				n && !this.isMemoriesFile(n)
					? this._webview?.postMessage({
							type: "currently-open-files",
							data: [n],
						})
					: this._webview?.postMessage({
							type: "currently-open-files",
							data: [],
						}),
					n && !this.isMemoriesFile(n)
						? this._webview?.postMessage(qme(r, this._workspaceManager))
						: this._webview?.postMessage({
								type: "file-ranges-selected",
								data: [],
							})
			} else this._webview?.postMessage({ type: "file-ranges-selected", data: [] })
		},
		250,
		{ leading: !0, trailing: !0 },
	)
	onOpenConfirmationModal = async (r) => {
		let n = await Lt.window.showInformationMessage(
			r.data.message,
			{ modal: !0 },
			{ title: r.data.cancelButtonText, isCloseAffordance: !0 },
			{ title: r.data.confirmButtonText },
		)
		return {
			type: "confirmation-modal-response",
			data: { ok: n?.title === r.data.confirmButtonText },
		}
	}
	_handleCompleteChatReply(r) {
		this._workspaceManager.recordChatReponse(r)
	}
	async postStreamChunksToPanel(r, n, i, s) {
		await r.postStreamChunk(
			{
				type: "chat-model-reply",
				data: { text: n, requestId: i, workspaceFileChunks: [] },
			},
			s,
		)
	}
	getNextLine(r) {
		let n = r.indexOf(`
`)
		return n === -1 ? [r, ""] : [r.slice(0, n + 1), r.slice(n + 1)]
	}
	async *onGenerateCommitMessage(r) {
		let n = this._apiServer.createRequestId(),
			i = await this._apiServer.generateCommitMessageStream(n, r)
		for await (let s of i)
			yield {
				type: "chat-model-reply",
				data: { text: s.text, requestId: n, workspaceFileChunks: [] },
			}
	}
	handleAutofixStateUpdate = async (r) => (await sA.currentPanel?.handleAutofixStateUpdate(r), { type: "empty" })
	onLaunchAutofixPanel = (r) => (
		sA.launchAutofixPanel(
			this._extensionUri,
			r.data.conversationId,
			r.data.iterationId,
			r.data.stage,
			this,
			this._resolveFileService,
		),
		{ type: "empty" }
	)
	async *onUserSendMessage(r) {
		let n = this._apiServer.createRequestId(),
			i = this._workspaceManager.getContext(),
			s = { checkpointId: void 0, addedBlobs: [], deletedBlobs: [] }
		;(r.data.context?.userSpecifiedFiles?.length || r.data.context?.sourceFolders?.length) &&
			!r.data.disableRetrieval &&
			(s = i.blobs)
		let o = []
		r.data.context?.userSpecifiedFiles &&
			!r.data.disableRetrieval &&
			(o = this._getBlobNames(r.data.context.userSpecifiedFiles))
		let a = this._guidelinesWatcher.getUserGuidelinesContent(),
			l = this._guidelinesWatcher.getCurrentWorkspaceGuidelinesContent(this._workspaceManager),
			c = []
		r.data.context?.externalSources &&
			!r.data.disableRetrieval &&
			(c = r.data.context.externalSources.map((p) => p.id))
		let u
		if (
			(r.data.context?.selections?.length || r.data.context?.recentFiles?.length) &&
			!r.data.disableSelectedCodeDetails
		) {
			Sme(Lt.window.activeTextEditor)
			let p = this._chatModelConfigs.get(r.data?.modelId ?? "")?.suggestedPrefixCharCount ?? cF,
				g = this._chatModelConfigs.get(r.data?.modelId ?? "")?.suggestedSuffixCharCount ?? cF
			;(u = EW(Lt.window.activeTextEditor, this._workspaceManager, p, g)),
				(u = this.filterMemoriesFromSelectedCode(u))
		}
		let f = (p) => {
			let g = this._workspaceManager
			p.unknownBlobNames && p.unknownBlobNames.length > 0 && g.handleUnknownBlobs(i, p.unknownBlobNames),
				p.checkpointNotFound && g.handleUnknownCheckpoint(n, s.checkpointId)
		}
		try {
			let p = !0
			if (this._config.config.chat.stream !== !1 && !this._config.config.preferenceCollection.enable) {
				let m = ""
				if (r.data.memoriesInfo?.isClassifyAndDistill) {
					let C = this._featureFlagManager.currentFlags.memoriesParams.classify_and_distill_prompt
					if (!C) {
						this._logger.error("Classify and distill prompt missing.")
						return
					}
					r.data.text = C.replace("{message}", r.data.text)
				} else if (r.data.memoriesInfo?.isDistill) {
					let C = this._featureFlagManager.currentFlags.memoriesParams.distill_prompt
					if (!C) {
						this._logger.error("Distill prompt missing.")
						return
					}
					r.data.text = C.replace("{message}", r.data.text)
				}
				let y
				this._toolsModel.chatMode === Mn.agent &&
					(y = await vk(this._checkpointManager.getAgentMemoriesAbsPath))
				for await (let C of this._chatModel.chatStream(
					{
						requestId: n,
						message: r.data.text,
						chatHistory: r.data.chatHistory,
						blobs: s,
						userGuidedBlobs: o,
						externalSourceIds: c,
						modelId: r.data.modelId,
						userGuidelines: a,
						workspaceGuidelines: l,
						toolDefinitions: (await this._toolsModel.getToolDefinitions()).map((v) => v.definition),
						nodes: r.data.nodes,
						mode: this._toolsModel.getMode(),
						agentMemories: y,
					},
					u,
				)) {
					if ((f(C.data), p)) {
						p = !1
						let v = this._syncingStatus.status.foldersProgress.some((b) => b.progress?.newlyTracked)
						this._syncingStatus.status.status !== "done" &&
							v &&
							(C.data.text =
								`*Note: Augment is not yet fully synced and may be unable to answer questions about your workspace.*

` + C.data.text)
					}
					;(m += C.data.text), yield C
				}
				this._handleCompleteChatReply(m)
				return
			}
			yield* await this.handlePreferenceCollection(r, n, s, o, c, u)
		} catch (p) {
			if (p instanceof kr && p.status === He.augmentTooLarge)
				return yield {
					type: "chat-model-reply-failed",
					data: { text: "", requestId: n, workspaceFileChunks: [] },
					displayErrorMessage:
						"The selected text exceeds the allowable limit. Please reduce the amount of text and try again",
				}
			if (p instanceof Error)
				return yield {
					type: "chat-model-reply-failed",
					data: { text: "", requestId: n, workspaceFileChunks: [] },
					displayErrorMessage: p.message,
				}
			if (String(p).startsWith("Error: Cancelled")) return
			throw (Lt.window.showErrorMessage(`Failed to send chat message: ${p}`), p)
		}
	}
	async handlePreferenceCollection(r, n, i, s, o, a) {
		let l = this._featureFlagManager.currentFlags.eloModelConfiguration
		if (
			((!l.highPriorityModels || l.highPriorityModels.length < 2) && l.highPriorityThreshold !== 0) ||
			((!l.regularBattleModels || l.regularBattleModels.length < 2) && l.highPriorityThreshold < 1)
		)
			return (async function* () {
				await Promise.resolve(),
					yield {
						type: "chat-model-reply-failed",
						data: { text: "", requestId: n, workspaceFileChunks: [] },
						displayErrorMessage: "Model comparison is not available at this time.",
					}
			})()
		let c = l.highPriorityThreshold
		;(this._chatModel._preferenceState._selectedCode !== a?.selectedCode ||
			this._chatModel._preferenceState._filePath !== a?.path) &&
			(this._chatModel._preferenceState = new Qx())
		let u = {
			message: r,
			requestId: n,
			blobs: i,
			userGuidedBlobs: s,
			selectedCodeDetails: a,
		}
		return Math.random() < c
			? this.handleHighPriorityTest(u, o, l.highPriorityModels)
			: this.handleRegularBattle(u, o, l.regularBattleModels)
	}
	handleHighPriorityTest(r, n, i) {
		let s, o
		if (i.length > 0 && Array.isArray(i[0])) {
			let a = Math.floor(Math.random() * i.length)
			;[s, o] = i[a]
		} else [s, o] = i.sort(() => Math.random() - 0.5).slice(0, 2)
		return Promise.resolve(
			this.runComparison(r, {
				modelId: s,
				modelIdB: o,
				externalSourceIds: n,
				externalSourceIdsB: n,
			}),
		)
	}
	handleRegularBattle(r, n, i) {
		let s = i[Math.floor(Math.random() * i.length)],
			o
		do o = i[Math.floor(Math.random() * i.length)]
		while (o === s && i.length > 1)
		return Promise.resolve(
			this.runComparison(r, {
				modelId: s,
				modelIdB: o,
				externalSourceIds: n,
				externalSourceIdsB: n,
			}),
		)
	}
	async *runComparison(r, n) {
		let i = this._apiServer.createRequestId(),
			s = (await this._toolsModel.getToolDefinitions()).map((m) => m.definition),
			o = this._chatModel.chatStream(
				{
					requestId: r.requestId,
					message: r.message.data.text,
					chatHistory: r.message.data.chatHistory,
					blobs: r.blobs,
					userGuidedBlobs: r.userGuidedBlobs,
					externalSourceIds: n.externalSourceIds,
					modelId: n.modelId,
					toolDefinitions: s,
				},
				r.selectedCodeDetails,
			),
			a = this._chatModel.chatStream(
				{
					requestId: i,
					message: r.message.data.text,
					chatHistory: r.message.data.chatHistory,
					blobs: r.blobs,
					userGuidedBlobs: r.userGuidedBlobs,
					externalSourceIds: n.externalSourceIdsB,
					modelId: n.modelIdB,
					toolDefinitions: s,
				},
				r.selectedCodeDetails,
			),
			{
				responseA: l,
				responseB: c,
				workspaceFileChunksA: u,
				workspaceFileChunksB: f,
				preferencePanel: p,
			} = await this.processStreams(
				o,
				a,
				r.message,
				r.requestId,
				i,
				n.implicitExternalSources ? n.implicitExternalSources : [],
				[...(n.externalSourceIds ?? []), ...(n.externalSourceIdsB ?? [])],
			)
		p.postStreamDone()
		let g = await p?.getResult({ a: r.requestId, b: i }, this._apiServer, {
			a: n.modelId,
			b: n.modelIdB,
		})
		g
			? (this._chatModel._preferenceState._selectedCodeReferenceRequestIdOptionB =
					this._chatModel._preferenceState._selectedCodeReferenceRequestId)
			: (this._chatModel._preferenceState._selectedCodeReferenceRequestId =
					this._chatModel._preferenceState._selectedCodeReferenceRequestIdOptionB),
			this._handleCompleteChatReply(g ? l : c),
			yield {
				type: "chat-model-reply",
				data: {
					text: g ? l : c,
					requestId: g ? r.requestId : i,
					workspaceFileChunks: g ? u : f,
				},
			}
	}
	async processStreams(r, n, i, s, o, a, l) {
		let c = "",
			u = "",
			f = "",
			p = "",
			g = [],
			m = [],
			y = await eC.launchStandalonePreferencePanel(
				this._extensionUri,
				{ a: new $x(i.data.text, ""), b: new $x(i.data.text, "") },
				this._config.config.preferenceCollection.enableRetrievalDataCollection,
				this._fuzzyFsSearcher,
				a,
				l,
			),
			C = r[Symbol.asyncIterator](),
			v = n[Symbol.asyncIterator](),
			b = await C.next(),
			w = await v.next()
		for (; !b.done || !w.done; ) {
			!b.done &&
				(!c.includes(`
`) ||
					w.done) &&
				((c += b.value.data.text), (g = g.concat(b.value.data.workspaceFileChunks)), (b = await C.next())),
				!w.done &&
					(!u.includes(`
`) ||
						b.done) &&
					((u += w.value.data.text), (m = m.concat(w.value.data.workspaceFileChunks)), (w = await v.next()))
			let B, M
			for (
				;
				((c.includes(`
`) &&
					u.includes(`
`)) ||
					b.done ||
					w.done) &&
				(([B, c] =
					b.done &&
					!c.includes(`
`)
						? [c, ""]
						: this.getNextLine(c)),
				([M, u] =
					w.done &&
					!u.includes(`
`)
						? [u, ""]
						: this.getNextLine(u)),
				(f += B),
				(p += M),
				this.postStreamChunksToPanel(y, f, s, "A"),
				this.postStreamChunksToPanel(y, p, o, "B"),
				!(c.length === 0 || u.length === 0));

			);
		}
		return (
			c && ((f += c), this.postStreamChunksToPanel(y, f, s, "A")),
			u && ((p += u), this.postStreamChunksToPanel(y, p, o, "B")),
			{
				responseA: f,
				responseB: p,
				workspaceFileChunksA: g,
				workspaceFileChunksB: m,
				preferencePanel: y,
			}
		)
	}
	onExternalSourceSearch = async (r) => {
		if (!Gr(this._featureFlagManager.currentFlags.vscodeExternalSourcesInChatMinVersion))
			return { type: "find-external-sources-response", data: { sources: [] } }
		let n = await this._apiServer.searchExternalSources(r.data.query, [])
		return { type: "find-external-sources-response", data: n }
	}
	getActiveWorkspacePath = () => {
		let r = Lt.window.activeTextEditor
		if (!r) return
		let n = r.document.uri.fsPath
		return this._workspaceManager.safeResolvePathName(n)?.rootPath
	}
	_resolvePathName(r) {
		let n = this._workspaceManager.safeResolvePathName(r)
		if (n !== void 0) return { repoRoot: n.rootPath, pathName: n.relPath }
	}
	_getDefaultTargetPath = () => {
		let r = Lt.window.activeTextEditor
		if (!r) return
		let n = r.document.uri.fsPath,
			i = this._workspaceManager.safeResolvePathName(n)
		return i ? Ph(i) : void 0
	}
	resolveTargetPath = async (r, n = void 0, i = !0) => {
		if (!r) return
		let s
		if (Qh(r)) s = this._workspaceManager.safeResolvePathName(r)
		else {
			let a = this._workspaceManager.findBestWorkspaceRootMatch(r)
			a && (s = { rootPath: a.qualifiedPathName.rootPath, relPath: r })
		}
		if (s) {
			let a = await this._fuzzyFsSearcher.statPath(s)
			if (a) {
				let l = Ph(s)
				return (l.fileType = a.type), l
			}
		}
		let o = this._fuzzyFsSearcher.findFiles({
			type: "find-file-request",
			data: {
				rootPath: "",
				relPath: r,
				exactMatch: i,
				maxResults: 10,
				searchScope: n,
			},
		})
		if (o.data.length >= 0) return o.data[0]
	}
	async *_smartPasteWithChatInstruction(r, n) {
		let { message: i, targetFilePath: s, targetFileContent: o } = r,
			a = r.selectedCodeDetails
		n = n ?? this._apiServer.createRequestId()
		let l = this._workspaceManager.getContext().blobs,
			c = i.data.chatHistory.map((f) => ({
				request_message: f.request_message,
				response_text: f.response_text,
				request_id: f.request_id,
			})),
			u = this._chatModel.getReferenceReqId()
		for (let f = c.length - 1; f >= 0; f--) {
			let p = c[f],
				g = this._chatModel.selectionCache.get(p.request_id)
			if (g) {
				;(a = g), (u = p.request_id)
				break
			}
		}
		try {
			let f = await this._apiServer.smartPasteStream(
				n,
				"",
				l,
				c,
				a?.selectedCode,
				a?.prefix,
				a?.suffix,
				a?.path,
				void 0,
				a?.prefixBegin,
				a?.suffixEnd,
				a?.language,
				i.data.generatedCode,
				s,
				o,
				u,
			)
			for await (let p of f) yield p
		} catch (f) {
			throw (this._logger.error(`Error in _smartPasteWithChatInstruction: ${Ye(f)}`), f)
		}
	}
	onClearMetadataFor = (r) => {
		let n = r.data,
			i = this._chatModel
		n.requestIds?.forEach((s) => {
			i.deleteChatStream(s), i.selectionCache.remove(s)
		}),
			n.conversationIds?.forEach((s) => {
				this._checkpointManager.clearConversationCheckpoints(s)
			})
	}
	async onExecuteCommand(r) {
		let { iterationId: n, command: i, args: s } = r.data,
			o = (0, Nbe.spawn)(i, s, {
				stdio: ["ignore", "pipe", "pipe"],
				shell: !0,
				cwd: this.getActiveWorkspacePath(),
			}),
			a = "",
			l = -1
		return (
			await new Promise((c, u) => {
				o.stdout?.on("data", (f) => {
					;(a += f.toString()),
						sA.currentPanel?.handleCommandPartialOutput({
							type: "autofix-panel-execute-command-partial-output",
							data: { iterationId: n, output: a },
						})
				}),
					o.stderr?.on("data", (f) => {
						;(a += f.toString()),
							sA.currentPanel?.handleCommandPartialOutput({
								type: "autofix-panel-execute-command-partial-output",
								data: { iterationId: n, output: a },
							})
					}),
					o.on("close", (f) => {
						;(l = f ?? -1), c()
					}),
					o.on("error", u)
			}),
			{
				type: "chat-autofix-execute-command-result",
				data: { output: a, returnCode: l },
			}
		)
	}
	async _getVCSChange() {
		return this._workspaceManager !== void 0
			? await this._workspaceManager.getVCSChange()
			: { commits: [], workingDirectory: [] }
	}
	async onAutofixPlan(r) {
		let i = this._workspaceManager.getContext().blobs,
			s = await this._getVCSChange(),
			o = null
		try {
			o = await this._apiServer.autofixPlan(r.data.command, s, i, r.data.steeringHistory)
		} catch {
			return {
				type: "chat-autofix-plan-response",
				data: {
					plan: {
						summary: "Error",
						replacements: [],
						originalReplacements: [],
					},
				},
			}
		}
		let a = o.replacements,
			l = await Promise.all(a.map(async (c) => await uCe(this._workspaceManager, c)))
		return {
			type: "chat-autofix-plan-response",
			data: {
				plan: { summary: o.summary, replacements: l, originalReplacements: a },
			},
		}
	}
	onDidReceiveMessage = async (r) => {
		switch (r.type) {
			case "chat-create-file": {
				let n = r.data.relPath
				if (n) {
					let i = this._workspaceManager.findBestWorkspaceRootMatch(n)
					if (!i || i.fileType !== "Directory") {
						Lt.window.showWarningMessage(`Directory ${_c(n)} not found.`)
						break
					}
					let s = Bs({ rootPath: i.qualifiedPathName.rootPath, relPath: n }),
						o = Lt.Uri.file(s)
					try {
						await Lt.workspace.fs.stat(o),
							Lt.window.showErrorMessage(`Cannot create file at ${o.fsPath}. File already exists.`)
						break
					} catch {}
					try {
						await Lt.workspace.fs.writeFile(o, Buffer.from(r.data.code))
						let a = await Lt.workspace.openTextDocument(o)
						if (!a) {
							this._logger.error(`Could not open document at ${o.fsPath} during file creation.`)
							break
						}
						await Lt.window.showTextDocument(a)
					} catch (a) {
						this._logger.error(`Could not create file at ${o.fsPath}: ${a}`)
					}
				} else {
					try {
						let i = await Lt.workspace.openTextDocument({
								content: r.data.code,
							}),
							s = i.uri
						await Lt.workspace.fs.writeFile(s, Buffer.from(r.data.code)),
							await Lt.window.showTextDocument(i)
					} catch (i) {
						this._logger.error(`Could not create untitled file: ${i}`)
					}
					break
				}
				break
			}
			case "chat-smart-paste": {
				let n = Lt.window.activeTextEditor,
					i = null
				n && (i = EW(n, this._workspaceManager, cF, cF))
				let s,
					o = (await this.resolveTargetPath(r.data.targetFile)) ?? this._getDefaultTargetPath()
				if (!r.data.options?.dryRun)
					if (o) {
						if (
							r.data.options?.requireFileConfirmation &&
							!(
								await this.onOpenConfirmationModal({
									type: "open-confirmation-modal",
									data: {
										title: "Apply Codeblock",
										message: `Are you sure you want to apply the codeblock to ${o.pathName}?`,
										confirmButtonText: "Apply",
										cancelButtonText: "Cancel",
									},
								})
							).data.ok
						)
							return
					} else {
						Lt.window.showWarningMessage("Cannot apply codeblock. No valid target file found."),
							this._clientMetricsReporter.reportWebviewClientMetric({
								webviewName: "chat",
								client_metric: "chat-failed-smart-paste-resolve-file",
								value: 1,
							})
						return
					}
				if (!o) return
				s = Bs({ rootPath: o.repoRoot, relPath: o.pathName })
				let a = (await ho(s)).getText(),
					l = Je.from({ rootPath: o.repoRoot, relPath: o.pathName }),
					c
				!r.data.options?.dryRun &&
					!r.data.options?.instantApply &&
					this._createOrShowDiffView({
						smartPasteContext: { applyTime: c },
						document: new Qu(l, a, r.data.generatedCode),
					})
				let u, f
				if (this._config.config.chat.smartPasteUsePrecomputation ?? !0) {
					let p = await this._smartPasteCache.get(r.data.generatedCode, s, a, {
						message: r,
						selectedCodeDetails: i,
						targetFilePath: s,
						targetFileContent: a,
					})
					if (!p) {
						this._logger.error("Could not get valid edit stream for smart paste.")
						return
					}
					;(u = p.generator),
						(f = p.requestId),
						this._clientMetricsReporter.reportWebviewClientMetric({
							webviewName: "chat",
							client_metric: "chat-precompute-smart-paste",
							value: 1,
						})
				} else {
					if (r.data.options?.dryRun) return
					{
						let p = await this._smartPasteCache.getDirect({
							message: r,
							selectedCodeDetails: i,
							targetFilePath: s,
							targetFileContent: a,
						})
						if (!p) {
							this._logger.error("Could not get valid edit stream for smart paste.")
							return
						}
						;(u = p.generator),
							(f = p.requestId),
							this._clientMetricsReporter.reportWebviewClientMetric({
								webviewName: "chat",
								client_metric: "chat-smart-paste",
								value: 1,
							})
					}
				}
				if (!u) {
					this._logger.error("Could not get valid edit stream for smart paste.")
					return
				}
				r.data.options?.dryRun ||
					(r.data.options?.instantApply
						? await Bn.instantApply(
								{
									extensionUri: this._extensionUri,
									workspaceManager: this._workspaceManager,
									apiServer: this._apiServer,
									keybindingWatcher: this._keybindingWatcher,
									fuzzyFsSearcher: this._fuzzyFsSearcher,
									fuzzySymbolSearcher: this._fuzzySymbolSearcher,
								},
								{ document: new Qu(l, a, r.data.generatedCode) },
								u,
							)
						: Bn.startStream(XM(a, u), f, "smart-paste"))
				break
			}
			case "open-file": {
				let n = await this.resolveTargetPath(r.data.pathName, void 0, !1)
				if (!n && r.data.allowOutOfWorkspace) {
					iA(r.data)
					return
				} else if (!n) return
				let i = n.repoRoot,
					s = n.pathName
				iA({
					repoRoot: i,
					pathName: s,
					range: r.data.range,
					fullRange: r.data.fullRange,
					differentTab: r.data.differentTab,
					snippet: r.data.snippet,
				})
				break
			}
			case "main-panel-perform-action": {
				this.performAction(r.data)
				break
			}
			case "used-slash-action": {
				this._onboardingSessionEventReporter.reportEvent("used-slash-action")
				break
			}
			case "used-chat": {
				this._onboardingSessionEventReporter.reportEvent("used-chat")
				break
			}
			case "chat-clear-metadata": {
				this.onClearMetadataFor(r)
				break
			}
			case "open-guidelines": {
				this._openGuidelines(r.data)
				break
			}
			case "update-user-guidelines": {
				this._updateUserGuidelines(r.data)
				break
			}
			case "augment-link": {
				try {
					let n = r.data
					if (n) {
						let i = Lt.Uri.parse(n)
						Lt.env.openExternal(i)
					}
				} catch (n) {
					this._logger.error(`Failed to open URL: ${Ye(n)}`)
				}
				break
			}
			case "trigger-initial-orientation": {
				if (!this._featureFlagManager.currentFlags.memoriesParams?.enable_initial_orientation) return
				await Ek(
					this._apiServer,
					this._workspaceManager,
					this._featureFlagManager,
					this._checkpointManager,
					this._agentSessionEventReporter,
					Ey.onboarding,
				)
				break
			}
		}
	}
	_openGuidelines = (r) => {
		if (r) {
			let n = Lbe.default.join(r, ".augment-guidelines"),
				i = Lt.Uri.file(n)
			Lt.commands.executeCommand("vscode.open", i)
			return
		} else {
			Lt.commands.executeCommand("workbench.action.openSettings", "augment.userGuidelines")
			return
		}
	}
	_updateUserGuidelines = (r) => {
		Lt.workspace.getConfiguration("augment.chat").update("userGuidelines", r, Lt.ConfigurationTarget.Global)
	}
	_getBlobNames(r) {
		let n = new Array()
		for (let i of r) {
			let s = this._workspaceManager.getBlobName(Je.from(i))
			s !== void 0 && n.push(s)
		}
		return n
	}
	performAction(r) {
		switch (r) {
			case "disable-github-copilot": {
				Xp.disableGitHubCopilot()
				break
			}
			case "disable-codeium": {
				Xp.disableCodeium()
				break
			}
			case "move-extension-aside": {
				this._actionsModel.setSystemStateStatus("hasMovedExtensionAside", "complete")
				break
			}
			case "open-folder": {
				Lt.commands.executeCommand("vscode.openFolder")
				break
			}
			case "grant-sync-permission": {
				this._syncingEnabledTracker.enableSyncing()
				break
			}
		}
	}
	handleDerivedStateChange(r) {
		this.sendActionsToWebview(r.map((n) => n.name))
	}
	async sendActionsToWebview(r) {
		await this._webview?.postMessage({ type: "main-panel-actions", data: r })
	}
	async sendAutofixUpdateRequestMessage() {
		await this._webview?.postMessage({
			type: "chat-autofix-state-update-request",
		})
	}
	async sendAutofixSuggestionsAppliedMessage(r) {
		await this._webview?.postMessage({
			type: "chat-autofix-suggestions-applied",
			data: { selectedSolutions: r },
		})
	}
	onChatExtensionMessage = async (r) => {
		switch (r) {
			case "runSlashFix": {
				await this._webview?.postMessage({
					type: "run-slash-command",
					data: "fix",
				})
				break
			}
			case "runSlashExplain": {
				await this._webview?.postMessage({
					type: "run-slash-command",
					data: "explain",
				})
				break
			}
			case "newThread": {
				await this._webview?.postMessage({ type: "new-thread" })
				break
			}
			case "runSlashTest": {
				await this._webview?.postMessage({
					type: "run-slash-command",
					data: "write-test",
				})
				break
			}
			case "runSlashDocument": {
				await this._webview?.postMessage({
					type: "run-slash-command",
					data: "document",
				})
				break
			}
			case "reset-agent-onboarding": {
				await this._webview?.postMessage({ type: "reset-agent-onboarding" })
				break
			}
		}
	}
	showAugmentPanel = async () => (await Lt.commands.executeCommand(Hi.commandID), { type: "empty" })
	callTool = async (r) => {
		let n = r.data,
			i = await this._chatModel.hydrateChatHistory(n.chatHistory),
			s = this._chatModel.limitChatHistory(i),
			o = await this._toolsModel.callTool(n.chatRequestId, n.toolUseId, n.name, n.input, s, n.conversationId)
		return { type: "call-tool-response", data: o }
	}
	cancelToolRun = async (r) => (
		await this._toolsModel.cancelToolRun(r.data.requestId, r.data.toolUseId), { type: "cancel-tool-run-response" }
	)
	toolCheckSafe = async (r) => {
		let n = r.data,
			i = await this._toolsModel.checkToolCallSafe(n.name, n.input)
		return { type: "check-safe-response", data: { isSafe: i } }
	}
	checkToolExists = async (r) => {
		let n = await this._toolsModel.checkToolExists(r.toolName)
		return { type: "checkToolExistsResponse", exists: n }
	}
	_getAgentEditContentsByRequestId = async (r) => {
		let n = await this._checkpointManager.getCheckpointByRequestId(r.data.requestId),
			i = n?.files.at(0)
		return n === void 0 || i === void 0 || n.files.length !== 1
			? Promise.resolve({
					type: "getAgentEditContentsByRequestId",
					data: void 0,
				})
			: Promise.resolve({
					type: "getAgentEditContentsByRequestId",
					data: {
						originalCode: i.changeDocument.originalCode,
						modifiedCode: i.changeDocument.modifiedCode,
					},
				})
	}
	_getChatRequestIdeState = async (r) => {
		let n = this._toolsModel.getTool("launch-process"),
			i
		n && n.name === Ny.name && (i = n.processTools.getLongRunningTerminalInfo())
		let s = Lt.window.activeTextEditor
				? this._workspaceManager.getFolderRoot(Lt.window.activeTextEditor?.document.uri)
				: void 0,
			o = this._workspaceManager.getMostRecentlyChangedFolderRoot(),
			a = this._workspaceManager
				.listSourceFolders()
				.filter((l) => l.type === 0 || l.type === 2)
				.sort((l) => (l.folderRoot === s ? -1 : l.folderRoot === o ? 0 : 1))
				.map((l) => ({
					folder_root: l.folderRoot,
					repository_root: l.type === 2 ? l.containingFolderRoot : l.folderRoot,
				}))
		return Promise.resolve({
			type: "get-ide-state-node-response",
			data: {
				workspace_folders: a,
				workspace_folders_unchanged: !1,
				current_terminal: i,
			},
		})
	}
	_showAgentReview = async (r) => {
		let n = Je.from(r.data.qualifiedPathName),
			s = (
				await this._checkpointManager.getAggregateCheckpointForFile(n, {
					minTimestamp: r.data.fromTimestamp,
					maxTimestamp: r.data.toTimestamp,
				})
			).files.at(0)?.changeDocument
		if (!s) return Promise.resolve({ type: "empty" })
		let o = r.data.toTimestamp ?? Number.MAX_SAFE_INTEGER >= Number.MAX_SAFE_INTEGER,
			a = Bn.isVisible ?? !1
		if (r.data.retainFocus && !a) return Promise.resolve({ type: "empty" })
		let l = new z()
		l.addDisposable(s)
		let c = {
			editable: !1,
			disableResolution: !0,
			document: s,
			viewOptions: { preserveFocus: !0, viewColumn: Lt.ViewColumn.Active },
			onDispose: () => l.dispose(),
		}
		return (
			o &&
				l.addDisposable(
					s.onModifiedUpdated(() => {
						this._checkpointManager
							.updateLatestCheckpoint(n, s.modifiedCode, {
								saveToWorkspace: !0,
							})
							.then(() => {
								this._notifyAgentEditListHasUpdates()
							})
					}),
				),
			l.addDisposable(s.onModifiedUpdated(() => this._notifyAgentEditListHasUpdates())),
			l.addDisposable(s.onOriginalUpdated(() => this._notifyAgentEditListHasUpdates())),
			this._createOrShowDiffView(c),
			Promise.resolve({ type: "empty" })
		)
	}
	_createOrShowDiffView = (r) => {
		Bn.createOrShow(
			{
				extensionUri: this._extensionUri,
				workspaceManager: this._workspaceManager,
				apiServer: this._apiServer,
				keybindingWatcher: this._keybindingWatcher,
				fuzzyFsSearcher: this._fuzzyFsSearcher,
				fuzzySymbolSearcher: this._fuzzySymbolSearcher,
			},
			r,
		)
	}
	_notifyAgentEditListHasUpdates = (0, Wh.default)(
		() => {
			this._webview?.postMessage({
				type: "chat-agent-edit-list-has-updates",
				data: {},
			})
		},
		1e3,
		{ leading: !0, trailing: !0 },
	)
	_saveImage = async (r) => {
		let { filename: n, data: i } = r.data
		return await this._assetManager.saveAsset(n, i), { type: "chat-save-image-response", data: n }
	}
	_deleteImage = async (r) => {
		let n = r.data
		return await this._assetManager.deleteAsset(n), { type: "chat-delete-image-response" }
	}
	_loadImage = async (r) => {
		let n = r.data,
			i = await this._assetManager.loadAsset(n)
		return { type: "chat-load-image-response", data: i }
	}
}
var BG = W(require("vscode")),
	Obe = require("vscode")
var Ube = require("vscode")
var rC = class extends lt {
	constructor(r, n) {
		super()
		this._featureFlagManager = r
		this._changeWebviewAppEvent = n
	}
	type = "public"
	static commandID = "_vscode-augment.showSidebarChat"
	run() {
		this._changeWebviewAppEvent.fire("chat"), Ube.commands.executeCommand(Hi.commandID)
	}
}
async function nf(e) {
	try {
		await BG.commands.executeCommand(Hi.commandID), await BG.commands.executeCommand(rC.commandID)
	} catch (t) {
		t instanceof Error &&
			Obe.window.showErrorMessage(`Sorry, Augment ${e} encountered an unexpected error: ${Ye(t)}`)
	}
}
var nC = class extends Jo {
		constructor(r, n, i, s, o, a) {
			super(s, o, a)
			this._extension = r
			this._configListener = n
			this._chatExtensionEvent = i
			;(this._extension = r), (this._configListener = n), (this._chatExtensionEvent = i)
		}
		type = "public"
		canRun() {
			return this._extension.ready
		}
		updateSelectionToCoverDiagnostics(r) {
			let n = $h.window.activeTextEditor
			if (n) {
				let i
				if (r && !r.every((s) => n.selection.contains(s.range))) {
					let s = Math.min(...r.map((c) => c.range.start.line)),
						o = Math.max(...r.map((c) => c.range.end.line)),
						a = new $h.Position(s, 0),
						l = n.document.lineAt(o).range.end
					i = new $h.Range(a, l)
				} else n.selection.isEmpty && (i = n.document.lineAt(n.selection.active.line).range)
				i && (n.selection = new $h.Selection(i.start, i.end))
			}
		}
	},
	Gh = class extends nC {
		static commandID = "vscode-augment.chat.slash.fix"
		constructor(t, r, n, i) {
			super(t, r, n, i, "Fix using Augment", !1)
		}
		async run(t, r) {
			await nf("Quick Fix"),
				r && this.updateSelectionToCoverDiagnostics(r),
				this._chatExtensionEvent.fire("runSlashFix")
		}
	},
	iC = class extends nC {
		static commandID = "vscode-augment.chat.slash.explain"
		constructor(t, r, n, i) {
			super(t, r, n, i, "Explain using Augment", !1)
		}
		async run() {
			await nf("Explain"), this._chatExtensionEvent.fire("runSlashExplain")
		}
	},
	sC = class extends nC {
		static commandID = "vscode-augment.chat.slash.test"
		constructor(t, r, n, i) {
			super(t, r, n, i, "Write test using Augment", !1)
		}
		async run() {
			await nf("Write a Test"), this._chatExtensionEvent.fire("runSlashTest")
		}
	},
	oC = class extends nC {
		static commandID = "vscode-augment.chat.slash.document"
		constructor(t, r, n, i) {
			super(t, r, n, i, "Document", !0)
		}
		async run() {
			await nf("Document"), this._chatExtensionEvent.fire("runSlashDocument")
		}
	}
var dF = class {
	provideCodeActions(t, r, n, i) {
		let s = n.diagnostics
		if (s.length === 0) return Promise.resolve(void 0)
		let o = new fF.CodeAction("Fix using Augment", fF.CodeActionKind.QuickFix)
		return (
			(o.command = {
				command: Gh.commandID,
				title: "Fix using Augment",
				arguments: [t.uri, s],
			}),
			Promise.resolve([o])
		)
	}
	resolveCodeAction(t, r) {
		return t
	}
}
var DG = W(require("vscode"))
var hF = class extends lt {
		constructor(r, n) {
			super("Reset Agent Onboarding", !0)
			this._chatExtensionEvent = r
			this._globalState = n
		}
		static commandID = "augment.resetAgentOnboarding"
		type = "debug"
		async run() {
			await nf("Reset Agent Onboarding"),
				this._chatExtensionEvent.fire("reset-agent-onboarding"),
				await this._globalState.update("memoriesFileOpenCount", 0)
		}
	},
	aC = class extends Jo {
		constructor(r, n, i) {
			super(i, "Run Agent Initial Orientation", !0)
			this._extension = r
			this._apiServer = n
		}
		static commandID = "vscode-augment.runAgentInitialOrientation"
		type = "debug"
		async run() {
			if (!this._extension.workspaceManager) {
				DG.window.showErrorMessage("Workspace manager is not ready")
				return
			}
			if (!this._extension.agentCheckpointManager) {
				DG.window.showErrorMessage("Agent checkpoint manager is not ready")
				return
			}
			await Ek(
				this._apiServer,
				this._extension.workspaceManager,
				this._extension.featureFlagManager,
				this._extension.agentCheckpointManager,
				this._extension.agentSessionEventReporter,
				Ey.command,
			)
		}
		canRun() {
			return super.canRun() && this._extension.ready
		}
	}
var aA = class e extends lt {
	constructor(r, n, i, s) {
		super(s)
		this._auth = r
		this._oauthFlow = n
		this._commandID = i
	}
	static signInCommandID = "vscode-augment.signIn"
	static signOutCommandID = "vscode-augment.signOut"
	type = "public"
	async run() {
		this.commandID === e.signInCommandID ? await this._oauthFlow.startFlow() : await this._auth.removeSession()
	}
	canRun() {
		return this._auth.useOAuth
			? this.commandID === e.signOutCommandID
				? this._auth.isLoggedIn === !0
				: !this._auth.isLoggedIn
			: !1
	}
}
var Vbe = require("child_process"),
	lC = W(require("fs")),
	lA = require("path"),
	gr = W(require("vscode"))
var TG = class {
		documents = new Map()
		setDocumentContent(t, r) {
			this.documents.set(t.toString(), r)
		}
		provideTextDocumentContent(t) {
			return this.documents.get(t.toString())
		}
	},
	gF = class e extends lt {
		constructor(r, n) {
			super()
			this._extension = r
			this._apiServer = n
			this._outputChannel = gr.window.createOutputChannel("Autofix Command Output")
		}
		static commandID = "vscode-augment.autofixCommand"
		type = "public"
		static testCommandHistory = []
		_outputChannel
		_chunkCount = 32
		_autofixLogger = X("AutofixCommand")
		async _locationToChunkContents(r, n) {
			let i = (0, lA.join)(n, r.path),
				o = (await lC.promises.readFile(i, { encoding: "utf8" })).split(`
`),
				a = 0,
				l = Math.max(r.range.start - a, 0),
				c = Math.min(r.range.stop + a, o.length)
			return {
				path: r.path,
				content: o.slice(l, c).join(`
`),
				start_line: l,
				end_line: c,
			}
		}
		_clearAndShowOutput(r) {
			this._outputChannel.clear(), this._outputChannel.appendLine(r), this._outputChannel.show()
		}
		async _openDiffForChanges(r, n) {
			let i = r.map(async (s) => {
				let o = "virtual",
					a = new TG(),
					l = gr.workspace.registerTextDocumentContentProvider(o, a),
					c = gr.Uri.parse(`${o}:/${s.path}.right`)
				a.setDocumentContent(c, s.targetContent),
					await gr.commands.executeCommand(
						"vscode.diff",
						gr.Uri.file((0, lA.join)(n, s.path)),
						c,
						`Diff - ${s.path}`,
					),
					await new Promise((u) => {
						let f = gr.workspace.onDidCloseTextDocument((p) => {
							p.uri.toString() === c.toString() && (f.dispose(), l.dispose(), u())
						})
					})
			})
			await Promise.all(i)
		}
		async _getTestCommand() {
			let r = gr.window.createQuickPick()
			;(r.placeholder = "Enter the test command to run (e.g. `pytest`)"), (r.ignoreFocusOut = !0)
			let n = () => {
				let s = r.value ? [{ label: r.value, description: "New command" }] : [],
					o = e.testCommandHistory
						.filter((a) => a.toLowerCase() !== r.value.toLowerCase())
						.map((a) => ({ label: a, description: "Previous command" }))
				r.items = [...s, ...o]
			}
			r.onDidChangeValue(n), n(), r.show()
			let i = await new Promise((s) => {
				r.onDidAccept(() => {
					let o = r.selectedItems[0]?.label || r.value
					s(o || void 0), r.hide()
				}),
					r.onDidHide(() => s(void 0))
			})
			return (
				r.dispose(),
				i && (e.testCommandHistory = [i, ...e.testCommandHistory.filter((s) => s !== i)].slice(0, 10)),
				i
			)
		}
		_runCommand(r, n, i = !1) {
			return (
				i && this._clearAndShowOutput("Running command: " + r),
				new Promise((s) => {
					let o = r.split(" "),
						a = o[0],
						l = o.slice(1),
						c = (0, Vbe.spawn)(a, l, {
							cwd: n,
							stdio: ["ignore", "pipe", "pipe"],
							shell: !0,
						}),
						u = ""
					c.stdout.on("data", (f) => {
						;(u += f.toString()), i && this._outputChannel.append(f.toString())
					}),
						c.stderr.on("data", (f) => {
							;(u += f.toString()), i && this._outputChannel.append(f.toString())
						}),
						c.on("close", (f) => {
							s({ output: u, success: f === 0 })
						}),
						c.on("error", (f) => {
							s({ output: f.message, success: !1 })
						})
				})
			)
		}
		async _askYesNo(r, n = "") {
			let i = { modal: !0, detail: n },
				s = [{ title: "Yes" }, { title: "No", isCloseAffordance: !0 }]
			return (await gr.window.showInformationMessage(r, i, ...s)) === s[0]
		}
		async _getEditLocations(r, n, i, s, o, a) {
			let l = await this._apiServer.nextEditLocation(a, r, "", n, [], i, [], [], o, !1)
			if (l.checkpointNotFound) throw new Error("Checkpoint not found")
			if (l.candidateLocations.length === 0) throw new Error("No candidate locations found")
			return Promise.all(l.candidateLocations.map(async (c) => this._locationToChunkContents(c.item, s)))
		}
		async _diffToChunks(r) {
			return Promise.all(
				r.map((n) => {
					let i = n.afterContent.split(`
`)
					return {
						path: n.afterPath,
						content: n.afterContent,
						start_line: 0,
						end_line: i.length - 1,
					}
				}),
			)
		}
		async _applyChanges(r, n, i) {
			if (n && (await this._askYesNo("Would you like to apply and test the changes?"))) {
				for (let o of r) {
					let { path: a, targetContent: l } = o
					await lC.promises.writeFile((0, lA.join)(i, a), l)
				}
				if ((await this._runCommand(n, i, !0)).success)
					gr.window.showInformationMessage("The tests has passed.")
				else {
					let o = "Command failed. Keep changes anyway?"
					if (!(await this._askYesNo(o, "return code != 0")))
						for (let a of r) {
							let { path: l, sourceContent: c } = a
							await lC.promises.writeFile((0, lA.join)(i, l), c)
						}
				}
			}
		}
		_checkOutputReturn(r) {
			return r.success && r.output.length > 0
		}
		async _getGitDiffObject(r, n) {
			let i = `git diff ${r} --name-status -M`,
				o = (await this._runGitCommand(i, n)).split(`
`),
				a = []
			for (let l of o) {
				let [c, ...u] = l.split("	"),
					f = u[0],
					p = u[u.length - 1],
					g
				switch (c[0]) {
					case "M":
						if (((g = "MODIFIED"), f !== p)) throw new Error("Unexpected change type: modified with rename")
						break
					case "A":
						;(g = "ADDED"), (f = "")
						break
					case "D":
						;(g = "DELETED"), (p = "")
						break
					case "R":
						if (((g = "RENAMED"), f === p)) throw new Error("Unexpected change type: rename with no change")
						break
					default:
						continue
				}
				let m = "",
					y = ""
				if (g !== "ADDED") {
					let C = `git show ${r}:${f}`,
						v = await this._runCommand(C, n)
					if (!v.success) throw new Error("Failed to execute git command")
					m = v.output
				}
				if (g !== "DELETED") {
					let C = (0, lA.join)(n, p)
					y = await lC.promises.readFile(C, { encoding: "utf8" })
				}
				a.push({
					beforePath: f,
					afterPath: p,
					changeType: g,
					beforeContent: m,
					afterContent: y,
				})
			}
			return a
		}
		_diffToVCSChange(r) {
			let n = new Hf(1e3)
			return {
				commits: [],
				workingDirectory: r.map((i) => {
					let s = n.calculateNoThrow(i.afterPath, i.afterContent) || "",
						o = n.calculateNoThrow(i.afterPath, i.afterContent) || ""
					return {
						beforePath: i.beforePath,
						afterPath: i.afterPath,
						changeType: i.changeType,
						headBlobName: s,
						indexedBlobName: o,
						currentBlobName: o,
					}
				}),
			}
		}
		async _uploadBlobs(r, n) {
			let i = []
			r.workingDirectory.forEach((s, o) => {
				s.currentBlobName &&
					i.push({
						pathName: s.afterPath || "",
						text: n[o].afterContent,
						blobName: s.currentBlobName,
						metadata: [],
					}),
					s.headBlobName &&
						i.push({
							pathName: s.beforePath || "",
							text: n[o].beforeContent,
							blobName: s.headBlobName,
							metadata: [],
						})
			})
			try {
				await Promise.all(i.map((s) => this._apiServer.batchUpload([s])))
			} catch {}
		}
		async _runGitCommand(r, n) {
			let i = await this._runCommand(r, n)
			if (!this._checkOutputReturn(i))
				throw new Error(`Failed to execute git command: ${r}
Output: ${i.output}`)
			return i.output.trimEnd()
		}
		async run() {
			if (!this._extension.workspaceManager) throw new Error("Workspace manager is not ready")
			let r = this._extension.workspaceManager.getContext()
			if (!gr.workspace.workspaceFolders || gr.workspace.workspaceFolders.length === 0) {
				gr.window.showErrorMessage("No workspace folders")
				return
			}
			let n = gr.workspace.workspaceFolders[0].uri.fsPath,
				i = await this._runGitCommand("git rev-parse --show-toplevel", n),
				s = await this._runGitCommand("git rev-parse --abbrev-ref origin/HEAD", i),
				o = await this._runGitCommand("git rev-parse --abbrev-ref HEAD", i),
				a = (N) => N.slice(N.lastIndexOf("/") + 1),
				l = "HEAD"
			a(o) !== a(s) && (l = await this._runGitCommand(`git merge-base HEAD ${s}`, i))
			let c = `git diff -U10 ${l}`,
				u = await this._runCommand(c, i)
			if (!this._checkOutputReturn(u)) {
				gr.window.showErrorMessage(`Failed to get git diff: ${u.output}`)
				return
			}
			let f
			try {
				f = await this._getGitDiffObject(l, i)
			} catch (N) {
				gr.window.showErrorMessage(`Failed to parse git diff: ${N instanceof Error ? N.message : String(N)}`)
				return
			}
			let p = this._diffToVCSChange(f)
			try {
				await this._uploadBlobs(p, f)
			} catch (N) {
				gr.window.showErrorMessage(`Failed to upload blobs: ${N instanceof Error ? N.message : String(N)}`)
				return
			}
			let g = await this._getTestCommand()
			if (!g) {
				gr.window.showInformationMessage("No test command provided.")
				return
			}
			let m = await this._runCommand(g, i, !0),
				y = "The tests has passed, would you like to continue anyway?"
			if (m.success && !(await this._askYesNo(y, "return code: 0"))) return
			if (m.output.length === 0) {
				gr.window.showInformationMessage("No command output found.")
				return
			}
			let C = this._apiServer.createRequestId()
			this._autofixLogger.info(`Requesting edit locations with requestId=${C}`)
			let v = this._getEditLocations(m.output, p, r.blobs, i, this._chunkCount, C)
			;(C = this._apiServer.createRequestId()),
				this._autofixLogger.info(`Requesting check command with requestId=${C}`)
			let b = this._apiServer.checkCommand(g, m.output, C)
			;(C = this._apiServer.createRequestId()),
				this._autofixLogger.info(`Requesting contain errors with requestId=${C}`)
			let w = this._apiServer.containErrors(g, m.output, C)
			try {
				let N = await b,
					re = "Command doesn't appear code-related. Continue anyway?"
				if (N.result) gr.window.showInformationMessage("\u2705 Command check passed.")
				else if (!(await this._askYesNo(re, N.desc))) return
			} catch (N) {
				gr.window.showErrorMessage(`Failed to check command: ${N instanceof Error ? N.message : String(N)}`)
				return
			}
			try {
				let N = await w,
					re = "Couldn't find errors in the output. Continue anyway?"
				if (N.result) gr.window.showInformationMessage("\u2705 Contain errors check passed.")
				else if (!(await this._askYesNo(re, N.desc))) return
			} catch (N) {
				gr.window.showErrorMessage(`Failed to check for errors: ${N instanceof Error ? N.message : String(N)}`)
				return
			}
			let B
			try {
				B = await v
			} catch (N) {
				gr.window.showErrorMessage(
					`Failed to get edit locations: ${N instanceof Error ? N.message : String(N)}`,
				)
				return
			}
			let M = f.filter((N) => N.afterPath !== ""),
				Q = M.map((N) => N.afterPath),
				O = await this._diffToChunks(M),
				Y = B.filter((N) => !Q.includes(N.path)).concat(O)
			gr.window.showInformationMessage(`Found ${B.length} potential edit locations.`),
				gr.window.showInformationMessage("Creating fix plan...")
			let j
			try {
				;(C = this._apiServer.createRequestId()),
					this._autofixLogger.info(`Requesting create fix plan with requestId=${C}`),
					(j = await this._apiServer.createFixPlan(u.output, g, m.output, Y, C))
			} catch (N) {
				gr.window.showErrorMessage(`Failed to create fix plan: ${N instanceof Error ? N.message : String(N)}`)
				return
			}
			let ne = `Changes:
${j.changes.map((N) => `- ${N.path}`).join(`
`)}`,
				q = `${j.fix_desc}

${ne}`,
				me = Promise.all(
					j.changes.map(async (N) => {
						let re = (0, lA.join)(i, N.path),
							K = await lC.promises.readFile(re, { encoding: "utf8" })
						return (
							(C = this._apiServer.createRequestId()),
							this._autofixLogger.info(`Requesting apply file fix with requestId=${C}`),
							this._apiServer.applyFileFix(N, K, C)
						)
					}),
				)
			if (!(await this._askYesNo("Do you confirm the the following fix?", q))) return
			gr.window.showInformationMessage("Generating patch...")
			let Qe
			try {
				Qe = await me
			} catch (N) {
				gr.window.showErrorMessage(`Failed to generate patch: ${N instanceof Error ? N.message : String(N)}`)
				return
			}
			if (((Qe = Qe.filter((N) => N.targetContent !== N.sourceContent)), Qe.length === 0)) {
				gr.window.showWarningMessage("Sorry, no changes to apply.")
				return
			}
			gr.window.showInformationMessage("Close all diff views to continue.")
			try {
				await this._openDiffForChanges(Qe, i)
			} catch (N) {
				N instanceof Error && gr.window.showErrorMessage(`Failed to open diff views: ${N.message}`)
				return
			}
			try {
				await this._applyChanges(Qe, g, i)
			} catch (N) {
				gr.window.showErrorMessage(`Failed to apply changes: ${N instanceof Error ? N.message : String(N)}`)
				return
			}
		}
	}
var qF = W(require("vscode"))
var ki = W(require("vscode"))
var cA = W(require("vscode"))
var f_ = ((n) => (
		(n.showDiffInHover = "showDiffInHover"),
		(n.highlightSuggestionsInTheEditor = "highlightSuggestionsInTheEditor"),
		(n.enableAutoApply = "enableAutoApply"),
		n
	))(f_ || {}),
	pF = class extends z {
		constructor(r, n, i) {
			super()
			this.configListener = r
			this.featureFlagManager = n
			this.augmentGlobalState = i
			this.addDisposable(
				this.featureFlagManager.subscribe(
					["vscodeNextEditUx2MaxVersion"],
					(s) => void this.processUxMigration(s),
				),
			)
		}
		get config() {
			return b0t(this.configListener.config, this.featureFlagManager)
		}
		async toggleSetting(r) {
			let n = cA.workspace.getConfiguration("augment"),
				i = "nextEdit." + f_[r],
				s = n.inspect(i),
				o = cA.ConfigurationTarget.Global
			return (
				s?.workspaceValue !== void 0 && (o = cA.ConfigurationTarget.Workspace),
				n.update(i, !this.configListener.config.nextEdit[r], o)
			)
		}
		async setGlobalBooleanSetting(r, n) {
			let i = cA.workspace.getConfiguration("augment"),
				s = "nextEdit." + f_[r]
			return i.update(s, n, cA.ConfigurationTarget.Global)
		}
		async processUxMigration({ newFlags: r }) {
			let n = this.augmentGlobalState.get("nextEditUxMigrationStatus")
			u4(r.vscodeNextEditUx2MaxVersion) && n?.ux3ToUx2Status !== !0
				? (await Promise.all([
						this.setGlobalBooleanSetting("showDiffInHover", !0),
						this.setGlobalBooleanSetting("enableAutoApply", !1),
					]),
					await this.augmentGlobalState.update("nextEditUxMigrationStatus", {
						...n,
						ux3ToUx2Status: !0,
					}))
				: !u4(r.vscodeNextEditUx2MaxVersion) &&
					n?.ux2ToUx3Status !== !0 &&
					n?.ux3ToUx2Status === !0 &&
					(await Promise.all([
						this.setGlobalBooleanSetting("showDiffInHover", void 0),
						this.setGlobalBooleanSetting("enableAutoApply", void 0),
					]),
					await this.augmentGlobalState.update("nextEditUxMigrationStatus", {
						...n,
						ux2ToUx3Status: !0,
					}))
		}
	}
function b0t(e, t) {
	return {
		enableAutoApply: e.nextEdit.enableAutoApply,
		showDiffInHover: e.nextEdit.showDiffInHover,
		enablePanel: e.nextEdit.enableBottomPanel ?? Gr(t.currentFlags.vscodeNextEditBottomPanelMinVersion) ?? !1,
	}
}
var Xr = class extends Jo {
		constructor(r, n, i, s, o = !0, a = !1) {
			super(i, s, o)
			this._extension = r
			this._configListener = n
			this._isFileRequired = a
		}
		type = "debug"
		static _generateHref(r, n, ...i) {
			return `command:${r}?${encodeURIComponent(JSON.stringify([n, ...i]))}`
		}
		canRun() {
			return (
				super.canRun() &&
				this._extension.ready &&
				Rl(
					this._configListener.config,
					this._extension.featureFlagManager.currentFlags.vscodeNextEditMinVersion,
				) &&
				(this._isFileRequired ? ki.window.activeTextEditor !== void 0 : !0)
			)
		}
		_getEventSource(r) {
			if (r.length === 0) return "command"
			for (let n in ws) {
				if (!isNaN(Number(n))) continue
				let i = ws[n]
				if (r[0] === i) return i
			}
			return r.length === 2 && r[0] instanceof ki.Uri && "groupId" in r[1]
				? "editor-action-click"
				: r.length === 1 && r[0] instanceof ki.Uri
					? "right-click"
					: r.length === 1 && r[0] === void 0
						? "next-edit-panel-item-click"
						: "command"
		}
	},
	AF = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.force"
		constructor(t, r, n) {
			super(t, r, n, void 0, void 0, !0)
		}
		canRun() {
			return super.canRun()
		}
		run(...t) {
			this._extension.forceNextEditSuggestion(this._getEventSource(t))
		}
	},
	mF = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.update"
		constructor(t, r, n) {
			super(t, r, n, void 0, !0, !1)
		}
		run(...t) {
			this._extension.nextEditUpdate(this._getEventSource(t))
		}
	},
	yF = class extends Xr {
		type = "private"
		static commandID = "_vscode-augment.next-edit.update.loading"
		constructor(t, r, n) {
			super(t, r, n, void 0, !1)
		}
		run() {
			this._extension.noopClicked()
		}
	},
	CF = class extends Xr {
		type = "private"
		static commandID = "_vscode-augment.next-edit.update.disabled-no-changes"
		constructor(t, r, n) {
			super(t, r, n, void 0, !1)
		}
		run() {
			this._extension.noopClicked()
		}
	},
	vF = class extends Xr {
		type = "private"
		static commandID = "_vscode-augment.next-edit.update.disabled-cached"
		constructor(t, r, n) {
			super(t, r, n, void 0, !1)
		}
		run() {
			this._extension.noopClicked()
		}
	},
	Dc = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.background.accept"
		constructor(t, r, n) {
			super(t, r, n, void 0)
		}
		static generateHref(t, r) {
			return super._generateHref(this.commandID, t, r)
		}
		run(...t) {
			this._extension.editorNextEdit?.accept(
				this._getEventSource(t),
				void 0,
				typeof t[1] == "string" ? t[1] : void 0,
			)
		}
	},
	uA = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.background.accept-all"
		constructor(t, r, n) {
			super(t, r, n, void 0, !0)
		}
		run(...t) {
			this._extension.editorNextEdit?.acceptAllSuggestions(this._getEventSource(t))
		}
	},
	sf = class extends Xr {
		type = "private"
		static commandID = "_vscode-augment.next-edit.background.accept-code-action"
		constructor(t, r, n) {
			super(t, r, n, void 0, !1)
		}
		run(t) {
			this._extension.editorNextEdit?.acceptSuggestion(t, "code-action")
		}
	},
	Tc = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.background.reject"
		constructor(t, r, n) {
			super(t, r, n, void 0)
		}
		static generateHref(t = "hover-click", r) {
			return super._generateHref(this.commandID, t, r)
		}
		run(...t) {
			this._extension.editorNextEdit?.reject(this._getEventSource(t), typeof t[1] == "string" ? t[1] : void 0)
		}
	},
	dA = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.background.reject-all"
		constructor(t, r, n) {
			super(t, r, n, void 0, !0)
		}
		run(...t) {
			this._extension.editorNextEdit?.rejectAllSuggestions(this._getEventSource(t))
		}
	},
	Uu = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.background.dismiss"
		constructor(t, r, n) {
			super(t, r, n, void 0)
		}
		run(...t) {
			this._extension.editorNextEdit?.dismissOrReject(this._getEventSource(t))
		}
	},
	Fa = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.background.goto-hinting"
		constructor(t, r, n) {
			super(t, r, n, void 0)
		}
		run(...t) {
			this._extension.editorNextEdit?.gotoHinting(this._getEventSource(t))
		}
	},
	Xo = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.background.next"
		constructor(t, r, n) {
			super(t, r, n, void 0)
		}
		run(...t) {
			this._extension.editorNextEdit?.next(this._getEventSource(t))
		}
	},
	Ou = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.background.previous"
		constructor(t, r, n) {
			super(t, r, n, void 0)
		}
		run(...t) {
			this._extension.editorNextEdit?.previous(this._getEventSource(t))
		}
	},
	EF = class extends Xr {
		type = "private"
		static commandID = "_vscode-augment.next-edit.background.open"
		constructor(t, r, n) {
			super(t, r, n, void 0, !1)
		}
		run(...t) {
			let r = t[0]
			this._extension.editorNextEdit?.openSuggestionAt(r.uri, r.lineNumber - 1)
		}
	},
	bF = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.toggle-panel-horizontal-split"
		constructor(t, r, n) {
			super(t, r, n, void 0, !1)
		}
		run(...t) {
			this._extension.nextEditTogglePanelHorizontalSplit(this._getEventSource(t))
		}
	},
	Yh = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.learn-more"
		constructor(t, r, n) {
			super(t, r, n, void 0, !0)
		}
		static generateHref(t = "hover-click", r) {
			return super._generateHref(this.commandID, t, r)
		}
		run(...t) {
			this._extension.nextEditLearnMore(this._getEventSource(t))
		}
	},
	xF = class extends Xr {
		type = "private"
		static commandID = "_vscode-augment.next-edit.background.next.disabled"
		constructor(t, r, n) {
			super(t, r, n, void 0, !1)
		}
		run() {
			this._extension.noopClicked()
		}
	},
	_F = class extends Xr {
		type = "private"
		static commandID = "_vscode-augment.next-edit.background.previous.disabled"
		constructor(t, r, n) {
			super(t, r, n, void 0, !1)
		}
		run() {
			this._extension.noopClicked()
		}
	},
	qu = class extends Xr {
		constructor(r, n, i) {
			super(r, n, i, void 0, r.nextEditConfigManager.config.enablePanel)
			this.extension = r
		}
		type = "public"
		static commandID = "vscode-augment.next-edit.open-panel"
		get showInActionPanel() {
			return this.extension.nextEditConfigManager.config.enablePanel
		}
		static generateHref(r = "hover-click", n) {
			return "command:augment-next-edit.focus"
		}
		run(...r) {
			this._extension.openNextEditPanel(this._getEventSource(r))
		}
	},
	Co = class extends Xr {
		type = "private"
		static commandID = "_vscode-augment.next-edit.undo-accept-suggestion"
		constructor(t, r, n) {
			super(t, r, n, void 0, !1)
		}
		static generateHref(t = "hover-click", r) {
			return super._generateHref(this.commandID, t, r)
		}
		run(...t) {
			this._extension.editorNextEdit?.undoAcceptSuggestion(void 0, this._getEventSource(t))
		}
	},
	cC = class extends Xr {
		type = "private"
		static commandID = "_vscode-augment.next-edit.toggle-hover-diff"
		constructor(t, r, n) {
			super(t, r, n, void 0, !1)
		}
		static generateHref(t = "hover-click", r) {
			return super._generateHref(this.commandID, t, r)
		}
		run(...t) {
			this._extension.editorNextEdit?.toggleHoverDiff(
				this._getEventSource(t),
				typeof t[1] == "string" ? t[1] : void 0,
			)
		}
	},
	wF = class e extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.toggle-bg"
		static backgroundSuggestionsConfigKey = "nextEdit.enableBackgroundSuggestions"
		defaultParams = { promptFirst: !1, newValue: void 0 }
		constructor(t, r, n) {
			super(
				t,
				r,
				n,
				() =>
					r.config.nextEdit.enableBackgroundSuggestions
						? "Turn Background Suggestions Off"
						: "Turn Background Suggestions On",
				!0,
			)
		}
		async run(t) {
			let r = { ...this.defaultParams, ...t },
				n = ki.workspace.getConfiguration("augment"),
				i = n.inspect(e.backgroundSuggestionsConfigKey),
				s = ki.ConfigurationTarget.Global
			i?.workspaceValue !== void 0 && (s = ki.ConfigurationTarget.Workspace)
			let o = r.newValue ?? !this._configListener.config.nextEdit.enableBackgroundSuggestions
			if (r.promptFirst && o === !1) {
				let a = await ki.window.showErrorMessage(
					"Are you sure you want to disable Next Edit Suggestions?",
					{
						modal: !0,
						detail: "You can re-enable them in Settings > Augment > Enable Background Suggestions.",
					},
					"Disable",
					"Go to Settings",
				)
				if (
					(a === "Go to Settings" &&
						ki.commands.executeCommand(
							"workbench.action.openSettings",
							"@ext:augment.vscode-augment nextEdit.enableBackgroundSuggestions",
						),
					a !== "Disable")
				)
					return
			}
			await n.update(e.backgroundSuggestionsConfigKey, o, s)
		}
	},
	IF = class extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.toggle-all-highlights"
		constructor(t, r, n) {
			super(t, r, n, () =>
				this._configListener.config.nextEdit.highlightSuggestionsInTheEditor
					? "Turn Off All Line Highlights"
					: "Turn On All Line Highlights",
			)
		}
		canRun() {
			return super.canRun()
		}
		run() {
			this._extension.nextEditConfigManager.toggleSetting("highlightSuggestionsInTheEditor")
		}
	},
	h_ = class e extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.enable-bg"
		static backgroundSuggestionsConfigKey = "nextEdit.enableBackgroundSuggestions"
		constructor(t, r, n) {
			super(t, r, n, () => "Enable Background Suggestions", !0)
		}
		canRun() {
			return (
				super.canRun() &&
				this._extension.ready &&
				!this._configListener.config.nextEdit.enableBackgroundSuggestions
			)
		}
		async run() {
			let t = ki.workspace.getConfiguration("augment")
			if (t.get(e.backgroundSuggestionsConfigKey)) return
			let r = t.inspect(e.backgroundSuggestionsConfigKey),
				n = ki.ConfigurationTarget.Global
			r?.workspaceValue !== void 0 && (n = ki.ConfigurationTarget.Workspace),
				await t.update(e.backgroundSuggestionsConfigKey, !0, n)
		}
	},
	SF = class e extends Xr {
		type = "public"
		static commandID = "vscode-augment.next-edit.disable-bg"
		static backgroundSuggestionsConfigKey = "nextEdit.enableBackgroundSuggestions"
		constructor(t, r, n) {
			super(t, r, n, () => "Disable Background Suggestions", !0)
		}
		canRun() {
			return (
				super.canRun() &&
				this._extension.ready &&
				this._configListener.config.nextEdit.enableBackgroundSuggestions
			)
		}
		async run() {
			let t = ki.workspace.getConfiguration("augment")
			if (!t.get(h_.backgroundSuggestionsConfigKey)) return
			let r = t.inspect(e.backgroundSuggestionsConfigKey),
				n = ki.ConfigurationTarget.Global
			r?.workspaceValue !== void 0 && (n = ki.ConfigurationTarget.Workspace),
				await t.update(e.backgroundSuggestionsConfigKey, !1, n)
		}
	},
	BF = class e extends Xr {
		constructor(r, n, i, s) {
			super(r, n, i, e.title)
			this._globalState = s
		}
		static title = "Reset Next Edit Onboarding"
		static commandID = "_vscode-augment.next-edit.reset-onboarding"
		type = "debug"
		canRun() {
			return this._configListener.config.enableDebugFeatures && super.canRun()
		}
		async run() {
			await this._globalState.update("nextEditSuggestionSeen", void 0),
				await this._globalState.update("nextEditSuggestionAccepted", void 0),
				await this._globalState.update("nextEditKeybindingUsageCount", void 0),
				await this._globalState.update("nextEditUxMigrationStatus", void 0)
		}
	},
	DF = class extends Xr {
		static commandID = "vscode-augment.next-edit.settings"
		type = "public"
		constructor(t, r, n) {
			super(t, r, n, () => "Enable Background Suggestions", !1)
		}
		run() {
			ki.commands.executeCommand("workbench.action.openSettings", "@ext:augment.vscode-augment augment.nextEdit")
		}
	}
var UF = W(require("fs")),
	oxe = W(OG()),
	axe = W(require("os")),
	lxe = W(require("path")),
	kl = W(require("vscode"))
var A_ = class {
		_keyCodeToStr
		_strToKeyCode
		constructor() {
			;(this._keyCodeToStr = []), (this._strToKeyCode = Object.create(null))
		}
		define(t, r) {
			;(this._keyCodeToStr[t] = r), (this._strToKeyCode[r.toLowerCase()] = t)
		}
		keyCodeToStr(t) {
			return this._keyCodeToStr[t]
		}
		strToKeyCode(t) {
			return this._strToKeyCode[t.toLowerCase()] || 0
		}
	},
	FF = new A_(),
	qG = new A_(),
	VG = new A_(),
	R0t = new Array(230),
	k0t = {},
	Xbe = [],
	exe = Object.create(null),
	txe = Object.create(null),
	QF = {
		lowerCaseToEnum: (e) => txe[e] || 0,
		toEnum: (e) => exe[e] || 0,
		toString: (e) => Xbe[e] || "None",
	},
	rxe = [],
	HG = []
for (let e = 0; e <= 193; e++) rxe[e] = -1
for (let e = 0; e <= 132; e++) HG[e] = -1
;(function () {
	let e = "",
		t = [
			[1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", e, e],
			[1, 1, "Hyper", 0, e, 0, e, e, e],
			[1, 2, "Super", 0, e, 0, e, e, e],
			[1, 3, "Fn", 0, e, 0, e, e, e],
			[1, 4, "FnLock", 0, e, 0, e, e, e],
			[1, 5, "Suspend", 0, e, 0, e, e, e],
			[1, 6, "Resume", 0, e, 0, e, e, e],
			[1, 7, "Turbo", 0, e, 0, e, e, e],
			[1, 8, "Sleep", 0, e, 0, "VK_SLEEP", e, e],
			[1, 9, "WakeUp", 0, e, 0, e, e, e],
			[0, 10, "KeyA", 31, "A", 65, "VK_A", e, e],
			[0, 11, "KeyB", 32, "B", 66, "VK_B", e, e],
			[0, 12, "KeyC", 33, "C", 67, "VK_C", e, e],
			[0, 13, "KeyD", 34, "D", 68, "VK_D", e, e],
			[0, 14, "KeyE", 35, "E", 69, "VK_E", e, e],
			[0, 15, "KeyF", 36, "F", 70, "VK_F", e, e],
			[0, 16, "KeyG", 37, "G", 71, "VK_G", e, e],
			[0, 17, "KeyH", 38, "H", 72, "VK_H", e, e],
			[0, 18, "KeyI", 39, "I", 73, "VK_I", e, e],
			[0, 19, "KeyJ", 40, "J", 74, "VK_J", e, e],
			[0, 20, "KeyK", 41, "K", 75, "VK_K", e, e],
			[0, 21, "KeyL", 42, "L", 76, "VK_L", e, e],
			[0, 22, "KeyM", 43, "M", 77, "VK_M", e, e],
			[0, 23, "KeyN", 44, "N", 78, "VK_N", e, e],
			[0, 24, "KeyO", 45, "O", 79, "VK_O", e, e],
			[0, 25, "KeyP", 46, "P", 80, "VK_P", e, e],
			[0, 26, "KeyQ", 47, "Q", 81, "VK_Q", e, e],
			[0, 27, "KeyR", 48, "R", 82, "VK_R", e, e],
			[0, 28, "KeyS", 49, "S", 83, "VK_S", e, e],
			[0, 29, "KeyT", 50, "T", 84, "VK_T", e, e],
			[0, 30, "KeyU", 51, "U", 85, "VK_U", e, e],
			[0, 31, "KeyV", 52, "V", 86, "VK_V", e, e],
			[0, 32, "KeyW", 53, "W", 87, "VK_W", e, e],
			[0, 33, "KeyX", 54, "X", 88, "VK_X", e, e],
			[0, 34, "KeyY", 55, "Y", 89, "VK_Y", e, e],
			[0, 35, "KeyZ", 56, "Z", 90, "VK_Z", e, e],
			[0, 36, "Digit1", 22, "1", 49, "VK_1", e, e],
			[0, 37, "Digit2", 23, "2", 50, "VK_2", e, e],
			[0, 38, "Digit3", 24, "3", 51, "VK_3", e, e],
			[0, 39, "Digit4", 25, "4", 52, "VK_4", e, e],
			[0, 40, "Digit5", 26, "5", 53, "VK_5", e, e],
			[0, 41, "Digit6", 27, "6", 54, "VK_6", e, e],
			[0, 42, "Digit7", 28, "7", 55, "VK_7", e, e],
			[0, 43, "Digit8", 29, "8", 56, "VK_8", e, e],
			[0, 44, "Digit9", 30, "9", 57, "VK_9", e, e],
			[0, 45, "Digit0", 21, "0", 48, "VK_0", e, e],
			[1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", e, e],
			[1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", e, e],
			[1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", e, e],
			[1, 49, "Tab", 2, "Tab", 9, "VK_TAB", e, e],
			[1, 50, "Space", 10, "Space", 32, "VK_SPACE", e, e],
			[0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
			[0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
			[0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
			[0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
			[0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
			[0, 56, "IntlHash", 0, e, 0, e, e, e],
			[0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
			[0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
			[0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
			[0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
			[0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
			[0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
			[1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", e, e],
			[1, 64, "F1", 59, "F1", 112, "VK_F1", e, e],
			[1, 65, "F2", 60, "F2", 113, "VK_F2", e, e],
			[1, 66, "F3", 61, "F3", 114, "VK_F3", e, e],
			[1, 67, "F4", 62, "F4", 115, "VK_F4", e, e],
			[1, 68, "F5", 63, "F5", 116, "VK_F5", e, e],
			[1, 69, "F6", 64, "F6", 117, "VK_F6", e, e],
			[1, 70, "F7", 65, "F7", 118, "VK_F7", e, e],
			[1, 71, "F8", 66, "F8", 119, "VK_F8", e, e],
			[1, 72, "F9", 67, "F9", 120, "VK_F9", e, e],
			[1, 73, "F10", 68, "F10", 121, "VK_F10", e, e],
			[1, 74, "F11", 69, "F11", 122, "VK_F11", e, e],
			[1, 75, "F12", 70, "F12", 123, "VK_F12", e, e],
			[1, 76, "PrintScreen", 0, e, 0, e, e, e],
			[1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", e, e],
			[1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", e, e],
			[1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", e, e],
			[1, 80, "Home", 14, "Home", 36, "VK_HOME", e, e],
			[1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", e, e],
			[1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", e, e],
			[1, 83, "End", 13, "End", 35, "VK_END", e, e],
			[1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", e, e],
			[1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", e],
			[1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", e],
			[1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", e],
			[1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", e],
			[1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", e, e],
			[1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", e, e],
			[1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", e, e],
			[1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", e, e],
			[1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", e, e],
			[1, 94, "NumpadEnter", 3, e, 0, e, e, e],
			[1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", e, e],
			[1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", e, e],
			[1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", e, e],
			[1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", e, e],
			[1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", e, e],
			[1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", e, e],
			[1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", e, e],
			[1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", e, e],
			[1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", e, e],
			[1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", e, e],
			[1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", e, e],
			[0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", e, e],
			[1, 107, "ContextMenu", 58, "ContextMenu", 93, e, e, e],
			[1, 108, "Power", 0, e, 0, e, e, e],
			[1, 109, "NumpadEqual", 0, e, 0, e, e, e],
			[1, 110, "F13", 71, "F13", 124, "VK_F13", e, e],
			[1, 111, "F14", 72, "F14", 125, "VK_F14", e, e],
			[1, 112, "F15", 73, "F15", 126, "VK_F15", e, e],
			[1, 113, "F16", 74, "F16", 127, "VK_F16", e, e],
			[1, 114, "F17", 75, "F17", 128, "VK_F17", e, e],
			[1, 115, "F18", 76, "F18", 129, "VK_F18", e, e],
			[1, 116, "F19", 77, "F19", 130, "VK_F19", e, e],
			[1, 117, "F20", 78, "F20", 131, "VK_F20", e, e],
			[1, 118, "F21", 79, "F21", 132, "VK_F21", e, e],
			[1, 119, "F22", 80, "F22", 133, "VK_F22", e, e],
			[1, 120, "F23", 81, "F23", 134, "VK_F23", e, e],
			[1, 121, "F24", 82, "F24", 135, "VK_F24", e, e],
			[1, 122, "Open", 0, e, 0, e, e, e],
			[1, 123, "Help", 0, e, 0, e, e, e],
			[1, 124, "Select", 0, e, 0, e, e, e],
			[1, 125, "Again", 0, e, 0, e, e, e],
			[1, 126, "Undo", 0, e, 0, e, e, e],
			[1, 127, "Cut", 0, e, 0, e, e, e],
			[1, 128, "Copy", 0, e, 0, e, e, e],
			[1, 129, "Paste", 0, e, 0, e, e, e],
			[1, 130, "Find", 0, e, 0, e, e, e],
			[1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", e, e],
			[1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", e, e],
			[1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", e, e],
			[1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", e, e],
			[0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", e, e],
			[1, 136, "KanaMode", 0, e, 0, e, e, e],
			[0, 137, "IntlYen", 0, e, 0, e, e, e],
			[1, 138, "Convert", 0, e, 0, e, e, e],
			[1, 139, "NonConvert", 0, e, 0, e, e, e],
			[1, 140, "Lang1", 0, e, 0, e, e, e],
			[1, 141, "Lang2", 0, e, 0, e, e, e],
			[1, 142, "Lang3", 0, e, 0, e, e, e],
			[1, 143, "Lang4", 0, e, 0, e, e, e],
			[1, 144, "Lang5", 0, e, 0, e, e, e],
			[1, 145, "Abort", 0, e, 0, e, e, e],
			[1, 146, "Props", 0, e, 0, e, e, e],
			[1, 147, "NumpadParenLeft", 0, e, 0, e, e, e],
			[1, 148, "NumpadParenRight", 0, e, 0, e, e, e],
			[1, 149, "NumpadBackspace", 0, e, 0, e, e, e],
			[1, 150, "NumpadMemoryStore", 0, e, 0, e, e, e],
			[1, 151, "NumpadMemoryRecall", 0, e, 0, e, e, e],
			[1, 152, "NumpadMemoryClear", 0, e, 0, e, e, e],
			[1, 153, "NumpadMemoryAdd", 0, e, 0, e, e, e],
			[1, 154, "NumpadMemorySubtract", 0, e, 0, e, e, e],
			[1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", e, e],
			[1, 156, "NumpadClearEntry", 0, e, 0, e, e, e],
			[1, 0, e, 5, "Ctrl", 17, "VK_CONTROL", e, e],
			[1, 0, e, 4, "Shift", 16, "VK_SHIFT", e, e],
			[1, 0, e, 6, "Alt", 18, "VK_MENU", e, e],
			[1, 0, e, 57, "Meta", 91, "VK_COMMAND", e, e],
			[1, 157, "ControlLeft", 5, e, 0, "VK_LCONTROL", e, e],
			[1, 158, "ShiftLeft", 4, e, 0, "VK_LSHIFT", e, e],
			[1, 159, "AltLeft", 6, e, 0, "VK_LMENU", e, e],
			[1, 160, "MetaLeft", 57, e, 0, "VK_LWIN", e, e],
			[1, 161, "ControlRight", 5, e, 0, "VK_RCONTROL", e, e],
			[1, 162, "ShiftRight", 4, e, 0, "VK_RSHIFT", e, e],
			[1, 163, "AltRight", 6, e, 0, "VK_RMENU", e, e],
			[1, 164, "MetaRight", 57, e, 0, "VK_RWIN", e, e],
			[1, 165, "BrightnessUp", 0, e, 0, e, e, e],
			[1, 166, "BrightnessDown", 0, e, 0, e, e, e],
			[1, 167, "MediaPlay", 0, e, 0, e, e, e],
			[1, 168, "MediaRecord", 0, e, 0, e, e, e],
			[1, 169, "MediaFastForward", 0, e, 0, e, e, e],
			[1, 170, "MediaRewind", 0, e, 0, e, e, e],
			[1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", e, e],
			[1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", e, e],
			[1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", e, e],
			[1, 174, "Eject", 0, e, 0, e, e, e],
			[1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", e, e],
			[1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", e, e],
			[1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", e, e],
			[1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", e, e],
			[1, 179, "LaunchApp1", 0, e, 0, "VK_MEDIA_LAUNCH_APP1", e, e],
			[1, 180, "SelectTask", 0, e, 0, e, e, e],
			[1, 181, "LaunchScreenSaver", 0, e, 0, e, e, e],
			[1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", e, e],
			[1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", e, e],
			[1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", e, e],
			[1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", e, e],
			[1, 186, "BrowserStop", 0, e, 0, "VK_BROWSER_STOP", e, e],
			[1, 187, "BrowserRefresh", 0, e, 0, "VK_BROWSER_REFRESH", e, e],
			[1, 188, "BrowserFavorites", 0, e, 0, "VK_BROWSER_FAVORITES", e, e],
			[1, 189, "ZoomToggle", 0, e, 0, e, e, e],
			[1, 190, "MailReply", 0, e, 0, e, e, e],
			[1, 191, "MailForward", 0, e, 0, e, e, e],
			[1, 192, "MailSend", 0, e, 0, e, e, e],
			[1, 0, e, 114, "KeyInComposition", 229, e, e, e],
			[1, 0, e, 116, "ABNT_C2", 194, "VK_ABNT_C2", e, e],
			[1, 0, e, 96, "OEM_8", 223, "VK_OEM_8", e, e],
			[1, 0, e, 0, e, 0, "VK_KANA", e, e],
			[1, 0, e, 0, e, 0, "VK_HANGUL", e, e],
			[1, 0, e, 0, e, 0, "VK_JUNJA", e, e],
			[1, 0, e, 0, e, 0, "VK_FINAL", e, e],
			[1, 0, e, 0, e, 0, "VK_HANJA", e, e],
			[1, 0, e, 0, e, 0, "VK_KANJI", e, e],
			[1, 0, e, 0, e, 0, "VK_CONVERT", e, e],
			[1, 0, e, 0, e, 0, "VK_NONCONVERT", e, e],
			[1, 0, e, 0, e, 0, "VK_ACCEPT", e, e],
			[1, 0, e, 0, e, 0, "VK_MODECHANGE", e, e],
			[1, 0, e, 0, e, 0, "VK_SELECT", e, e],
			[1, 0, e, 0, e, 0, "VK_PRINT", e, e],
			[1, 0, e, 0, e, 0, "VK_EXECUTE", e, e],
			[1, 0, e, 0, e, 0, "VK_SNAPSHOT", e, e],
			[1, 0, e, 0, e, 0, "VK_HELP", e, e],
			[1, 0, e, 0, e, 0, "VK_APPS", e, e],
			[1, 0, e, 0, e, 0, "VK_PROCESSKEY", e, e],
			[1, 0, e, 0, e, 0, "VK_PACKET", e, e],
			[1, 0, e, 0, e, 0, "VK_DBE_SBCSCHAR", e, e],
			[1, 0, e, 0, e, 0, "VK_DBE_DBCSCHAR", e, e],
			[1, 0, e, 0, e, 0, "VK_ATTN", e, e],
			[1, 0, e, 0, e, 0, "VK_CRSEL", e, e],
			[1, 0, e, 0, e, 0, "VK_EXSEL", e, e],
			[1, 0, e, 0, e, 0, "VK_EREOF", e, e],
			[1, 0, e, 0, e, 0, "VK_PLAY", e, e],
			[1, 0, e, 0, e, 0, "VK_ZOOM", e, e],
			[1, 0, e, 0, e, 0, "VK_NONAME", e, e],
			[1, 0, e, 0, e, 0, "VK_PA1", e, e],
			[1, 0, e, 0, e, 0, "VK_OEM_CLEAR", e, e],
		],
		r = [],
		n = []
	for (let i of t) {
		let [s, o, a, l, c, u, f, p, g] = i
		if (
			(n[o] ||
				((n[o] = !0),
				(Xbe[o] = a),
				(exe[a] = o),
				(txe[a.toLowerCase()] = o),
				s && ((rxe[o] = l), l !== 0 && l !== 3 && l !== 5 && l !== 4 && l !== 6 && l !== 57 && (HG[l] = o))),
			!r[l])
		) {
			if (((r[l] = !0), !c))
				throw new Error(`String representation missing for key code ${l} around scan code ${a}`)
			FF.define(l, c), qG.define(l, p || c), VG.define(l, g || p || c)
		}
		u && (R0t[u] = l), f && (k0t[f] = l)
	}
	HG[3] = 46
})()
var m_
;((o) => {
	function e(a) {
		return FF.keyCodeToStr(a)
	}
	o.toString = e
	function t(a) {
		return FF.strToKeyCode(a)
	}
	o.fromString = t
	function r(a) {
		return qG.keyCodeToStr(a)
	}
	o.toUserSettingsUS = r
	function n(a) {
		return VG.keyCodeToStr(a)
	}
	o.toUserSettingsGeneral = n
	function i(a) {
		return qG.strToKeyCode(a) || VG.strToKeyCode(a)
	}
	o.fromUserSettings = i
	function s(a) {
		if (a >= 98 && a <= 113) return null
		switch (a) {
			case 16:
				return "Up"
			case 18:
				return "Down"
			case 15:
				return "Left"
			case 17:
				return "Right"
		}
		return FF.keyCodeToStr(a)
	}
	o.toElectronAccelerator = s
})((m_ ||= {}))
var WG = class {
		unexpectedErrorHandler
		listeners
		constructor() {
			;(this.listeners = []),
				(this.unexpectedErrorHandler = function (t) {
					setTimeout(() => {
						throw t.stack
							? NF.isErrorNoTelemetry(t)
								? new NF(
										t.message +
											`

` +
											t.stack,
									)
								: new Error(
										t.message +
											`

` +
											t.stack,
									)
							: t
					}, 0)
				})
		}
		addListener(t) {
			return (
				this.listeners.push(t),
				() => {
					this._removeListener(t)
				}
			)
		}
		emit(t) {
			this.listeners.forEach((r) => {
				r(t)
			})
		}
		_removeListener(t) {
			this.listeners.splice(this.listeners.indexOf(t), 1)
		}
		setUnexpectedErrorHandler(t) {
			this.unexpectedErrorHandler = t
		}
		getUnexpectedErrorHandler() {
			return this.unexpectedErrorHandler
		}
		onUnexpectedError(t) {
			this.unexpectedErrorHandler(t), this.emit(t)
		}
		onUnexpectedExternalError(t) {
			this.unexpectedErrorHandler(t)
		}
	},
	bqt = new WG()
function nxe(e) {
	return e ? new Error(`Illegal argument: ${e}`) : new Error("Illegal argument")
}
var NF = class e extends Error {
	name
	constructor(t) {
		super(t), (this.name = "CodeExpectedError")
	}
	static fromError(t) {
		if (t instanceof e) return t
		let r = new e()
		return (r.message = t.message), (r.stack = t.stack), r
	}
	static isErrorNoTelemetry(t) {
		return t.name === "CodeExpectedError"
	}
}
var uC = class e {
		constructor(t, r, n, i, s) {
			this.ctrlKey = t
			this.shiftKey = r
			this.altKey = n
			this.metaKey = i
			this.keyCode = s
		}
		equals(t) {
			return (
				t instanceof e &&
				this.ctrlKey === t.ctrlKey &&
				this.shiftKey === t.shiftKey &&
				this.altKey === t.altKey &&
				this.metaKey === t.metaKey &&
				this.keyCode === t.keyCode
			)
		}
		getHashCode() {
			let t = this.ctrlKey ? "1" : "0",
				r = this.shiftKey ? "1" : "0",
				n = this.altKey ? "1" : "0",
				i = this.metaKey ? "1" : "0"
			return `K${t}${r}${n}${i}${this.keyCode}`
		}
		isModifierKey() {
			return (
				this.keyCode === 0 ||
				this.keyCode === 5 ||
				this.keyCode === 57 ||
				this.keyCode === 6 ||
				this.keyCode === 4
			)
		}
		toKeybinding() {
			return new gA([this])
		}
		isDuplicateModifierCase() {
			return (
				(this.ctrlKey && this.keyCode === 5) ||
				(this.shiftKey && this.keyCode === 4) ||
				(this.altKey && this.keyCode === 6) ||
				(this.metaKey && this.keyCode === 57)
			)
		}
	},
	Jh = class e {
		constructor(t, r, n, i, s) {
			this.ctrlKey = t
			this.shiftKey = r
			this.altKey = n
			this.metaKey = i
			this.scanCode = s
		}
		equals(t) {
			return (
				t instanceof e &&
				this.ctrlKey === t.ctrlKey &&
				this.shiftKey === t.shiftKey &&
				this.altKey === t.altKey &&
				this.metaKey === t.metaKey &&
				this.scanCode === t.scanCode
			)
		}
		getHashCode() {
			let t = this.ctrlKey ? "1" : "0",
				r = this.shiftKey ? "1" : "0",
				n = this.altKey ? "1" : "0",
				i = this.metaKey ? "1" : "0"
			return `S${t}${r}${n}${i}${this.scanCode}`
		}
		isDuplicateModifierCase() {
			return (
				(this.ctrlKey && (this.scanCode === 157 || this.scanCode === 161)) ||
				(this.shiftKey && (this.scanCode === 158 || this.scanCode === 162)) ||
				(this.altKey && (this.scanCode === 159 || this.scanCode === 163)) ||
				(this.metaKey && (this.scanCode === 160 || this.scanCode === 164))
			)
		}
	},
	gA = class {
		chords
		constructor(t) {
			if (t.length === 0) throw nxe("chords")
			this.chords = t
		}
		getHashCode() {
			let t = ""
			for (let r = 0, n = this.chords.length; r < n; r++)
				r !== 0 && (t += ";"), (t += this.chords[r].getHashCode())
			return t
		}
		equals(t) {
			if (t === null || this.chords.length !== t.chords.length) return !1
			for (let r = 0; r < this.chords.length; r++) if (!this.chords[r].equals(t.chords[r])) return !1
			return !0
		}
	}
var PF = class {
	static _readModifiers(t) {
		t = t.toLowerCase().trim()
		let r = !1,
			n = !1,
			i = !1,
			s = !1,
			o
		do
			(o = !1),
				/^ctrl(\+|\-)/.test(t) && ((r = !0), (t = t.substr(5)), (o = !0)),
				/^shift(\+|\-)/.test(t) && ((n = !0), (t = t.substr(6)), (o = !0)),
				/^alt(\+|\-)/.test(t) && ((i = !0), (t = t.substr(4)), (o = !0)),
				/^meta(\+|\-)/.test(t) && ((s = !0), (t = t.substr(5)), (o = !0)),
				/^win(\+|\-)/.test(t) && ((s = !0), (t = t.substr(4)), (o = !0)),
				/^cmd(\+|\-)/.test(t) && ((s = !0), (t = t.substr(4)), (o = !0))
		while (o)
		let a,
			l = t.indexOf(" ")
		return (
			l > 0 ? ((a = t.substring(0, l)), (t = t.substring(l))) : ((a = t), (t = "")),
			{ remains: t, ctrl: r, shift: n, alt: i, meta: s, key: a }
		)
	}
	static parseChord(t) {
		let r = this._readModifiers(t),
			n = r.key.match(/^\[([^\]]+)\]$/)
		if (n) {
			let s = n[1],
				o = QF.lowerCaseToEnum(s)
			return [new Jh(r.ctrl, r.shift, r.alt, r.meta, o), r.remains]
		}
		let i = m_.fromUserSettings(r.key)
		return [new uC(r.ctrl, r.shift, r.alt, r.meta, i), r.remains]
	}
	static parseKeybinding(t) {
		if (!t) return null
		let r = [],
			n
		for (; t.length > 0; ) ([n, t] = this.parseChord(t)), r.push(n)
		return r.length > 0 ? new gA(r) : null
	}
}
var OF = class {
		constructor(t, r) {
			this.platform = t
			this.keybindings = r
		}
	},
	kc = class e extends z {
		constructor(r) {
			super()
			this._globalState = r
			if (((this.defaultKeybindings = this.getDefaultKeybindings()), !this.isRemote && !this.isWeb)) {
				this.platform = axe.default.platform()
				let n = eCe()
				if (n) {
					let i = lxe.default.join(n, e.keybindingFileName)
					;(this.userKeybindings = this.getUserKeybindings(i)),
						(this.watcher = UF.default.watch(n, (s, o) => {
							o === e.keybindingFileName &&
								(e._logger.info(`keybindings file changed: ${s} ${o}`),
								(this.userKeybindings = this.getUserKeybindings(i)))
						})),
						this.addDisposable({
							dispose: () => {
								this.watcher?.close()
							},
						})
				}
			} else {
				let n = this._globalState.get("userKeybindingInfo")
				;(this.platform = n?.platform),
					(this.userKeybindings = n?.keybindings ?? {}),
					this.addDisposable(
						kl.workspace.onDidSaveTextDocument((i) => {
							i.uri.scheme === "vscode-userdata" &&
								i.fileName.endsWith(e.keybindingFileName) &&
								((this.platform = this.getPlatformFromFilename(i.fileName)),
								(this.userKeybindings = this.getUserKeybindingsFromJSON(i.fileName, i.getText())),
								this._globalState.update(
									"userKeybindingInfo",
									new OF(this.platform, this.userKeybindings),
								))
						}),
					),
					setTimeout(() => {
						this.tryToFindPlatformAndUserKeybindings()
					}, e.remoteHeuristicDelayMs)
			}
		}
		static remoteHeuristicDelayMs = 1e3 * 5
		static _logger = X("KeybindingWatcher")
		static keybindingFileName = "keybindings.json"
		isRemote = kl.env.remoteName !== void 0
		isWeb = kl.env.uiKind === kl.UIKind.Web
		platform
		watcher
		defaultKeybindings = {}
		userKeybindings = {}
		async tryToFindPlatformAndUserKeybindings() {
			if (this.isRemote && this.platform === void 0) {
				let n = (
						await kl.workspace.openTextDocument(kl.Uri.from({ scheme: "output", path: "exthost" }))
					).getText(),
					i = /Skipping acquiring lock for (.*)\./,
					s = n.match(i)
				if (s) {
					e._logger.debug("Loading user keybindings")
					let a = s[1].replace(/workspaceStorage.*/, e.keybindingFileName)
					this.platform = this.getPlatformFromFilename(a)
					let l = await kl.workspace.openTextDocument(kl.Uri.from({ scheme: "vscode-userdata", path: a }))
					;(this.userKeybindings = this.getUserKeybindingsFromJSON(l.fileName, l.getText())),
						this._globalState.update("userKeybindingInfo", new OF(this.platform, this.userKeybindings))
				}
			}
		}
		getKeybindingForCommand(r, n = !1) {
			let i = this.userKeybindings[r]
			if (!i) {
				if (this.userKeybindings["-" + r]) return
				let o = this.defaultKeybindings[r]
				o && (this.platform !== void 0 || o.key === o.mac) && (i = o)
			}
			let s
			return i
				? (this.platform === void 0
						? (s = Array.from(new Set([i.key, i.mac]))
								.filter((o) => o !== void 0)
								.join("/"))
						: this.platform === "darwin" && i.mac
							? (s = i.mac)
							: (s = i.key),
					n ? e.formatKeyboardShortcut(s, this.getSimplifiedPlatform()) : s)
				: null
		}
		static getStructuredKeybinding(r) {
			try {
				if (!r) return null
				let n = PF.parseKeybinding(r)
				return n ? new GG(n.chords) : null
			} catch (n) {
				return this._logger.warn(`error parsing keybinding ${r}`, n), null
			}
		}
		static formatKeyboardShortcut(r, n) {
			try {
				let i = e.getStructuredKeybinding(r)
				return i ? i.toPrettyString(n) : ""
			} catch (i) {
				return this._logger.warn("error formatting keybinding, returning unformatted keybinding.", i), r || ""
			}
		}
		getSimplifiedPlatform() {
			return this.platform === "darwin" ? "darwin" : this.platform === "win32" ? "win32" : "linux"
		}
		getDefaultKeybindings() {
			let r = Qy()
			if (r && r.contributes && r.contributes.keybindings) {
				let { keybindings: n } = r.contributes
				return Object.fromEntries(n.map((i) => [i.command, i]))
			}
			return {}
		}
		getUserKeybindings(r) {
			if (UF.default.existsSync(r)) {
				let n = UF.default.readFileSync(r, "utf8")
				return this.getUserKeybindingsFromJSON(r, n)
			}
			return {}
		}
		getUserKeybindingsFromJSON(r, n) {
			try {
				let i = oxe.default.parse(n)
				return Object.fromEntries(i.map((s) => [s.command, s]))
			} catch (i) {
				return e._logger.debug(`Failed to parse '${r}': ${i.message}`), {}
			}
		}
		getPlatformFromFilename(r) {
			return r.startsWith("/Users/") ? "darwin" : r.match(/^\/?[a-zA-Z](?::|%3A)\/.*/) ? "win32" : "linux"
		}
	},
	LF = {
		meta: { darwin: "\u2318", win32: "Win", linux: "Meta" },
		ctrl: { darwin: "\u2303", win32: "Ctrl", linux: "Ctrl" },
		alt: { darwin: "\u2325", win32: "Alt", linux: "Alt" },
		shift: "\u21E7",
	},
	sxe = {
		Enter: "\u23CE",
		UpArrow: "\u2191",
		DownArrow: "\u2193",
		Backspace: "\u232B",
		Escape: "Esc",
	},
	GG = class extends gA {
		constructor(t) {
			super(t)
		}
		toPrettyString(t) {
			let r = []
			for (let n of this.chords) {
				let i = []
				n.ctrlKey && i.push(LF.ctrl[t]),
					n.shiftKey && i.push(LF.shift),
					n.altKey && i.push(LF.alt[t]),
					n.metaKey && i.push(LF.meta[t])
				let s
				n instanceof uC ? (s = m_.toString(n.keyCode)) : (s = QF.toString(n.scanCode)),
					s in sxe && (s = sxe[s]),
					(s = s.charAt(0).toUpperCase() + s.substring(1).toLowerCase()),
					i.push(s),
					i.join("").length <= 2 || t === "darwin" ? r.push(i.join("")) : r.push(i.join("+"))
			}
			return r.indexOf("Unknown") !== -1 ? "" : r.join(" ").trim()
		}
	}
function Rl(e, t) {
	return e.nextEdit.enabled ?? Gr(t)
}
function y_(e, t) {
	return e.nextEdit.enableBackgroundSuggestions && e.nextEdit.backgroundEnabled && Rl(e, t)
}
function dC() {
	let e = qF.window.tabGroups.activeTabGroup?.activeTab?.input
	return (
		e instanceof qF.TabInputTextDiff ||
		(e != null && Object.hasOwn(e, "base") && Object.hasOwn(e, "input1") && Object.hasOwn(e, "input2"))
	)
}
var $G = (e) => {
		let t = new Map()
		for (let r of e.filter(Boolean)) t.set(r.result.suggestionId, r)
		return Array.from(t.values())
	},
	C_ =
		(...e) =>
		(t) =>
			e.some((r) => r(t))
function fC(e) {
	return e?.state === "accepted"
}
function ui(e) {
	return e?.state === "fresh" && e.changeType !== "noop"
}
function Vu(e, t, r = !1) {
	let n = e.getKeybindingForCommand(t, r)
	return (
		n ||
		(t === Co.commandID
			? (e.getSimplifiedPlatform() === "darwin" ? (n = "Cmd+Z") : (n = "Ctrl+Z"),
				r ? kc.formatKeyboardShortcut(n, e.getSimplifiedPlatform()) : n)
			: t === "redo"
				? (e.getSimplifiedPlatform() === "darwin" ? (n = "Cmd+Shift+Z") : (n = "Ctrl+Y"),
					r ? kc.formatKeyboardShortcut(n, e.getSimplifiedPlatform()) : n)
				: n)
	)
}
var VF = class e extends lt {
	constructor(r, n) {
		super(e.title)
		this._extension = r
		this._configListener = n
	}
	static title = "Clear Recent Editing History"
	static commandID = "vscode-augment.clear-recent-editing-history"
	type = "public"
	run() {
		this._extension.clearFileEdits()
	}
	canRun() {
		return (
			super.canRun() &&
			this._extension.ready &&
			Rl(this._configListener.config, this._extension.featureFlagManager.currentFlags.vscodeNextEditMinVersion)
		)
	}
}
var WF = require("vscode")
var M0t = X("CopySessionIdPanelCommand"),
	HF = class extends lt {
		constructor(r) {
			super()
			this._apiServer = r
		}
		static commandID = "vscode-augment.copySessionId"
		type = "public"
		async run() {
			try {
				let r = this._apiServer.sessionId
				await WF.env.clipboard.writeText(r),
					await WF.window.showInformationMessage("Copied session ID to clipboard")
			} catch (r) {
				M0t.error(`Failed to copy session ID: ${r}`)
			}
		}
	}
var pA = class e extends lt {
		constructor(r) {
			super("Start Extension CPU Profile")
			this._flagManager = r
		}
		static commandID = "vscode-augment.cpu-profile.start"
		static isProfileRunning = !1
		type = "debug"
		run() {
			!this._flagManager.currentFlags.vscodeEnableCpuProfile ||
				e.isProfileRunning ||
				(e.markAsRunning(), console.profile())
		}
		canRun() {
			return this._flagManager.currentFlags.vscodeEnableCpuProfile && !e.isProfileRunning
		}
		static markAsRunning() {
			e.isProfileRunning = !0
		}
		static markAsNotRunning() {
			e.isProfileRunning = !1
		}
	},
	GF = class extends lt {
		constructor(r) {
			super("End Extension CPU Profile")
			this._flagManager = r
		}
		static commandID = "vscode-augment.cpu-profile.stop"
		type = "debug"
		run() {
			pA.isProfileRunning && (console.profileEnd(), pA.markAsNotRunning())
		}
		canRun() {
			return pA.isProfileRunning
		}
	}
var cf = class extends lt {
	constructor(r, n, i = !0) {
		super(n, i)
		this._config = r
	}
	type = "debug"
	canRun() {
		return this._config.config.enableDebugFeatures
	}
}
var $F = class e extends cf {
		constructor(r, n, i) {
			super(n, e.title)
			this._syncingEnabledTracker = r
			this._extension = i
		}
		static title = "$(sync) Enable workspace syncing"
		static commandID = "vscode-augment.enable-workspace-syncing"
		run() {
			this._syncingEnabledTracker.syncingEnabledState !== "initializing" &&
				this._syncingEnabledTracker.enableSyncing()
		}
		canRun() {
			let r = this._syncingEnabledTracker.syncingEnabledState
			return super.canRun() && this._extension.ready && (r === "disabled" || r === "partial")
		}
	},
	YF = class e extends cf {
		constructor(r, n, i) {
			super(n, e.title)
			this._syncingStateTracker = r
			this._extension = i
		}
		static title = "$(circle-slash) Disable workspace syncing"
		static commandID = "vscode-augment.disable-workspace-syncing"
		run() {
			this._syncingStateTracker.syncingEnabledState !== "initializing" &&
				this._syncingStateTracker.disableSyncing()
		}
		canRun() {
			let r = this._syncingStateTracker.syncingEnabledState
			return super.canRun() && this._extension.ready && (r === "enabled" || r === "partial")
		}
	}
var JF = require("vscode")
var KF = class extends cf {
	constructor(r, n) {
		super(n, "Show Extension Status")
		this._extension = r
	}
	static commandID = "vscode-augment.extensionStatus"
	async run() {
		this._extension.updateStatusTrace()
		let r = await JF.workspace.openTextDocument(AA.displayStatusUri)
		await JF.window.showTextDocument(r)
	}
}
var zh = W(require("vscode"))
var zF = class extends lt {
	constructor(r, n, i) {
		super()
		this._configListener = i
		;(this._apiServer = n),
			(this.extension = r),
			(this.commitMessagePromptPreparer = new Hy(zh.default?.workspace.workspaceFolders?.[0].uri.fsPath ?? ""))
	}
	type = "public"
	static commandID = "vscode-augment.generateCommitMessage"
	_apiServer
	extension
	commitMessagePromptPreparer
	canRun() {
		return this._configListener.config.enableDebugFeatures
	}
	async run(r) {
		await this.generateCommitMessage()
	}
	async generateCommitMessage() {
		let r
		try {
			r = zh.default.extensions.getExtension("vscode.git")?.exports
		} catch {
			zh.default.window.showInformationMessage(
				"Cannot generate commit message: Failed to interact with git extension",
			)
			return
		}
		let n = r?.getAPI(1)?.repositories,
			i = zh.default.workspace.workspaceFolders?.at(0)?.uri ?? "",
			s = n?.find((u) => u.rootUri.toString() === i.toString())
		if (!s) {
			zh.default.window.showInformationMessage("Cannot generate commit message: no repo")
			return
		}
		if (((s.inputBox.value = "Augment is generating..."), !this.extension.workspaceManager)) {
			zh.default.window.showInformationMessage("Cannot generate commit message: no workspace")
			return
		}
		let o
		try {
			o = await this.commitMessagePromptPreparer.getCommitMessagePromptData({
				diffBudget: 9216,
				messageBudget: 3072,
				relevantMessageSubbudget: 1024,
				diffNoopLineLimit: 5e3,
				onlyUseStagedChanges: !1,
				maxExampleCommitMessages: 3,
			})
		} catch (u) {
			zh.default.window.showInformationMessage(
				`Cannot generate commit message: Failed to generate diff details. Error: ${
					u instanceof Error ? u.message : String(u)
				}`,
			)
			return
		}
		let a = this._apiServer.createRequestId(),
			l = await this._apiServer.generateCommitMessageStream(a, o),
			c = ""
		try {
			for await (let u of l) (c += u.text), (s.inputBox.value = c)
		} catch {
			s.inputBox.value = "Server error: failed to generate commit message."
		}
	}
}
var Hu = require("vscode")
var v_ = require("vscode"),
	cxe = new v_.EventEmitter(),
	uxe = new v_.EventEmitter(),
	dxe = new v_.EventEmitter(),
	fxe = new v_.EventEmitter(),
	Mc = (e) => cxe.event(e),
	mA = (e) => dxe.event(e),
	hxe = (e) => uxe.event(e),
	gxe = (e) => cxe.fire(e),
	pxe = () => dxe.fire(),
	YG = (e) => uxe.fire(e),
	Axe = (e) => fxe.event(e),
	uf = (e) => fxe.fire(e)
var jF = class extends Jo {
	constructor(r, n) {
		super(n)
		this._extension = r
	}
	static commandID = "vscode-augment.insertCompletion"
	completionTimeoutMS = 1e4
	type = "public"
	async run() {
		let r = {
				location: Hu.ProgressLocation.Notification,
				title: "Waiting for completion...",
				cancellable: !0,
			},
			n,
			i = async (s, o) => {
				n = await this.requestCompletion(o)
			}
		if ((await Hu.window.withProgress(r, i), !n)) {
			await Hu.window.showWarningMessage("Failed to request a completion")
			return
		}
		switch (n.resultType) {
			case "timeout":
				await Hu.window.showWarningMessage("Failed to request a completion")
				break
			case "cancelled":
				await Hu.window.showInformationMessage("Completion request cancelled")
				break
			default:
				n.foundCompletion || (await Hu.window.showInformationMessage("No completions found"))
				break
		}
	}
	async requestCompletion(r) {
		let n = Promise.race([
			(async () => {
				let i = await Iu(Mc),
					s = !1
				return (
					i?.completions && i.completions.length > 0 && (s = !0),
					{ foundCompletion: s, resultType: "completion" }
				)
			})(),
			(async () => (await Iu(mA), { foundCompletion: !1, resultType: "cancelled" }))(),
			(async () => (await Iu(r.onCancellationRequested), { foundCompletion: !1, resultType: "cancelled" }))(),
			new Promise((i) => {
				setTimeout(() => {
					i({ foundCompletion: !1, resultType: "timeout" })
				}, this.completionTimeoutMS)
			}),
		])
		return Hu.commands.executeCommand("editor.action.inlineSuggest.trigger"), await n
	}
	canRun() {
		return super.canRun() && this._extension.ready
	}
}
var ea = W(require("vscode"))
var ZF = class e extends cf {
	constructor(r, n) {
		super(n, "Show Internal Context")
		this._extension = r
	}
	static commandID = "vscode-augment.showWorkspaceContext"
	static textDocumentName = "Augment Workspace Context.txt"
	_documentUri = ea.Uri.file(e.textDocumentName).with({ scheme: "untitled" })
	async run() {
		let r = this._formatContext(),
			n = await ea.workspace.openTextDocument(this._documentUri)
		await ea.window.showTextDocument(n)
		let i = new ea.Range(new ea.Position(0, 0), new ea.Position(n.lineCount, 0)),
			s = new ea.WorkspaceEdit()
		s.replace(n.uri, i, r), await ea.workspace.applyEdit(s)
	}
	_formatContext() {
		let r = this._extension.workspaceManager
		if (r === void 0) return "no workspace manager"
		let n = r.getContextWithBlobNames(),
			i = `Augment workspace context
`,
			s = this._formatBlobs(r, n),
			o = this._formatChunks(n.recentChunks)
		return (
			i +
			s +
			`


` +
			o
		)
	}
	_formatBlobs(r, n) {
		let i = new Array(),
			s = new Set()
		for (let [c, u] of n.trackedPaths) for (let [f, p] of u) s.add(p)
		let o = new Map(),
			a = new Set()
		for (let c of n.blobNames) {
			let u = r.getAllPathInfo(c)
			for (let [f, p, g] of u) {
				let m = o.get(f)
				m === void 0 && ((m = new Map()), o.set(f, m)), m.set(g, [c, u.length])
			}
			u.length === 0 && !s.has(c) && a.add(c)
		}
		let l = new Map()
		for (let c of n.recentChunks) {
			let u = c.repoRoot,
				f = c.pathName,
				p = l.get(u)
			p === void 0 && ((p = new Map()), l.set(u, p)), p.set(f, (p.get(f) || 0) + 1)
		}
		for (let [c, u] of o) {
			let f = n.trackedPaths.get(c) || new Map(),
				p = u.size,
				g = f.size,
				m = l.get(c) || new Map()
			for (let b of m.keys()) f.has(b) || i.push(`    ${c}: ${b} has recent chunks but is not open`)
			let y = `Repo root ${c}: ${p} paths (${g} open)`
			i.push(""), i.push(y), i.push("=".repeat(y.length))
			let C = Array.from(f.keys())
			C.sort()
			for (let b of C) {
				let w = f.get(b),
					B = m.get(b) || 0
				i.push(`    ${w} -> ${b}: open, recent chunks: ${B}`)
			}
			C.length > 0 && i.push("")
			let v = Array.from(u.keys())
			v.sort()
			for (let b of v) {
				if (f.has(b)) continue
				let [w, B] = u.get(b),
					M = B === 1 ? "" : ` (x ${B})`
				i.push(`    ${w} -> ${b}${M}`)
			}
		}
		if (a.size > 0) for (let c of a) i.push(`unknown blob: ${c}`)
		return i.join(`
`)
	}
	_formatChunks(r) {
		let n = new Array(),
			i = "Recent chunks"
		if ((n.push(i), n.push("=".repeat(i.length)), r.length === 0))
			return (
				n.push("    (no recent chunks)"),
				n.join(`
`)
			)
		for (let s = 0; s < r.length; s++) {
			let o = r[s]
			n.push(""),
				n.push(`Chunk ${s + 1} of ${r.length}`),
				n.push(`    seq:      ${o.seq}`),
				n.push(`    uploaded: ${o.uploaded}`),
				n.push(`    repoRoot: ${o.repoRoot}`),
				n.push(`    pathName: ${o.pathName}`),
				n.push(`    blobName: ${o.blobName}`),
				n.push(`    start:    ${o.origStart}`),
				n.push(`    length:   ${o.origLength}`),
				n.push("======== chunk begin ========"),
				n.push(o.text),
				n.push("-------- chunk end ----------"),
				n.push("")
		}
		return n.join(`
`)
	}
}
var XF = W(require("vscode"))
var df = class e extends lt {
	constructor(r, n) {
		super()
		this.extension = r
		this._commandID = n
	}
	static commandIDCommunity = "vscode-augment.manageAccountCommunity"
	static commandIDProfessional = "vscode-augment.manageAccountProfessional"
	static commandIDEnterprise = "vscode-augment.manageAccountEnterprise"
	type = "public"
	run() {
		XF.env.openExternal(XF.Uri.parse("https://app.augmentcode.com/account"))
	}
	canRun() {
		let r = this.extension.userTier,
			n =
				this._commandID === e.commandIDCommunity
					? "community"
					: this._commandID === e.commandIDProfessional
						? "professional"
						: "enterprise"
		return super.canRun() && r === n
	}
}
var Gu = W(require("vscode"))
var yxe = require("child_process"),
	Cxe = require("util")
var mxe = X("CommandUtils"),
	F0t = (0, Cxe.promisify)(yxe.exec),
	Q0t = 5e3
async function Eo(e, t = {}) {
	try {
		let { stdout: r, stderr: n } = await F0t(e, { timeout: Q0t, ...t })
		return n && mxe.debug("stderr:" + n?.toString()), r?.toString()
	} catch (r) {
		mxe.debug(`exec error [${r.code}] [${r.signal}] [${r.message}] [${r.stackTrace}]`)
	}
}
var KG = W(require("vscode")),
	e1 = class extends z {
		constructor(r) {
			super()
			this._panel = r
			if (((this._asyncMsgHandler = Ti(this._panel.webview)), !KG.workspace.workspaceFolders?.[0]))
				throw new Error("No workspace folder found")
		}
		_asyncMsgHandler
		execOptions = { cwd: KG.workspace.workspaceFolders?.[0].uri.fsPath }
		register() {
			this._asyncMsgHandler.registerHandler(
				"get-git-branches-request",
				this.handleGetGitBranchesRequest.bind(this),
			),
				this._asyncMsgHandler.registerHandler(
					"get-workspace-diff-request",
					this.handleGetWorkspaceDiffRequest.bind(this),
				),
				this._asyncMsgHandler.registerHandler(
					"get-remote-url-request",
					this.handleGetRemoteUrlRequest.bind(this),
				),
				this._asyncMsgHandler.registerHandler("git-fetch-request", this.handleGitFetchRequest.bind(this)),
				this._asyncMsgHandler.registerHandler(
					"is-git-repository-request",
					this.handleIsGitRepositoryRequest.bind(this),
				)
		}
		dispose() {
			this._asyncMsgHandler.dispose()
		}
		async handleGetGitBranchesRequest(r) {
			try {
				let { prefix: n = "" } = r.data,
					{ execOptions: i } = this,
					s = [],
					o = (await Eo("git branch --show-current", i))?.trim(),
					a = !!(await Eo("git branch -r | grep $(git branch --show-current)", i)),
					l = (await Eo("git symbolic-ref --short refs/remotes/origin/HEAD", i))?.trim(),
					f = (await Eo("git branch --list --remote | sed 's/^[ *]*//'", i))
						?.split(
							`
`,
						)
						.filter(Boolean)
						?.map((p) => {
							if (!(p === o || p === l) && p.includes(n)) return p
						})
						.filter(Boolean)
				return (
					o && f?.unshift(o),
					l && f?.unshift(l),
					f?.forEach((p) => {
						s.push({
							name: p.trim(),
							isRemote: p === o ? a : !0,
							isCurrentBranch: p === o,
							isDefault: p === l,
						})
					}),
					{ type: "get-git-branches-response", data: { branches: s } }
				)
			} catch (n) {
				return (
					console.error("Failed to get git branches:", n),
					{ type: "get-git-branches-response", data: { branches: [] } }
				)
			}
		}
		async handleGetWorkspaceDiffRequest(r) {
			try {
				let { branchName: n } = r.data,
					i = (await Eo(`git diff origin/${n} || true`, this.execOptions)) || "",
					s = (await Eo("git ls-files --others --exclude-standard", this.execOptions)) || ""
				for (let o of s.trimEnd().split(`
`) || [])
					i += (await Eo(`git diff --no-index /dev/null ${o} || true`, this.execOptions)) || ""
				return { type: "get-workspace-diff-response", data: { diff: i } }
			} catch (n) {
				return (
					console.error("Failed to get workspace diff:", n),
					{ type: "get-workspace-diff-response", data: { diff: "" } }
				)
			}
		}
		async handleGetRemoteUrlRequest(r) {
			let { execOptions: n } = this
			try {
				let i = (await Eo("git remote get-url origin", n))?.trim()
				if (!i) throw new Error("Failed to get remote url, no remote found")
				if ((i?.startsWith("https://") ? "https" : "ssh") === "https")
					return { type: "get-remote-url-response", data: { remoteUrl: i } }
				{
					let o = i.replace("git@", "https://").replace(".com:", ".com/").replace(".git", "")
					return { type: "get-remote-url-response", data: { remoteUrl: o } }
				}
			} catch (i) {
				return (
					console.error("Failed to get remote url:", i),
					{ type: "get-remote-url-response", data: { remoteUrl: "" } }
				)
			}
		}
		async handleGitFetchRequest(r) {
			try {
				return await Eo("git fetch", this.execOptions), { type: "git-fetch-response" }
			} catch (n) {
				return console.error("Failed to fetch remote branch:", n), { type: "git-fetch-response" }
			}
		}
		async handleIsGitRepositoryRequest(r) {
			try {
				let n = !!(await Eo("git rev-parse --is-inside-work-tree 2>/dev/null", this.execOptions))
				return (
					console.log("isGitRepository: ", n),
					{ type: "is-git-repository-response", data: { isGitRepository: n } }
				)
			} catch (n) {
				return (
					console.error("Failed to check if is git repository:", n),
					{ type: "is-git-repository-response", data: { isGitRepository: !1 } }
				)
			}
		}
	}
var vxe = async (e, t) => {
	let r = e.map((l) => {
			let c = N0t(l.old_path, l.new_path, l.old_contents || "", l.new_contents || "")
			return { path: l.new_path || l.old_path, changes: c }
		}),
		n = r.map((l) => ({
			path: l.path,
			changes: l.changes.map((c) => ({ id: c.id, path: c.path, diff: c.diff })),
		})),
		i = `You are a helpful software engineer. You are given a diff of a set of files. Your job is to walk a fellow developer through the changes in the diff.

You need to storytell through the updates, splitting it into two levels of semantic chunks of changes. You should respond with just JSON in this format:
{
    title: string; // these are top-level categories, like "Footer updates" or "New API routes"
    description: string; // use Markdown. eg. put variable names in backticks, strings in quotes in backticks (eg. \`"String"\`)
    sections: {
        title: string; // use sentence case and make it descriptive, like "Added...". Be as descriptive as possible, eg. "Tweaked heading spacing in footer"
        description: string; // use Markdown. eg. put variable names in backticks, strings in quotes in backticks (eg. \`"String"\`). Use \u2192 to describe value changes
        type: "fix" | "feature" | "refactor" | "documentation" | "style" | "test" | "chore" | "revert" | "other";
        warning?: string; // look for anything that might be important for the user to know. eg. "This implementation isn't complete"
        changeIds: string[]; // you can group multiple changes into a single section, if they are related
    }[]
}[]

Here's an example set of changes:

[{
    "path": "src/global.css",
    "changes": [{
    "id": "1",
    "path": "src/global.css",
    "diff": "body {
- background-color: #fff;
+ background-color: #000;
}"
    }
}]

You would respond:

[{
  "title": "Style tweaks",
  "description": "Global style changes across the app",
  "sections": [{
        "title": "Change background color",
        "description": "Change the background color from white \u2192 black",
        "changeIds": ["1"]
    }]
}]


The changes are:

${JSON.stringify(n, null, 2)}

Start your response with [{`,
		s = await t(i)
	return JSON.parse(s).map((l) => ({
		title: l.title,
		description: l.description,
		sections: l.sections.map((c) => {
			let u = c.changeIds
				.map((f) => {
					let p = r.find((m) => m.changes.find((y) => y.id === f))
					return (p && p.changes.find((m) => m.id === f)) || void 0
				})
				.filter((f) => f !== void 0)
			return {
				title: c.title,
				description: c.description,
				type: c.type,
				warning: c.warning,
				changes: u,
			}
		}),
	}))
}
function N0t(e, t, r, n) {
	let i = vI(e, t, r, n, "", "", { context: 3 })
	return [
		{
			id: Math.random().toString(36).substring(2, 15),
			path: e || t,
			diff: i,
			originalCode: r,
			modifiedCode: n,
		},
	]
}
var P0t = Object.freeze({ git: { name: ".git", type: "Directory" } })
async function E_(e) {
	for (let [t, r] of Object.entries(P0t)) {
		let n = await yk(e, r.name, r.type)
		if (n !== void 0) return { root: n, toolName: t }
	}
}
var r1 = W(require("fs"))
function L0t(e, t) {
	let r = {}
	for (let s = 0; s < t.length; s++) {
		let o = t[s]
		r[o] ? r[o].push(s) : (r[o] = [s])
	}
	let i = [{ buffer1index: -1, buffer2index: -1, chain: null }]
	for (let s = 0; s < e.length; s++) {
		let o = e[s],
			a = r[o] || [],
			l = 0,
			c = i[0]
		for (let u = 0; u < a.length; u++) {
			let f = a[u],
				p
			for (
				p = l;
				p < i.length && !(i[p].buffer2index < f && (p === i.length - 1 || i[p + 1].buffer2index > f));
				p++
			);
			if (p < i.length) {
				let g = { buffer1index: s, buffer2index: f, chain: i[p] }
				if ((l === i.length ? i.push(c) : (i[l] = c), (l = p + 1), (c = g), l === i.length)) break
			}
		}
		i[l] = c
	}
	return i[i.length - 1]
}
function Exe(e, t) {
	let r = L0t(e, t),
		n = [],
		i = e.length,
		s = t.length
	for (let o = r; o !== null; o = o.chain) {
		let a = i - o.buffer1index - 1,
			l = s - o.buffer2index - 1
		;(i = o.buffer1index),
			(s = o.buffer2index),
			(a || l) &&
				n.push({
					buffer1: [i + 1, a],
					buffer1Content: e.slice(i + 1, i + 1 + a),
					buffer2: [s + 1, l],
					buffer2Content: t.slice(s + 1, s + 1 + l),
				})
	}
	return n.reverse(), n
}
function U0t(e, t, r) {
	let n = []
	function i(l, c) {
		n.push({
			ab: c,
			oStart: l.buffer1[0],
			oLength: l.buffer1[1],
			abStart: l.buffer2[0],
			abLength: l.buffer2[1],
		})
	}
	Exe(t, e).forEach((l) => i(l, "a")), Exe(t, r).forEach((l) => i(l, "b")), n.sort((l, c) => l.oStart - c.oStart)
	let s = [],
		o = 0
	function a(l) {
		l > o &&
			(s.push({
				stable: !0,
				buffer: "o",
				bufferStart: o,
				bufferLength: l - o,
				bufferContent: t.slice(o, l),
			}),
			(o = l))
	}
	for (; n.length; ) {
		let l = n.shift(),
			c = l.oStart,
			u = l.oStart + l.oLength,
			f = [l]
		for (a(c); n.length; ) {
			let p = n[0],
				g = p.oStart
			if (g > u) break
			;(u = Math.max(u, g + p.oLength)), f.push(n.shift())
		}
		if (f.length === 1) {
			if (l.abLength > 0) {
				let p = l.ab === "a" ? e : r
				s.push({
					stable: !0,
					buffer: l.ab,
					bufferStart: l.abStart,
					bufferLength: l.abLength,
					bufferContent: p.slice(l.abStart, l.abStart + l.abLength),
				})
			}
		} else {
			let p = {
				a: [e.length, -1, t.length, -1],
				b: [r.length, -1, t.length, -1],
			}
			for (; f.length; ) {
				l = f.shift()
				let b = l.oStart,
					w = b + l.oLength,
					B = l.abStart,
					M = B + l.abLength,
					Q = p[l.ab]
				;(Q[0] = Math.min(B, Q[0])),
					(Q[1] = Math.max(M, Q[1])),
					(Q[2] = Math.min(b, Q[2])),
					(Q[3] = Math.max(w, Q[3]))
			}
			let g = p.a[0] + (c - p.a[2]),
				m = p.a[1] + (u - p.a[3]),
				y = p.b[0] + (c - p.b[2]),
				C = p.b[1] + (u - p.b[3]),
				v = {
					stable: !1,
					aStart: g,
					aLength: m - g,
					aContent: e.slice(g, m),
					oStart: c,
					oLength: u - c,
					oContent: t.slice(c, u),
					bStart: y,
					bLength: C - y,
					bContent: r.slice(y, C),
				}
			s.push(v)
		}
		o = u
	}
	return a(t.length), s
}
function O0t(e, t, r, n) {
	;(n = Object.assign({ excludeFalseConflicts: !0, stringSeparator: /\s+/ }, n)),
		typeof e == "string" && (e = e.split(n.stringSeparator)),
		typeof t == "string" && (t = t.split(n.stringSeparator)),
		typeof r == "string" && (r = r.split(n.stringSeparator))
	let s = [],
		o = U0t(e, t, r),
		a = []
	function l() {
		a.length && s.push({ ok: a }), (a = [])
	}
	function c(u, f) {
		if (u.length !== f.length) return !1
		for (let p = 0; p < u.length; p++) if (u[p] !== f[p]) return !1
		return !0
	}
	return (
		o.forEach((u) => {
			u.stable
				? a.push(...u.bufferContent)
				: n.excludeFalseConflicts && c(u.aContent, u.bContent)
					? a.push(...u.aContent)
					: (l(),
						s.push({
							conflict: {
								a: u.aContent,
								aIndex: u.aStart,
								o: u.oContent,
								oIndex: u.oStart,
								b: u.bContent,
								bIndex: u.bStart,
							},
						}))
		}),
		l(),
		s
	)
}
function bxe(e, t, r, n) {
	n = Object.assign({ excludeFalseConflicts: !0, stringSeparator: /\s+/, label: {} }, n)
	let s = "<<<<<<<" + (n.label.a ? ` ${n.label.a}` : ""),
		o = "=======",
		a = ">>>>>>>" + (n.label.b ? ` ${n.label.b}` : ""),
		l = O0t(e, t, r, n),
		c = !1,
		u = []
	return (
		l.forEach((f) => {
			f.ok
				? (u = u.concat(f.ok))
				: f.conflict && ((c = !0), (u = u.concat([s], f.conflict.a, [o], f.conflict.b, [a])))
		}),
		{ conflict: c, result: u }
	)
}
var xxe = W(require("os")),
	n1 = W(require("path")),
	Wu = W(require("vscode")),
	jh = require("vscode")
var t1 = class extends z {
	constructor(r, n) {
		super()
		this._panel = r
		this._api = n
		this._asyncMsgHandler = Ti(this._panel.webview)
	}
	_asyncMsgHandler
	_agentId
	register() {
		this._asyncMsgHandler.registerStreamHandler("chat-user-message", this.handleChatUserMessage.bind(this)),
			this._asyncMsgHandler.registerHandler("chat-user-cancel", this.handleChatUserCancel.bind(this))
	}
	setAgentId(r) {
		this._agentId = r
	}
	async *handleChatUserMessage(r) {
		let { data: n } = r,
			i = n.text
		if (!this._agentId) throw new Error("No agent ID set")
		let o = Math.random() * 1e6
		for (let a = 0; a < i.length / 10; a += 1)
			await new Promise((l) => setTimeout(l, 100)),
				yield {
					type: "chat-model-reply",
					data: {
						text: i.slice(a * 10, a * 10 + 10),
						requestId: `${o}`,
						streaming: !0,
						workspaceFileChunks: [],
					},
				}
	}
	async handleChatUserCancel(r) {
		return await new Promise((n) => setTimeout(n, 0)), { type: "remote-agent-interrupt-response", data: 4 }
	}
	dispose() {
		this._asyncMsgHandler.dispose()
	}
}
var i1 = class extends z {
	constructor(r, n) {
		super()
		this._panel = r
		this._api = n
		;(this._asyncMsgHandler = Ti(this._panel.webview)),
			(this._chatAdapter = new t1(this._panel, this._api)),
			this.addDisposable(this._chatAdapter)
	}
	_asyncMsgHandler
	_chatAdapter
	register() {
		this._asyncMsgHandler.registerHandler(
			"remote-agent-manager-initialize",
			this.handlePanelLoadedMessage.bind(this),
		),
			this._asyncMsgHandler.registerHandler(
				"create-remote-agent-request",
				this.handleCreateRemoteAgentMessage.bind(this),
			),
			this._asyncMsgHandler.registerHandler(
				"delete-remote-agent-request",
				this.handleDeleteRemoteAgentMessage.bind(this),
			),
			this._asyncMsgHandler.registerHandler(
				"get-remote-agent-chat-history-request",
				this.handleGetRemoteAgentChatHistoryMessage.bind(this),
			),
			this._asyncMsgHandler.registerHandler(
				"remote-agent-chat-request",
				this.handleRemoteAgentChatRequestMessage.bind(this),
			),
			this._asyncMsgHandler.registerHandler(
				"remote-agent-interrupt-request",
				this.handleRemoteAgentInterruptRequestMessage.bind(this),
			),
			this._asyncMsgHandler.registerHandler(
				"get-remote-agent-overviews-request",
				this.handleGetRemoteAgentOverviewsMessage.bind(this),
			),
			this._asyncMsgHandler.registerHandler("set-remote-agent-id", this.handleSetRemoteAgentIdMessage.bind(this)),
			this._asyncMsgHandler.registerHandler(
				"get-diff-explanation-request",
				this.handleDiffExplanationRequestMessage.bind(this),
			),
			this._asyncMsgHandler.registerHandler("apply-changes-request", this.handleDiffApplyMessage.bind(this)),
			this._asyncMsgHandler.registerHandler(
				"get-setup-script-request",
				this.handleGetSetupScriptMessage.bind(this),
			),
			this._chatAdapter.register()
	}
	dispose() {
		this._asyncMsgHandler.dispose()
	}
	async postMessage(r) {
		!this._panel || !this._panel.visible || (await this._panel.webview.postMessage(r))
	}
	handleSetRemoteAgentIdMessage(r) {
		let { agentId: n } = r.data
		return this._chatAdapter.setAgentId(n), { type: "set-remote-agent-id", data: { agentId: n } }
	}
	async streamLlmCompletion(r) {
		let n = await Kp(r, this._api.createRequestId(), [], [], [], Mn.agent, "gemini-2-flash-001-simple")
		for await (let { nodes: i = [] } of n) {
			let s = i.find((o) => o.type === Jl.RAW_RESPONSE)?.content
			if (s) {
				let o = s.trim()
				return (o = o.replace(/^```|```$/g, "")), (o = o.replace(/^json/g, "")), o
			}
		}
		return ""
	}
	async handleDiffExplanationRequestMessage(r) {
		let { changedFiles: n } = r.data,
			i = this.streamLlmCompletion.bind(this)
		try {
			let s = await vxe(n, i)
			return {
				type: "get-diff-explanation-response",
				data: { explanation: s },
			}
		} catch (s) {
			return (
				console.error("Failed to explain diff:", s),
				{ type: "get-diff-explanation-response", data: { explanation: [] } }
			)
		}
	}
	async handleDiffApplyMessage(r) {
		let { path: n, originalCode: i, newCode: s } = r.data
		try {
			if (!n?.trim()) throw new Error("File path cannot be empty")
			if (typeof s != "string") throw new Error("New code must be a string")
			let o = this.resolveFilePath(n),
				a = Wu.Uri.file(o),
				l = new Wu.WorkspaceEdit(),
				c = new Wu.Range(0, 0, 0, 0),
				u = "",
				f = "",
				p = !1
			try {
				await jh.workspace.fs.stat(a), (p = !0), (f = s)
				let m = await jh.workspace.openTextDocument(a)
				;(c = new Wu.Range(0, 0, m.lineCount - 1, m.lineAt(m.lineCount - 1).text.length)),
					(u = (await jh.workspace.openTextDocument(a))?.getText() || "")
				let y = (B = "") => B.split(/(?<=\r\n|\n|\r)/g),
					C = y(u),
					v = y(i),
					b = y(s),
					w = bxe(C, v, b, { excludeFalseConflicts: !1 })
				w.conflict || (f = w.result.join(""))
			} catch {
				;(p = !1), (f = s)
			}
			if ((p || l.createFile(a, { overwrite: !0 }), l.replace(a, c, f), !(await Wu.workspace.applyEdit(l))))
				throw new Error("Failed to apply workspace edit")
			return { type: "apply-changes-response", data: { success: !0 } }
		} catch (o) {
			let a = o instanceof Error ? o.message : String(o)
			return {
				type: "apply-changes-response",
				data: { success: !1, error: a },
			}
		}
	}
	resolveFilePath(r) {
		let n = jh.workspace.workspaceFolders?.[0]
		if (!n) throw new Error("No workspace folder available")
		return Wu.Uri.joinPath(n.uri, r).fsPath
	}
	handlePanelLoadedMessage(r) {
		return { type: "remote-agent-manager-initialize", data: {} }
	}
	async handleCreateRemoteAgentMessage(r) {
		try {
			let { prompt: n, workspaceSetup: i, setupScript: s } = r.data,
				o = {
					request_nodes: [{ id: 1, type: $c.TEXT, text_node: { content: n } }],
				},
				a = await this._api.createRemoteAgent(i, o, void 0, s)
			return (
				console.log("Created remote agent:", a),
				this.postMessage({
					type: "create-remote-agent-response",
					data: { success: !0, agentId: a.remote_agent_id },
				}).catch((l) => {
					throw l
				}),
				{
					type: "create-remote-agent-response",
					data: { success: !0, agentId: a.remote_agent_id },
				}
			)
		} catch (n) {
			return (
				console.error("Failed to create remote agent:", n),
				{
					type: "create-remote-agent-response",
					data: {
						success: !1,
						error: n instanceof Error ? n.message : "Unknown error",
					},
				}
			)
		}
	}
	async handleDeleteRemoteAgentMessage(r) {
		try {
			let { agentId: n } = r.data
			return await this._api.deleteRemoteAgent(n), { type: "remote-agent-delete-response", data: { success: !0 } }
		} catch (n) {
			return (
				console.error("Failed to delete remote agent:", n),
				{
					type: "remote-agent-delete-response",
					data: {
						success: !1,
						error: n instanceof Error ? n.message : "Unknown error",
					},
				}
			)
		}
	}
	async handleGetRemoteAgentOverviewsMessage(r) {
		try {
			let n = await this._api.listRemoteAgents()
			return {
				type: "get-remote-agent-overviews-response",
				data: { overviews: n.remote_agents },
			}
		} catch (n) {
			return (
				console.error("Failed to get remote agent overviews:", n),
				{ type: "get-remote-agent-overviews-response", data: { overviews: [] } }
			)
		}
	}
	async handleGetRemoteAgentChatHistoryMessage(r) {
		try {
			let { agentId: n } = r.data,
				i = await this._api.getRemoteAgentChatHistory(n)
			return {
				type: "get-remote-agent-chat-history-response",
				data: { chatHistory: i.chat_history },
			}
		} catch (n) {
			return (
				console.error("Failed to get remote agent chat history:", n),
				{
					type: "get-remote-agent-chat-history-response",
					data: { chatHistory: [] },
				}
			)
		}
	}
	async handleRemoteAgentChatRequestMessage(r) {
		try {
			let { agentId: n, requestDetails: i } = r.data,
				s = await this._api.remoteAgentChat(n, i)
			return { type: "remote-agent-chat-response", data: s.nodes }
		} catch (n) {
			return (
				console.error("Failed to get remote agent chat response:", n),
				{ type: "remote-agent-chat-response", data: [] }
			)
		}
	}
	async handleRemoteAgentInterruptRequestMessage(r) {
		console.log("Interrupting remote agent:", r.data.agentId)
		let { agentId: n } = r.data
		try {
			let i = await this._api.interruptRemoteAgent(n)
			return { type: "remote-agent-interrupt-response", data: i }
		} catch (i) {
			return (
				console.error("Failed to interrupt remote agent:", i),
				{ type: "remote-agent-interrupt-response", data: 4 }
			)
		}
	}
	async handleGetSetupScriptMessage(r) {
		let n = ".augment",
			i = "setup.sh"
		try {
			let s = xxe.homedir(),
				o = n1.join(s, n, i)
			if (r1.existsSync(o)) {
				let a = await Fr(o)
				return { type: "get-setup-script-response", data: { content: a } }
			}
			if (
				(console.log("No home setup script found at:", o),
				jh.workspace.workspaceFolders && jh.workspace.workspaceFolders.length > 0)
			) {
				let a = jh.workspace.workspaceFolders[0].uri.fsPath,
					l,
					c = await E_(a)
				if ((c && ((l = c.root.fsPath), console.log("Found git root using findVCS:", l)), !l))
					try {
						let f = await Eo("git rev-parse --show-toplevel", { cwd: a })
						f && ((l = f.trim()), console.log("Found git root using git command:", l))
					} catch (f) {
						console.log("Failed to get git root:", f)
					}
				if (l) {
					let f = n1.join(l, n, i)
					if ((console.log("Checking for git root setup script at:", f), r1.existsSync(f))) {
						console.log("Found git root setup script at:", f)
						let p = await Fr(f)
						return { type: "get-setup-script-response", data: { content: p } }
					}
				}
				let u = n1.join(a, n, i)
				if ((console.log("Checking for workspace setup script at:", u), r1.existsSync(u))) {
					console.log("Found workspace setup script at:", u)
					let f = await Fr(u)
					return { type: "get-setup-script-response", data: { content: f } }
				}
			}
			return (
				console.log("No setup script found in any location"),
				{ type: "get-setup-script-response", data: { content: null } }
			)
		} catch (s) {
			return (
				console.error("Failed to get setup script:", s),
				{
					type: "get-setup-script-response",
					data: {
						content: null,
						error: s instanceof Error ? s.message : String(s),
					},
				}
			)
		}
	}
}
var s1 = class e extends Lu {
	constructor(r, n) {
		let i = Gu.window.createWebviewPanel("agent", "Agent Manager", Gu.ViewColumn.Active, {
			retainContextWhenHidden: !0,
			enableScripts: !0,
		})
		super("remote-agent-manager.html", i.webview)
		this._extensionUri = r
		this._api = n
		;(this._panel = i),
			(this._panel.iconPath = {
				light: Gu.Uri.joinPath(this._extensionUri, "media", "panel-icon-light.svg"),
				dark: Gu.Uri.joinPath(this._extensionUri, "media", "panel-icon-dark.svg"),
			}),
			this._panel.onDidDispose(() => {
				this.dispose()
			}),
			this.addDisposables(
				this._panel,
				new Gu.Disposable(() => {
					e.currentPanel = void 0
				}),
			),
			(this._remoteAgentsMessenger = new i1(this._panel, this._api)),
			this._remoteAgentsMessenger.register(),
			this.addDisposable(this._remoteAgentsMessenger),
			(this._gitReferenceMessenger = new e1(this._panel)),
			this._gitReferenceMessenger.register(),
			this.addDisposable(this._gitReferenceMessenger),
			this.loadHTML(this._extensionUri)
	}
	static currentPanel
	_panel
	_remoteAgentsMessenger
	_gitReferenceMessenger
	static createOrShow(r, n) {
		if (e.currentPanel) {
			e.currentPanel._panel.reveal(Gu.ViewColumn.Active)
			return
		}
		e.currentPanel = new e(r, n)
	}
	dispose() {
		super.dispose(), (e.currentPanel = void 0), this._panel.dispose()
	}
}
var o1 = class extends lt {
	constructor(r, n) {
		super("Manage Background Agents")
		this._extensionUri = r
		this._apiServer = n
	}
	static commandID = "vscode-augment.open-agent-manager"
	type = "debug"
	run = () => {
		s1.createOrShow(this._extensionUri, this._apiServer)
	}
	canRun() {
		return !0
	}
}
var JG = require("vscode")
var a1 = class extends lt {
		static commandID = "vscode-augment.settings"
		type = "public"
		run() {
			JG.commands.executeCommand("workbench.action.openSettings", "@ext:augment.vscode-augment")
		}
	},
	l1 = class extends lt {
		static commandID = "vscode-augment.keyboard-shortcuts"
		type = "public"
		run() {
			JG.commands.executeCommand("workbench.action.openGlobalKeybindings", "@ext:augment.vscode-augment")
		}
	}
var _xe = require("vscode"),
	wxe = W(require("vscode"))
var c1 = class extends lt {
	static commandID = "vscode-augment.showDocs"
	type = "public"
	async run() {
		await wxe.env.openExternal(_xe.Uri.parse("https://docs.augmentcode.com"))
	}
}
var ss = W(require("vscode"))
var u1 = class e extends z {
	constructor(r, n, i, s, o, a, l) {
		super()
		this._extensionUri = r
		this._config = n
		this._apiServer = i
		this._recentCompletions = o
		this._recentInstructions = a
		this._recentNextEditResults = l
		;(this._panel = ss.window.createWebviewPanel("history", "Augment History", s)),
			(this._panel.iconPath = {
				light: ss.Uri.joinPath(this._extensionUri, "media", "panel-icon-light.svg"),
				dark: ss.Uri.joinPath(this._extensionUri, "media", "panel-icon-dark.svg"),
			}),
			this._panel.onDidDispose(() => {
				this.dispose()
			}),
			this.addDisposables(
				this._panel,
				new ss.Disposable(() => {
					e.currentPanel = void 0
				}),
			),
			this.addDisposable(
				this._recentInstructions.onNewItems((c) => {
					!this._panel ||
						!this._panel.visible ||
						this._panel.webview.postMessage({
							type: "instructions",
							data: [c],
						})
				}),
			),
			this.addDisposable(
				this._recentNextEditResults.onNewItems((c) => {
					!this._panel ||
						!this._panel.visible ||
						this._panel.webview.postMessage({
							type: "next-edit-suggestions",
							data: c,
						})
				}),
			),
			this.addDisposable(
				this._recentCompletions.onNewItems(async (c) => {
					await this.sendCompletions()
				}),
			),
			this.addDisposable(
				this._config.onDidChange(async () => {
					await this.sendConfig()
				}),
			),
			this._panel.webview.onDidReceiveMessage(async (c) => {
				if (!(!this._panel || !this._panel.visible))
					switch (c.type) {
						case "history-loaded":
							await this._postMessage({
								type: "history-initialize",
								data: {
									config: this._config.config,
									completionRequests: this._getCompletions(),
									instructions: this._recentInstructions.items.slice(),
									nextEdits: this._recentNextEditResults.items.slice(),
								},
							})
							break
						case "copy-request-id-to-clipboard":
							await ss.env.clipboard.writeText(c.data),
								await ss.window.showInformationMessage("Copied request ID to clipboard")
							break
						case "open-file": {
							iA(c.data, this._panel.viewColumn)
							break
						}
						case "completion-rating": {
							let u = !0
							try {
								await this._apiServer.completionFeedback(c.data)
							} catch (f) {
								;(u = !1), ss.window.showErrorMessage(`Failed to submit feedback: ${f.message}`)
							} finally {
								this._panel.webview.postMessage({
									type: "completion-rating-done",
									data: { success: u, requestId: c.data.requestId },
								})
							}
							break
						}
						case "next-edit-rating": {
							let u = !0
							try {
								await this._apiServer.nextEditFeedback(c.data)
							} catch (f) {
								;(u = !1), ss.window.showErrorMessage(`Failed to submit feedback: ${f.message}`)
							} finally {
								this._panel.webview.postMessage({
									type: "next-edit-rating-done",
									data: { success: u, requestId: c.data.requestId },
								})
							}
							break
						}
					}
			}),
			this._setHTML()
	}
	static currentPanel
	_panel
	async _setHTML() {
		let r = this._panel.webview,
			n = ss.Uri.joinPath(this._extensionUri, "common-webviews")
		;(r.options = { enableScripts: !0, localResourceRoots: [n] }),
			(this._panel.webview.html = await this._getHtmlForWebview(n, this._panel.webview))
	}
	async _getHtmlForWebview(r, n) {
		let i = ss.Uri.joinPath(r, "history.html").fsPath,
			s = Xy(),
			o = wl(Sl(n), tF(s), Bl(), Dl(), Il())
		return (await Fr(i)).replace(
			/<head>/i,
			`<head><base href="${n
				.asWebviewUri(ss.Uri.joinPath(r, "/"))
				.toString()}" /><meta http-equiv="Content-Security-Policy" content="${o}">`,
		)
	}
	async _postMessage(r) {
		!this._panel || !this._panel.visible || (await this._panel.webview.postMessage(r))
	}
	async sendCompletions() {
		await this._postMessage({
			type: "completions",
			data: this._getCompletions(),
		})
	}
	_getCompletions() {
		return this._recentCompletions.items.map((r) => ({
			occuredAt: r.occuredAt.toISOString(),
			requestId: r.requestId,
			repoRoot: r.repoRoot,
			pathName: r.pathName,
			prefix: r.prefix,
			completions: r.completions.map((n) => ({
				text: n.completionText,
				skippedSuffix: n.skippedSuffix,
				suffixReplacementText: n.suffixReplacementText,
			})),
			suffix: r.suffix,
		}))
	}
	async sendConfig() {
		await this._postMessage({
			type: "history-config",
			data: this._config.config,
		})
	}
	static createOrShow(r, n, i, s, o, a) {
		if (e.currentPanel) {
			e.currentPanel._panel.reveal(ss.ViewColumn.Beside)
			return
		}
		e.currentPanel = new e(r, n, i, ss.ViewColumn.Beside, s, o, a)
	}
}
var d1 = class extends lt {
	constructor(r, n, i, s, o, a) {
		super()
		this._extensionUri = r
		this._config = n
		this._apiServer = i
		this._recentCompletions = s
		this._recentInstructions = o
		this._recentNextEditResults = a
	}
	static commandID = "vscode-augment.showHistoryPanel"
	type = "public"
	run() {
		u1.createOrShow(
			this._extensionUri,
			this._config,
			this._apiServer,
			this._recentCompletions,
			this._recentInstructions,
			this._recentNextEditResults,
		)
	}
}
var hC = W(require("vscode"))
var f1 = class extends lt {
	constructor(r, n, i) {
		super()
		this._extension = r
		this._context = n
		this._commandManager = i
	}
	static commandID = "vscode-augment.showAugmentCommands"
	type = "public"
	async run() {
		let r = this._context.extension.packageJSON?.contributes?.commands
		if (!r) return
		let n = Object.fromEntries(r.map(({ command: a, title: l }) => [a, l]))
		for (let a of this._commandManager.availableCommands) {
			let l = a.title || n[a.commandID]
			l && (n[a.commandID] = l)
		}
		let i = {}
		if (this._extension.keybindingWatcher)
			for (let a of Object.keys(n)) {
				let l = this._extension.keybindingWatcher.getKeybindingForCommand(a, !0)
				l && (i[a] = `${l}`)
			}
		let s = this.getActions(n, i),
			o = await hC.window.showQuickPick(s, { title: "Augment Commands" })
		o && o.commandID && hC.commands.executeCommand(o.commandID)
	}
	getActions(r, n) {
		let i = []
		for (let { name: s, commands: o } of this._commandManager.availableCommandGroups) {
			let a = o.filter((l) => r[l.commandID])
			if (a.length !== 0) {
				i.length > 0 && i.push({ label: s, kind: hC.QuickPickItemKind.Separator })
				for (let l of a)
					l.showInActionPanel &&
						i.push({
							commandID: l.commandID,
							label: r[l.commandID],
							description: n[l.commandID],
						})
			}
		}
		return Promise.resolve(i)
	}
}
var Ixe = W(require("path")),
	Mi = W(require("vscode"))
var zG = W(ZA()),
	h1 = W(require("vscode"))
var gC = class e extends z {
	constructor(r, n, i) {
		super()
		this._workspaceManager = r
		this._webview = n
		this._featureFlagManager = i
		;(this._asyncMsgHandler = Ti(this._webview)),
			this.addDisposable(
				this._featureFlagManager.subscribe(["enableWorkspaceManagerUi"], this._registerAllHandlers.bind(this)),
			),
			this._registerAllHandlers()
	}
	_logger = X("WorkspaceUIModel")
	_asyncMsgHandler
	_registerAllHandlers() {
		this._featureFlagManager.currentFlags.enableWorkspaceManagerUi &&
			(this._setupWorkspaceListeners(),
			this.addDisposable(this._asyncMsgHandler),
			this.addDisposable(this._webview.onDidReceiveMessage(this.onDidReceiveMessage)),
			this._asyncMsgHandler.registerHandler(
				"ws-context-get-source-folders-request",
				this.getSourceFoldersHandler,
			),
			this._asyncMsgHandler.registerHandler("ws-context-get-children-request", this.getChildrenHandler))
	}
	_setupWorkspaceListeners() {
		this.addDisposable(
			this._workspaceManager.onDidChangeSourceFolders(
				(0, zG.default)(
					() => {
						this._webview.postMessage({
							type: "ws-context-source-folders-changed",
						})
					},
					500,
					{ leading: !0, trailing: !0 },
				),
			),
		),
			this.addDisposable(
				this._workspaceManager.onDidChangeSourceFolderContents(
					(0, zG.default)(
						(r) => {
							this._webview.postMessage({
								type: "ws-context-folder-contents-changed",
								data: r,
							})
						},
						500,
						{ leading: !0, trailing: !0 },
					),
				),
			)
	}
	getSourceFoldersHandler = () => {
		let r = this._workspaceManager.listSourceFolders().sort((n, i) => n.name.localeCompare(i.name))
		return {
			type: "ws-context-get-source-folders-response",
			data: { workspaceFolders: r.map(e.makeWSContextSourceFolder) },
		}
	}
	getChildrenHandler = (r) => {
		let n = this._workspaceManager
			.listChildren(r.data.fileId.folderRoot, r.data.fileId.relPath)
			.sort((i, s) => i.name.localeCompare(s.name))
		return {
			type: "ws-context-get-children-response",
			data: { children: n.map(e.makeWSContextFileItem) },
		}
	}
	static getInclusionState(r) {
		return r.included ? (r.type === "Directory" && r.containsExcludedItems ? "partial" : "included") : "excluded"
	}
	static makeWSContextFileItem = (r) => ({
		name: r.name,
		fileId: { folderRoot: r.folderRoot, relPath: r.relPath },
		type: r.type === "Directory" ? "folder" : "file",
		inclusionState: e.getInclusionState(r),
		reason: r.reason,
		trackedFileCount: r.type === "Directory" ? r.trackedFileCount : void 0,
	})
	static makeWSContextSourceFolder = (r) => ({
		name: r.name,
		fileId: { folderRoot: r.folderRoot, relPath: "" },
		inclusionState: r.containsExcludedItems ? "partial" : "included",
		isWorkspaceFolder: r.type === 0 || r.type === 2,
		isNestedFolder: r.type === 2 || r.type === 3,
		isPending: r.enumerationState === 0,
		trackedFileCount: r.type === 0 || r.type === 1 ? r.trackedFileCount : void 0,
	})
	onDidReceiveMessage = async (r) => {
		switch ((this._logger.debug(`Extension received message: ${r.type}`), r.type)) {
			case "ws-context-add-more-source-folders": {
				let n = await h1.window.showOpenDialog({
					canSelectFolders: !0,
					canSelectFiles: !1,
					canSelectMany: !0,
					openLabel: "Add Source Folder",
				})
				if (n && n.length > 0) {
					let i = n
						.map((s) => {
							try {
								return this._workspaceManager.addExternalSourceFolder(s), null
							} catch (o) {
								return (
									this._logger.error("Failed to add source folder:", o),
									o instanceof Error
										? { path: s.fsPath, message: o.message }
										: { path: s.fsPath, message: String(o) }
								)
							}
						})
						.filter((s) => s !== null)
					i.length > 0 &&
						h1.window.showErrorMessage(
							`One or more source folders could not be added:
` +
								i.map((s) => `${s.path}: ${s.message}`).join(`
`),
						)
				}
				break
			}
			case "ws-context-remove-source-folder": {
				try {
					this._workspaceManager.removeExternalSourceFolder(r.data)
				} catch (n) {
					let i = n
					n instanceof Error && (i = n.message),
						this._logger.error("Failed to remove source folder:", i),
						h1.window.showErrorMessage(`Failed to remove source folder ${r.data}:
 ${String(i)}`)
				}
				break
			}
			case "ws-context-user-requested-refresh": {
				this._workspaceManager.refreshSourceFolders()
				break
			}
		}
	}
}
var jG = 1,
	Ml = class extends Error {
		constructor(t) {
			super(t), (this.name = "ToolConfigError")
		}
	}
var b_ = class extends Ml {
	constructor(t) {
		super(`Failed to parse tool config: ${t}`), (this.name = "ToolConfigParseError")
	}
}
var g1 = class e extends z {
	constructor(r, n, i, s) {
		super()
		this._extensionUri = r
		this._extension = n
		this._apiServer = i
		this._config = s
		;(this._store = this._extension.toolConfigStore),
			(this._featureFlagManager = this._extension.featureFlagManager),
			(this._panel = Mi.window.createWebviewPanel(e.viewType, "Augment Settings", Mi.ViewColumn.Active, {
				retainContextWhenHidden: !0,
				enableScripts: !0,
			})),
			(this._panel.iconPath = {
				light: Mi.Uri.joinPath(this._extensionUri, "media", "panel-icon-light.svg"),
				dark: Mi.Uri.joinPath(this._extensionUri, "media", "panel-icon-dark.svg"),
			}),
			this._panel.onDidDispose(() => {
				this.dispose()
			}),
			this.addDisposables(
				this._panel,
				new Mi.Disposable(() => {
					e.currentPanel = void 0
				}),
			),
			this.addDisposable(
				this._panel.webview.onDidReceiveMessage(async (o) => {
					try {
						switch (o.type) {
							case "tool-config-loaded":
								await this._handleConfigLoaded()
								break
							case "tool-config-save":
								await this._handleConfigSave(o.data)
								break
							case "tool-config-get-definitions":
								await this._handleGetDefinitions(o)
								break
							case "tool-config-start-oauth":
								await this._handleStartOAuth(o.data)
								break
							case "tool-config-revoke-access":
								await this._handleRevokeAccess(o.data)
								break
							case "get-storage-value":
								await this._handleGetStorageValue(o.data)
								break
							case "set-storage-value":
								await this._handleSetStorageValue(o.data)
								break
							case "execute-initial-orientation":
								await this._handleExecuteInitialOrientation()
								break
						}
					} catch (a) {
						this._handleError(a)
					}
				}),
			),
			this._extension.workspaceManager &&
				((this._workspaceUiModel = new gC(
					this._extension.workspaceManager,
					this._panel.webview,
					this._extension.featureFlagManager,
				)),
				this.addDisposable(this._workspaceUiModel)),
			this._setHTML()
	}
	static viewType = "augmentSettingsPanel"
	_logger = X("SettingsWebviewPanel")
	static currentPanel
	_panel
	_workspaceUiModel = null
	static mcpServersKey = "mcpServers"
	_store
	_featureFlagManager
	dispose = () => {
		this._panel.dispose(), (e.currentPanel = void 0), super.dispose()
	}
	_handleError(r) {
		r instanceof Ml
			? Mi.window.showErrorMessage(r.message)
			: Mi.window.showErrorMessage(`Unexpected error: ${Ye(r)}`)
	}
	async _setHTML() {
		let r = this._panel.webview,
			n = Mi.Uri.joinPath(this._extensionUri, "common-webviews")
		r.options = { enableScripts: !0, localResourceRoots: [n] }
		let i = r.asWebviewUri(Mi.Uri.joinPath(n, "/")),
			s = wl(Sl(r), Il(), Bl(), Dl(), Wy()),
			o = await Fr(Ixe.join(n.fsPath, "settings.html"))
		;(o = o.replace(
			/<head>/i,
			`<head>
            <base href="${i.toString()}" />
            <meta http-equiv="Content-Security-Policy" content="${s}">
        `,
		)),
			(r.html = o)
	}
	async _handleConfigLoaded() {
		try {
			let r = await this._store.get(),
				n = this._getEnableAgentMode(),
				i = [],
				s = []
			n &&
				((i = await (this._extension.toolsModel?.getToolStatusForSettingsPanel() ?? Promise.resolve([]))),
				(s = r.tools.map((o) => ({
					config: JSON.stringify(o.config, null, 2),
					isConfigured: o.isConfigured,
					name: o.name,
				})))),
				await this._postMessage({
					type: "tool-config-initialize",
					data: {
						toolConfigs: s,
						hostTools: i,
						enableDebugFeatures: this._config.config.enableDebugFeatures,
						enableAgentMode: n,
					},
				}),
				await this._handleGetStorageValue({ key: e.mcpServersKey })
		} catch (r) {
			this._handleError(r)
		}
	}
	async _handleConfigSave(r) {
		try {
			let n = await this._store.get(),
				i
			try {
				i = JSON.parse(r.toolConfig)
			} catch (a) {
				throw (this._logger.error(`Failed to parse tool config: ${Ye(a)}`), new b_(Ye(a)))
			}
			let s = { config: i, isConfigured: r.isConfigured, name: r.toolName },
				o = n.tools.findIndex((a) => a.name === r.toolName)
			o >= 0 ? (n.tools[o] = s) : n.tools.push(s), await this._store.save(n)
		} catch (n) {
			throw (this._logger.error(`Error saving tool configuration: ${Ye(n)}`), new b_(Ye(n)))
		}
	}
	async _handleGetDefinitions(r) {
		let n = !!r?.data?.useCache,
			i = []
		this._getEnableAgentMode() &&
			(i = await (this._extension.toolsModel?.getToolStatusForSettingsPanel(n) ?? Promise.resolve([]))),
			await this._postMessage({
				type: "tool-config-definitions-response",
				data: { hostTools: i },
			})
	}
	async _handleStartOAuth(r) {
		let n = !1
		try {
			let i = r.authUrl,
				s = Mi.Uri.parse(i)
			;(n = await Mi.env.openExternal(s)), n || this._logger.warn(`Failed to open URL: ${i}`)
		} catch (i) {
			this._logger.error(`Error opening URL: ${Ye(i)}`)
		} finally {
			await this._postMessage({
				type: "tool-config-start-oauth-response",
				data: { ok: n },
			})
		}
	}
	async _handleRevokeAccess(r) {
		try {
			let i = (await (this._extension.toolsModel?.getToolStatusForSettingsPanel() ?? Promise.resolve([]))).find(
				(s) => s.identifier.hostName === r.toolId.hostName && s.identifier.toolId === r.toolId.toolId,
			)
			if (i && i.identifier.hostName === Ro.remoteToolHost) {
				let s = i.identifier.toolId
				this._logger.info(`Revoking access for remote tool: ${i.definition.name} (${s})`)
				let o
				try {
					o = await this._apiServer.revokeToolAccess(s)
				} catch (a) {
					this._logger.error(`API error revoking access: ${Ye(a)}`),
						Mi.window.showErrorMessage(`Error revoking access: ${Ye(a)}`)
					return
				}
				switch (o.status) {
					case 3:
						this._logger.info(`Successfully revoked access for ${i.definition.name} (${s}).`),
							await this._handleGetDefinitions()
						break
					case 4:
						this._logger.info(`Tool ${i.definition.name} (${s}) has no access to revoke.`),
							await this._handleGetDefinitions()
						break
					case 1:
						this._logger.warn(`Revoking access is not implemented for ${i.definition.name} (${s}).`),
							Mi.window.showWarningMessage(
								`Revoking access is not implemented for ${i.definition.name} (${s}).`,
							)
						break
					case 2:
						throw new Ml(`Tool not found: ${i.definition.name} (${s}).`)
					case 5:
						throw new Ml(`Failed to revoke access for ${i.definition.name} (${s}).`)
					default:
						throw new Ml(
							`Unknown status (${o.status}) when revoking access for ${i.definition.name} (${s}).`,
						)
				}
			} else throw new Ml(`Tool not found: ${r.toolId.hostName} ${r.toolId.toolId}`)
		} catch (n) {
			this._logger.error(`Error revoking access: ${Ye(n)}`), this._handleError(n)
		}
	}
	async _handleGetStorageValue(r) {
		try {
			if (r.key === e.mcpServersKey) {
				let n = await this._store.getMCPServers()
				await this._postMessage({
					type: "storage-value-response",
					data: { key: r.key, value: n },
				})
			}
		} catch (n) {
			this._logger.error(`Error getting storage value: ${Ye(n)}`), this._handleError(n)
		}
	}
	async _handleSetStorageValue(r) {
		try {
			r.key === e.mcpServersKey && (await this._store.saveMCPServers(r.value))
		} catch (n) {
			this._logger.error(`Error setting storage value: ${Ye(n)}`), this._handleError(n)
		}
	}
	async _postMessage(r) {
		try {
			return await this._panel.webview.postMessage(r), !0
		} catch (n) {
			return this._logger.error(`Failed to post message to webview: ${Ye(n)}`), !1
		}
	}
	async _handleExecuteInitialOrientation() {
		try {
			await Mi.commands.executeCommand(aC.commandID)
		} catch (r) {
			this._logger.error(`Failed to execute initial orientation: ${Ye(r)}`), this._handleError(r)
		}
	}
	_getEnableAgentMode() {
		return Gr(this._featureFlagManager.currentFlags.vscodeAgentModeMinVersion ?? "")
	}
	static createOrShow(r, n, i, s) {
		return e.currentPanel
			? (e.currentPanel._panel.reveal(), e.currentPanel)
			: ((e.currentPanel = new e(r, n, i, s)), e.currentPanel)
	}
}
var p1 = class extends lt {
	constructor(r, n, i, s) {
		super("Show Settings Panel", !1)
		this._extensionUri = r
		this._extension = n
		this._apiServer = i
		this._config = s
	}
	static commandID = "vscode-augment.showSettingsPanel"
	type = "public"
	run() {
		g1.createOrShow(this._extensionUri, this._extension, this._apiServer, this._config)
	}
}
var A1 = class extends lt {
	constructor(r) {
		super()
		this._chatExtensionEvent = r
	}
	static commandID = "vscode-augment.startNewChat"
	type = "public"
	async run() {
		await nf("Start chat command"), this._chatExtensionEvent.fire("newThread")
	}
}
var Sxe = W(require("vscode"))
var pC = class extends lt {
	static commandID = "_vscode-augment.statusbarClick"
	type = "private"
	constructor() {
		super(void 0, !1)
	}
	async run() {
		await Sxe.commands.executeCommand("augment-chat.focus")
	}
}
var x_ = require("vscode")
var m1 = class e extends Jo {
	constructor(r, n) {
		super(n, () =>
			this._configListener.config.completions.enableAutomaticCompletions
				? "Turn Automatic Completions Off"
				: "Turn Automatic Completions On",
		)
		this._configListener = r
	}
	static commandID = "vscode-augment.toggleAutomaticCompletionSetting"
	static autoCompletionsConfigKey = "completions.enableAutomaticCompletions"
	type = "public"
	run() {
		let r = x_.workspace.getConfiguration("augment"),
			n = r.inspect(e.autoCompletionsConfigKey),
			i = x_.ConfigurationTarget.Global
		n?.workspaceValue !== void 0 && (i = x_.ConfigurationTarget.Workspace),
			r.update(e.autoCompletionsConfigKey, !this._configListener.config.completions.enableAutomaticCompletions, i)
	}
	canRun() {
		return super.canRun()
	}
}
function Bxe(e, t, r, n, i, s, o, a, l, c, u, f, p) {
	let g = new iM(r)
	return (
		g.registerGroup("", [new aA(n, i, aA.signInCommandID, "$(sign-in) Sign In"), new Hi(), new $F(f, r, t)]),
		g.registerGroup("Completions", [new jF(t, f), new m1(r, f)]),
		g.registerGroup("Code Instruction", [new $y(t, e.extensionUri, s, t.guidelinesWatcher, f)]),
		g.registerGroup("Chat", [
			new Gh(t, r, u, f),
			new iC(t, r, u, f),
			new A1(u),
			new sC(t, r, u, f),
			new oC(t, r, u, f),
			new hF(u, p),
			new aC(t, s, f),
			new p1(e.extensionUri, t, s, r),
		]),
		g.registerGroup("Next Edit Suggestions", [
			new Dc(t, r, f),
			new Tc(t, r, f),
			new uA(t, r, f),
			new dA(t, r, f),
			new Uu(t, r, f),
			new Ou(t, r, f),
			new Xo(t, r, f),
			new Fa(t, r, f),
			new AF(t, r, f),
			new bF(t, r, f),
			new mF(t, r, f),
			new Yh(t, r, f),
			new h_(t, r, f),
			new SF(t, r, f),
			new IF(t, r, f),
			new BF(t, r, f, p),
			new VF(t, r),
			new yF(t, r, f),
			new CF(t, r, f),
			new vF(t, r, f),
			new sf(t, r, f),
			new EF(t, r, f),
			new qu(t, r, f),
			new _F(t, r, f),
			new xF(t, r, f),
			new Co(t, r, f),
			new cC(t, r, f),
		]),
		g.registerGroup("Debug", [
			new KF(t, r),
			new ZF(t, r),
			new pA(t.featureFlagManager),
			new GF(t.featureFlagManager),
		]),
		r.config.remoteAgent.url && g.register([new o1(e.extensionUri, s)]),
		g.registerGroup("", [
			new a1(),
			new l1(),
			new YF(f, r, t),
			new c1(),
			new d1(e.extensionUri, r, s, o, a, l),
			new HF(s),
			new df(t, df.commandIDCommunity),
			new df(t, df.commandIDProfessional),
			new df(t, df.commandIDEnterprise),
			new aA(n, i, aA.signOutCommandID, "$(sign-out) Sign Out"),
			new DF(t, r, f),
		]),
		r.config.autofix.enabled && r.config.autofix.autofixUrl && g.register([new gF(t, s)]),
		g.register([
			new f1(t, e, g),
			new wF(t, r, f),
			new rC(t.featureFlagManager, c),
			new zF(t, s, r),
			new nF(t, e.extensionUri, s),
			new Yy(),
			new Ky(),
			new Jy(),
			new zy(),
			new jy(),
			new Zy(),
			new pC(),
		]),
		g
	)
}
var y1 = class e {
	constructor(t, r, n, i, s = e.chunkSize) {
		this._apiServer = t
		;(this._completionTimeoutMs = r), (this._completionParams = { prefixSize: n, suffixSize: i, chunkSize: s })
	}
	static chunkSize = 1024
	_completionTimeoutMs
	_completionParams
	createRequestId() {
		return this._apiServer.createRequestId()
	}
	get completionParams() {
		return this._completionParams
	}
	async complete(t, r, n, i, s, o, a, l, c, u, f, p, g) {
		let m = await this._apiServer.complete(t, r, n, i, s, o, a, l, c, u, f, p, g)
		return (
			m.completionTimeoutMs !== void 0 && (this._completionTimeoutMs = m.completionTimeoutMs),
			m.suggestedPrefixCharCount !== void 0 && (this._completionParams.prefixSize = m.suggestedPrefixCharCount),
			m.suggestedSuffixCharCount !== void 0 && (this._completionParams.suffixSize = m.suggestedSuffixCharCount),
			m.suggestedPrefixCharCount !== void 0 && (this._completionParams.chunkSize = e.chunkSize),
			m
		)
	}
}
var Rxe = W(gs()),
	Fc = W(require("vscode"))
var ff = class {
	constructor(t, r, n, i) {
		this.completionText = t
		this.suffixReplacementText = r
		this.skippedSuffix = n
		this.range = i
	}
	toString() {
		return `text: ${this.completionText}
    suffixReplacementText: ${this.suffixReplacementText}
    skippedSuffix: ${this.skippedSuffix}
    start: ${this.range.startOffset}
    end: ${this.range.endOffset}`
	}
}
function C1(e, t, r) {
	let n = "",
		i = t.completionText,
		s = e.document,
		o = s.offsetAt(r) - t.range.startOffset
	return (
		o < 0 ? (n = e.prefix.slice(o)) : (i = i.slice(o)),
		new ff(n + i, t.suffixReplacementText, t.skippedSuffix, {
			startOffset: s.offsetAt(r),
			endOffset: t.range.endOffset,
		})
	)
}
function Dxe(e, t) {
	return `context:
    text: ${t.selectedCompletionInfo?.text}
    range: ${AC(e, t.selectedCompletionInfo?.range)}
    triggerKind: ${t.triggerKind}`
}
function Txe(e) {
	return `context:
    text: ${e.triggerCharacter}
    triggerKind: ${e.triggerKind}`
}
function Zh(e, t) {
	return `ln: ${t.line} ch: ${t.character} offset: ${e.offsetAt(t)}`
}
function AC(e, t) {
	return t === void 0 ? "<undefined>" : `start: ${Zh(e, t.start)} -> end: ${Zh(e, t.end)}`
}
function v1(e, t) {
	return t ? `${e}'${t}'` : ""
}
var mC = class {
	constructor(t) {
		this._config = t
		this._documentation.isTrusted = !0
	}
	_logger = X("CompletionItemsProvider")
	_documentation = new Fc.MarkdownString(`This is a suggestion from Augment.

You can let us know about good or bad suggestions via [the History Panel](command:vscode-augment.showHistoryPanel).`)
	static triggerCharacters = [".", ":"]
	static languageSelector = [
		"python",
		"typescript",
		"javascript",
		"java",
		"go",
		"rust",
		"c",
		"cpp",
		"php",
		"csharp",
		"ruby",
		"bash",
		"html",
		"css",
		"scss",
		"less",
		"sass",
		"json",
		"yaml",
		"markdown",
		"xml",
		"sql",
		"swift",
		"kotlin",
		"objective-c",
		"perl",
		"scala",
		"lua",
		"groovy",
		"powershell",
		"*",
	]
	async provideCompletionItems(t, r, n, i) {
		if (
			(this._logger.debug(`Pop-Up Request - ${t.uri.toString()} ${Zh(t, r)}${v1(" ", i.triggerCharacter)}`),
			this._logger.verbose(Txe(i)),
			i.triggerKind === Fc.CompletionTriggerKind.TriggerCharacter)
		)
			return this._logger.debug("Returning no completions because trigger kind was a trigger character"), []
		if (!this._config.config.completions.enableAutomaticCompletions)
			return this._logger.debug("Automatic completions are disabled"), []
		let s, o
		try {
			return await Promise.race([
				this._getCompletions(t, r, n),
				new Promise((a) => {
					let c = (0, Rxe.debounce)(
						() => {
							this._logger.warn("Failed to find completions in time"), a([])
						},
						this._config.config.completions.timeoutMs,
						{ maxWait: this._config.config.completions.maxWaitMs },
					)
					;(o = mA(() => {
						c()
					})),
						(s = c),
						c()
				}),
			])
		} finally {
			o?.dispose(), s?.cancel()
		}
	}
	_getCompletionSuffix(t, r) {
		let n = r.substring(t.length, t.length + 50)
		if (n.length === 0) return ""
		let i = n.match(/^[^{}\[\]\(\)"`'<>]+/)
		return i ? (i[0] === n ? n : i[0] + "\u2026") : "\u2026"
	}
	async _getCompletions(t, r, n) {
		let i = await Iu(Mc)
		if (!this._config.config.completions.enableQuickSuggestions)
			return this._logger.debug("Enable IntelliSense suggestion is disabled"), []
		if (!i) return this._logger.debug("No completion request"), []
		if (t !== i.document)
			return (
				this._logger.debug(
					`Completion request document does not match the current document.     current document: ${t.uri.toString()}     completion request document: ${i.document.uri.toString()}`,
				),
				[]
			)
		let s = []
		for (let o of i.completions) {
			this._logger.verbose(`AugmentCompletion: ${o.toString()}`)
			let a = t.getWordRangeAtPosition(r)?.start ?? r,
				l = C1(i, o, a),
				c = t.offsetAt(r)
			if (c < l.range.startOffset || c > l.range.endOffset) {
				this._logger.debug(
					`Inline provider event does not satisfy this requests position.     completion item: ${Zh(
						t,
						r,
					)}    inline provider event: ${l.range.startOffset} => ${l.range.endOffset}}`,
				)
				continue
			}
			let u = t.offsetAt(r) - t.offsetAt(a),
				f = (l.completionText + l.suffixReplacementText).slice(u),
				p = f.split(/[^a-zA-Z0-9_]/).shift() ?? "",
				g = new Fc.Range(a, r),
				y = t.getText(g) + p + this._getCompletionSuffix(p, f),
				C = new Fc.CompletionItem(y)
			C.insertText = l.completionText + l.suffixReplacementText
			let v = new Fc.Range(
				t.positionAt(l.range.startOffset),
				t.positionAt(t.offsetAt(r) + l.skippedSuffix.length),
			)
			;(C.range = { inserting: v, replacing: v }),
				(C.preselect = !1),
				(C.kind = Fc.CompletionItemKind.Snippet),
				(C.detail = "Augment"),
				(C.documentation = this._documentation),
				(C.keepWhitespace = !0),
				this._logger.debug(`insert: ${C.insertText}
label: ${y}
position: ${Zh(t, r)}
inserting: ${AC(t, C.range.inserting)}
replacing: ${AC(t, C.range.replacing)})}`),
				s.push(C)
		}
		return n.isCancellationRequested ? (this._logger.debug("Completion cancelled"), []) : s
	}
}
var ZG = W(require("vscode"))
function W0t(e, t) {
	return (r) => {
		let n = performance.now() - e
		return t(Math.round(n)), r
	}
}
function kxe(e, t) {
	return (...r) => {
		let n = performance.now(),
			i = W0t(n, t),
			s = e(...r)
		return s instanceof Promise ? s.then(i) : i(s)
	}
}
var E1 = class {
	constructor(t, r, n) {
		this._extension = t
		this._configListener = r
		this._metricsReporter = n
		this.generateCompletion = kxe(this.generateCompletion.bind(this), (i) => {
			this._metricsReporter.report({
				client_metric: "generate_completion_latency",
				value: i,
			})
		})
	}
	_logger = X("CompletionsModel")
	_completionSerial = 0
	async generateCompletion(t, r, n) {
		let i = this._extension.workspaceManager
		if (i === void 0) return
		let s = i.completionServer,
			o = s.createRequestId(),
			a = i.safeResolvePathName(t.uri)
		if (a === void 0) return
		let [l, c] = [a.rootPath, a.relPath],
			u = t.offsetAt(r),
			[f, p, g, m, y] = this._extractPrefixAndSuffix(t, u)
		u += y
		let C = { prefixBegin: g, cursorPosition: u, suffixEnd: m },
			b = (await this._requestCompletion(i, s, o, t, f, p, C, a, n)).completionItems
		if (b.length === 0)
			return {
				completions: [],
				document: t,
				requestId: o,
				repoRoot: l,
				pathName: c,
				prefix: f,
				suffix: p,
				occuredAt: new Date(),
				isReused: !1,
			}
		b.length > 1 && this._logger.warn("Multiple completions not supported, ignoring all but the first")
		let w = [],
			M = b[0]
		return (
			M.skippedSuffix.includes(`
`) &&
				(this._logger.debug("Skipped suffix spans multiple lines, dropping it"),
				(M.skippedSuffix = ""),
				(M.suffixReplacementText = "")),
			w.push(
				new ff(M.text, M.suffixReplacementText, M.skippedSuffix, {
					startOffset: t.offsetAt(r),
					endOffset: t.offsetAt(r),
				}),
			),
			this._logger.debug(`Returning ${w.length} completion(s)`),
			{
				occuredAt: new Date(),
				completions: w,
				document: t,
				requestId: o,
				repoRoot: l,
				pathName: c,
				prefix: f,
				suffix: p,
				isReused: !1,
			}
		)
	}
	async _requestCompletion(t, r, n, i, s, o, a, l, c) {
		let u = i.languageId
		if (this._configListener.config.completions.disableCompletionsByLanguage.has(u))
			throw new bh(`Language ${u} is disabled.`)
		let p = this._completionSerial++
		this._logger.debug(`Requesting new completion - #${p} submitted; requestId: ${n}`)
		let g = t.translateRange(l, a.prefixBegin, a.suffixEnd),
			m =
				g === void 0
					? a
					: {
							prefixBegin: g.beginOffset,
							cursorPosition: a.cursorPosition,
							suffixEnd: g.endOffset,
						},
			y = t.getContext(),
			C = y.blobs,
			v = this._getRecentChanges(y),
			w = t.getEnableCompletionFileEditEvents() ? t.getFileEditEvents() : void 0
		try {
			let B = await r.complete(n, s, o, l.relPath, g?.blobName, m, u, C, v, w, void 0, void 0, c)
			return (
				B.unknownBlobNames.length > 0 && t.handleUnknownBlobs(y, B.unknownBlobNames),
				B.checkpointNotFound && t.handleUnknownCheckpoint(n, C.checkpointId),
				G0t(B.completionItems, o, this._logger),
				this._extension.updateModelInfo(B),
				(B.completionItems = B.completionItems.filter((M) => (M.text + M.suffixReplacementText).length > 0)),
				B
			)
		} catch (B) {
			if (kr.isAPIErrorWithStatus(B, He.cancelled))
				throw (
					(this._logger.debug(`Completion #${p} cancelled in back end; requestId ${n}`),
					new bh("Cancelled in back end"))
				)
			if (kr.isRetriableAPIError(B))
				throw (
					(this._logger.debug(`Completion #${p} retriable error on back end; requestId ${n}`),
					new bh("Retriable error on back end"))
				)
			let M = Ye(B)
			throw (this._logger.warn(`Completion #${p} failed: ${M}; requestId ${n}`), B)
		}
	}
	_extractPrefixAndSuffix(t, r) {
		let n = this._extension.modelInfo,
			i = n.suggestedPrefixCharCount,
			s = n.suggestedSuffixCharCount,
			[o, a] = Dbe(t)
		o !== void 0 && (r += a)
		let l = Math.max(0, r - i),
			c = r + s
		if (o !== void 0) {
			let b = o.slice(l, r),
				w = o.slice(r, c)
			return [b, w, l, r + w.length, a]
		}
		let u = t.positionAt(l),
			f = t.positionAt(r),
			p = t.positionAt(r),
			g = t.positionAt(c),
			m = new ZG.Range(u, f),
			y = new ZG.Range(p, g),
			C = t.getText(m),
			v = t.getText(y)
		return [C, v, l, r + v.length, 0]
	}
	_getRecentChanges(t) {
		let r = t.recentChunks,
			n = t.lastChatResponse
		if (n !== void 0) {
			let i = {
					seq: n.seq,
					uploaded: !1,
					repoRoot: "",
					pathName: "",
					blobName: "",
					text: n.text,
					origStart: 0,
					origLength: 0,
					expectedBlobName: "",
				},
				s = r.findIndex((o) => o.seq < i.seq)
			s < 0 && (s = r.length), (r = r.slice(0, s).concat([i]).concat(r.slice(s)))
		}
		return By(r)
	}
}
function G0t(e, t, r) {
	for (let n of e)
		t.startsWith(n.skippedSuffix) ||
			(r.warn(
				`Skipped suffix does not match the actual suffix. Skipped suffix: ${
					n.skippedSuffix
				}. First ${n.skippedSuffix.length} characters of suffix: ${t.substring(0, n.skippedSuffix.length)}`,
			),
			(n.suffixReplacementText = ""),
			(n.skippedSuffix = ""))
}
var Xh = W(require("vscode"))
var yA = class {
	constructor(t) {
		this._statusBar = t
	}
	_state
	setState(t) {
		return this.dispose(), (this._state = this._statusBar.setState(t)), this._state
	}
	dispose() {
		this._state?.dispose()
	}
}
var __ = require("vscode")
var b1 = ((i) => (
		(i[(i.high = 0)] = "high"),
		(i[(i.medium = 1)] = "medium"),
		(i[(i.low = 2)] = "low"),
		(i[(i.neutral = 3)] = "neutral"),
		i
	))(b1 || {}),
	XG = Object.values(b1)
		.filter((e) => typeof e == "number")
		.sort()
var yC = {
		background: new __.ThemeColor("statusBarItem.warningBackground"),
		foreground: new __.ThemeColor("statusBarItem.warningForeground"),
	},
	e8 = {
		background: new __.ThemeColor("statusBarItem.errorBackground"),
		foreground: new __.ThemeColor("statusBarItem.errorForeground"),
	},
	Mxe = { priority: 3, tooltip: "Augment", icon: "$(augment-icon-simple)" },
	Fxe = { priority: 3, tooltip: "Open Augment", icon: "$(augment-icon-smile)" },
	Qxe = {
		priority: 0,
		tooltip: "Sign in to start using Augment",
		icon: "$(augment-icon-simple)",
		colors: yC,
	},
	Nxe = {
		priority: 2,
		tooltip: "Augment is indexing your codebase",
		icon: "$(sync)",
	},
	Pxe = {
		priority: 0,
		tooltip: "No API token",
		icon: "$(augment-icon-simple)",
		colors: yC,
	},
	Lxe = {
		priority: 0,
		tooltip: "No completion URL",
		icon: "$(augment-icon-simple)",
		colors: yC,
	},
	Uxe = {
		priority: 2,
		tooltip: "Initializing Augment",
		icon: "$(loading~spin)",
	},
	Oxe = {
		priority: 0,
		tooltip: "Authentication failed, please sign in again",
		icon: "$(augment-icon-simple)",
		colors: yC,
	},
	qxe = {
		priority: 0,
		tooltip: "Authentication failed, please check your API token and completion URL",
		icon: "$(augment-icon-simple)",
		colors: yC,
	},
	Vxe = {
		priority: 0,
		tooltip: "The completion URL setting is invalid. Please enter a valid value",
		icon: "$(augment-icon-simple)",
		colors: yC,
	},
	Hxe = {
		priority: 2,
		tooltip: "Automatic completions are off",
		icon: "$(augment-icon-closed-eyes)",
	},
	Wxe = {
		priority: 1,
		tooltip: "Enhancements are off",
		icon: "$(augment-icon-simple)",
	},
	t8 = {
		priority: 0,
		tooltip: "Cannot connect to Augment",
		icon: "$(augment-icon-simple)",
		colors: e8,
	},
	Gxe = {
		priority: 0,
		tooltip: "Failed to generate completion",
		icon: "$(augment-icon-simple)",
		colors: e8,
	},
	$xe = {
		priority: 1,
		tooltip: "Generating completion",
		icon: "$(augment-icon-dots)",
	},
	Yxe = {
		priority: 2,
		tooltip: "No completions generated",
		icon: "$(augment-icon-zero)",
	},
	Kxe = {
		priority: 0,
		tooltip: "Failed to generate suggestions",
		icon: "$(augment-icon-simple)",
		colors: e8,
	},
	Jxe = {
		priority: 1,
		tooltip: "Generating suggestions",
		icon: "$(augment-icon-dots)",
	},
	zxe = {
		priority: 2,
		tooltip: "No suggestions generated",
		icon: "$(augment-icon-zero)",
	},
	jxe = {
		priority: 0,
		tooltip: "Workspace indexing is disabled",
		icon: "$(circle-slash)",
	}
var x1 = class {
	rpcStart
	rpcEnd
	constructor() {}
}
var _1 = class extends x1 {
	requestStart
	emitTime
	constructor(t = Date.now(), r, n, i) {
		super(), (this.requestStart = t), (this.rpcStart = r), (this.rpcEnd = n), (this.emitTime = i)
	}
	isComplete() {
		return [this.rpcStart, this.rpcEnd, this.emitTime].every((r) => r !== void 0)
	}
}
var I_ = W(require("vscode"))
var w1 = class extends z {
	constructor(r) {
		super()
		this._metricsReporter = r
		this.addDisposables(
			I_.workspace.onDidChangeTextDocument((n) => {
				this._onTextDocumentChange(n)
			}),
			I_.window.onDidChangeActiveTextEditor(() => {
				this._rejectPendingCompletion()
			}),
			I_.window.onDidChangeWindowState(() => {
				this._rejectPendingCompletion()
			}),
			Mc((n) => {
				n && this._onNewCompletion(n)
			}),
		)
	}
	_logger = X("PendingCompletion")
	_pendingCompletion
	getPendingCompletion(r, n) {
		if (!this._pendingCompletion) {
			this._logger.verbose("No previous completion to use")
			return
		}
		if (this._pendingCompletion.document !== r) {
			this._logger.debug(
				`Not reusing previous completion as documents differ ${this._pendingCompletion.document.uri.toString()} vs ${r.uri.toString()}`,
			),
				this._rejectPendingCompletion()
			return
		}
		let i = this._pendingCompletion.completion,
			s = r.offsetAt(n),
			o = i.range.endOffset + this._pendingCompletion.added
		if (s < i.range.startOffset) {
			this._logger.debug(`Not reusing previous completion as position is before completion: ${s} vs
                ${i.range.startOffset}`),
				this._rejectPendingCompletion()
			return
		}
		if (s > o) {
			this._logger.debug(`Not reusing previous completion as position is after completion: ${s} vs
                ${o}`),
				this._rejectPendingCompletion()
			return
		}
		let a = i.skippedSuffix,
			l = i.completionText,
			c = i.suffixReplacementText
		this._pendingCompletion.deleted > 0 && (a = a.slice(this._pendingCompletion.deleted)),
			a === "" && ((l = l + c), (c = ""))
		let u = new ff(l, c, a, { startOffset: i.range.startOffset, endOffset: o })
		return (
			this._logger.verbose(`Reusing pending completion: ${u.completionText}`),
			{ ...this._pendingCompletion, completions: [u], isReused: !0 }
		)
	}
	_onNewCompletion(r) {
		let { completions: n, requestId: i } = r
		if (this._pendingCompletion?.requestId === i) return
		if (!n.length) {
			this._logger.verbose(`No completions in ${i}`), this._rejectPendingCompletion()
			return
		}
		if (n.length !== 1) {
			this._logger.warn(`Unable to handle multiple completions, received ${n.length}`),
				this._rejectPendingCompletion()
			return
		}
		let s = this._findLastMatches(n[0])
		if (!s) {
			this._logger.verbose(`Skipped suffix is not a subsequence of the suffix replacement text:
                ${n[0].skippedSuffix} !<= ${n[0].suffixReplacementText}`),
				this._rejectPendingCompletion()
			return
		}
		this._logger.verbose(`Registering pending completion: ${n[0].completionText}`),
			(this._pendingCompletion = {
				...r,
				completion: this._stripCommonSkippedSuffix(n[0]),
				added: 0,
				deleted: 0,
				suffixMatches: s,
				emitTime: Date.now(),
			})
	}
	_findLastMatches(r) {
		let n = r.skippedSuffix,
			i = r.suffixReplacementText,
			s = [],
			o = n.length - 1,
			a = i.length - 1
		for (; o >= 0 && a >= 0; ) n[o] === i[a] && (s.push(a), o--), a--
		if (!(o >= 0)) return s.reverse()
	}
	_stripCommonSkippedSuffix(r) {
		let n = r.skippedSuffix,
			i = r.suffixReplacementText,
			s = 0
		for (; s < n.length && s < i.length && n[n.length - 1 - s] === i[i.length - 1 - s]; ) s++
		return s === 0 ? r : new ff(r.completionText, i.slice(0, -s), n.slice(0, -s), r.range)
	}
	_onTextDocumentChange(r) {
		if (
			!this._pendingCompletion ||
			this._pendingCompletion.document !== r.document ||
			r.contentChanges.length === 0
		)
			return
		if (r.contentChanges.length > 1) {
			this._logger.verbose(`Unexpected number of content changes: ${r.contentChanges.length}`),
				this._rejectPendingCompletion()
			return
		}
		let n = this._normalizeChange(r.contentChanges[0])
		if (!n) {
			this._logger.verbose(`Unexpected content change: ${JSON.stringify(r.contentChanges[0])}`),
				this._rejectPendingCompletion()
			return
		}
		let i = this._pendingCompletion.added,
			s = this._pendingCompletion.deleted,
			o = this._pendingCompletion.completion,
			a = n.rangeOffset + n.rangeLength,
			l = o.range.startOffset + i,
			c = a - l,
			u = l - n.rangeOffset
		if (c < 0 || u < 0) {
			this._logger.verbose(`Change would delete or unadd negative characters: ${a} - ${l} < 0
                    or ${l} - ${n.rangeOffset} < 0`),
				this._rejectPendingCompletion()
			return
		}
		;(s += c), (i -= u)
		let f = o.completionText + o.suffixReplacementText,
			p = n.text.length,
			g = f.slice(i, i + p)
		if (n.text.slice(0, g.length) !== g) {
			this._logger.verbose(`Pending completion mismatch: ${n.text} vs ${g}`), this._rejectPendingCompletion()
			return
		}
		if (((i += p), s < this._pendingCompletion.suffixMatches.length)) {
			let m = this._pendingCompletion.suffixMatches[s]
			if (i > o.completionText.length + m) {
				this._logger
					.verbose(`Remaining skipped suffix is not a subsequence of the remaining suffix replacement text:
                    ${o.skippedSuffix.slice(s)} !<= ${f.slice(i)}`),
					this._rejectPendingCompletion()
				return
			}
		}
		;(this._pendingCompletion.added = i),
			(this._pendingCompletion.deleted = s),
			this._pendingCompletion.added >= f.length && this._pendingCompletion.deleted >= o.skippedSuffix.length
				? this._acceptPendingInlineCompletion()
				: (this._pendingCompletion.added >= f.length ||
						this._pendingCompletion.deleted > o.skippedSuffix.length) &&
					this._rejectPendingCompletion()
	}
	_normalizeChange(r) {
		if (!this._pendingCompletion) return
		let n = this._pendingCompletion.completion,
			i = this._pendingCompletion.added,
			s = this._pendingCompletion.deleted
		if (r.rangeOffset < n.range.startOffset) {
			let a = n.range.startOffset - r.rangeOffset
			return a > r.rangeLength
				? void 0
				: {
						rangeLength: r.rangeLength - a,
						rangeOffset: r.rangeOffset + a,
						text: r.text.slice(a),
					}
		}
		let o = n.range.startOffset + i
		if (r.rangeOffset > o) {
			let a = r.rangeOffset - o
			return s + a > n.skippedSuffix.length
				? void 0
				: {
						rangeLength: r.rangeLength + a,
						rangeOffset: r.rangeOffset - a,
						text: n.skippedSuffix.slice(s, s + a) + r.text,
					}
		}
		return {
			rangeLength: r.rangeLength,
			rangeOffset: r.rangeOffset,
			text: r.text,
		}
	}
	_rejectPendingCompletion() {
		this._pendingCompletion &&
			(YG({
				requestId: this._pendingCompletion.requestId,
				acceptedIdx: -1,
				document: this._pendingCompletion.document,
			}),
			uf(!1),
			this._logger.debug(`Rejecting completion: ${this._pendingCompletion.requestId}`),
			this._metricsReporter.reportResolution(
				this._pendingCompletion.requestId,
				this._pendingCompletion.emitTime,
				Date.now(),
				void 0,
			),
			(this._pendingCompletion = void 0))
	}
	_acceptPendingInlineCompletion() {
		this._pendingCompletion &&
			(YG({
				requestId: this._pendingCompletion.requestId,
				acceptedIdx: 0,
				document: this._pendingCompletion.document,
			}),
			uf(!1),
			this._logger.debug(`Accepting completion: ${this._pendingCompletion.requestId}`),
			this._metricsReporter.reportResolution(
				this._pendingCompletion.requestId,
				this._pendingCompletion.emitTime,
				Date.now(),
				0,
			),
			(this._pendingCompletion = void 0))
	}
}
var CA = W(require("vscode"))
var I1 = class extends z {
	_logger = X("SuppressDeletedCompletions")
	_inProgressDeletion = void 0
	_prevCompletions = void 0
	constructor() {
		super(),
			this.addDisposables(
				CA.workspace.onDidChangeTextDocument((t) => {
					this._onTextDocumentChange(t)
				}),
				CA.window.onDidChangeActiveTextEditor((t) => {
					this._resetDeletions(t)
				}),
			)
	}
	_onTextDocumentChange(t) {
		if ((t.document.uri.scheme !== "file" && !yo(t.document.uri)) || t.contentChanges.length === 0) return
		if (
			this._inProgressDeletion === void 0 ||
			t.contentChanges.length !== 1 ||
			t.contentChanges[0].text.length > 0 ||
			t.document !== this._inProgressDeletion.document
		) {
			;(this._inProgressDeletion = {
				document: t.document,
				preDeletionDocumentText: t.document.getText(),
				prevDeletionRange: void 0,
				prevDeletionText: void 0,
				curDocumentText: t.document.getText(),
			}),
				(this._prevCompletions = [])
			return
		}
		;(this._inProgressDeletion.prevDeletionRange === void 0 ||
			!this._areAdjacentDeletions(t.contentChanges[0].range, this._inProgressDeletion.prevDeletionRange)) &&
			(this._inProgressDeletion.preDeletionDocumentText = this._inProgressDeletion.curDocumentText)
		let r = this._inProgressDeletion.curDocumentText.substring(
			t.contentChanges[0].rangeOffset,
			t.contentChanges[0].rangeOffset + t.contentChanges[0].rangeLength,
		)
		;(this._inProgressDeletion.prevDeletionRange = t.contentChanges[0].range),
			(this._inProgressDeletion.prevDeletionText = r),
			(this._inProgressDeletion.curDocumentText = t.document.getText())
	}
	_areAdjacentDeletions(t, r) {
		return t.end.isEqual(r.start) || t.start.isEqual(r.start)
	}
	_resetDeletions(t) {
		if (((this._prevCompletions = []), t === void 0)) {
			this._inProgressDeletion = void 0
			return
		}
		this._inProgressDeletion = {
			document: t.document,
			preDeletionDocumentText: t.document.getText(),
			prevDeletionRange: void 0,
			prevDeletionText: void 0,
			curDocumentText: t.document.getText(),
		}
	}
	processRequest(t) {
		if (!t || !this._inProgressDeletion) return t
		let r = t.completions
		return (
			this._inProgressDeletion.document === t.document &&
				(r = t.completions.filter((n) =>
					this._checkIfCompletionWasDeleted(t, n)
						? (this._logger.debug("Suppressing previously deleted completion"), !1)
						: this._checkIfForwardDeletion(t, n)
							? (this._logger.debug("Suppressing completion due to forward deletion"), !1)
							: !0,
				)),
			this._inProgressDeletion.document === t.document && (this._prevCompletions = [...t.completions]),
			(t.completions = r),
			t
		)
	}
	_checkIfCompletionWasDeleted(t, r) {
		let n = t.document,
			i = n.getText(new CA.Range(n.positionAt(0), n.positionAt(r.range.startOffset))),
			s = n.getText(
				new CA.Range(
					n.positionAt(r.range.endOffset + r.skippedSuffix.length),
					n.positionAt(n.getText().length),
				),
			),
			o = i + r.completionText + s
		return this._inProgressDeletion.preDeletionDocumentText === o
	}
	_checkIfForwardDeletion(t, r) {
		if (this._inProgressDeletion.prevDeletionRange)
			return this._prevCompletions?.some((i) => {
				let s = this._inProgressDeletion?.document?.positionAt(i.range.endOffset),
					o = t.document.positionAt(r.range.endOffset)
				if (!s || !s.isEqual(o)) return !1
				let a = (i.completionText + i.suffixReplacementText).substring(i.range.endOffset - i.range.startOffset),
					l = r.completionText + r.suffixReplacementText,
					c = [a]
				if (
					(this._inProgressDeletion?.prevDeletionText &&
						c.push(a + this._inProgressDeletion?.prevDeletionText),
					!c.some((f) => f === l))
				)
					return !1
				let u = this._inProgressDeletion?.document.positionAt(i.range.endOffset)
				return (
					u &&
					this._inProgressDeletion?.prevDeletionRange?.start &&
					u.isEqual(this._inProgressDeletion.prevDeletionRange.start)
				)
			})
	}
}
var $0t = 2e3,
	S1 = class extends z {
		constructor(r, n, i, s, o) {
			super()
			this._completionsModel = r
			this._config = s
			this._timelineReporter = o
			;(this._pendingCompletions = new w1(n)),
				(this._stateController = new yA(i)),
				this.addDisposable(this._pendingCompletions),
				this.addDisposable(this._deletedCompletions),
				this.addDisposable(
					Xh.window.onDidChangeTextEditorSelection((a) => {
						a.textEditor.document.uri.scheme === "file" && uf(!1)
					}),
				)
		}
		_logger = X("InlineCompletionProvider")
		_pendingCompletions
		_deletedCompletions = new I1()
		_stateController
		async provideInlineCompletionItems(r, n, i, s) {
			let o = new _1()
			if (
				!this._config.config.completions.enableAutomaticCompletions &&
				i.triggerKind === Xh.InlineCompletionTriggerKind.Automatic
			)
				return uf(!1), []
			this._stateController.dispose(),
				this._logger.debug(
					`Inline Request - ${r.uri.toString()} ${Zh(r, n)}${v1(" ", i.selectedCompletionInfo?.text)}`,
				),
				this._logger.verbose(Dxe(r, i))
			let a = await this._getCompletions(r, n, i, o),
				l = this._deletedCompletions.processRequest(a)
			if (s.isCancellationRequested) return this._logger.debug("Completion cancelled"), pxe(), uf(!1), []
			if ((gxe(l), !l)) return this._logger.debug("Returning no completions"), uf(!1), []
			;(o.emitTime = Date.now()), l.isReused || this._timelineReporter.reportCompletionTimeline(l.requestId, o)
			let c = l.completions.map((u) => {
				this._logger.verbose(`AugmentCompletion: ${u.toString()}`)
				let f = new Xh.InlineCompletionItem(
					u.completionText + u.suffixReplacementText,
					new Xh.Range(
						r.positionAt(u.range.startOffset),
						r.positionAt(u.range.endOffset + u.skippedSuffix.length),
					),
				)
				return (
					this._logger.verbose(`InlineCompletionItem: ${JSON.stringify(f.insertText)} ${AC(r, f.range)}`), f
				)
			})
			return c.length > 0 && uf(!0), c
		}
		async _getCompletions(r, n, i, s) {
			let o = this._pendingCompletions.getPendingCompletion(r, n)
			if (o && o.completions.length > 0) {
				let l = this._processCompletionForMode(o, i)
				return this._logger.debug(`Returning ${l.length} completions`), { ...o, completions: l }
			}
			if (i.selectedCompletionInfo?.text) {
				this._logger.debug(
					"Returning no completions because the provider request includes selected text that does not match an Augment suggestion",
				)
				return
			}
			let a = this._stateController.setState($xe)
			try {
				let l = await this._completionsModel.generateCompletion(r, n, s)
				if (l && l.completions.length === 0) {
					let c = this._stateController.setState(Yxe)
					setTimeout(() => {
						c.dispose()
					}, $0t)
				}
				return l
			} catch (l) {
				l instanceof bh || this._stateController.setState(Gxe)
			} finally {
				a.dispose()
			}
		}
		_processCompletionForMode(r, n) {
			if (!n.selectedCompletionInfo || !n.selectedCompletionInfo.text) return r.completions
			let i = n.selectedCompletionInfo.range.start
			return r.completions.map((o) => C1(r, o, i))
		}
	}
var Zxe = W(require("vscode"))
var eg = class extends z {
	constructor(r = 100, n = () => !0) {
		super()
		this._itemVerifier = n
		;(this._ringBuffer = new Gc(r)), this.addDisposable(this._newItemEventEmitter)
	}
	_ringBuffer
	_newItemEventEmitter = new Zxe.EventEmitter()
	get onNewItems() {
		return this._newItemEventEmitter.event
	}
	get items() {
		return this._ringBuffer.slice()
	}
	get mostRecentItem() {
		return this._ringBuffer.at(-1)
	}
	addItem(r) {
		this._itemVerifier(r) && (this._ringBuffer.addItem(r), this._newItemEventEmitter.fire(r))
	}
}
var B1 = class extends eg {
	constructor() {
		super(100, (t) => t.completions.length > 0 && !t.isReused)
	}
}
var T1 = W(require("vscode"))
var Xxe = W(require("crypto"))
function CC(e) {
	let t = Xxe.createHash("sha256")
	return t.update(e), t.digest("hex")
}
var vC = class e {
		constructor(t, r) {
			this.start = t
			this.stop = r
		}
		equals(t) {
			return this.start === t.start && this.stop === t.stop
		}
		get length() {
			return this.stop - this.start
		}
		toString() {
			return `[${this.start}, ${this.stop})`
		}
		compareTo(t) {
			return this.start - t.start
		}
		contains(t) {
			return (
				typeof t == "number" && (t = new e(t, t + 1)),
				this.start <= t.start && this.stop >= t.stop && this.stop > t.start
			)
		}
		intersects(t) {
			return typeof t == "number" && (t = new e(t, t + 1)), this.start < t.stop && this.stop > t.start
		}
		touches(t) {
			return typeof t == "number" && (t = new e(t, t + 1)), this.start === t.stop || this.stop === t.start
		}
		intersection(t) {
			if (this.intersects(t)) return new e(Math.max(this.start, t.start), Math.min(this.stop, t.stop))
		}
		distanceTo(t) {
			return (
				typeof t == "number" && (t = new e(t, t + 1)),
				-Math.min(0, Math.min(this.stop, t.stop) - Math.max(this.start, t.start))
			)
		}
		offset(t, r, n = -1 / 0, i = 1 / 0) {
			let s = Math.min(i, Math.max(n, this.start + t)),
				o = Math.max(n, Math.min(i, this.stop + r))
			if (s > o) {
				let a = Math.ceil((this.start + this.stop) / 2),
					l = Math.max(n, Math.min(i, a))
				return new e(l, l)
			}
			return new e(s, o)
		}
		static anyOverlaps(t) {
			if (t.length <= 1) return !1
			t.sort((n, i) => (n.start === i.start ? n.stop - i.stop : n.start - i.start))
			let r = t[0].stop
			for (let n = 1; n < t.length; n++) {
				if (t[n].start < r) return !0
				r = t[n].stop
			}
			return !1
		}
		static mergeTouching(t) {
			if (t.length <= 1) return [...t]
			let r = [...t].sort((i, s) => i.start - s.start),
				n = [r[0]]
			for (let i = 1; i < r.length; i++) {
				let s = n[n.length - 1],
					o = r[i]
				s.stop >= o.start ? (s.stop = Math.max(s.stop, o.stop)) : n.push(o)
			}
			return n
		}
	},
	bo = class extends vC {},
	Rn = class extends vC {}
function Y0t(e, t) {
	let r = t.text === void 0 ? "" : t.text,
		n
	return (
		t.rangeOffset !== void 0 && t.rangeLength !== void 0
			? (n = { start: t.rangeOffset, end: t.rangeOffset + t.rangeLength })
			: (n = {
					start: e.offsetAt(t.range.start),
					end: e.offsetAt(t.range.end),
				}),
		{ text: r, range: n }
	)
}
var r8 = class {
		constructor(t, r, n) {
			this._uploadBatchFunction = t
			this._batchSize = r
			this._maxUploadDelayMs = n
		}
		_queue = []
		_queueNonEmptyTimer
		add(t) {
			if (
				(this._queue.push(t),
				this._queue.length === 1 &&
					(clearTimeout(this._queueNonEmptyTimer),
					(this._queueNonEmptyTimer = setTimeout(() => {
						this._uploadBatch()
					}, this._maxUploadDelayMs))),
				this._queue.length >= this._batchSize)
			) {
				let r = this._queue
				this._queue = []
				let n = { user_events: r }
				this._uploadBatchFunction(n)
			}
		}
		_uploadBatch() {
			let t = this._queue
			this._queue = []
			let r = t.length,
				n = { user_events: t }
			r !== 0 && this._uploadBatchFunction(n), clearTimeout(this._queueNonEmptyTimer)
		}
		dispose() {
			this.stop()
		}
		stop() {
			clearTimeout(this._queueNonEmptyTimer)
		}
	},
	n8 = class {
		constructor(t) {
			this._apiServer = t
			this._logger = X("UploadHandler")
		}
		_logger
		_lastErrorTime
		_uploadInterruptPeriodMs = 15e3
		async uploadUserEvents(t) {
			try {
				if (this._lastErrorTime ? Date.now() - this._lastErrorTime < this._uploadInterruptPeriodMs : !1) return
				await this._apiServer.uploadUserEvents(t)
			} catch (r) {
				throw (this._logger.info("Error uploading tracked events", r), (this._lastErrorTime = Date.now()), r)
			}
		}
	},
	D1 = class e extends z {
		constructor(r, n, i, s, o, a = e.defaultUploadBatchSize, l = e.defaultMaxUploadDelayMs) {
			super()
			this._pathResolver = n
			this._recentInstructions = i
			this._recentCompletions = s
			this._recentNextEditSuggestions = o
			;(this._uploadHandler = new n8(r)),
				(this._uploadQueue = new r8(
					(c) => void this._uploadHandler.uploadUserEvents.bind(this._uploadHandler)(c),
					a,
					l,
				)),
				this._createSubscriptions(),
				this.addDisposable(this._uploadQueue)
		}
		static defaultUploadBatchSize = 128
		static defaultMaxUploadDelayMs = 5e3
		_uploadQueue
		_uploadHandler
		_createSubscriptions() {
			this.addDisposable(T1.workspace.onDidChangeTextDocument(this._processChangeTextDocument.bind(this))),
				this.addDisposable(this._recentInstructions.onNewItems(this._processInstruction.bind(this))),
				this.addDisposable(this._recentCompletions.onNewItems(this._processCompletion.bind(this))),
				this.addDisposable(this._recentNextEditSuggestions.onNewItems(this._processNextEdit.bind(this)))
		}
		_processChangeTextDocument(r) {
			let n = r.document.uri.fsPath,
				i = new Date().toISOString(),
				s = this._pathResolver.resolvePathName(n)
			if (s === void 0 || r.contentChanges.length === 0) return
			let o = []
			for (let y of r.contentChanges) o.push(Y0t(r.document, y))
			let a = 500,
				l = r.document.getText().length,
				c = o.map((y) => new bo(y.range.start, y.range.end)).map((y) => y.offset(-a, a, 0, l)),
				u = vC.mergeTouching(c),
				f = u.map((y) =>
					r.document.getText(new T1.Range(r.document.positionAt(y.start), r.document.positionAt(y.stop))),
				),
				p = CC(new TextEncoder().encode(f.join(""))),
				g = {
					reason: r.reason,
					content_changes: o,
					after_changes_hash: p,
					source_folder_root: s.rootPath,
					hash_char_ranges: u.map((y) => ({ start: y.start, end: y.stop })),
					after_doc_length: l,
				},
				m = { time: i, file_path: s.relPath, text_edit: g }
			this._uploadQueue.add(m)
		}
		_processInstruction(r) {
			let n = { request_id: r.requestId },
				i = {
					time: r.requestedAt.toISOString(),
					file_path: r.pathName,
					edit_request_id_issued: n,
				}
			this._uploadQueue.add(i)
		}
		_processNextEdit(r) {
			let n = { request_id: r.requestId },
				i = {
					time: r.requestTime.toISOString(),
					file_path: r.qualifiedPathName?.relPath ?? "",
					next_edit_request_id_issued: n,
				}
			this._uploadQueue.add(i)
		}
		_processCompletion(r) {
			let n = {
				time: r.occuredAt.toISOString(),
				file_path: r.pathName ?? "",
				completion_request_id_issued: { request_id: r.requestId },
			}
			this._uploadQueue.add(n)
		}
	}
var EC = W(require("vscode"))
var i8 = class {
		constructor(t, r, n) {
			this.uri = t
			this.diagnostic = r
			this.time = n
		}
	},
	s8 = class {
		constructor(t, r, n, i) {
			this.uri = t
			this.diagnostic = r
			this.charStart = n
			this.charEnd = i
		}
	}
function K0t(e, t) {
	return e.message === t.message && e.severity === t.severity && e.range.isEqual(t.range)
}
var R1 = class e extends z {
	static _maxDiagnosticsPerFile = 10
	_diagnostics = new Map()
	_logger = X("DiagnosticsManager")
	constructor() {
		super(),
			this.addDisposable(
				EC.languages.onDidChangeDiagnostics((t) => {
					let r = new Date()
					for (let n of t.uris) {
						if (yo(n)) continue
						let i = this._diagnostics.get(n.path),
							s = EC.languages.getDiagnostics(n).slice(0, e._maxDiagnosticsPerFile),
							o = []
						for (let a of s) {
							if (
								a.severity !== EC.DiagnosticSeverity.Error &&
								a.severity !== EC.DiagnosticSeverity.Warning
							)
								continue
							let l = i?.find((c) => K0t(c.diagnostic, a))
							l === void 0 ? o.push(new i8(n, a, r)) : o.push(l)
						}
						this._diagnostics.set(n.path, o)
					}
				}),
			)
	}
	async getMostRecentDiagnostics(t, r, n = void 0) {
		let s = Array.from(this._diagnostics.entries())
				.flatMap(([c, u]) => (n !== void 0 && !c.startsWith(n) ? [] : u))
				.sort((c, u) => {
					let f = u.time.getTime() - c.time.getTime()
					return f !== 0 ? f : c.diagnostic.severity - u.diagnostic.severity
				}),
			o = new Map(),
			a = [],
			l = new Map()
		for (let c of s) {
			if (c.diagnostic.range.start.line < 0 || c.diagnostic.range.start.line > c.diagnostic.range.end.line) {
				this._logger.debug(
					`Ignoring invalid diagnostic ${c.diagnostic.message} in ${c.uri.path} at ${c.diagnostic.range.start.line}:${c.diagnostic.range.end.line}`,
				)
				continue
			}
			let u = o.get(c.uri.path) ?? 0
			if (u < r) {
				if (!l.has(c.uri.path))
					try {
						l.set(c.uri.path, await ho(c.uri))
					} catch {
						this._logger.debug(`Failed to open document ${c.uri.fsPath}.`)
						continue
					}
				let f = l.get(c.uri.path)
				if (!f) continue
				if (c.diagnostic.range.end.line >= f.lineCount) {
					this._logger.debug(
						`Ignoring stale diagnostic ${c.diagnostic.message} in ${c.uri.path} at ${c.diagnostic.range.start.line}:${c.diagnostic.range.end.line}`,
					)
					continue
				}
				let p = f.offsetAt(c.diagnostic.range.start),
					g = f.offsetAt(c.diagnostic.range.end)
				if ((a.push(new s8(c.uri, c.diagnostic, p, g)), o.set(c.uri.path, u + 1), a.length >= t)) break
			}
		}
		return a
	}
}
var o8 = W(jA()),
	os = W(require("vscode"))
var J0t = 5,
	k1 = class extends z {
		constructor(r, n) {
			super()
			this._keybindingWatcher = r
			this._inlineCompletionProvider = n
			this.createDecorationTypes(), this.addDisposables(...this.setupEmptyFileHint())
			let i = os.window.activeTextEditor
			i && i.document.getText() === "" && this.debouncedDecorations(i),
				this._logger.info("HotKeyHints initialized")
		}
		_logger = X("HotKeyHints")
		activeCompletion = !1
		emptyFileHotKeyHintDecorationType
		debouncedDecorations = (0, o8.default)(
			(r) => {
				;(r.document.uri.scheme === "file" || r.document.uri.scheme === "untitled") &&
				r.document.getText() === "" &&
				!this.activeCompletion
					? r.setDecorations(this.emptyFileHotKeyHintDecorationType, [r.selection])
					: this.hideHints(r)
			},
			J0t,
			{ leading: !1, trailing: !0 },
		)
		createDecorationTypes() {
			let r = this._keybindingWatcher.getKeybindingForCommand(Hi.commandID),
				n = ""
			r ? (n = `${r} to open Augment.`) : (n = "Click the robot icon in the side bar to open Augment."),
				(this.emptyFileHotKeyHintDecorationType = os.window.createTextEditorDecorationType({
					after: {
						contentText: n,
						color: "rgba(150, 150, 150, 0.9)",
						margin: "0 0 0 0.5rem",
					},
				}))
		}
		setupEmptyFileHint() {
			let r = []
			return (
				r.push({
					dispose: () => {
						this.debouncedDecorations.cancel()
					},
				}),
				this._inlineCompletionProvider &&
					(r.push(
						Mc((n) => {
							let i = os.window.activeTextEditor
							!i ||
								!n ||
								n.completions.length === 0 ||
								(this.debouncedDecorations.cancel(), this.hideHints(i), (this.activeCompletion = !0))
						}),
					),
					r.push(
						mA(() => {
							this.activeCompletion = !1
							let n = os.window.activeTextEditor
							!n || n.document.getText() !== "" || this.debouncedDecorations(n)
						}),
					)),
				os.workspace.onDidCloseTextDocument(() => {
					this.activeCompletion = !1
				}),
				r.push(
					os.window.onDidChangeActiveTextEditor((n) => {
						!n ||
							n.document.getText() !== "" ||
							((this.activeCompletion = !1), this.debouncedDecorations(n))
					}),
				),
				r.push(
					os.workspace.onDidChangeTextDocument((n) => {
						if (
							(n.contentChanges.length > 0 && (this.activeCompletion = !1),
							n.document.uri.scheme !== "file" && n.document.uri.scheme !== "untitled")
						)
							return
						let i = os.window.activeTextEditor
						if (!(!i || i.document.uri.toString() !== n.document.uri.toString())) {
							if (i.document.getText() !== "") {
								this.hideHints(i)
								return
							}
							this.activeCompletion || this.debouncedDecorations(i)
						}
					}),
				),
				r
			)
		}
		hideHints(r) {
			r.setDecorations(this.emptyFileHotKeyHintDecorationType, [])
		}
	},
	M1 = class extends z {
		constructor(r, n) {
			super()
			this._keybindingWatcher = r
			this._inlineCompletionProvider = n
			this.createDecorationTypes(), this.addDisposables(...this.setupEmptyLineHint())
		}
		_logger = X("EmptyLineHints")
		activeCompletion = !1
		decorationType
		debouncedDecorations = (0, o8.default)(
			(r) => {
				let n = r.selection.active,
					s = r.document.lineAt(n.line).text,
					o = s.lastIndexOf(" ") !== -1 ? s.lastIndexOf(" ") : s.length - 1,
					a = new os.Range(n.line, o + 1, n.line, o + 1)
				;/\S/.test(s) === !1 && (s.trim() === "" || n.character === s.length)
					? r.setDecorations(this.decorationType, [a])
					: this.hideHints(r)
			},
			16,
			{ leading: !1, trailing: !0 },
		)
		createDecorationTypes() {
			let r = "",
				n = this._keybindingWatcher.getKeybindingForCommand("augment-chat.focus", !0)
			n && (r = `${n} to open Augment`),
				(this.decorationType = os.window.createTextEditorDecorationType({
					after: {
						contentText: r,
						color: "rgba(150, 150, 150, 0.5)",
						margin: "0 0 0 1.2rem",
					},
				}))
		}
		setupEmptyLineHint() {
			let r = []
			return (
				r.push({
					dispose: () => {
						this.debouncedDecorations.cancel()
					},
				}),
				this._inlineCompletionProvider &&
					(r.push(
						Mc((n) => {
							let i = os.window.activeTextEditor
							!i ||
								!n ||
								n.completions.length === 0 ||
								(this.debouncedDecorations.cancel(), this.hideHints(i), (this.activeCompletion = !0))
						}),
					),
					r.push(
						mA(() => {
							this.activeCompletion = !1
							let n = os.window.activeTextEditor
							n && this.debouncedDecorations(n)
						}),
					)),
				r.push(
					os.window.onDidChangeTextEditorSelection((n) => {
						this.debouncedDecorations(n.textEditor)
					}),
				),
				r.push(
					os.workspace.onDidChangeTextDocument((n) => {
						let i = os.window.activeTextEditor
						!i ||
							i.document.uri.toString() !== n.document.uri.toString() ||
							this.activeCompletion ||
							this.debouncedDecorations(i)
					}),
				),
				r
			)
		}
		hideHints(r) {
			r.setDecorations(this.decorationType, [])
		}
	}
var r_e = W(require("vscode"))
var e_e = new Map([
		["authenticated", { name: "authenticated", status: "initializing" }],
		["syncingPermitted", { name: "syncingPermitted", status: "complete" }],
		["disabledGithubCopilot", { name: "disabledGithubCopilot", status: "initializing" }],
		["hasMovedExtensionAside", { name: "hasMovedExtensionAside", status: "incomplete" }],
		["workspacePopulated", { name: "workspacePopulated", status: "initializing" }],
		["workspaceSelected", { name: "workspaceSelected", status: "initializing" }],
		["disabledCodeium", { name: "disabledCodeium", status: "initializing" }],
		["uploadingHomeDir", { name: "uploadingHomeDir", status: "initializing" }],
		["workspaceTooLarge", { name: "workspaceTooLarge", status: "initializing" }],
	]),
	t_e = new Map([
		[
			"UserShouldSignIn",
			{
				name: "UserShouldSignIn",
				renderOrder: 0,
				desiredConditions: [{ name: "authenticated", status: "incomplete" }],
			},
		],
		[
			"SyncingPermissionNeeded",
			{
				name: "SyncingPermissionNeeded",
				renderOrder: 1,
				desiredConditions: [{ name: "syncingPermitted", status: "initializing" }],
			},
		],
		[
			"uploadingHomeDir",
			{
				name: "uploadingHomeDir",
				renderOrder: 2,
				desiredConditions: [{ name: "uploadingHomeDir", status: "complete" }],
			},
		],
		[
			"workspaceTooLarge",
			{
				name: "workspaceTooLarge",
				renderOrder: 2,
				desiredConditions: [{ name: "workspaceTooLarge", status: "complete" }],
			},
		],
		[
			"ShouldDisableCopilot",
			{
				name: "ShouldDisableCopilot",
				renderOrder: 3,
				desiredConditions: [
					{ name: "authenticated", status: "complete" },
					{ name: "disabledGithubCopilot", status: "incomplete" },
				],
			},
		],
		[
			"ShouldDisableCodeium",
			{
				name: "ShouldDisableCodeium",
				renderOrder: 3,
				desiredConditions: [
					{ name: "authenticated", status: "complete" },
					{ name: "disabledCodeium", status: "incomplete" },
				],
			},
		],
		[
			"WorkspaceNotSelected",
			{
				name: "WorkspaceNotSelected",
				renderOrder: 5,
				desiredConditions: [
					{ name: "authenticated", status: "complete" },
					{ name: "syncingPermitted", status: "complete" },
					{ name: "workspaceSelected", status: "incomplete" },
				],
			},
		],
		[
			"WorkspacePopulated",
			{
				name: "WorkspacePopulated",
				renderOrder: 5,
				desiredConditions: [
					{ name: "authenticated", status: "complete" },
					{ name: "syncingPermitted", status: "complete" },
					{ name: "workspaceSelected", status: "complete" },
					{ name: "workspacePopulated", status: "complete" },
				],
			},
		],
		[
			"WorkspaceNotPopulated",
			{
				name: "WorkspaceNotPopulated",
				renderOrder: 5,
				desiredConditions: [
					{ name: "authenticated", status: "complete" },
					{ name: "syncingPermitted", status: "complete" },
					{ name: "workspaceSelected", status: "complete" },
					{ name: "workspacePopulated", status: "incomplete" },
				],
			},
		],
		[
			"AllActionsComplete",
			{
				name: "AllActionsComplete",
				renderOrder: 6,
				desiredConditions: [
					{ name: "authenticated", status: "complete" },
					{ name: "syncingPermitted", status: "complete" },
					{ name: "disabledGithubCopilot", status: "complete" },
					{ name: "disabledCodeium", status: "complete" },
					{ name: "workspacePopulated", status: "complete" },
					{ name: "workspaceSelected", status: "complete" },
				],
			},
		],
	]),
	F1 = class extends z {
		_systemStates
		_derivedStates
		_onDerivedStatesSatisfied = new r_e.EventEmitter()
		_systemToDerivedStateMap = new Map()
		_globalState
		_satisfiedDerivedStates = new Set()
		constructor(t, r = e_e, n = t_e) {
			super(),
				this.addDisposable(this._onDerivedStatesSatisfied),
				(this._systemStates = new Map(r)),
				(this._derivedStates = new Map(n)),
				(this._globalState = t),
				this.loadSystemStates(),
				this._derivedStates.forEach(this.updateSystemToDerivedStateMap.bind(this)),
				this._derivedStates.forEach((i) => {
					this._isStateSatisfied(i) && this._satisfiedDerivedStates.add(i.name)
				}),
				this._emitSatisfiedStates()
		}
		get satisfiedStates() {
			return Array.from(this._satisfiedDerivedStates)
				.map((t) => this._derivedStates.get(t))
				.sort((t, r) => t.renderOrder - r.renderOrder)
		}
		saveSystemStates() {
			let t = JSON.stringify(Array.from(this._systemStates.entries()))
			this._globalState.update("actionSystemStates", t)
		}
		loadSystemStates() {
			let t = this._globalState.get("actionSystemStates") || "[]"
			new Map(JSON.parse(t)).forEach((n) => {
				this._systemStates.set(n.name, n)
			})
		}
		get onDerivedStatesSatisfied() {
			return this._onDerivedStatesSatisfied.event
		}
		updateSystemToDerivedStateMap(t) {
			t.desiredConditions.forEach((r) => {
				this._systemToDerivedStateMap.has(r.name) || this._systemToDerivedStateMap.set(r.name, new Set()),
					this._systemToDerivedStateMap.get(r.name).add(t.name)
			})
		}
		setSystemStateStatus(t, r) {
			let n = { name: t, status: r }
			this._systemStates.set(n.name, n), this.saveSystemStates()
			let i = this._systemToDerivedStateMap.get(n.name) || new Set(),
				s = !1
			i.forEach((o) => {
				let a = this._derivedStates.get(o)
				if (a) {
					let l = this._satisfiedDerivedStates.has(o),
						c = this._isStateSatisfied(a)
					l !== c &&
						((s = !0), c ? this._satisfiedDerivedStates.add(o) : this._satisfiedDerivedStates.delete(o))
				}
			}),
				s && this._emitSatisfiedStates(),
				this.saveSystemStates()
		}
		restartActionsState() {
			;(this._systemStates = new Map(e_e)),
				(this._derivedStates = new Map(t_e)),
				(this._systemToDerivedStateMap = new Map()),
				(this._satisfiedDerivedStates = new Set()),
				this._derivedStates.forEach(this.updateSystemToDerivedStateMap.bind(this)),
				this._derivedStates.forEach((t) => {
					this._isStateSatisfied(t) && this._satisfiedDerivedStates.add(t.name)
				}),
				this._emitSatisfiedStates(),
				this.saveSystemStates()
		}
		getSystemState(t) {
			return this._systemStates.get(t)
		}
		addDerivedState(t) {
			this._derivedStates.set(t.name, t),
				this.updateSystemToDerivedStateMap(t),
				this._isStateSatisfied(t) && (this._satisfiedDerivedStates.add(t.name), this._emitSatisfiedStates()),
				this.saveSystemStates()
		}
		isDerivedStateSatisfied(t) {
			let r = this._derivedStates.get(t)
			return r ? this._isStateSatisfied(r) : !1
		}
		isSystemStateComplete(t) {
			return this._systemStates.get(t)?.status === "complete"
		}
		_emitSatisfiedStates() {
			this._onDerivedStatesSatisfied.fire(this.satisfiedStates)
		}
		broadcastDerivedStates() {
			this._emitSatisfiedStates()
		}
		_isStateSatisfied(t) {
			for (let r of t.desiredConditions) {
				let n = this._systemStates.get(r.name)
				if (!n || n.status !== r.status) return !1
			}
			return !0
		}
	}
var n_e = W(ZA()),
	N1 = W(require("vscode"))
var Q1 = class extends z {
	constructor(r, n, i, s, o, a, l) {
		super()
		this._actionsModel = r
		this._apiServer = n
		this._config = i
		this._syncingEnabledTracker = s
		this._changeWebviewAppEvent = o
		this._featureFlagManager = a
		this._userTier = l
		this.addDisposables(
			this._actionsModel.onDerivedStatesSatisfied(this.handleDerivedStateChange.bind(this)),
			this._syncingEnabledTracker.onDidChangeSyncingEnabled(this.sendSyncEnabledStatus.bind(this)),
			this._actionsModel.onDerivedStatesSatisfied((c) => {
				for (let u of c)
					(u.name === "WorkspacePopulated" || u.name === "WorkspaceNotPopulated") &&
						((this._workspaceChecked = !0),
						this._waitingOnWorkspace && ((this._waitingOnWorkspace = !1), this.changeToChatApp()))
			}),
		)
	}
	_logger = X("AwaitingSyncingPermissionApp")
	_webview
	_asyncMsgHandler
	_workspaceChecked = !1
	_waitingOnWorkspace = !1
	appType() {
		return "awaiting-syncing-permission"
	}
	title() {
		return "Syncing Permission Needed"
	}
	register(r) {
		this._logger.info("Registering AwaitingSyncingPermissionApp"),
			(this._webview = r),
			this.addDisposable(r.onDidReceiveMessage((n) => this.onMessageFromWebview(n)))
	}
	sendSyncEnabledStatus = (0, n_e.default)(
		() => {
			this._webview?.postMessage({
				type: "sync-enabled-state",
				data: this._syncingEnabledTracker.syncingEnabledState,
			})
		},
		250,
		{ leading: !0, trailing: !0 },
	)
	async handleDerivedStateChange(r) {
		let n = new Set(["SyncingPermissionNeeded", "uploadingHomeDir", "workspaceTooLarge", "WorkspaceNotSelected"]),
			i = r.map((s) => s.name).filter((s) => n.has(s))
		if (i.length === 0) {
			this._workspaceChecked ? this.changeToChatApp() : (this._waitingOnWorkspace = !0)
			return
		}
		await this.sendActionsToWebview(i)
	}
	changeToChatApp() {
		this._changeWebviewAppEvent.fire("chat")
	}
	async sendActionsToWebview(r) {
		await this._webview?.postMessage({ type: "main-panel-actions", data: r })
	}
	onMessageFromWebview(r) {
		switch (r.type) {
			case "main-panel-perform-action":
				this.performAction(r.data)
				break
			case "awaiting-syncing-permission-loaded": {
				this.handleDerivedStateChange(this._actionsModel.satisfiedStates),
					this.sendSyncEnabledStatus(),
					this._webview?.postMessage({
						type: "awaiting-syncing-permission-initialize",
						data: {
							workspaceName: N1.workspace.name,
							enableDebugFeatures: this._config.config.enableDebugFeatures,
							maxTrackableFileCount: this._featureFlagManager.currentFlags.maxTrackableFileCount,
							userTier: this._userTier,
						},
					})
				break
			}
		}
	}
	performAction(r) {
		switch (r) {
			case "grant-sync-permission": {
				this._logger.info("User granted syncing permission"), this._syncingEnabledTracker.enableSyncing()
				break
			}
			case "open-folder": {
				N1.commands.executeCommand("vscode.openFolder")
				break
			}
		}
	}
	async *onUserSendMessage(r) {
		let n = this._apiServer.createRequestId(),
			i = fCe
		for (let s of i)
			yield {
				type: "chat-model-reply",
				data: { text: s, requestId: n, workspaceFileChunks: [], streaming: !0 },
			},
				await new Promise((o) => setTimeout(o, 8))
		yield {
			type: "chat-model-reply",
			data: { text: "", requestId: n, workspaceFileChunks: [], streaming: !1 },
		}
	}
}
var tg = W(require("vscode"))
var P1 = class extends z {
	_webview
	constructor() {
		super()
	}
	appType() {
		return "folder-selection"
	}
	title() {
		return "Select Folder"
	}
	register(t) {
		;(this._webview = t), this.addDisposables(this._webview.onDidReceiveMessage(this.onDidReceiveMessage))
	}
	onDidReceiveMessage = (t) => {
		switch (t.type) {
			case "main-panel-perform-action":
				this.performAction(t.data)
				break
			case "main-panel-create-project":
				this.createProject(t.data.name)
				break
		}
	}
	performAction(t) {
		switch (t) {
			case "open-folder": {
				tg.commands.executeCommand("vscode.openFolder")
				break
			}
			case "clone-repository": {
				tg.commands.executeCommand("git.clone")
				break
			}
		}
	}
	async createProject(t) {
		let r = "augment-projects",
			n = tCe()
		if (!n) return
		let i = tg.Uri.file(n),
			s = tg.Uri.joinPath(i, r),
			o = tg.Uri.joinPath(s, t)
		;(await $d(o.fsPath)) || (await Su(o.fsPath)), tg.commands.executeCommand("vscode.openFolder", o)
	}
}
var L1 = class extends z {
	constructor(r, n, i, s) {
		super()
		this._apiServer = r
		this._config = n
		this._oauthFlow = i
		this._actionsModel = s
	}
	_logger = X("SignInApp")
	_webview
	_signInFlow
	appType() {
		return "sign-in"
	}
	title() {
		return ""
	}
	register(r) {
		;(this._webview = r),
			this.addDisposable(r.onDidReceiveMessage((i) => this.onMessageFromWebview(i))),
			this.addDisposable(this._actionsModel.onDerivedStatesSatisfied(this.handleDerivedStateChange.bind(this)))
		let n = Ti(r)
		this.addDisposable(n),
			n.registerStreamHandler("chat-user-message", (i) => this.onUserSendMessage(i)),
			n.registerHandler(
				"chat-loaded",
				(i) => (
					this._actionsModel.isDerivedStateSatisfied("UserShouldSignIn") && this.sendSignInActions(),
					Promise.resolve({
						type: "chat-initialize",
						data: {
							enableDebugFeatures: this._config.config.enableDebugFeatures,
							fullFeatured: !1,
						},
					})
				),
			)
	}
	onMessageFromWebview(r) {
		switch (r.type) {
			case "main-panel-perform-action":
				this.performAction(r.data)
				break
			case "augment-link":
				switch (r.data) {
					case x4:
						this.performAction("sign-in")
						break
					default:
						this._logger.warn(`Unknown augment link: ${r.data}`)
						break
				}
		}
	}
	performAction(r) {
		switch (r) {
			case "cancel-sign-in":
				this._oauthFlow.doProgrammaticCancellation(), this.sendSignInActions()
				break
			case "sign-in": {
				this.sendInProgressActions()
				let n = this._oauthFlow.startFlow(!1)
				;(this._signInFlow = n),
					n.catch((i) => {
						this._signInFlow === n && this.sendSignInActions()
					})
				break
			}
		}
	}
	async sendSignInActions() {
		await this.sendActionsToWebview(["UserShouldSignIn"])
	}
	async sendInProgressActions() {
		await this.sendActionsToWebview(["SignInInProgress"])
	}
	handleDerivedStateChange(r) {
		for (let n of r) n.name === "UserShouldSignIn" && this.sendSignInActions()
	}
	async sendActionsToWebview(r) {
		await this._webview?.postMessage({ type: "main-panel-actions", data: r })
	}
	async *onUserSendMessage(r) {
		let n = this._apiServer.createRequestId(),
			i = dCe
		for (let s of i)
			yield {
				type: "chat-model-reply",
				data: { text: s, requestId: n, workspaceFileChunks: [], streaming: !0 },
			},
				await new Promise((o) => setTimeout(o, 8))
		yield {
			type: "chat-model-reply",
			data: { text: "", requestId: n, workspaceFileChunks: [], streaming: !1 },
		}
	}
}
var U1 = class extends z {
	constructor(r, n) {
		super()
		this._workspaceManager = r
		this._featureFlagManager = n
	}
	_workspaceUiModel = null
	appType() {
		return "workspace-context"
	}
	title() {
		return "Workspace Context"
	}
	register(r) {
		this._workspaceUiModel?.dispose(),
			this._featureFlagManager.currentFlags.enableWorkspaceManagerUi &&
				((this._workspaceUiModel = new gC(this._workspaceManager, r, this._featureFlagManager)),
				this.addDisposable(this._workspaceUiModel))
	}
}
var O1 = class e extends Zn {
	constructor(r, n, i, s) {
		super("AgentRequestEventReporter", n ?? e.defaultMaxRecords, i ?? e.defaultUploadMsec, s ?? e.defaultBatchSize)
		this._apiServer = r
	}
	static defaultMaxRecords = 1e4
	static defaultBatchSize = 1e3
	static defaultUploadMsec = 1e4
	reportEvent(r) {
		let [n, i] = kn(Date.now())
		this.report({
			event_time_sec: n,
			event_time_nsec: i,
			event_name: r.eventName,
			conversation_id: r.conversationId,
			request_id: r.requestId,
			chat_history_length: r.chatHistoryLength,
		})
	}
	performUpload(r) {
		return this._apiServer.logAgentRequestEvent(r)
	}
}
var q1 = class e extends Zn {
	constructor(r) {
		super("ClientMetricsReporter", e.defaultMaxRecords, e.defaultUploadMsec, e.defaultBatchSize)
		this._apiServer = r
	}
	static defaultMaxRecords = 1e4
	static defaultBatchSize = 500
	static defaultUploadMsec = 1e4
	reportWebviewClientMetric = (r) => {
		this.report({
			client_metric: `webview__${r.webviewName}__${r.client_metric}`,
			value: r.value,
		})
	}
	performUpload(r) {
		return this._apiServer.clientMetrics(r)
	}
}
var V1 = class {
	constructor(t) {
		this._apiServer = t
	}
	uploadEnabled = !1
	_logger = X("CodeEditReporter")
	enableUpload() {
		this.uploadEnabled = !0
	}
	disableUpload() {
		this.uploadEnabled = !1
	}
	dispose() {
		this.disableUpload()
	}
	async reportResolution(t, r, n, i, s) {
		let [o, a] = kn(r),
			[l, c] = kn(n),
			u = {
				request_id: t,
				emit_time_sec: o,
				emit_time_nsec: a,
				resolve_time_sec: l,
				resolve_time_nsec: c,
				is_accepted: i,
				annotated_text: s,
			}
		await xi(async () => {
			if (this.uploadEnabled)
				try {
					return await this._apiServer.logCodeEditResolution(u)
				} catch (f) {
					throw (this._logger.error(`Error reporting edit resolution: ${f}`), f)
				}
		}, this._logger)
	}
}
var H1 = class e extends Zn {
	constructor(r, n, i, s, o) {
		super(
			"CompletionAcceptanceReporter",
			i ?? e.defaultMaxRecords,
			s ?? e.defaultUploadMsec,
			o ?? e.defaultBatchSize,
		)
		this._apiServer = r
		this._onboardingSessionEventReporter = n
	}
	static defaultMaxRecords = 1e4
	static defaultBatchSize = 1e3
	static defaultUploadMsec = 1e4
	reportResolution(r, n, i, s) {
		let [o, a] = kn(n),
			[l, c] = kn(i)
		this.report({
			request_id: r,
			emit_time_sec: o,
			emit_time_nsec: a,
			resolve_time_sec: l,
			resolve_time_nsec: c,
			accepted_idx: s ?? -1,
		}),
			s !== void 0 && this._onboardingSessionEventReporter.reportEvent("accepted-completion")
	}
	performUpload(r) {
		return this._apiServer.resolveCompletions(r)
	}
}
var W1 = class e extends Zn {
	constructor(r, n, i, s) {
		super("TimelineEventReporter", n ?? e.defaultMaxRecords, i ?? e.defaultUploadMsec, s ?? e.defaultBatchSize)
		this._apiServer = r
	}
	static defaultMaxRecords = 1e4
	static defaultBatchSize = 1e3
	static defaultUploadMsec = 1e4
	reportCompletionTimeline(r, n) {
		if (!n.emitTime || !n.rpcStart || !n.rpcEnd) return
		let [i, s] = kn(n.requestStart),
			[o, a] = kn(n.emitTime),
			[l, c] = kn(n.rpcStart),
			[u, f] = kn(n.rpcEnd)
		this.report({
			request_id: r,
			initial_request_time_sec: i,
			initial_request_time_nsec: s,
			api_start_time_sec: l,
			api_start_time_nsec: c,
			api_end_time_sec: u,
			api_end_time_nsec: f,
			emit_time_sec: o,
			emit_time_nsec: a,
		})
	}
	performUpload(r) {
		return this._apiServer.reportClientCompletionTimelines(r)
	}
}
var rg = W(require("vscode"))
var G1 = class e extends Zn {
	constructor(r, n, i, s) {
		super(
			"ExtensionSessionEventReporter",
			n ?? e.defaultMaxRecords,
			i ?? e.defaultUploadMsec,
			s ?? e.defaultBatchSize,
		)
		this._apiServer = r
	}
	static defaultMaxRecords = 1e4
	static defaultBatchSize = 1e3
	static defaultUploadMsec = 1e4
	reportEvent(r, n) {
		this.report({
			time_iso: new Date().toISOString(),
			event_name: r,
			additional_data: n,
		})
	}
	performUpload(r) {
		return this._apiServer.logExtensionSessionEvent(r)
	}
	reportSourceFolders(r) {
		if (!r.workspaceStorageUri) return
		let n = CC(new TextEncoder().encode(r.workspaceStorageUri))
		delete r.workspaceStorageUri
		let i = tk({ projectId: n, ...r })
		this.report({
			time_iso: new Date().toISOString(),
			event_name: "source-folder-snapshot",
			additional_data: Object.entries(i).map(([s, o]) => ({
				key: s,
				value: o,
			})),
		})
	}
	reportConfiguration(r, n, i) {
		let s = tk({
			otherConfig: {
				theme: rg.workspace.getConfiguration().get("workbench.colorTheme"),
				fontSize: rg.workspace.getConfiguration().get("editor.fontSize"),
				isDark: [rg.ColorThemeKind.Dark, rg.ColorThemeKind.HighContrast].includes(
					rg.window.activeColorTheme.kind,
				),
			},
			config: n,
			featureFlags: i,
		})
		for (let o in s) o.toLowerCase().includes("token") && s[o] && (s[o] = "<redacted>")
		this.report({
			time_iso: new Date().toISOString(),
			event_name: "configuration-snapshot",
			additional_data: Object.entries(s).map(([o, a]) => ({
				key: o,
				value: a,
			})),
		})
	}
}
var $1 = class e extends Zn {
	constructor(r, n, i, s) {
		super("NextEditResolutionReporter", n ?? e.defaultMaxRecords, i ?? e.defaultUploadMsec, s ?? e.defaultBatchSize)
		this._apiServer = r
	}
	static defaultMaxRecords = 1e4
	static defaultBatchSize = 1e3
	static defaultUploadMsec = 1e4
	reportResolution(r, n, i, s) {
		let [o, a] = kn(n),
			[l, c] = kn(i)
		this.report({
			request_id: r,
			emit_time_sec: o,
			emit_time_nsec: a,
			resolve_time_sec: l,
			resolve_time_nsec: c,
			is_accepted: s,
		})
	}
	performUpload(r) {
		return this._apiServer.resolveNextEdits(r)
	}
}
var Y1 = class e extends Zn {
	constructor(r, n, i, s) {
		super(
			"NextEditSessionEventReporter",
			n ?? e.defaultMaxRecords,
			i ?? e.defaultUploadMsec,
			s ?? e.defaultBatchSize,
		)
		this._apiServer = r
	}
	static defaultMaxRecords = 1e4
	static defaultBatchSize = 1e3
	static defaultUploadMsec = 1e4
	reportEvent(r, n, i, s, o) {
		let [a, l] = kn(i)
		this.report({
			related_request_id: r,
			related_suggestion_id: n,
			event_time_sec: a,
			event_time_nsec: l,
			event_name: s,
			event_source: o,
		})
	}
	reportEventFromSuggestion(r, n, i) {
		this.reportEvent(r?.requestId, r?.result.suggestionId, Date.now(), n, i)
	}
	reportEventWithoutIds(r, n) {
		this.reportEvent(void 0, void 0, Date.now(), r, n)
	}
	performUpload(r) {
		return this._apiServer.logNextEditSessionEvent(r)
	}
}
var K1 = class e extends Zn {
	constructor(r, n, i, s) {
		super(
			"OnboardingSessionEventReporter",
			n ?? e.defaultMaxRecords,
			i ?? e.defaultUploadMsec,
			s ?? e.defaultBatchSize,
		)
		this._apiServer = r
	}
	static defaultMaxRecords = 1e4
	static defaultBatchSize = 1e3
	static defaultUploadMsec = 1e4
	reportEvent(r) {
		let [n, i] = kn(Date.now())
		this.report({ event_time_sec: n, event_time_nsec: i, event_name: r })
	}
	performUpload(r) {
		return this._apiServer.logOnboardingSessionEvent(r)
	}
}
var J1 = class extends z {
	constructor(r, n) {
		super()
		this._reporter = r
		this._options = n
		;(this._options.periodMs = Math.max(this._options.periodMs, 10)),
			(this._options.infoThresholdMs = Math.max(this._options.infoThresholdMs, 10)),
			(this._options.debugThresholdMs = Math.min(
				Math.max(this._options.debugThresholdMs, 10),
				this._options.infoThresholdMs,
			)),
			this._schedule(),
			this.addDisposable({ dispose: () => clearTimeout(this._nextCheck) })
	}
	_logger = X("StallDetector")
	_targetWakeup = 0
	_nextCheck
	_schedule() {
		;(this._targetWakeup = Date.now() + this._options.periodMs),
			(this._nextCheck = setTimeout(() => this._checkStall(), this._options.periodMs))
	}
	_checkStall() {
		let n = Date.now() - this._targetWakeup
		if (n > this._options.debugThresholdMs) {
			let i = `Event loop delay: Timer(${this._options.periodMs} msec) ran ${n} msec late.`,
				s = n > this._options.infoThresholdMs ? "info" : "debug"
			this._logger.log(s, i), this._reporter.report({ client_metric: "event_loop_delay", value: n })
		}
		this._schedule()
	}
}
var Qa = W(require("vscode"))
var a8 = W(require("vscode"))
var j0t = X("RangesVSCode")
function Ds(e, t) {
	return t && t.lineCount < e.stop
		? (j0t.warn(`LineRange[${e.start}, ${e.stop}) is out of bounds for document ${t.uri.path}.`),
			new a8.Range(e.start, 0, t.lineCount, 0))
		: new a8.Range(e.start, 0, e.stop, 0)
}
function $u(e) {
	return new Rn(e.start.line, e.end.line + (e.end.character > 0 ? 1 : 0))
}
function s_e(e) {
	return `[${i_e(e.start)},${i_e(e.end)})`
}
function i_e(e) {
	return `${e.line}:${e.character}`
}
function l8(e) {
	return [...e.visibleRanges].sort((t, r) => t.start.line - r.start.line)
}
function as(e) {
	return wy(e.fsPath)
}
function z1(e) {
	return e.fsPath
}
function hf(e) {
	if (e.scheme === "file" || e.scheme === "untitled" || yo(e)) return as(e)
}
function o_e(e) {
	if (e.scheme === "file") return as(e)
}
var X1 = W(require("vscode"))
var bC = class {
		constructor(t, r) {
			this.title = t
			this.action = r
			;(this.title = t), (this.action = r)
		}
	},
	Z1 = class extends z {
		constructor(r, n, i, s, o, a, l) {
			super()
			this._configListener = r
			this._suggestionManager = n
			this._keybindingWatcher = i
			this._globalState = s
			this._nextEditSessionEventReporter = o
			this._nextEditConfigManager = a
			this._completionVisibilityWatcher = l
			this._addInitialTutorial(), this._addSecondTutorial()
		}
		_addInitialTutorial() {
			let r = this._nextEditConfigManager.config.enableAutoApply,
				n = Vu(
					this._keybindingWatcher,
					this._configListener.config.nextEdit.enableGotoHinting ? Fa.commandID : Xo.commandID,
					!0,
				),
				i = Vu(this._keybindingWatcher, Uu.commandID, !0)
			this._addTutorial(
				"nextEditSuggestionSeen",
				(s) => s.newSuggestions,
				ui,
				"You have a Next Edit suggestion available. Next Edit helps you complete your train of thought by suggesting changes that continue your recent work.",
				[
					new bC(
						r ? `Preview & Apply (${n})` : `Preview (${n})`,
						j1(this._configListener.config.nextEdit.enableGotoHinting ? Fa.commandID : Xo.commandID),
					),
					new bC(`Dismiss All (${i})`, j1(Uu.commandID)),
				],
				"tutorial-initial-shown",
			)
		}
		_addSecondTutorial() {
			let r = Vu(this._keybindingWatcher, Co.commandID, !0),
				n = Vu(this._keybindingWatcher, "redo", !0),
				i = Vu(this._keybindingWatcher, qu.commandID, !0),
				s = [new bC("Learn More", j1(Yh.commandID))].concat(
					this._nextEditConfigManager.config.enablePanel
						? [new bC(`View All in Panel (${i})`, j1(qu.commandID))]
						: [],
				)
			this._addTutorial(
				"nextEditSuggestionAccepted",
				(o) => o.accepted,
				void 0,
				`You just applied a Next Edit suggestion! Use Undo (${r}) and Redo (${n}) to go back and forth between the original and suggested code.`,
				s,
				"tutorial-after-accept-shown",
			)
		}
		_addTutorial(r, n, i, s, o, a) {
			this._globalState.get(r) !== !0 &&
				this.addDisposable(
					this._suggestionManager.onSuggestionsChanged(async (l) => {
						if (
							!this._shouldShowTutorial(r, n(l), i) ||
							this._completionVisibilityWatcher.maybeInlineCompletionVisible
						)
							return
						this._globalState.update(r, !0),
							this._nextEditSessionEventReporter.reportEventWithoutIds(a, "unknown")
						let c = await X1.window.showInformationMessage(s, ...o)
						c?.action(),
							this._nextEditSessionEventReporter.reportEventWithoutIds(
								c ? "tutorial-nonempty-response" : "tutorial-empty-response",
								"unknown",
							)
					}),
				)
		}
		_shouldShowTutorial(r, n, i = void 0) {
			return i && (n = n.filter(i)), !(n.length === 0 || this._globalState.get(r) === !0)
		}
	}
function j1(e) {
	return () => void X1.commands.executeCommand(e, "tutorial")
}
var eQ = class extends z {
	constructor(r, n, i, s, o, a, l, c, u) {
		super()
		this.workspaceManager = r
		this._nextEditSessionEventReporter = n
		this._configListener = s
		this._suggestionManager = o
		this._requestManager = a
		this._nextEditConfigManager = c
		this._completionVisibilityWatcher = u
		this.addDisposable(
			new Qa.Disposable(() => {
				this._requestManager?.clearCompletedRequests(),
					this._suggestionManager?.clear(!1, "BACKGROUND"),
					this._noopReportTimer && (clearTimeout(this._noopReportTimer), (this._noopReportTimer = null))
			}),
		),
			this._scheduleNoopReport(),
			this.addDisposable(Qa.workspace.onDidChangeTextDocument(this._handleTextDocumentChanged)),
			this.addDisposable(Qa.window.onDidChangeTextEditorSelection(this._handleTextEditorSelectionChanged)),
			this.addDisposable(
				new Qa.Disposable(
					this._requestManager.lastFinishedRequest.listen((g) => {
						if (
							this._configListener.config.nextEdit.enableGlobalBackgroundSuggestions &&
							g &&
							g.apiResult === He.ok &&
							g.mode === "BACKGROUND" &&
							g.scope !== "WORKSPACE" &&
							g.suggestions.filter(ui).length === 0
						) {
							let m = Qa.window.activeTextEditor,
								y = m && this.workspaceManager.safeResolvePathName(m.document.uri)
							this._requestManager.enqueueRequest(y, "BACKGROUND", "WORKSPACE")
						}
					}),
				),
			),
			this.addDisposable(
				this._suggestionManager.onSuggestionsChanged((g) => {
					for (let C of g.accepted.filter((v) => v.result.truncationChar !== void 0))
						this._requestManager.enqueueRequest(C.qualifiedPathName, "BACKGROUND", "CURSOR", C.lineRange)
					let y = g.accepted
						.map((C) => C.requestId)
						.map((C) => g.newSuggestions.filter((v) => ui(v) && v.requestId === C))
					for (let C of y)
						if (!C.some((v) => v.result.truncationChar === void 0))
							for (let v of C)
								this._requestManager.enqueueRequest(
									v.qualifiedPathName,
									"BACKGROUND",
									"CURSOR",
									v.lineRange,
								)
				}),
			),
			this.addDisposable(
				new Z1(
					this._configListener,
					this._suggestionManager,
					i,
					l,
					n,
					this._nextEditConfigManager,
					this._completionVisibilityWatcher,
				),
			)
		let f = Qa.window.activeTextEditor
		if (!f) return
		let p = this.workspaceManager.safeResolvePathName(f.document.uri)
		p &&
			(this._requestManager.enqueueRequest(p, "BACKGROUND", "FILE"),
			this._requestManager.enqueueRequest(p, "BACKGROUND", "CURSOR"))
	}
	_logger = X("BackgroundNextEdits")
	_noopSources = new Set()
	_noopReportTimer = null
	_noopReportDelayMs = 6e4 * 5
	get _isDebugging() {
		return Qa.debug.activeDebugSession !== void 0 && !this._configListener.config.nextEdit.allowDuringDebugging
	}
	_scheduleNoopReport() {
		this._noopReportTimer && (clearTimeout(this._noopReportTimer), (this._noopReportTimer = null)),
			(this._noopReportTimer = setTimeout(() => {
				this._reportNoopSources(), this._scheduleNoopReport()
			}, this._noopReportDelayMs))
	}
	_reportNoopSources() {
		if (this._noopSources.size !== 0) {
			for (let r of this._noopSources.values())
				this._nextEditSessionEventReporter.reportEventWithoutIds("background-noop", r)
			this._noopSources.clear()
		}
	}
	_handleTextDocumentChanged = (r) => {
		if (r.contentChanges.length === 0) {
			this._noopSources.add("no-content-changes")
			return
		}
		if (this._isDebugging) {
			this._noopSources.add("debug-session")
			return
		}
		if (tf(r.document)) {
			this._noopSources.add("notebook-document")
			return
		}
		if (!o_e(r.document.uri)) {
			this._noopSources.add("unsupported-uri")
			return
		}
		let n = this.workspaceManager.safeResolvePathName(r.document.uri)
		if (!n) {
			this._noopSources.add("missing-path-name")
			return
		}
		let i = Qa.window.activeTextEditor
		if (!i || r.document !== i.document) {
			this._noopSources.add("not-active-editor")
			return
		}
		if (
			(this._logger.debug(`Received TextDocumentChangeEvent for ${n.relPath}`),
			this._suggestionManager
				.getActiveSuggestions()
				.filter((o) => o.qualifiedPathName.equals(n) && ui(o) && o.result.truncationChar === void 0).length > 0)
		) {
			this._noopSources.add("fresh-suggestions"),
				this._logger.debug("Continuing with remaining fresh suggestions.")
			return
		}
		this._requestManager.enqueueRequest(n, "BACKGROUND", "FILE"),
			this._requestManager.enqueueRequest(n, "BACKGROUND", "CURSOR")
	}
	_handleTextEditorSelectionChanged = (r) => {
		let n = Qa.window.activeTextEditor
		if (!n || r.textEditor.document !== n.document || dC() || this._isDebugging || yo(n.document.uri)) return
		let i = this.workspaceManager.safeResolvePathName(r.textEditor.document.uri)
		if (!i) return
		let s = this._suggestionManager
				.getActiveSuggestions()
				.filter((a) => a.qualifiedPathName.equals(i) && (a.state === "fresh" || a.state === "accepted")),
			o = $u(n.selection)
		s.some((a) => {
			let l = a.state === "accepted" ? a.afterLineRange(n.document) : a.lineRange
			return l.intersects(o) || l.touches(o)
		}) ||
			(this._requestManager.enqueueRequest(i, "BACKGROUND", "FILE"),
			this._requestManager.enqueueRequest(i, "BACKGROUND", "CURSOR"))
	}
}
var ta = class e {
	constructor(t, r = (i, s) => i === s, n = []) {
		this._value = t
		this._equalityFn = r
		this._listeners = n
	}
	static watch(t, ...r) {
		let n = () => t(...r.map((a) => a.value)),
			i = new e(n()),
			s = r.map((a) =>
				a.listen(() => {
					i.value = n()
				}),
			),
			o = i.dispose
		return (
			(i.dispose = () => {
				o(), s.forEach((a) => a())
			}),
			i
		)
	}
	dispose = () => {
		this._listeners = []
	}
	listen(t, r = !1) {
		return (
			r && t(this._value, this._value),
			this._listeners.push(t),
			() => {
				this._listeners = this._listeners.filter((n) => n !== t)
			}
		)
	}
	get value() {
		return this._value
	}
	set value(t) {
		if (this._equalityFn(t, this._value)) return
		let r = this._value
		this._value = t
		for (let n of this._listeners) n(t, r)
	}
	waitUntil(t, r) {
		return new Promise((n, i) => {
			let s,
				o =
					r !== void 0 &&
					setTimeout(() => {
						s?.(), i(new Error("Timeout exceeded."))
					}, r)
			s = this.listen((a) => {
				t(a) && (o && clearTimeout(o), s?.(), n(a))
			}, !0)
		})
	}
}
var tQ = class extends z {
	_maybeInlineCompletionVisible = new ta(!1)
	constructor() {
		super(),
			this.addDisposable(
				Axe((t) => {
					this._maybeInlineCompletionVisible.value = t
				}),
			)
	}
	get maybeInlineCompletionVisible() {
		return this._maybeInlineCompletionVisible.value
	}
	listen(t) {
		return this._maybeInlineCompletionVisible.listen(t)
	}
}
var D_e = W(gs()),
	Ie = W(require("vscode"))
var Yu = W(require("vscode"))
var c8 = class {
		constructor(t, r) {
			this.suggestion = t
			this.isNext = r
		}
		toString() {
			return "hinted-suggestion"
		}
	},
	Kn = class {
		constructor() {}
		get suggestion() {}
		toString() {
			return "no-suggestions"
		}
	},
	ls = class {
		constructor(t, r) {
			this.suggestion = t
			this.isNext = r
		}
		toString() {
			return "hinting"
		}
		get hintedSuggestion() {
			return new c8(this.suggestion, this.isNext)
		}
	},
	_r = class {
		constructor(t) {
			this.suggestion = t
		}
		toString() {
			return "before-preview"
		}
	},
	Ut = class {
		constructor(t) {
			this.suggestion = t
		}
		toString() {
			return "after-preview"
		}
	},
	wr = class {
		constructor(t, r, n) {
			this.suggestion = t
			this.selection = r
			this.timeout = n
		}
		toString() {
			return "animating"
		}
	}
function a_e(e, t) {
	return e instanceof Kn && t instanceof Kn
		? !0
		: e instanceof ls && t instanceof ls
			? e.suggestion.equals(t.suggestion) && e.isNext === t.isNext
			: (e instanceof _r && t instanceof _r) || (e instanceof Ut && t instanceof Ut)
				? e.suggestion.equals(t.suggestion)
				: e instanceof wr && t instanceof wr
					? e.suggestion.equals(t.suggestion) && e.selection.isEqual(t.selection) && e.timeout === t.timeout
					: !1
}
var rQ = class {
	constructor(t, r) {
		this._state = t
		this._keybindingWatcher = r
	}
	_onDidChangeCodeLenses = new Yu.EventEmitter()
	onDidChangeCodeLenses = this._onDidChangeCodeLenses.event
	get _activeSuggestion() {
		return this._state.value instanceof _r || this._state.value instanceof Ut || this._state.value instanceof wr
			? this._state.value.suggestion
			: void 0
	}
	refresh() {
		this._onDidChangeCodeLenses.fire()
	}
	_buildCodeLens(t, r, n) {
		return new Yu.CodeLens(n, {
			title: t,
			command: r,
			tooltip: this._getKeybindingForCommand(r, !0) ?? void 0,
			arguments: ["code-lens"],
		})
	}
	_getKeybindingForCommand(t, r = !1) {
		return Vu(this._keybindingWatcher, t, r)?.replace("Escape", "esc")
	}
	provideCodeLenses(t, r) {
		let n = this._activeSuggestion
		if (!n) return []
		if (!n.qualifiedPathName.equals(t.uri)) return []
		let i = [],
			s = new Yu.Range(new Yu.Position(n.lineRange.start, 0), new Yu.Position(n.lineRange.start, 0))
		return (
			i.push(
				new Yu.CodeLens(s, {
					title: `Augment Next Edit: ${n.result.changeDescription}`,
					command: "",
				}),
			),
			this._state.value instanceof Ut || this._state.value instanceof wr
				? i.push(this._buildCodeLens("Undo", Co.commandID, s))
				: i.push(this._buildCodeLens("Apply", Dc.commandID, s)),
			i.push(this._buildCodeLens("Reject", Tc.commandID, s)),
			i
		)
	}
}
var xC = require("vscode")
var l_e = new xC.EventEmitter(),
	vA = l_e.event,
	S_ = class extends z {
		constructor(r, n, i) {
			super()
			this._reportId = n
			this._vcsDetails = i
			this._logger = X(`HeadChangeWatcher[${r}]`)
		}
		_logger
		listening = !1
		handleChange = () => {
			this._logger.debug("handling HEAD change"), l_e.fire({ repoId: this._reportId })
		}
		listenForChanges() {
			if (this.listening) return
			if (this._vcsDetails.toolName !== "git") throw new Error("only git is supported for now")
			let r = xC.workspace.createFileSystemWatcher(
				new xC.RelativePattern(this._vcsDetails.root, ".git/logs/HEAD"),
			)
			this.addDisposables(
				r,
				r.onDidCreate(this.handleChange),
				r.onDidChange(this.handleChange),
				r.onDidDelete(this.handleChange),
			),
				(this.listening = !0),
				this._logger.debug("Listening for HEAD changes.")
		}
	}
var _C = require("vscode")
var nQ = new _C.EventEmitter(),
	sQ = nQ.event,
	iQ = class extends z {
		constructor(r, n, i) {
			super()
			this._repoRoot = r
			this._folderName = n
			this._repoId = i
			this._logger = X(`StashWatcher[${this._folderName}]`)
		}
		_logger
		listening = !1
		listenForChanges() {
			if (this.listening) return
			let r = _C.Uri.joinPath(this._repoRoot, ".git", "refs", "stash"),
				n = _C.workspace.createFileSystemWatcher(r.fsPath)
			this.addDisposables(
				n,
				n.onDidCreate(() => {
					this._logger.debug("Stash created"), nQ.fire({ repoId: this._repoId })
				}),
				n.onDidChange(() => {
					this._logger.debug("Stash changed"), nQ.fire({ repoId: this._repoId })
				}),
				n.onDidDelete(() => {
					this._logger.debug("Stash deleted"), nQ.fire({ repoId: this._repoId })
				}),
			),
				(this.listening = !0),
				this._logger.debug("Listening for stash changes.")
		}
	}
var y_e = W(require("assert")),
	qe = W(require("vscode"))
var oQ = W(require("vscode")),
	u_e = "var(--vscode-editorGhostText-foreground)"
function d8() {
	return oQ.window.createTextEditorDecorationType({
		after: { contentText: " ", margin: "0 0 0 3em" },
	})
}
function f8(e) {
	let t = { after: { color: u_e, margin: "0 0.25em 0 0" } }
	return (e || [1, 2, 3, 4, 5]).map((n, i) => oQ.window.createTextEditorDecorationType({ ...t, ...(e ? e[i] : {}) }))
}
function aQ(e) {
	return oQ.window.createTextEditorDecorationType({
		after: { color: u_e, margin: "0 0 0 0.5em", contentText: e },
	})
}
function d_e() {
	return [d8(), f8(), aQ()]
}
var X0t = W(require("vscode"))
function lQ(e) {
	return e
		.replace(/&/g, "&amp;")
		.replace(/</g, "&lt;")
		.replace(/>/g, "&gt;")
		.replace(/"/g, "&quot;")
		.replace(/'/g, "&#039;")
}
var eyt = new Map([
	[31, "a"],
	[32, "b"],
	[33, "c"],
	[34, "d"],
	[35, "e"],
	[36, "f"],
	[37, "g"],
	[38, "h"],
	[39, "i"],
	[40, "j"],
	[41, "k"],
	[42, "l"],
	[43, "m"],
	[44, "n"],
	[45, "o"],
	[46, "p"],
	[47, "q"],
	[48, "r"],
	[49, "s"],
	[50, "t"],
	[51, "u"],
	[52, "v"],
	[53, "w"],
	[54, "x"],
	[55, "y"],
	[56, "z"],
	[4, "shift"],
	[20, "delete"],
	[3, "return"],
	[2, "tab"],
	[9, "escape"],
	[85, "semicolon"],
	[1, "backspace"],
	[5, { linux: "ctrl", win32: "ctrl", darwin: "control" }],
	[6, { linux: "alt", win32: "alt", darwin: "option" }],
	[57, { linux: "meta", win32: "win", darwin: "command" }],
])
function f_e(e, t) {
	let r = eyt.get(e)
	return r == null || (typeof r == "object" && ((r = r[t]), r == null)) ? null : r
}
function tyt(e, t) {
	let r = f_e(e, t)
	return r == null ? null : `$(augment-kb-${r})`
}
function h_e(e, t) {
	let r = f_e(e, t)
	if (r == null) return null
	let i = Qy()?.contributes.icons[`augment-kb-${r}`].default.fontCharacter?.replace("\\", "") ?? null
	return i == null ? null : String.fromCharCode(parseInt(i, 16))
}
function g_e(e, t) {
	return e == null || e.chords.length < 1
		? null
		: e.chords.find((n) => n instanceof Jh)
			? e.toPrettyString(t)
			: e.chords
					.map((n) => {
						let i = [],
							s = (o) => {
								i.push(tyt(o, t))
							}
						return (
							n.ctrlKey && s(5),
							n.shiftKey && s(4),
							n.altKey && s(6),
							n.metaKey && s(57),
							n.keyCode && s(n.keyCode),
							i.some((o) => o == null) ? lQ(e.toPrettyString(t)) : i.join("&nbsp;")
						)
					})
					.join("&nbsp;&nbsp;")
}
function B_(e, t, r) {
	let n = kc.getStructuredKeybinding(t.getKeybindingForCommand(e))
	if (!n || n.chords.length < 1) return []
	if (n.chords.length > 1 || n.chords[0] instanceof Jh)
		return [
			{
				after: {
					contentText: n ? `[${n.toPrettyString(t.getSimplifiedPlatform())}]` : "",
				},
			},
		]
	{
		let i = n.chords[0],
			s = [],
			o = (l) => {
				s.push(h_e(l, t.getSimplifiedPlatform()))
			}
		if (
			(i.ctrlKey && o(5),
			i.shiftKey && o(4),
			i.altKey && o(6),
			i.metaKey && o(57),
			i.keyCode && o(i.keyCode),
			s.some((l) => l == null))
		)
			return [
				{
					after: {
						contentText: n ? `[${n.toPrettyString(t.getSimplifiedPlatform())}]` : "",
					},
				},
			]
		let a = {
			fontFamily: '"Augment.vscode-augment/augment-kb-icon-font.woff"',
			verticalAlign: "bottom",
		}
		return s.map((l) => ({
			light: { after: { ...a, contentText: l } },
			dark: { after: { ...a, contentText: l } },
		}))
	}
}
var wC = W(require("vscode"))
function ng(e) {
	let t = new wC.Position(e, 0)
	return new wC.Range(t, t)
}
function ig(e, t) {
	let r = e.document.lineAt(t).range.end
	return new wC.Range(r, r)
}
var A_e = W(require("assert")),
	cQ = W(require("vscode"))
var p_e = X("DecorationManager"),
	uQ = class extends z {
		previousDecorationsPerEditor = new Map()
		addExtraDecorationsForActiveEditor(t, r, n, i) {
			return t
		}
		getDecorationsForNextSuggestion
		decorate(t, r) {
			let n = new Map()
			for (let i of cQ.window.visibleTextEditors) {
				if (!i.viewColumn) continue
				let s = n.get(i) ?? n.set(i, this.createEmptyDecorations()).get(i),
					o = t.filter((a) => a.qualifiedPathName.equals(i.document.uri))
				for (let a of o) this.addDecorationsForItem(s, i, a, r)
				i === cQ.window.activeTextEditor && this.addExtraDecorationsForActiveEditor(s, i, t, r)
			}
			for (let [i, s] of n)
				for (let [o, a] of s) {
					if (o === void 0) {
						p_e.warn("Got an undefined decoration type.")
						continue
					}
					;(0, A_e.default)(a.every((l) => l instanceof a[0].constructor)), i.setDecorations(o, a)
				}
			for (let [i, s] of this.previousDecorationsPerEditor) {
				if (!cQ.window.visibleTextEditors.includes(i)) {
					this.previousDecorationsPerEditor.delete(i)
					continue
				}
				if (!n.has(i))
					for (let [o, a] of s) {
						if (o === void 0) {
							p_e.warn("Got an undefined decoration type.")
							continue
						}
						i.setDecorations(o, [])
					}
			}
			this.previousDecorationsPerEditor = n
		}
	}
var Na = class e {
	constructor(t, r, n, i, s, o, a = "file", l = new Date(), c = "fresh") {
		this.requestId = t
		this.mode = r
		this.scope = n
		this.result = i
		this.qualifiedPathName = s
		this.lineRange = o
		this.uriScheme = a
		this.occurredAt = l
		this.state = c
		;(this.changeType = e.determineChangeType(this.result.existingCode, this.result.suggestedCode)),
			this.changeType === "modification" &&
				this.makeOneLineDiffSpans()
					.filter((f) => f.type !== "noop")
					.every((f) => f.type === "insertion" && f.updated.isWholeLine) &&
				(this.changeType = "insertion"),
			this.changeType === "insertion" && this.lineRange.start > 0
				? (this.highlightRange = new Rn(
						this.lineRange.start - 1,
						this.lineRange.stop -
							(this.lineRange.stop > this.lineRange.start &&
							this.result.existingCode.indexOf(`
`) === -1
								? 1
								: 0),
					))
				: this.changeType === "insertion" && this.lineRange.start === 0 && this.lineRange.stop === 0
					? (this.highlightRange = new Rn(0, 1))
					: (this.highlightRange = this.lineRange)
	}
	changeType
	highlightRange
	previewCursorRange(t) {
		let r = this.previewBoxRange(t)
		return new Rn(Math.max(0, r.start - 1), r.stop)
	}
	previewBoxRange(t) {
		let r = this.state === "accepted",
			n = r ? this.afterLineRange(t) : this.highlightRange
		return (
			r &&
				(this.changeType === "deletion" && n.start > 0
					? (n = new Rn(
							n.start - 1,
							n.stop -
								(n.stop > n.start &&
								this.result.suggestedCode.indexOf(`
`) === -1
									? 1
									: 0),
						))
					: this.changeType === "deletion" && n.start === 0 && n.stop === 0 && (n = new Rn(0, 1))),
			n
		)
	}
	get previewTargetCursorLine() {
		return Math.max(0, this.lineRange.start - 1)
	}
	toString() {
		return `EditSuggestion(${this.qualifiedPathName.relPath}:${this.lineRange.toString()})`
	}
	equals(t) {
		return this.result.suggestionId === t?.result.suggestionId
	}
	compareTo(t) {
		return this.qualifiedPathName.equals(t.qualifiedPathName)
			? this.lineRange.compareTo(t.lineRange)
			: this.qualifiedPathName.relPath.localeCompare(t.qualifiedPathName.relPath)
	}
	makeOneLineDiffSpans() {
		return e.makeOneLineDiffSpans(
			this.result.diffSpans,
			this.result.existingCode,
			this.result.suggestedCode,
			this.lineRange,
		)
	}
	static determineChangeType(t, r) {
		return t === r ? "noop" : t === "" ? "insertion" : r === "" ? "deletion" : "modification"
	}
	static makeOneLineDiffSpans(t, r, n, i) {
		if (!t) return []
		let s = t.sort((f, p) => f.original.start - p.original.start),
			o = [],
			a = i.start,
			l = i.start,
			c = !0,
			u = !0
		for (let f of s) {
			let p = r.slice(f.original.start, f.original.stop),
				g = n.slice(f.updated.start, f.updated.stop),
				m = e.determineChangeType(p, g),
				y = p.split(`
`),
				C = g.split(`
`),
				v = Math.max(y.length, C.length),
				b = f.original.start,
				w = f.updated.start
			for (let B = 0; B < v; B++) {
				let M = y.length > B ? y[B] : "",
					Q = C.length > B ? C[B] : ""
				if (
					(B < y.length - 1 &&
						(M += `
`),
					B < C.length - 1 &&
						(Q += `
`),
					M === "" && Q === "")
				)
					continue
				let O = m
				o.push({
					original: {
						text: M,
						charRange: new bo(b, b + M.length),
						line: a,
						isWholeLine:
							c &&
							M.endsWith(`
`),
					},
					updated: {
						text: Q,
						charRange: new bo(w, w + Q.length),
						line: l,
						isWholeLine:
							u &&
							Q.endsWith(`
`),
					},
					type: O,
				}),
					(b += M.length),
					(w += Q.length),
					M.endsWith(`
`)
						? (a++, (c = !0))
						: (c = !1),
					Q.endsWith(`
`)
						? (l++, (u = !0))
						: (u = !1)
			}
		}
		return o.filter((f) => f.original.text !== "" || f.updated.text !== "")
	}
	afterLineRange(t) {
		return this.state !== "accepted"
			? this.lineRange
			: t
				? this.result.charStart + yl(this.result.suggestedCode) > yl(t.getText())
					? this.lineRange
					: new Rn(
							t.positionAt(this.result.charStart).line,
							t.positionAt(this.result.charStart + yl(this.result.suggestedCode)).line,
						)
				: new Rn(
						this.lineRange.start,
						this.lineRange.stop +
							this.result.suggestedCode.split(`
`).length -
							this.result.existingCode.split(`
`).length,
					)
	}
	intersects(t) {
		return (
			this.qualifiedPathName.equals(t.qualifiedPathName) &&
			(this.lineRange.equals(t.lineRange) || this.lineRange.intersects(t.lineRange))
		)
	}
	with(t) {
		return new e(
			t.requestId ?? this.requestId,
			t.mode ?? this.mode,
			t.scope ?? this.scope,
			t.result ?? this.result,
			t.qualifiedPathName ?? this.qualifiedPathName,
			t.lineRange ?? this.lineRange,
			t.uriScheme ?? this.uriScheme,
			t.occurredAt ?? this.occurredAt,
			t.state ?? this.state,
		)
	}
	static from(t) {
		return new e(
			t.requestId,
			t.mode,
			t.scope,
			t.result,
			Je.from(t.qualifiedPathName),
			new Rn(t.lineRange.start, t.lineRange.stop),
			t.uriScheme,
			t.occurredAt,
			t.state,
		)
	}
}
var Nc = W(require("vscode"))
var m_e = { border: 0, background: 1, line: 2 },
	dQ = class extends z {
		constructor(r) {
			super()
			this._styles = r
			;(this._decorationTypes.insertion = this._createDecorations(this._styles.insertion)),
				(this._decorationTypes.deletion = this._createDecorations(this._styles.deletion)),
				this.addDisposables(
					...Object.values(this._decorationTypes.insertion).flat(),
					...Object.values(this._decorationTypes.deletion).flat(),
				)
		}
		_decorationTypes = {
			insertion: { upper: [], lower: [] },
			deletion: { upper: [], lower: [] },
		}
		_createDecorations(r) {
			return {
				upper: this._createHalfDecoration(r, !1),
				lower: this._createHalfDecoration(r, !0),
			}
		}
		_createHalfDecoration(r, n) {
			let i = (s) => (n ? `${s} 0 0 0` : `0 0 ${s} 0`)
			return [
				Nc.window.createTextEditorDecorationType({
					borderWidth: i(r.borderWidth),
					light: { borderColor: r.lightBorderColor },
					dark: { borderColor: r.darkBorderColor },
					borderStyle: "solid",
					isWholeLine: !0,
				}),
				Nc.window.createTextEditorDecorationType({
					borderWidth: i("0.2em"),
					light: { borderColor: r.lightBackgroundColor },
					dark: { borderColor: r.darkBackgroundColor },
					borderStyle: "solid",
					isWholeLine: !0,
				}),
				Nc.window.createTextEditorDecorationType({
					borderWidth: i("0.1em"),
					borderColor: r.lineColor,
					borderStyle: "solid",
					isWholeLine: !0,
					overviewRulerColor: n ? r.overviewRulerColor : void 0,
					overviewRulerLane: n ? Nc.OverviewRulerLane.Right : void 0,
				}),
			]
		}
		addEmptyDecorations(r) {
			for (let n of ["insertion", "deletion"])
				for (let i of ["upper", "lower"]) for (let s of this._decorationTypes[n][i]) r.set(s, [])
		}
		addDecorations(r, n, i) {
			if (n > 0) for (let s of this._decorationTypes[r].upper) i.get(s)?.push(new Nc.Range(n - 1, 0, n - 1, 0))
			for (let s of this._decorationTypes[r].lower) i.get(s)?.push(new Nc.Range(n, 0, n, 0))
		}
		addSimpleInsertionDecoration(r, n) {
			r > 0 && n.get(this._decorationTypes.insertion.upper[m_e.line])?.push(new Nc.Range(r - 1, 0, r - 1, 0)),
				n.get(this._decorationTypes.insertion.lower[m_e.line])?.push(new Nc.Range(r, 0, r, 0))
		}
	}
var fQ = class e extends uQ {
	constructor(r, n, i, s, o, a, l) {
		super()
		this._context = r
		this._workspaceManager = n
		this._keybindingWatcher = i
		this._configListener = s
		this._nextEditSessionEventReporter = o
		this._completionVisible = a
		this._showAllLineHighlights = l
		let c = {
				active: {
					insertion: {
						light: "nextedit-addition-selected-light.svg",
						dark: "nextedit-addition-selected-dark.svg",
					},
					insertionInBetween: {
						light: "nextedit-addition-inbetween-selected-light.svg",
						dark: "nextedit-addition-inbetween-selected-dark.svg",
					},
					deletion: {
						light: "nextedit-deletion-selected-light.svg",
						dark: "nextedit-deletion-selected-dark.svg",
					},
					modification: {
						light: "nextedit-change-selected-light.svg",
						dark: "nextedit-change-selected-dark.svg",
					},
				},
				inactive: {
					insertion: {
						light: "nextedit-addition-light.svg",
						dark: "nextedit-addition-dark.svg",
					},
					insertionInBetween: {
						light: "nextedit-addition-inbetween-light.svg",
						dark: "nextedit-addition-inbetween-dark.svg",
					},
					deletion: {
						light: "nextedit-deletion-light.svg",
						dark: "nextedit-deletion-dark.svg",
					},
					modification: {
						light: "nextedit-change-light.svg",
						dark: "nextedit-change-dark.svg",
					},
				},
				applied: {
					light: "nextedit-applied-light.svg",
					dark: "nextedit-applied-dark.svg",
				},
				appliedInBetween: {
					light: "nextedit-applied-inbetween-light.svg",
					dark: "nextedit-applied-inbetween-dark.svg",
				},
				grayline: {
					light: "bg-next-edit-gray-line.svg",
					dark: "bg-next-edit-gray-line.svg",
				},
				grayhook: {
					light: "bg-next-edit-gray-hook.svg",
					dark: "bg-next-edit-gray-hook.svg",
				},
			},
			u = new Map([
				[
					"insertion",
					{
						inline: "rgb(from var(--vscode-diffEditor-insertedTextBackground) r g b / calc(alpha * 1.8))",
						focusLine:
							"rgb(from var(--vscode-diffEditor-insertedTextBackground) r g b / calc(alpha * 1.3))",
						lineBackground: new qe.ThemeColor("diffEditor.insertedLineBackground"),
						lineOverview: new qe.ThemeColor("editorOverviewRuler.addedForeground"),
					},
				],
				[
					"deletion",
					{
						inline: "rgb(from var(--vscode-diffEditor-removedTextBackground) r g b / calc(alpha * 2))",
						focusLine: "var(--vscode-diffEditor-removedLineBackground)",
						lineBackground:
							"rgb(from var(--vscode-diffEditor-removedLineBackground) r g b / calc(alpha * 0.5))",
						lineOverview: new qe.ThemeColor("editorOverviewRuler.deletedForeground"),
					},
				],
				[
					"modification",
					{
						inline: "rgb(from var(--vscode-editorOverviewRuler-modifiedForeground) r g b / calc(alpha * 0.5))",
						focusLine:
							"rgb(from var(--vscode-editorOverviewRuler-modifiedForeground) r g b / calc(alpha * 0.35))",
						lineBackground:
							"rgb(from var(--vscode-editorOverviewRuler-modifiedForeground) r g b / calc(alpha * 0.2))",
						lineOverview: new qe.ThemeColor("editorOverviewRuler.modifiedForeground"),
					},
				],
			]),
			f = new Map([
				[
					"insertion",
					{
						dark: { backgroundColor: "#27E14966", color: "#BCF0C9" },
						light: { backgroundColor: "#82CC0266", color: "#4B543E" },
					},
				],
				[
					"deletion",
					{
						dark: { backgroundColor: "#FF272766", color: "#F4A2A6" },
						light: { backgroundColor: "#FF272766", color: "#412C2D" },
					},
				],
				[
					"modification",
					{
						dark: { backgroundColor: "#FFE30966", color: "#F4EEB6" },
						light: { backgroundColor: "#EDBD0099", color: "#433C1E" },
					},
				],
			]),
			p = {
				light: {
					after: {
						color: "color-mix(in srgb, rgb(0, 0, 0) 50%, var(--vscode-editor-background))",
						backgroundColor: "color-mix(in srgb, rgb(0,0,0) 15%, var(--vscode-editor-background))",
					},
				},
				dark: {
					after: {
						color: "color-mix(in srgb, rgb(255, 255, 255) 90%, var(--vscode-editor-background))",
						backgroundColor: "color-mix(in srgb, rgb(255, 255, 255) 25%, var(--vscode-editor-background))",
					},
				},
			},
			g = (v, b, w, B = "75%") => {
				let M = c[v][b][w]
				return {
					gutterIconPath: qe.Uri.joinPath(r.extensionUri, "media", "next-edit", M),
					gutterIconSize: B,
				}
			},
			m = (v, b, w = "75%") => {
				let B = c[v][b]
				return {
					gutterIconPath: qe.Uri.joinPath(r.extensionUri, "media", "next-edit", B),
					gutterIconSize: w,
				}
			}
		;(this._gutterDecorations = {
			active: {
				insertion: qe.window.createTextEditorDecorationType({
					light: g("active", "insertion", "light"),
					dark: g("active", "insertion", "dark"),
					overviewRulerColor: u.get("insertion")?.lineOverview,
					overviewRulerLane: qe.OverviewRulerLane.Right,
				}),
				insertionInBetween: qe.window.createTextEditorDecorationType({
					light: g("active", "insertionInBetween", "light"),
					dark: g("active", "insertionInBetween", "dark"),
					overviewRulerColor: u.get("insertion")?.lineOverview,
					overviewRulerLane: qe.OverviewRulerLane.Right,
				}),
				deletion: qe.window.createTextEditorDecorationType({
					light: g("active", "deletion", "light"),
					dark: g("active", "deletion", "dark"),
					overviewRulerColor: u.get("deletion")?.lineOverview,
					overviewRulerLane: qe.OverviewRulerLane.Right,
				}),
				modification: qe.window.createTextEditorDecorationType({
					light: g("active", "modification", "light"),
					dark: g("active", "modification", "dark"),
					overviewRulerColor: u.get("modification")?.lineOverview,
					overviewRulerLane: qe.OverviewRulerLane.Right,
				}),
			},
			inactive: {
				insertion: qe.window.createTextEditorDecorationType({
					light: g("inactive", "insertion", "light"),
					dark: g("inactive", "insertion", "dark"),
					overviewRulerColor: u.get("insertion")?.lineOverview,
					overviewRulerLane: qe.OverviewRulerLane.Right,
				}),
				insertionInBetween: qe.window.createTextEditorDecorationType({
					light: g("inactive", "insertionInBetween", "light"),
					dark: g("inactive", "insertionInBetween", "dark"),
					overviewRulerColor: u.get("insertion")?.lineOverview,
					overviewRulerLane: qe.OverviewRulerLane.Right,
				}),
				deletion: qe.window.createTextEditorDecorationType({
					light: g("inactive", "deletion", "light"),
					dark: g("inactive", "deletion", "dark"),
					overviewRulerColor: u.get("deletion")?.lineOverview,
					overviewRulerLane: qe.OverviewRulerLane.Right,
				}),
				modification: qe.window.createTextEditorDecorationType({
					light: g("inactive", "modification", "light"),
					dark: g("inactive", "modification", "dark"),
					overviewRulerColor: u.get("modification")?.lineOverview,
					overviewRulerLane: qe.OverviewRulerLane.Right,
				}),
			},
			applied: qe.window.createTextEditorDecorationType({
				light: m("applied", "light"),
				dark: m("applied", "dark"),
			}),
			appliedInBetween: qe.window.createTextEditorDecorationType({
				light: m("appliedInBetween", "light"),
				dark: m("appliedInBetween", "dark"),
			}),
			grayline: qe.window.createTextEditorDecorationType({
				light: m("grayline", "light", "cover"),
				dark: m("grayline", "dark", "cover"),
			}),
			grayhook: qe.window.createTextEditorDecorationType({
				light: m("grayhook", "light", "cover"),
				dark: m("grayhook", "dark", "cover"),
			}),
		}),
			this.addDisposables(
				...Object.values(this._gutterDecorations.active),
				...Object.values(this._gutterDecorations.inactive),
				this._gutterDecorations.applied,
				this._gutterDecorations.appliedInBetween,
				this._gutterDecorations.grayline,
				this._gutterDecorations.grayhook,
			),
			(this._focusLineDecorations = new Map()),
			(this._focusWholeLineDecorations = new Map()),
			(this._wholeLineDecorations = new Map()),
			(this._lineDecorations = new Map()),
			(this._zeroWidthChangeDecorationsRight = new Map()),
			(this._zeroWidthChangeDecorationsLeft = new Map()),
			(this._zeroWidthChangeDecorationsStartLine = new Map()),
			(this._zeroWidthChangeDecorationsEndLine = new Map())
		for (let [v, b] of u) {
			this._focusLineDecorations.set(
				v,
				qe.window.createTextEditorDecorationType({
					backgroundColor: b.focusLine,
					isWholeLine: !1,
					overviewRulerColor: b.lineOverview,
					overviewRulerLane: qe.OverviewRulerLane.Right,
				}),
			),
				this._focusWholeLineDecorations.set(
					v,
					qe.window.createTextEditorDecorationType({
						backgroundColor: b.focusLine,
						isWholeLine: !0,
						overviewRulerColor: b.lineOverview,
						overviewRulerLane: qe.OverviewRulerLane.Right,
					}),
				),
				this._lineDecorations.set(
					v,
					qe.window.createTextEditorDecorationType({
						backgroundColor: b.lineBackground,
						isWholeLine: !1,
						overviewRulerColor: b.lineOverview,
						overviewRulerLane: qe.OverviewRulerLane.Right,
					}),
				),
				this._wholeLineDecorations.set(
					v,
					qe.window.createTextEditorDecorationType({
						backgroundColor: b.lineBackground,
						isWholeLine: !0,
						overviewRulerColor: b.lineOverview,
						overviewRulerLane: qe.OverviewRulerLane.Right,
					}),
				)
			let w = { borderStyle: "solid", borderColor: b.inline }
			this._zeroWidthChangeDecorationsRight.set(
				v,
				qe.window.createTextEditorDecorationType({
					borderWidth: "0 0.2em 0 0",
					...w,
				}),
			),
				this._zeroWidthChangeDecorationsLeft.set(
					v,
					qe.window.createTextEditorDecorationType({
						borderWidth: "0 0 0 0.2em",
						...w,
					}),
				),
				this._zeroWidthChangeDecorationsStartLine.set(
					v,
					qe.window.createTextEditorDecorationType({
						borderWidth: "0 0 0 0.4em",
						...w,
					}),
				),
				this._zeroWidthChangeDecorationsEndLine.set(
					v,
					qe.window.createTextEditorDecorationType({
						borderWidth: "0 0.4em 0 0",
						...w,
					}),
				)
		}
		this.addDisposables(
			...this._focusLineDecorations.values(),
			...this._focusWholeLineDecorations.values(),
			...this._lineDecorations.values(),
			...this._wholeLineDecorations.values(),
			...this._zeroWidthChangeDecorationsRight.values(),
			...this._zeroWidthChangeDecorationsLeft.values(),
			...this._zeroWidthChangeDecorationsStartLine.values(),
			...this._zeroWidthChangeDecorationsEndLine.values(),
		),
			(this._inlineDecorations = new Map())
		for (let [v, b] of f)
			this._inlineDecorations.set(
				v,
				qe.window.createTextEditorDecorationType({
					...b,
					borderRadius: "0.2em",
				}),
			)
		this.addDisposables(...this._inlineDecorations.values()),
			(this._bottomLineDecorationType = qe.window.createTextEditorDecorationType({
				after: { backgroundColor: "var(--vscode-editor-background)" },
			})),
			this.addDisposables(this._bottomLineDecorationType),
			(this._bottomBoxDecorationType = qe.window.createTextEditorDecorationType({
				light: { after: { backgroundColor: p.light.after.backgroundColor } },
				dark: { after: { backgroundColor: p.dark.after.backgroundColor } },
			})),
			this.addDisposables(this._bottomBoxDecorationType),
			(this._bottomBoxLogoDecorationType = qe.window.createTextEditorDecorationType({
				light: { after: { color: p.light.after.color } },
				dark: {
					after: {
						color: `color-mix(in srgb, ${p.dark.after.color} 50%, ${p.dark.after.backgroundColor})`,
					},
				},
			})),
			this.addDisposables(this._bottomBoxLogoDecorationType),
			([this._rightSpacerDecorationType, this._rightKeybindingDecorationTypes, this._rightDecorationType] =
				d_e()),
			this.addDisposables(
				this._rightSpacerDecorationType,
				...this._rightKeybindingDecorationTypes,
				this._rightDecorationType,
			),
			(this._bottomTextDecorationType = qe.window.createTextEditorDecorationType({
				dark: {
					after: {
						color: p.dark.after.color,
						backgroundColor: p.dark.after.backgroundColor,
					},
				},
				light: {
					after: {
						color: p.light.after.color,
						backgroundColor: p.light.after.backgroundColor,
					},
				},
			})),
			this.addDisposables(this._bottomTextDecorationType)
		let y = {
				light: {
					borderColor: "#87BFFF80",
					backgroundColor: "#87BFFF33",
					overviewRulerColor: "#87BFFF",
				},
				dark: {
					borderColor: "#9ECBFF80",
					backgroundColor: "#9ECBFF1A",
					overviewRulerColor: "#9ECBFF",
				},
				borderStyle: "solid",
				isWholeLine: !0,
				borderWidth: "0.1em",
				borderRadius: "0.4em",
				overviewRulerLane: qe.OverviewRulerLane.Right,
			},
			C = {
				light: {
					borderColor: "#87BFFF",
					backgroundColor: "#87BFFF33",
					overviewRulerColor: "#87BFFF",
				},
				dark: {
					borderColor: "#9ECBFF",
					backgroundColor: "#9ECBFF1A",
					overviewRulerColor: "#9ECBFF",
				},
				borderStyle: "solid",
				isWholeLine: !0,
				borderWidth: "0.2em",
				borderRadius: "0.4em",
				overviewRulerLane: qe.OverviewRulerLane.Right,
			}
		;(this._zeroHeightDiffLineBuilder = new dQ({
			insertion: {
				lineColor: "rgb(from var(--vscode-diffEditor-insertedLineBackground) r g b / 1)",
				lightBorderColor: y.light.borderColor,
				darkBorderColor: y.dark.borderColor,
				lightBackgroundColor: "color-mix(in srgb, #87BFFF 33%, var(--vscode-editor-background))",
				darkBackgroundColor: "color-mix(in srgb, #9ECBFF 10%, var(--vscode-editor-background))",
				borderWidth: "0.3em",
				overviewRulerColor: u.get("insertion")?.lineOverview,
			},
			deletion: {
				lineColor: "rgb(from var(--vscode-diffEditor-removedLineBackground) r g b / calc(alpha * 1.3))",
				lightBorderColor: C.light.borderColor,
				darkBorderColor: C.dark.borderColor,
				lightBackgroundColor: "color-mix(in srgb, #87BFFF 33%, var(--vscode-editor-background))",
				darkBackgroundColor: "color-mix(in srgb, #9ECBFF 10%, var(--vscode-editor-background))",
				borderWidth: "0.4em",
				overviewRulerColor: u.get("deletion")?.lineOverview,
			},
		})),
			this.addDisposables(this._zeroHeightDiffLineBuilder),
			(this._activeChangeDecoration1Line = new Map()),
			(this._activeChangeDecorationTop = new Map()),
			(this._activeChangeDecorationMiddle = new Map()),
			(this._activeChangeDecorationBottom = new Map())
		for (let { baseType: v, mode: b } of [
			{ baseType: y, mode: 0 },
			{ baseType: C, mode: 1 },
		])
			this._activeChangeDecoration1Line.set(b, qe.window.createTextEditorDecorationType({ ...v })),
				this._activeChangeDecorationTop.set(
					b,
					qe.window.createTextEditorDecorationType({
						...v,
						borderWidth: [v.borderWidth, v.borderWidth, "0", v.borderWidth].join(" "),
						borderRadius: [v.borderRadius, v.borderRadius, "0", "0"].join(" "),
					}),
				),
				this._activeChangeDecorationMiddle.set(
					b,
					qe.window.createTextEditorDecorationType({
						...v,
						borderRadius: void 0,
						borderWidth: ["0", v.borderWidth, "0", v.borderWidth].join(" "),
					}),
				),
				this._activeChangeDecorationBottom.set(
					b,
					qe.window.createTextEditorDecorationType({
						...v,
						borderWidth: ["0", v.borderWidth, v.borderWidth, v.borderWidth].join(" "),
						borderRadius: ["0", "0", v.borderRadius, v.borderRadius].join(" "),
					}),
				)
		this.addDisposables(
			...this._activeChangeDecoration1Line.values(),
			...this._activeChangeDecorationTop.values(),
			...this._activeChangeDecorationMiddle.values(),
			...this._activeChangeDecorationBottom.values(),
		)
	}
	_gutterDecorations
	_lineDecorations
	_wholeLineDecorations
	_focusLineDecorations
	_focusWholeLineDecorations
	_inlineDecorations
	_rightDecorationType
	_bottomBoxLogoDecorationType
	_rightKeybindingDecorationTypes
	_rightSpacerDecorationType
	_bottomLineDecorationType
	_bottomBoxDecorationType
	_bottomTextDecorationType
	_zeroWidthChangeDecorationsRight
	_zeroWidthChangeDecorationsLeft
	_zeroWidthChangeDecorationsStartLine
	_zeroWidthChangeDecorationsEndLine
	_activeChangeDecoration1Line
	_activeChangeDecorationTop
	_activeChangeDecorationMiddle
	_activeChangeDecorationBottom
	_zeroHeightDiffLineBuilder
	shouldDrawBottomDecorations = new ta(!0)
	babyGlobalHintRange
	bottomBoxRange
	cursorHintRange
	_filesWithGutterIconActions = new Set()
	_linesWithGutterIconActions = []
	_logger = X("BackgroundDecorationManager")
	static suppressGhostTextLineThreshold = 3
	static _maxGrayTextChars = 40
	static _maxBottomTextPathChars = 40
	static _maxBottomTextChars = 80
	createEmptyDecorations() {
		let r = new Map()
		r.set(this._rightSpacerDecorationType, []),
			r.set(this._rightDecorationType, []),
			this._rightKeybindingDecorationTypes.forEach((i) => {
				r.set(i, [])
			}),
			r.set(this._bottomLineDecorationType, []),
			r.set(this._bottomBoxDecorationType, []),
			r.set(this._bottomBoxLogoDecorationType, []),
			r.set(this._bottomTextDecorationType, []),
			this._zeroHeightDiffLineBuilder.addEmptyDecorations(r),
			this._activeChangeDecoration1Line.forEach((i) => {
				r.set(i, [])
			}),
			this._activeChangeDecorationTop.forEach((i) => {
				r.set(i, [])
			}),
			this._activeChangeDecorationMiddle.forEach((i) => {
				r.set(i, [])
			}),
			this._activeChangeDecorationBottom.forEach((i) => {
				r.set(i, [])
			}),
			Object.values(this._gutterDecorations.active).forEach((i) => {
				r.set(i, [])
			}),
			Object.values(this._gutterDecorations.inactive).forEach((i) => {
				r.set(i, [])
			}),
			r.set(this._gutterDecorations.applied, []),
			r.set(this._gutterDecorations.appliedInBetween, []),
			r.set(this._gutterDecorations.grayline, []),
			r.set(this._gutterDecorations.grayhook, [])
		let n = ["insertion", "deletion", "modification"]
		for (let i of n)
			r.set(this._lineDecorations.get(i), []),
				r.set(this._focusLineDecorations.get(i), []),
				r.set(this._wholeLineDecorations.get(i), []),
				r.set(this._focusWholeLineDecorations.get(i), []),
				r.set(this._inlineDecorations.get(i), []),
				r.set(this._zeroWidthChangeDecorationsRight.get(i), []),
				r.set(this._zeroWidthChangeDecorationsLeft.get(i), []),
				r.set(this._zeroWidthChangeDecorationsStartLine.get(i), []),
				r.set(this._zeroWidthChangeDecorationsEndLine.get(i), [])
		return r
	}
	decorate(r, n) {
		this._filesWithGutterIconActions.clear(),
			(this._linesWithGutterIconActions = []),
			super.decorate(r, n),
			qe.commands.executeCommand(
				"setContext",
				"vscode-augment.nextEdit.linesWithGutterIconActions",
				this._linesWithGutterIconActions,
			),
			qe.commands.executeCommand(
				"setContext",
				"vscode-augment.nextEdit.filesWithGutterIconActions",
				Array.from(this._filesWithGutterIconActions),
			)
	}
	addDecorationsForItem(r, n, i, s) {
		if (!i.qualifiedPathName.equals(n.document.uri) || i.changeType === "noop") return r
		let o = i.equals(s.activeSuggestion),
			a = o || i.equals(s.hintSuggestion?.suggestion),
			l = i.state === "accepted",
			c = i.makeOneLineDiffSpans(),
			u = l ? i.afterLineRange(n.document) : i.lineRange,
			f
		u.start === 0 ||
		(i.changeType !== "insertion" && !(c[0] && c[0].type === "insertion" && c[0].updated.isWholeLine))
			? (f = u)
			: n.document.lineAt(u.start - 1).text.length > 0
				? (f = new Rn(u.start - 1, u.stop))
				: (f = new Rn(u.start - 1, u.stop - 1))
		let p = (ne) => {
				l ||
					(this._filesWithGutterIconActions.add(i.qualifiedPathName.absPath),
					this._linesWithGutterIconActions.push(ne + 1))
			},
			g = i.changeType === "insertion" && i.lineRange.length === 0 ? "insertionInBetween" : i.changeType,
			m = s.activeSuggestion !== void 0 && s.activeSuggestion.state !== "accepted",
			y
		l && u.length === 0
			? (y = this._gutterDecorations.appliedInBetween)
			: l
				? (y = this._gutterDecorations.applied)
				: o || (!m && a)
					? (y = this._gutterDecorations.active[g])
					: (y = this._gutterDecorations.inactive[g])
		let C = i.previewBoxRange(n.document)
		r.get(y)?.push(ng(C.start)), p(C.start)
		for (let ne = C.start + 1; ne < C.stop - 1; ne++) r.get(this._gutterDecorations.grayline)?.push(ng(ne)), p(ne)
		if (
			(C.stop - C.start > 1 && (r.get(this._gutterDecorations.grayhook)?.push(ng(C.stop - 1)), p(C.stop - 1)),
			(s.isAnimating && s.activeSuggestion && !o) || (a && this._completionVisible()))
		)
			return r
		let v = o,
			b = this._showAllLineHighlights() && !v && !l,
			w = Ds(f)
		if (b && !o)
			if (i.changeType === "insertion")
				this._zeroHeightDiffLineBuilder.addSimpleInsertionDecoration(w.start.line + 1, r)
			else {
				let ne =
						f.length === 0 ||
						i.result.existingCode ===
							`
`,
					q = [
						[this._lineDecorations, this._wholeLineDecorations],
						[this._focusLineDecorations, this._focusWholeLineDecorations],
					][+a][+ne],
					me = w
				ne && (me = w.with(void 0, w.end.translate(-1, 0))), r.get(q.get(i.changeType))?.push(me)
			}
		else if (v) {
			if ((i.changeType === "insertion" && !l) || (i.changeType === "deletion" && l))
				this._zeroHeightDiffLineBuilder.addDecorations(
					i.changeType,
					w.start.line + (i.changeType === "insertion" ? 1 : 0),
					r,
				)
			else if (i.changeType === (l ? "deletion" : "insertion")) {
				let q = f.length === 0 ? this._focusWholeLineDecorations : this._focusLineDecorations
				r.get(q.get(i.changeType))?.push(w)
			}
			for (let [q, me] of ryt(n.document, i, !l))
				if (q === "noop") b && r.get(this._focusLineDecorations.get(i.changeType))?.push(me)
				else if (q === "deletion" && me.start.character === 0 && me.end.character === 0) {
					r.get(this._focusLineDecorations.get(q))?.push(me)
					continue
				} else
					me.start.isEqual(me.end)
						? this._addZeroWidthDecoration(n.document, r, me, q)
						: r.get(this._inlineDecorations.get(q)).push(me)
			let ne = l ? 1 : 0
			this._addPreviewBox(r, n, i, ne)
		}
		let B = i.result.changeDescription,
			M = n.selection,
			Q = n.visibleRanges.some((ne) => ne.contains(Ds(f))),
			O = this._configListener.config.nextEdit.useCursorDecorations,
			Y = M.active.line - f.start,
			j = !O || Math.abs(Y) <= e.suppressGhostTextLineThreshold
		return (
			a &&
				Q &&
				!l &&
				!o &&
				(j &&
					this.addKeybindingDecor(
						f.start,
						r,
						n,
						this._configListener.config.nextEdit.enableGotoHinting
							? Fa.commandID
							: s.hintSuggestion?.isNext
								? Xo.commandID
								: Ou.commandID,
					),
				this.addGrayText(`${B}`, f.start, r, n),
				this._nextEditSessionEventReporter.reportEventFromSuggestion(i, "suggestion-hint-shown", "background")),
			Q &&
				!l &&
				this._nextEditSessionEventReporter.reportEventFromSuggestion(
					i,
					"suggestion-visibly-shown",
					"background",
				),
			r
		)
	}
	_addZeroWidthDecoration(r, n, i, s) {
		if (i.start.character === 0) {
			n.get(this._zeroWidthChangeDecorationsStartLine.get(s)).push(new qe.Range(i.start, i.start.translate(0, 1)))
			return
		} else if (i.start.character === r.lineAt(i.start.line).text.length) {
			n.get(this._zeroWidthChangeDecorationsEndLine.get(s)).push(new qe.Range(i.start.translate(0, -1), i.start))
			return
		} else
			n.get(this._zeroWidthChangeDecorationsLeft.get(s)).push(new qe.Range(i.start, i.start.translate(0, 1))),
				n
					.get(this._zeroWidthChangeDecorationsRight.get(s))
					.push(new qe.Range(i.start.translate(0, -1), i.start))
	}
	addKeybindingDecor(r, n, i, s = Xo.commandID) {
		B_(s, this._keybindingWatcher, this._context).map((o, a) => {
			n.get(this._rightKeybindingDecorationTypes[a])?.push({
				range: ig(i, r),
				renderOptions: o,
			})
		})
	}
	addGrayText(r, n, i, s) {
		i.get(this._rightSpacerDecorationType).push({ range: ig(s, n) })
		let o = Xl(r, e._maxGrayTextChars)
		i.get(this._rightDecorationType).push({
			range: ig(s, n),
			renderOptions: { after: { contentText: o } },
		})
	}
	addExtraDecorationsForActiveEditor(r, n, i, s) {
		;(0, y_e.default)(n === qe.window.activeTextEditor)
		let o = this._workspaceManager.safeResolvePathName(n.document.uri)
		if (!o) return r
		;(this.babyGlobalHintRange = void 0), (this.bottomBoxRange = void 0), (this.cursorHintRange = void 0)
		let a = s.hintSuggestion?.suggestion
		if (this._completionVisible() || !a || n.visibleRanges.length === 0) return r
		let l = this._configListener.config.nextEdit.useCursorDecorations
		if (a.qualifiedPathName.equals(n.document.uri)) {
			let c = a.result.changeDescription,
				u = n.selection,
				f
			if (
				(a.changeType !== "insertion" || a.lineRange.start === 0
					? (f = a.lineRange)
					: n.document.lineAt(a.lineRange.start - 1).text.length > 0
						? (f = new Rn(a.lineRange.start - 1, a.lineRange.stop))
						: (f = new Rn(a.lineRange.start - 1, a.lineRange.stop - 1)),
				l)
			) {
				let p = u.intersection(Ds(f)),
					g = u.start.line - f.start,
					m =
						Math.abs(g) > e.suppressGhostTextLineThreshold ||
						!n.visibleRanges.some((C) => C.contains(Ds(f))),
					y = ""
				!p && m && (y = `${g > 0 ? "\u2191" : "\u2193"}${Math.abs(g)} lines: `),
					(y || p) &&
						(this.addKeybindingDecor(
							u.start.line,
							r,
							n,
							this._configListener.config.nextEdit.enableGotoHinting
								? Fa.commandID
								: g <= 0
									? Xo.commandID
									: Ou.commandID,
						),
						this.addGrayText(`${y}${c}`, u.start.line, r, n),
						(this.cursorHintRange = ig(n, u.start.line)),
						this._nextEditSessionEventReporter.reportEventFromSuggestion(
							a,
							"suggestion-offset-text-shown",
							"background",
						))
			} else {
				if (n.visibleRanges.some((g) => g.contains(Ds(a.highlightRange)))) return r
				let p = f.start < l8(n)[0].start.line ? "\u2191" : "\u2193"
				this.addBottomDecoration(r, n, `${p} ${c}`),
					this._nextEditSessionEventReporter.reportEventFromSuggestion(
						a,
						"suggestion-bottom-text-shown",
						"background",
					)
			}
		} else if (this._configListener.config.nextEdit.enableGlobalBackgroundSuggestions) {
			if (l) {
				this.addKeybindingDecor(n.selection.active.line, r, n)
				let c = "in file: "
				this.addGrayText(
					`${c}${Xl(a.qualifiedPathName.relPath, e._maxGrayTextChars - yl(c), !0)}`,
					n.selection.active.line,
					r,
					n,
				),
					(this.babyGlobalHintRange = ig(n, n.selection.active.line))
			} else {
				let c = "\u21AA ",
					u = vl(o.relPath, a.qualifiedPathName.relPath),
					f = Xl(
						u.length < a.qualifiedPathName.relPath.length ? u : a.qualifiedPathName.relPath,
						e._maxBottomTextPathChars,
						!0,
					),
					p = a.result.changeDescription,
					g = Xl(`${c}${f}: ${p}`, e._maxBottomTextChars, !1)
				this.addBottomDecoration(r, n, g)
			}
			this._nextEditSessionEventReporter.reportEventFromSuggestion(
				a,
				"suggestion-global-bottom-text-shown",
				"background",
			)
		}
		return r
	}
	addBottomDecoration(r, n, i) {
		if (n.visibleRanges.length === 0 || !this.shouldDrawBottomDecorations.value) return
		let s = l8(n),
			o = s[s.length - 1],
			a = o.end.line >= n.document.lineCount - 1,
			l = n.selection,
			c = a ? l.active.line > o.end.line - 2 : l.active.line > o.end.line - 3
		if (s.some((v) => v.intersection(l)) && c) return
		let u = Xl(i, e._maxBottomTextChars),
			f = (v) => {
				if (v < 0 || v >= n.document.lineCount) return
				let b = n.document.lineAt(v).text.length
				r.get(this._bottomLineDecorationType).push({
					range: new qe.Range(v, b, v, b),
					renderOptions: {
						after: {
							margin: `0 ${-b}ch 0 ${-b}ch`,
							contentText: `${"\xA0".repeat(b)}`,
							padding: "0 0 0.3lh 0",
						},
					},
				})
			}
		a ? f(o.end.line) : (f(o.end.line - 1), f(o.end.line), f(o.end.line + 1), f(o.end.line + 2))
		let p = a ? n.document.lineCount - 1 : o.end.line - 1,
			g = n.document.lineAt(p).text.length,
			m = new qe.Range(p, g, p, g)
		;(this.babyGlobalHintRange = new qe.Range(p, 0, p, g)), (this.bottomBoxRange = this.babyGlobalHintRange)
		let y = 20
		r.get(this._bottomBoxDecorationType).push({
			range: m,
			renderOptions: {
				after: {
					margin: `0 -${y + 1}ch 0 0`,
					contentText: `${"\xA0".repeat(y)}`,
					padding: "0.2em 1ch 0.15em 1ch",
					borderRadius: "0.3em",
				},
			},
		})
		let C = {
			contentText: "\uE901",
			fontFamily: '"Augment.vscode-augment/augment-icon-font.woff"',
			verticalAlign: "top",
			margin: "0 1ch 0 0",
		}
		r.get(this._bottomBoxLogoDecorationType).push({
			renderOptions: { light: { after: C }, dark: { after: C } },
			range: m,
		}),
			this.addKeybindingDecor(p, r, n),
			r.get(this._bottomTextDecorationType).push({
				range: m,
				renderOptions: {
					after: {
						margin: "0 0 0 1ch",
						contentText: u,
						padding: "0.2em 1ch 0.15em 0",
						borderRadius: "0 0.3em 0.3em 0",
					},
				},
			})
	}
	_addPreviewBox(r, n, i, s) {
		let o = s === 1
		if ((i.changeType === "insertion" && !o) || (i.changeType === "deletion" && o)) return
		let a = i.previewBoxRange(n.document)
		a.stop - a.start <= 1
			? r.get(this._activeChangeDecoration1Line.get(s))?.push(ng(a.start))
			: r.get(this._activeChangeDecorationTop.get(s))?.push(ng(a.start))
		for (let l = a.start + 1; l < a.stop - 1; l++) r.get(this._activeChangeDecorationMiddle.get(s))?.push(ng(l))
		a.stop - a.start > 1 && r.get(this._activeChangeDecorationBottom.get(s))?.push(ng(a.stop - 1))
	}
}
function ryt(e, t, r) {
	let n = t.result.existingCode,
		i = t.result.suggestedCode,
		s = []
	for (let o of t.result.diffSpans) {
		let a = n.slice(o.original.start, o.original.stop),
			l = i.slice(o.updated.start, o.updated.stop),
			c = Na.determineChangeType(a, l),
			u = r ? o.original : o.updated,
			f = t.result.charStart + u.start,
			p = t.result.charStart + u.stop
		c === (r ? "insertion" : "deletion") &&
			e.positionAt(f).character === 0 &&
			l.endsWith(`
`) &&
			(f = t.result.charStart + u.start - 1),
			s.push([c, new qe.Range(e.positionAt(f), e.positionAt(p))])
	}
	return s
}
var gQ = W(require("vscode"))
var hQ = class {
	constructor(t, r, n) {
		this._suggestionManager = t
		this._configListener = r
		this._nextEditSessionEventReporter = n
	}
	provideCodeActions(t, r, n, i) {
		if (!this._configListener.config.enableDebugFeatures) return
		let s = new Rn(r.start.line, r.end.line),
			o = this._suggestionManager
				.getActiveSuggestions()
				.find((c) => c.changeType !== "noop" && c.previewCursorRange(t).intersects(s))
		if (!o) return
		let a = o.result.changeDescription || "Augment: Accept suggestion",
			l = new gQ.CodeAction(a, gQ.CodeActionKind.QuickFix)
		return (
			(l.command = { command: sf.commandID, title: a, arguments: [o] }),
			this._nextEditSessionEventReporter.reportEventFromSuggestion(o, "code-action-shown", "code-action"),
			[l]
		)
	}
	resolveCodeAction(t, r) {
		return t
	}
}
var Jn = W(require("vscode"))
var b_e = W(require("os"))
var a6t = X("markdown-html-utils")
function C_e() {
	return Ko("1.92.0")
}
function nyt(e) {
	return e.replace(/\$\(([\w-]+)\)/gi, "&dollar;($1)")
}
function IC(e) {
	return nyt(lQ(e))
}
var D_ = class e {
	_spaces
	_tabs
	constructor({ spaces: t, tabs: r }) {
		;(this._spaces = t), (this._tabs = r)
	}
	static computeCommonLeadingWhitespace(t) {
		if (t.length === 0) return new e({ spaces: 0, tabs: 0 })
		let n = t
				.filter((o) => o.trim().length > 0)
				.map((o) => {
					let a = o.match(/^([ \t]*)/)
					return a ? a[1] : ""
				}),
			i = n.map((o) => o.length - o.replace(/ /g, "").length),
			s = n.map((o) => o.length - o.replace(/\t/g, "").length)
		return new e({
			spaces: i.reduce((o, a) => Math.min(o, a), i[0]),
			tabs: s.reduce((o, a) => Math.min(o, a), s[0]),
		})
	}
	trimLeadingIncremental(t) {
		let r = this._spaces,
			n = this._tabs,
			i = 0
		for (; i < t.length && (r > 0 || n > 0); ) {
			let s = t[i++]
			if (s === " " && r > 0) r--
			else if (s === "	" && n > 0) n--
			else return
		}
		return { trimmed: t.slice(i), remaining: new e({ spaces: r, tabs: n }) }
	}
	trimLeadingFull(t, r) {
		let n = this.trimLeadingIncremental(t)
		return n
			? !n.remaining.isEmpty() && t.length > 0
				? (r?.debug("Untrimmed whitespace"), t)
				: n.trimmed
			: (r?.debug(`No common leading whitespace for line: ${t}`), t)
	}
	isEmpty() {
		return this._spaces === 0 && this._tabs === 0
	}
	total() {
		return this._spaces + this._tabs
	}
}
function x_e(e, t, r, n, i, s, o) {
	let a = syt(e.makeOneLineDiffSpans()),
		l = a.filter((Q) => Q.type === "updated").length - a.filter((Q) => Q.type === "original").length,
		c = (e.lineRange.stop + 2 + l).toString().length + 1,
		u
	if (s) {
		let Q =
				t?.split(`
`) ?? [],
			O =
				r?.split(`
`) ?? [],
			Y = [...Q, ...a.map((j) => j.spans.map((ne) => ne.text).join("")), ...O]
		;(u = D_.computeCommonLeadingWhitespace(Y)),
			(t = Q.map((j) => u.trimLeadingFull(j, o)).join(`
`)),
			(r = O.map((j) => u.trimLeadingFull(j, o)).join(`
`))
	} else u = D_.computeCommonLeadingWhitespace([])
	let f = n,
		{ rendered: p, longestLineLength: g } = ayt(a, f, i, e.result.truncationChar, u, o)
	t && (t = Xl(t, g)), r && (r = Xl(r, g))
	let m = SC(e.lineRange.start, c),
		y = t
			? `<span style="color:${i.lineNumberColor};">${m}${m}<span class="codicon codicon-blank"></span> ${IC(
					E_e(T_(t), g + 1),
				)}</span>
`
			: "",
		C = SC(e.lineRange.stop + 1, c),
		v = SC(e.lineRange.stop + 1 + l, c),
		b = "",
		w = ""
	b_e.default.platform() === "win32" && ((b = "<strong>"), (w = "</strong>"))
	let B = "background-color:var(--vscode-editor-background);" + (iyt() ? "border-radius:5px;" : ""),
		M = r
			? `
<span style="color:${i.lineNumberColor};">${C}${v}<span class="codicon codicon-blank"></span> ${IC(
					E_e(T_(r), g + 1),
				)}</span>`
			: ""
	return {
		result: `
${b}<pre><span style="${B}">${y}${p}${M}</span></pre>${w}
`,
		longestLineLength: g + c,
	}
}
function iyt() {
	return C_e() && !Ko("1.97.0")
}
function syt(e) {
	let t = [],
		r = []
	if (e.length === 0) return []
	let n = {
			type: "noop",
			spans: [],
			originalLineNumber: -1,
			updatedLineNumber: -1,
		},
		i = {
			type: "noop",
			spans: [],
			originalLineNumber: -1,
			updatedLineNumber: -1,
		},
		s = () => {
			n.spans.some((a) => a.text.length > 0) && t.push(n)
		},
		o = () => {
			i.spans.some((a) => a.text.length > 0) && r.push(i)
		}
	for (let a of e)
		(a.original.text !== "" || !a.updated.isWholeLine) &&
			(n.spans.push({
				type: a.type,
				text: a.original.text,
				charRange: a.original.charRange,
			}),
			(n.originalLineNumber = a.original.line),
			a.type !== "noop" ? (n.type = "original") : (n.updatedLineNumber = a.updated.line)),
			(a.updated.text !== "" || !a.original.isWholeLine) &&
				(i.spans.push({
					type: a.type,
					text: a.updated.text,
					charRange: a.updated.charRange,
				}),
				(i.updatedLineNumber = a.updated.line),
				a.type !== "noop"
					? (i.type = "updated")
					: ((i.originalLineNumber = a.original.line),
						i.type !== "noop" ? (n.type = "original") : n.type !== "noop" && (i.type = "updated"))),
			a.original.text.endsWith(`
`) &&
				(s(),
				(n = {
					type: "noop",
					spans: [],
					originalLineNumber: -1,
					updatedLineNumber: -1,
				})),
			a.updated.text.endsWith(`
`) &&
				(o(),
				(i = {
					type: "noop",
					spans: [],
					originalLineNumber: -1,
					updatedLineNumber: -1,
				}))
	return s(), o(), oyt(t, r)
}
function oyt(e, t) {
	let r = [],
		n = 0,
		i = 0,
		s = 0
	for (; i < e.length || s < t.length; ) {
		if (n++ > 1e4) throw new Error("infinite loop in groupLines")
		for (; i < e.length && e[i].type !== "noop"; ) r.push(e[i]), i++
		for (; s < t.length && t[s].type !== "noop"; ) r.push(t[s]), s++
		for (; i < e.length && s < t.length && e[i].type === "noop" && t[s].type === "noop"; ) r.push(e[i]), i++, s++
	}
	return r
}
function ayt(e, t, r, n, i, s) {
	if (e.length === 0) return { rendered: "", longestLineLength: 0 }
	let { linePadAmounts: o, longestLineLength: a } = lyt(e, t, i),
		c =
			(
				e
					.map((f) => f.updatedLineNumber)
					.concat(e.map((f) => f.originalLineNumber))
					.reduce((f, p) => Math.max(f, p), 0) + 2
			).toString().length + 1,
		u = []
	for (let f = 0; f < e.length; f++) {
		let p = e[f],
			g,
			m
		p.type === "noop"
			? ((g = p.spans.map((b) => b.text).join("")), (g = i.trimLeadingFull(g)), (m = "#00000000"))
			: p.type === "original"
				? ((g = v_e(p.spans, !0, r, i, s)), (m = r.originalLineColor))
				: ((g = v_e(p.spans, !1, r, i, s)), (m = r.updatedLineColor)),
			(g = T_(g))
		let y = (p.type !== "updated" ? p.originalLineNumber + 1 : "").toString(),
			C = (p.type !== "original" ? p.updatedLineNumber + 1 : "").toString(),
			v =
				p.type === "noop"
					? '<span class="codicon codicon-blank"></span>'
					: p.type === "original"
						? '<span class="codicon codicon-diff-remove"></span>'
						: '<span class="codicon codicon-diff-insert"></span>'
		u.push(
			`<span style="color:${r.lineNumberColor};background-color:${m};">${SC(y, c)}${SC(
				C,
				c,
			)}</span><span style="background-color:${m};">${v} </span>${g}<span style="background-color:${m};">${" ".repeat(
				o[f],
			)}</span>`,
		)
	}
	return (
		n !== void 0 &&
			u.push(`<span style="color:${r.lineNumberColor};">${SC(" ", 2 * c + 1)}...(MORE CHANGES)...</span>`),
		{
			rendered: u.join(`
`),
			longestLineLength: a,
		}
	)
}
function lyt(e, t, r) {
	let n = e.map((s) => T_(s.spans.map((o) => o.text).join(""))),
		i = Math.max(t, n.map((s) => s.length).reduce((s, o) => Math.max(s, o), 0) - r.total())
	return {
		linePadAmounts: n.map((s) => i - Math.max(0, s.length - r.total()) + 1),
		longestLineLength: i,
	}
}
function v_e(e, t, r, n, i) {
	let s = []
	if (e.length === 0 || e.every((o) => o.text === "")) return ""
	for (let o of e) {
		let a
		o.type === "noop"
			? t
				? (a = `background-color:${r.originalLineColor};`)
				: (a = `background-color:${r.updatedLineColor};`)
			: t
				? (a = `background-color:${r.originalTextColor};`)
				: (a = `background-color:${r.updatedTextColor};`)
		let l = o.text,
			c = n.trimLeadingIncremental(o.text)
		c ? ((l = c.trimmed), (n = c.remaining)) : i?.debug(`No common leading whitespace for span: ${o.text}`)
		let u = IC(l),
			f = u.endsWith(`
`)
		;(u = T_(u)),
			s.push(
				`<span style="${a}">${u}</span>${
					f
						? `
`
						: ""
				}`,
			)
	}
	return n.isEmpty() || i?.debug("Untrimmed whitespace"), s.join("")
}
function SC(e, t) {
	let r = e.toString()
	return t - yl(r) >= 0 ? " ".repeat(t - r.length) + r : r
}
function E_e(e, t) {
	let r = e.toString()
	return t - yl(r) >= 0 ? r + " ".repeat(t - r.length) : r
}
function T_(e) {
	return e.endsWith(`
`)
		? e.slice(0, -1)
		: e
}
var w_e = W(require("vscode"))
function h8(e, t, r, n, i) {
	let s = "$(augment-icon-simple)&#x2009;&#x1D5D;",
		o = t.length > 0 ? __e(t[0]) : ""
	for (let c = 1; c < t.length; c++) {
		let u = t[c].noLeftMargin ? "&nbsp;&nbsp;" : "&nbsp;&nbsp;&nbsp;&nbsp;"
		o += `${u}${__e(t[c])}`
	}
	let a = r ? `<br/>${r}` : "",
		l = new w_e.MarkdownString(`${s}&nbsp;&nbsp;&nbsp;&nbsp;${o}<br/>${e}${a}`)
	return (l.isTrusted = !0), (l.supportHtml = !0), (l.supportThemeIcons = !0), l
}
function __e(e) {
	return `<a href="${e.href}" title="${e.tooltip}">${e.text}${
		e.keybindingIcons ? `&nbsp;${e.keybindingIcons}` : ""
	}</a>`
}
var cyt = 38,
	pQ = class e extends z {
		constructor(r, n, i, s, o, a, l, c, u) {
			super()
			this._keybindingWatcher = r
			this._nextEditSessionEventReporter = n
			this._suggestionManager = i
			this._state = s
			this._configListener = o
			this._hasCompletionShowing = a
			this._showKeybindingsOnButtons = l
			this._keybindingStatus = c
			this._nextEditConfigManager = u
			this.addDisposable(
				Jn.window.onDidChangeTextEditorVisibleRanges((f) => {
					this._handleVisibleRangesChanged(f)
				}),
			),
				this._register(void 0),
				this.addDisposable(Jn.window.onDidChangeActiveTextEditor((f) => this._register(f))),
				this.addDisposable(
					this._suggestionManager.onSuggestionsChanged((f) => {
						this._register(Jn.window.activeTextEditor)
					}),
				),
				this.addDisposable(
					new Jn.Disposable(() => {
						this._provider?.dispose(), (this._provider = void 0)
					}),
				)
		}
		_logger = X("BackgroundNextEditsHoverProvider")
		static inlineDiffColors = {
			originalLineColor: "var(--vscode-diffEditor-removedLineBackground)",
			originalTextColor: "#FF000066",
			updatedLineColor: "var(--vscode-diffEditor-insertedLineBackground)",
			updatedTextColor: "#9CCC2C66",
			lineNumberColor: "var(--vscode-editorGhostText-foreground)",
		}
		_provider
		_waitingToShowHover = !1
		get _showDiffInDifflessHover() {
			return this._nextEditConfigManager.config.showDiffInHover
		}
		_handleVisibleRangesChanged(r) {
			let n = r.textEditor.document,
				i = this._state.value.suggestion
			i &&
				(this._state.value instanceof _r ||
					this._state.value instanceof Ut ||
					this._state.value instanceof wr) &&
				i.qualifiedPathName.equals(n.uri) &&
				r.visibleRanges.some((s) => s.contains(Ds(i.highlightRange))) &&
				this.showHover()
		}
		_register(r) {
			this._waitingToShowHover ||
				(this._provider?.dispose(),
				(this._provider = void 0),
				r && (this._provider = Jn.languages.registerHoverProvider({ pattern: r.document.uri.fsPath }, this)))
		}
		provideHover(r, n, i) {
			if (this._hoverDisabled()) return
			let s, o
			try {
				if (r.uri.scheme === "output" || this._hasCompletionShowing()) return
				;(this._waitingToShowHover = !1),
					(o = this._suggestionManager
						.getActiveSuggestions()
						.filter(
							(c) => c.state === "fresh" && c.changeType !== "noop" && c.qualifiedPathName.equals(r.uri),
						)
						.find((c) => this.hoverContactCondition(c, n, r)))
				let l = this._provideDifflessHover(r, n, o)
				return (
					l && this._nextEditSessionEventReporter.reportEventFromSuggestion(o, "hover-shown", "unknown"),
					l && new Jn.Hover(l)
				)
			} catch (a) {
				return (
					a instanceof Error &&
						(this._logger.error(`Error in hover provider: ${a.message}, requestId: ${s}`),
						a.stack && this._logger.error(a.stack),
						this._nextEditSessionEventReporter.reportEventFromSuggestion(
							o,
							"error-hover-error",
							"unknown",
						)),
					new Jn.Hover(`Error rendering hover. requestId: ${s}`)
				)
			}
		}
		_keybindingWillWork(r, n) {
			return r === qu
				? this._nextEditConfigManager.config.enablePanel
				: n && !n.equals(this._state.value.suggestion)
					? !1
					: this._keybindingStatus.get(r)
		}
		_provideDifflessHover(r, n, i) {
			let s,
				o = []
			i = this._state.value instanceof Kn || this._state.value instanceof ls ? i : void 0
			let a = ["hover-click", i?.result.suggestionId ?? void 0],
				l = (y, C) => {
					if (this._keybindingWillWork(y, i)) {
						let v = this.getPrettyKeybinding(y.commandID)
						return `${C}${v ? "&nbsp;" + v : ""}`
					}
					return C
				},
				c = (y, C, v) => {
					let b = y.commandID
					return {
						href: y.generateHref(...a),
						text: C,
						tooltip: l(y, v),
						keybindingIcons:
							this._showKeybindingsOnButtons() && this._keybindingWillWork(y, i)
								? this.getPrettyKeybindingIcons(b)
								: null,
					}
				},
				u = c(Tc, "Reject", "Reject Suggestion"),
				f = c(qu, "$(layout-panel)", "Open Suggestions Panel")
			f.keybindingIcons = null
			let p = c(cC, "$(diff-single)", this._showDiffInDifflessHover ? "Hide Diff" : "Show Diff")
			p.noLeftMargin = !0
			let g = {
					href: `command:workbench.action.openSettings?${encodeURIComponent(
						JSON.stringify(["@ext:augment.vscode-augment augment.nextEdit"]),
					)}`,
					text: "$(gear)",
					tooltip: "Open Settings",
					noLeftMargin: !0,
				},
				m = c(Yh, "Learn More", "Learn More")
			if (
				((((this._state.value instanceof _r || this._state.value instanceof Ut) &&
					this._state.value.suggestion?.previewCursorRange(r).contains(n.line)) ||
					i) &&
					((s = i || this._state.value.suggestion),
					(o = [
						c(Dc, "Apply", "Apply Suggestion"),
						u,
						...(this._showKeybindingsOnButtons() ? [m] : []),
						...(this._nextEditConfigManager.config.enablePanel ? [f] : []),
						p,
						g,
					])),
				this._state.value instanceof Ut)
			) {
				let y = this._state.value.suggestion.previewCursorRange(r)
				;(y.contains(n.line) ||
					(this._state.value.suggestion?.changeType === "deletion" && y?.touches(n.line))) &&
					((s = this._state.value.suggestion),
					(o = [
						c(Co, "Undo", "Undo Suggestion"),
						u,
						...(this._showKeybindingsOnButtons() ? [m] : []),
						...(this._nextEditConfigManager.config.enablePanel ? [f] : []),
						p,
						g,
					]))
			}
			if (s) {
				let y = IC(s.result.changeDescription)
				if (this._showDiffInDifflessHover) {
					let { result: C, longestLineLength: v } = this.getHoverDiff(r, s, cyt)
					return h8(y, o, C, [], v)
				} else return h8(y, o)
			}
		}
		hoverContactCondition(r, n, i) {
			return r.previewCursorRange(i).contains(n.line)
		}
		getPrettyKeybinding(...r) {
			return this.getKeybindingsForCommands(r, !0)
		}
		getPrettyKeybindingIcons(...r) {
			let n = kc.getStructuredKeybinding(this.getKeybindingsForCommands(r))
			return g_e(n, this._keybindingWatcher.getSimplifiedPlatform())
		}
		getKeybindingsForCommands(r, n = !1) {
			let i = r.map((s) => Vu(this._keybindingWatcher, s, n))
			return i.includes(null) ? "" : i.join(" ")
		}
		getHoverDiff(r, n, i) {
			let s = n.state === "accepted" ? n.afterLineRange(r) : n.lineRange,
				o = s.start > 0 ? new Jn.Range(s.start - 1, 0, s.start, 0) : void 0,
				a = s.stop < r.lineCount - 1 ? new Jn.Range(s.stop, 0, s.stop + 1, 0) : void 0,
				l = x_e(n, o && r.getText(o), a && r.getText(a), i, e.inlineDiffColors, !0, this._logger)
			return (
				n.result.truncationChar !== void 0 &&
					this._nextEditSessionEventReporter.reportEventFromSuggestion(
						n,
						"suggestion-truncated-in-hover",
						"unknown",
					),
				l
			)
		}
		_hoverDisabled() {
			return this._configListener.config.nextEdit.noDiffModeUseCodeLens
		}
		showHover() {
			this._hoverDisabled() ||
				(this._register(Jn.window.activeTextEditor),
				(this._waitingToShowHover = !0),
				Jn.commands.executeCommand("editor.action.showHover", {
					focus: "noAutoFocus",
				}))
		}
		hideHover(r = "unknown") {
			this._hoverDisabled() ||
				r === "keybinding" ||
				(Ko("1.97.0-insider") || Ko("1.97.0")
					? Jn.commands.executeCommand("editor.action.hideHover")
					: (Jn.commands.executeCommand("editorScroll", {
							to: "down",
							by: "line",
							value: 0,
						}),
						Jn.commands.executeCommand("editorScroll", {
							to: "up",
							by: "line",
							value: 0,
						})))
		}
		async hideHoverAsync(r = "unknown") {
			this._hoverDisabled() ||
				r === "keybinding" ||
				(Ko("1.97.0-insider") || Ko("1.97.0")
					? await Jn.commands.executeCommand("editor.action.hideHover")
					: (await Jn.commands.executeCommand("editorScroll", {
							to: "down",
							by: "line",
							value: 0,
						}),
						await Jn.commands.executeCommand("editorScroll", {
							to: "up",
							by: "line",
							value: 0,
						})))
		}
	}
var I_e = W(require("vscode"))
var uyt = new Map([
		[Fa, "vscode-augment.nextEdit.canGotoHinting"],
		[Xo, "vscode-augment.nextEdit.canNext"],
		[Ou, "vscode-augment.nextEdit.canPrevious"],
		[Dc, "vscode-augment.nextEdit.canAccept"],
		[Tc, "vscode-augment.nextEdit.canReject"],
		[Uu, "vscode-augment.nextEdit.canDismiss"],
		[sf, "vscode-augment.nextEdit.canAcceptCodeAction"],
		[uA, "vscode-augment.nextEdit.canAcceptAll"],
		[dA, "vscode-augment.nextEdit.canRejectAll"],
		[Co, "vscode-augment.nextEdit.canUndoAcceptSuggestion"],
	]),
	AQ = class extends z {
		constructor(r) {
			super()
			this._state = r
			this.addDisposable(
				new I_e.Disposable(
					this._state.listen((n) => {
						let i = !(n instanceof Kn)
						this._set(Fa, i),
							this._set(Xo, i),
							this._set(Ou, i),
							this._set(Dc, n instanceof _r || n instanceof wr || n instanceof Ut),
							this._set(Tc, n instanceof _r || n instanceof wr || n instanceof Ut),
							this._set(Co, n instanceof Ut),
							this._set(Uu, i),
							this._set(sf, n instanceof Ut),
							this._set(uA, i),
							this._set(dA, i)
					}, !0),
				),
			)
		}
		_status = new Map()
		get(r) {
			return this._status.get(r) ?? !1
		}
		_set(r, n) {
			this._status.set(r, n)
			let i = uyt.get(r)
			i && xc(i, n)
		}
	}
var mQ = class e extends z {
	constructor(r, n, i, s, o, a, l, c, u, f, p = (g) => {}) {
		super()
		this.workspaceManager = n
		this._nextEditSessionEventReporter = i
		this._configListener = o
		this._suggestionManager = a
		this._requestManager = l
		this._globalState = c
		this._nextEditConfigManager = u
		this._completionVisibilityWatcher = f
		this._onCursorWithinSuggestion = p
		;(this._state = new ta(new Kn(), a_e)),
			(this._decorationManager = new fQ(
				r,
				n,
				s,
				o,
				i,
				this.isInlineCompletionVisible,
				this.isShowAllHighlightsEnabled,
			)),
			this.addDisposable(this._decorationManager),
			(this._codeActionProvider = new hQ(this._suggestionManager, this._configListener, i)),
			(this._keybindingStatus = this.addDisposable(new AQ(this._state))),
			(this._hoverProvider = new pQ(
				s,
				i,
				this._suggestionManager,
				this._state,
				this._configListener,
				this.isInlineCompletionVisible,
				() => (this._globalState.get("nextEditKeybindingUsageCount") ?? 0) < e.maxKeybindingUsageCount,
				this._keybindingStatus,
				this._nextEditConfigManager,
			)),
			this.addDisposable(this._hoverProvider),
			(this._codeLensProvider = new rQ(this._state, s)),
			this.addDisposable(
				new Ie.Disposable(() => {
					;(this._state.value = new Kn()),
						this._state.dispose(),
						this._decorationManager.decorate([], {}),
						this._hoverProvider.hideHover("command")
				}),
			),
			this.addDisposable(Ie.languages.registerCodeActionsProvider("*", this._codeActionProvider)),
			this.addDisposable(Ie.workspace.onDidChangeTextDocument(this._handleTextDocumentChanged)),
			this.addDisposable(Ie.window.onDidChangeActiveTextEditor(this._handleEditorChange)),
			this.addDisposable(Ie.window.onDidChangeTextEditorSelection(this._handleTextEditorSelectionChanged)),
			this.addDisposable(
				new Ie.Disposable(
					this._requestManager.lastResponse.listen((g) => {
						g && this._suggestionManager.add([Na.from(g)], g.mode === "FORCED")
					}),
				),
			),
			this.addDisposable(
				this._suggestionManager.onSuggestionsChanged((g) => {
					this._handleSuggestionsChanged(g)
				}),
			),
			this.addDisposable(
				Ie.window.onDidChangeTextEditorVisibleRanges((g) => {
					this.workspaceManager.safeResolvePathName(g.textEditor.document.uri) &&
						g.textEditor === Ie.window.activeTextEditor &&
						!dC() &&
						(!this._lastVisibleRanges ||
							this._lastVisibleRanges.uri.fsPath !== g.textEditor.document.uri.fsPath ||
							this._lastVisibleRanges.visibleRanges.length !== g.visibleRanges.length ||
							this._lastVisibleRanges.visibleRanges.some((m, y) => !m.equals($u(g.visibleRanges[y])))) &&
						(this._drawDecorations(),
						this._configListener.config.nextEdit.useCursorDecorations ||
							((this._decorationManager.shouldDrawBottomDecorations.value = !1),
							this._debouncedSetBottomDecorations()),
						(this._lastVisibleRanges = {
							uri: g.textEditor.document.uri,
							visibleRanges: g.visibleRanges.map((m) => $u(m)),
						}))
				}),
			),
			this.addDisposable(
				new Ie.Disposable(
					this._suggestionManager.suggestionWasJustAccepted.listen((g) => {
						g && (this._debouncedSetBottomDecorations.flush(), this._drawDecorations())
					}),
				),
			),
			this._configListener.addDisposable(
				this._configListener.onDidChange((g) => {
					!!g.newConfig.nextEdit.highlightSuggestionsInTheEditor !=
						!!g.previousConfig.nextEdit.highlightSuggestionsInTheEditor && this._drawDecorations()
				}),
			),
			this.addDisposable(
				this.workspaceManager.onDidChangeSourceFolderContents((g) => {
					let m = new Map(),
						y = this._suggestionManager.getAllSuggestions().filter((C) => {
							if (C.qualifiedPathName.rootPath !== g) return !1
							let v = C.qualifiedPathName.relPath
							return m.get(v) || m.set(v, this.workspaceManager.hasFile(C.qualifiedPathName)), !m.get(v)
						})
					this._suggestionManager.remove(y)
				}),
			),
			this.addDisposable(
				new Ie.Disposable(
					this._completionVisibilityWatcher.listen(() => {
						this._drawDecorations()
					}),
				),
			),
			this._configListener.config.nextEdit.noDiffModeUseCodeLens &&
				(this.addDisposable(Ie.languages.registerCodeLensProvider("*", this._codeLensProvider)),
				this.addDisposable(
					new Ie.Disposable(
						this._state.listen(() => {
							this._codeLensProvider.refresh()
						}),
					),
				)),
			this.addDisposable(
				new Ie.Disposable(
					this._state.listen(() => {
						this._drawDecorations()
					}),
				),
			),
			this.addDisposable(
				new Ie.Disposable(
					this._state.listen((g) => {
						let m
						g instanceof Kn
							? (m = "state-transitioned-to-no-suggestions")
							: g instanceof ls
								? (m = "state-transitioned-to-hinting")
								: g instanceof _r
									? (m = "state-transitioned-to-before-preview")
									: g instanceof Ut
										? (m = "state-transitioned-to-after-preview")
										: g instanceof wr && (m = "state-transitioned-to-animating"),
							m !== void 0 &&
								this._nextEditSessionEventReporter.reportEventFromSuggestion(g.suggestion, m, "unknown")
					}),
				),
			),
			this.addDisposable(
				Ie.debug.onDidStartDebugSession(() => {
					this._suggestionManager.clear(!1), this._decorationManager.decorate([], {})
				}),
			),
			this.addDisposable(
				Ie.debug.onDidTerminateDebugSession(() => {
					this._handleEditorChange(Ie.window.activeTextEditor)
				}),
			),
			this.addDisposable(
				vA(() => {
					this._suggestionManager.clear(!1), this._decorationManager.decorate([], {})
				}),
			),
			this.addDisposable(
				sQ(() => {
					this._suggestionManager.clear(!1), this._decorationManager.decorate([], {})
				}),
			)
	}
	static _waitForAcceptTimeoutMs = 1e3
	static _applySuggestionDelayMs = {
		fromHover: 50,
		atCursor: 250,
		onScreen: 500,
		offScreen: 750,
		largeBonus: 250,
	}
	static _largeChangeLineCountThreshold = 3
	static _postScrollRenderDelayMs = 250
	static maxKeybindingUsageCount = 30
	_logger = X("EditorNextEdits")
	_decorationManager
	_codeActionProvider
	_keybindingStatus
	_hoverProvider
	_codeLensProvider
	_state
	_lastVisibleRanges
	_ignoreSelectionChangeEvents = !1
	_debouncedSetBottomDecorations = (0, D_e.debounce)(() => {
		;(this._decorationManager.shouldDrawBottomDecorations.value = !0), this._drawDecorations()
	}, e._postScrollRenderDelayMs)
	static get _smoothScrollDelayMs() {
		return (Ie.workspace.getConfiguration("editor").smoothScrolling ?? !1) ? 150 : 0
	}
	dismiss(r, n = !1, i = !0) {
		this._state.value instanceof _r || this._state.value instanceof wr
			? ((this._state.value = new ls(this._state.value.suggestion, !0)),
				i && this._suggestionManager.clearJustAcceptedSuggestions(),
				this._nextEditSessionEventReporter.reportEventWithoutIds(
					"preview-decoration-dismissed",
					r ?? "command",
				))
			: this._state.value instanceof Ut &&
				((this._state.value = this._getHintedState()),
				i && this._suggestionManager.clearJustAcceptedSuggestions(),
				this._nextEditSessionEventReporter.reportEventWithoutIds(
					"reverse-decoration-dismissed",
					r ?? "command",
				)),
			n && this._hoverProvider.hideHover()
	}
	async dismissOrReject(r) {
		let n = Ie.window.activeTextEditor
		this._state.value instanceof Ut
			? (await this._undoSuggestions(this._state.value.suggestion), this.dismiss(r, !0))
			: this._state.value instanceof _r || this._state.value instanceof wr
				? this.dismiss(r)
				: n &&
					  this._state.value instanceof ls &&
					  this._hoverProvider.hoverContactCondition(
							this._state.value.suggestion,
							n.selection.active,
							n.document,
					  )
					? this.reject(r, this._state.value.suggestion.result.suggestionId)
					: this.reject(r)
	}
	isInlineCompletionVisible = () => this._completionVisibilityWatcher.maybeInlineCompletionVisible
	isShowAllHighlightsEnabled = () => this._configListener.config.nextEdit.highlightSuggestionsInTheEditor
	nextAvailableSuggestion = (r = !0, n = !1) =>
		B_e(
			this._suggestionManager.getActiveSuggestions().filter(ui),
			this._state.value instanceof _r || this._state.value instanceof Ut || this._state.value instanceof wr
				? this._state.value.suggestion
				: void 0,
			!r,
			n,
			this._configListener.config.nextEdit.enableGlobalBackgroundSuggestions,
		)
	_handleSuggestionsChanged = async (r) => {
		this._updateSuggestions(r.newSuggestions, !0)
		let n = Ie.window.activeTextEditor,
			i =
				n &&
				r.undone.find(
					(s) =>
						s.lineRange.contains(n.selection.active.line) || s.lineRange.touches(n.selection.active.line),
				)
		if (i && this._state.value instanceof Ut) {
			await this._suggestionManager.suggestionWasJustUndone.waitUntil((o) => o === !0, e._waitForAcceptTimeoutMs)
			let s = this._getSuggestionSelection(i)
			s.isEqual(n.selection) || ((this._ignoreSelectionChangeEvents = !0), (n.selection = s)),
				(this._state.value = new _r(i)),
				this._nextEditSessionEventReporter.reportEventFromSuggestion(
					this._state.value.suggestion,
					"undid-accepted-suggestion",
					"document-changed",
				),
				this._hoverProvider.showHover()
		}
		if (n && r.accepted.length > 0 && (this._state.value instanceof _r || this._state.value instanceof wr)) {
			await this._suggestionManager.suggestionWasJustAccepted.waitUntil(
				(a) => a === !0,
				e._waitForAcceptTimeoutMs,
			)
			let s = r.accepted[r.accepted.length - 1],
				o = this._getSuggestionSelection(s)
			o.isEqual(n.selection) || ((this._ignoreSelectionChangeEvents = !0), (n.selection = o)),
				(this._state.value = new Ut(s)),
				this._hoverProvider.showHover()
		} else r.accepted.length > 0 && (this._ignoreSelectionChangeEvents = !0)
	}
	_updateSuggestions(r, n) {
		if (dC()) return
		let i = r.filter(ui)
		if (
			(this._configListener.config.nextEdit.enableGlobalBackgroundSuggestions
				? i
				: i.filter((o) => o.qualifiedPathName.equals(Ie.window.activeTextEditor?.document.uri))
			).length === 0 &&
			this._state.value instanceof ls
		) {
			;(this._state.value = new Kn()), this._onCursorWithinSuggestion(void 0)
			return
		}
		n &&
			(this._state.value instanceof Kn || this._state.value instanceof ls) &&
			(this._state.value = this._getHintedState()),
			this._drawDecorations()
	}
	get _isDebugging() {
		return Ie.debug.activeDebugSession !== void 0 && !this._configListener.config.nextEdit.allowDuringDebugging
	}
	_drawDecorations() {
		if (this._isDebugging) {
			this._decorationManager.decorate([], {})
			return
		}
		let r = this._suggestionManager.getActiveSuggestions().filter(ui),
			n = this._suggestionManager.getJustAcceptedSuggestions(),
			i = this._state.value instanceof ls ? this._state.value : this._getHintedState()
		this._decorationManager.decorate(r.concat(n), {
			hintSuggestion: i instanceof ls ? i.hintedSuggestion : void 0,
			activeSuggestion:
				this._state.value instanceof _r || this._state.value instanceof Ut || this._state.value instanceof wr
					? this._state.value.suggestion
					: void 0,
			isAnimating: this._state.value instanceof wr,
		})
	}
	_handleTextDocumentChanged = (r) => {
		if (r.contentChanges.length === 0) return
		let n = this.workspaceManager.safeResolvePathName(r.document.uri)
		if (this._isDebugging || yo(r.document.uri) || !n) return
		let i = Ie.window.activeTextEditor
		!i ||
			r.document !== i.document ||
			(this._clearAnimatedApply(),
			(this._state.value instanceof Ut || this._state.value instanceof wr) &&
				((this._state.value = new Kn()),
				this._nextEditSessionEventReporter.reportEventWithoutIds(
					"reverse-decoration-dismissed",
					"document-changed",
				)))
	}
	_handleTextEditorSelectionChanged = (r) => {
		let n = Ie.window.activeTextEditor
		if (
			!n ||
			r.textEditor.document !== n.document ||
			dC() ||
			this._isDebugging ||
			yo(n.document.uri) ||
			!this.workspaceManager.safeResolvePathName(r.textEditor.document.uri)
		)
			return
		this._clearAnimatedApply(n.selection)
		let s =
			!(
				r.kind === Ie.TextEditorSelectionChangeKind.Keyboard ||
				r.kind === Ie.TextEditorSelectionChangeKind.Mouse
			) && this._ignoreSelectionChangeEvents
		;(this._ignoreSelectionChangeEvents = !1),
			(this._state.value instanceof _r || this._state.value instanceof wr || this._state.value instanceof Ut) &&
			!s
				? this.dismiss("editor-selection-changed")
				: s || this._suggestionManager.clearJustAcceptedSuggestions(),
			(this._state.value instanceof Kn ||
				this._state.value instanceof ls ||
				(this._state.value instanceof wr &&
					!this._getSuggestionSelection(this._state.value.suggestion).isEqual(n.selection))) &&
				(this._state.value = this._getHintedState()),
			this._drawDecorations()
		let o = this._state.value.suggestion
		if (o && n.selection.isEmpty && this._hoverProvider.hoverContactCondition(o, n.selection.active, n.document)) {
			let l = "unknown"
			r.kind === Ie.TextEditorSelectionChangeKind.Keyboard
				? (l = "keyboard")
				: r.kind === Ie.TextEditorSelectionChangeKind.Mouse
					? (l = "click")
					: r.kind === Ie.TextEditorSelectionChangeKind.Command && (l = "command"),
				this._nextEditSessionEventReporter.reportEventFromSuggestion(o, "cursor-inside-suggestion", l),
				this._onCursorWithinSuggestion(o)
		} else this._onCursorWithinSuggestion(void 0)
	}
	_handleEditorChange = (r) => {
		this.dismiss("active-editor-changed"),
			r && this._updateSuggestions(this._suggestionManager.getActiveSuggestions(), !1)
	}
	async accept(r, n = !0, i, s) {
		let o
		if (i) {
			if (((o = this._suggestionManager.findSuggestionById(i)), o))
				return (
					this._hoverProvider.hideHover(),
					await this.open(o, {
						shouldAutoApply: !0,
						animationDelayMs: e._applySuggestionDelayMs.fromHover,
						preserveFocus: s,
						eventSource: r,
					}),
					!0
				)
		} else
			(this._state.value instanceof _r || this._state.value instanceof wr || this._state.value instanceof Ut) &&
				(o = this._state.value.suggestion)
		return this.acceptSuggestion(o, r, n, s)
	}
	async acceptSuggestion(r, n, i = !0, s = !1) {
		if (!r)
			return (
				Ie.window.showInformationMessage("No Next Edit to accept."),
				this._nextEditSessionEventReporter.reportEventWithoutIds(
					"error-no-suggestion-to-accept",
					n ?? "command",
				),
				!1
			)
		if (this._state.value instanceof Ut && this._state.value.suggestion?.equals(r)) return this.dismiss(n), !1
		if (
			(i && this._hoverProvider.hideHover(n ?? "command"),
			await this.gotoSuggestion(r, void 0, s),
			Ie.window.activeTextEditor && !r.qualifiedPathName.equals(Ie.window.activeTextEditor.document.uri))
		)
			return (
				this._logger.debug(
					`Current suggestion ${
						r.qualifiedPathName.relPath
					} does not match active document ${Ie.window.activeTextEditor?.document.uri.toString()}`,
				),
				this._nextEditSessionEventReporter.reportEventFromSuggestion(
					r,
					"error-accept-suggestion-wrong-document",
					n ?? "command",
				),
				!1
			)
		this._nextEditSessionEventReporter.reportEventFromSuggestion(r, "accept", n ?? "command"),
			this._state.value instanceof _r || (this._state.value = new _r(r)),
			S_e(),
			this._suggestionManager.accept([r])
		try {
			await this._suggestionManager.suggestionWasJustAccepted.waitUntil(
				(o) => o === !0,
				e._waitForAcceptTimeoutMs,
			)
		} catch {
			return this._logger.debug("Error waiting for suggestion to be accepted."), !1
		}
		return this.incrementKeybindingUsageCount(n), !0
	}
	_acceptSuggestions(r, n) {
		if (r.length === 0) {
			Ie.window.showInformationMessage("No Next Edits to accept.")
			return
		}
		;(this._state.value = new Kn()), S_e(), this._hoverProvider.hideHover("command")
		for (let i of r) this._nextEditSessionEventReporter.reportEventFromSuggestion(i, "accept", n ?? "command")
		this._suggestionManager.accept(r)
	}
	acceptAllSuggestionsInFile(r, n) {
		let i = Bs(r),
			s = this._suggestionManager
				.getActiveSuggestions()
				.filter(ui)
				.filter((o) => i === o.qualifiedPathName.absPath)
		this._acceptSuggestions(s, n),
			this._nextEditSessionEventReporter.reportEventWithoutIds("accept-all-in-file", n ?? "command")
	}
	acceptAllSuggestions(r) {
		let n = this._suggestionManager.getActiveSuggestions().filter(ui)
		this._acceptSuggestions(n, r),
			this._nextEditSessionEventReporter.reportEventWithoutIds("accept-all", r ?? "command")
	}
	reject(r, n) {
		let i
		return (
			n
				? (i = this._suggestionManager.findSuggestionById(n))
				: (this._state.value instanceof _r ||
						this._state.value instanceof Ut ||
						this._state.value instanceof wr) &&
					(i = this._state.value.suggestion),
			this.rejectSuggestion(i, r)
		)
	}
	rejectSuggestion(r, n) {
		this._hoverProvider.hideHover(n ?? "command"),
			r &&
				Ie.window.activeTextEditor &&
				!r.qualifiedPathName.equals(Ie.window.activeTextEditor.document.uri) &&
				this._logger.debug(
					`Current suggestion ${
						r.qualifiedPathName.relPath
					} does not match active document ${Ie.window.activeTextEditor?.document.uri.toString()}`,
				)
		let i = this._state.value
		this._state.value instanceof wr
			? (this._clearAnimatedApply(), (this._state.value = new Kn()))
			: (this._state.value = new Kn())
		let s,
			o,
			a = !1
		r
			? ((s = [r]), this._suggestionManager.reject(s), (o = "reject"), (a = r.state === "accepted"))
			: ((s = this._suggestionManager.getActiveSuggestions().filter(ui)),
				this._suggestionManager.reject(s),
				(o = "reject-all")),
			this._drawDecorations(),
			this._requestManager?.clearCompletedRequests("FORCED")
		for (let l of s) this._nextEditSessionEventReporter.reportEventFromSuggestion(l, o, n ?? "command")
		i instanceof Ut ? this._undoSuggestions(i.suggestion) : r && a && this._undoSuggestions(r)
	}
	_rejectSuggestions(r, n) {
		if (
			(this._nextEditSessionEventReporter.reportEventWithoutIds("reject-all", n ?? "command"),
			this._suggestionManager.reject(r),
			r.length === 0)
		) {
			Ie.window.showInformationMessage("No Next Edits to reject.")
			return
		}
		;(this._state.value = new Kn()),
			this._hoverProvider.hideHover("command"),
			this._suggestionManager.reject(r),
			this._requestManager?.clearCompletedRequests("FORCED")
		for (let i of r) this._nextEditSessionEventReporter.reportEventFromSuggestion(i, "reject", n ?? "command")
	}
	rejectAllSuggestionsInFile(r, n) {
		let i = Bs(r),
			s = this._suggestionManager.getJustAcceptedSuggestions().filter((a) => i === a.qualifiedPathName.absPath),
			o = this._suggestionManager
				.getActiveSuggestions()
				.filter(ui)
				.filter((a) => i === a.qualifiedPathName.absPath)
				.concat(s)
		this._rejectSuggestions(o, n),
			this._undoSuggestions(s),
			this._nextEditSessionEventReporter.reportEventWithoutIds("reject-all-in-file", n ?? "command")
	}
	rejectAllSuggestions(r) {
		let n = this._suggestionManager.getJustAcceptedSuggestions(),
			i = this._suggestionManager.getActiveSuggestions().filter(ui).concat(n)
		this._rejectSuggestions(i, r),
			this._undoSuggestions(n),
			this._nextEditSessionEventReporter.reportEventWithoutIds("reject-all", r ?? "command")
	}
	_undoSuggestions(r) {
		Array.isArray(r) || (r = [r])
		let n = new Ie.WorkspaceEdit()
		for (let i of r)
			n.replace(
				Ie.Uri.from({ scheme: i.uriScheme, path: i.qualifiedPathName.absPath }),
				new Ie.Range(new Ie.Position(i.afterLineRange().start, 0), new Ie.Position(i.afterLineRange().stop, 0)),
				i.result.existingCode,
			)
		return Ie.workspace.applyEdit(n)
	}
	gotoHinting(r) {
		this.incrementKeybindingUsageCount(r)
		let n = this._getHintedState().suggestion
		if (this._state.value instanceof Kn) {
			Ie.window.showInformationMessage("No more suggestions right now."),
				this._hoverProvider.hideHover(r ?? "command")
			return
		} else {
			if (this._state.value instanceof Ut && !n) return this.dismiss(r)
			if (this._state.value instanceof wr) return this._clearAnimatedApply(), this.accept()
			if (n)
				return (
					this._nextEditSessionEventReporter.reportEventFromSuggestion(
						this._state.value instanceof _r || this._state.value instanceof Ut
							? this._state.value.suggestion
							: void 0,
						"goto-hinting-triggered-from",
						r ?? "command",
					),
					this._nextEditSessionEventReporter.reportEventFromSuggestion(
						n,
						"goto-hinting-triggered-to",
						r ?? "command",
					),
					this.open(n, { eventSource: r })
				)
			this._logger.debug("Could not goto hinting.")
		}
	}
	next(r) {
		return this._nextOrPrevious(!0, r)
	}
	previous(r) {
		return this._nextOrPrevious(!1, r)
	}
	_nextOrPrevious(r, n, i = !0) {
		let s = this._suggestionManager.getActiveSuggestions().filter(ui),
			o = B_e(
				s,
				this._state.value instanceof _r || this._state.value instanceof Ut || this._state.value instanceof wr
					? this._state.value.suggestion
					: void 0,
				!r,
				!1,
				this._configListener.config.nextEdit.enableGlobalBackgroundSuggestions,
			)
		if (
			(this._nextEditSessionEventReporter.reportEventFromSuggestion(
				this._state.value instanceof _r || this._state.value instanceof Ut
					? this._state.value.suggestion
					: void 0,
				r ? "next-triggered-from" : "previous-triggered-from",
				n ?? "command",
			),
			this._nextEditSessionEventReporter.reportEventFromSuggestion(
				o,
				r ? "next-triggered-to" : "previous-triggered-to",
				n ?? "command",
			),
			!o)
		) {
			i && Ie.window.showInformationMessage("No more suggestions right now."),
				this._hoverProvider.hideHover(n ?? "command")
			return
		}
		return (
			(this._decorationManager.shouldDrawBottomDecorations.value = !1),
			this._debouncedSetBottomDecorations(),
			this._state.value instanceof wr
				? (this._logger.debug("Finishing animation instead of opening suggestion."),
					this._clearAnimatedApply(),
					this.accept())
				: (this.incrementKeybindingUsageCount(n), this.open(o, { eventSource: n }))
		)
	}
	undoAcceptSuggestion(r, n) {
		;(r ??= this._state.value instanceof Ut ? this._state.value.suggestion : void 0),
			r && r.state === "accepted" ? this._undoSuggestions(r) : Ie.commands.executeCommand("undo"),
			this._hoverProvider.hideHover(n ?? "command"),
			this._nextEditSessionEventReporter.reportEventWithoutIds("undo-accept", n ?? "command")
	}
	undoAllSuggestionsInFile(r, n) {
		let i = Bs(r),
			s = this._suggestionManager
				.getActiveSuggestions()
				.filter(fC)
				.filter((o) => i === o.qualifiedPathName.absPath)
		if (s.length === 0) {
			Ie.window.showInformationMessage("No Next Edits to undo.")
			return
		}
		this._nextEditSessionEventReporter.reportEventWithoutIds("undo-all-in-file", n ?? "command"),
			this._undoSuggestions(s),
			this._hoverProvider.hideHover(n ?? "command")
	}
	async toggleHoverDiff(r, n) {
		if ((await this._nextEditConfigManager.toggleSetting("showDiffInHover"), n)) {
			let i = this._suggestionManager.findSuggestionById(n),
				s = Ie.window.activeTextEditor
			if (i && s) {
				this._hoverProvider.hideHover(r ?? "command")
				let o = s.selection,
					a = this._getSuggestionSelection(i)
				;(!this._hoverProvider.hoverContactCondition(i, s.selection.active, s.document) ||
					!s.selection.isEqual(a)) &&
					((this._ignoreSelectionChangeEvents = !0), (s.selection = a)),
					this._hoverProvider.showHover(),
					(s.selection = o)
			}
		} else this._hoverProvider.hideHover(r ?? "command"), this._hoverProvider.showHover()
	}
	_clearAnimatedApply(r) {
		this._state.value instanceof wr &&
			(!r || !r.isEqual(this._state.value.selection)) &&
			clearTimeout(this._state.value.timeout)
	}
	async gotoSuggestion(r, n = void 0, i = !1) {
		this._completionVisibilityWatcher.maybeInlineCompletionVisible &&
			(this._logger.debug("Clearing inline completion before opening next edit suggestion."),
			await Ie.commands.executeCommand("editor.action.inlineSuggest.hide"))
		let s = !1
		if (r.qualifiedPathName.equals(Ie.window.activeTextEditor?.document.uri))
			i || (await Ie.commands.executeCommand("workbench.action.focusActiveEditorGroup"))
		else {
			;(s = !0),
				this._nextEditSessionEventReporter.reportEventFromSuggestion(
					r,
					"suggestion-global-offset-text-triggered",
					"command",
				)
			let l = Ie.window.visibleTextEditors.find((c) => r.qualifiedPathName.equals(c.document.uri))
			if (l)
				await Ie.window.showTextDocument(l.document, {
					selection: this._getSuggestionSelection(r),
					preserveFocus: i,
				})
			else {
				if (!Pn(r.qualifiedPathName.absPath)) {
					Ie.window.showInformationMessage(
						`Suggestion for ${r.qualifiedPathName.relPath} is no longer relevant.`,
					),
						this._suggestionManager.remove(
							this._suggestionManager
								.getActiveSuggestions()
								.filter((c) => c.qualifiedPathName.equals(r.qualifiedPathName)),
						)
					return
				}
				await Ie.window.showTextDocument(Ie.Uri.file(r.qualifiedPathName.absPath), {
					selection: this._getSuggestionSelection(r),
					preserveFocus: i,
				})
			}
		}
		let o = Ie.window.activeTextEditor
		if (!o || !r.qualifiedPathName.equals(o.document.uri)) {
			this._logger.debug(`Unable to go to suggestion in ${r.qualifiedPathName.absPath}.`)
			return
		}
		if (
			(r.lineRange.start >= o.document.lineCount &&
				(this._logger.warn("Trying to move to a line that doesn't exist."),
				this._nextEditSessionEventReporter.reportEventFromSuggestion(
					r,
					"error-moving-to-line-that-doesnt-exist",
					"unknown",
				)),
			o.visibleRanges.some((l) => l.contains(Ds(r.lineRange))) ||
				(o.revealRange(
					new Ie.Range(r.lineRange.start, 0, r.lineRange.stop, 0),
					Ie.TextEditorRevealType.InCenterIfOutsideViewport,
				),
				await Kl(e._smoothScrollDelayMs)),
			n === void 0)
		) {
			let l = !s && r.highlightRange.contains(o.selection.active.line),
				c = !s && o.visibleRanges.some((u) => u.contains(Ds(r.lineRange)))
			;(n = l
				? e._applySuggestionDelayMs.atCursor
				: c
					? e._applySuggestionDelayMs.onScreen
					: e._applySuggestionDelayMs.offScreen),
				r.lineRange.length > e._largeChangeLineCountThreshold && (n += e._applySuggestionDelayMs.largeBonus)
		}
		let a = this._getSuggestionSelection(r)
		return (
			(!this._hoverProvider.hoverContactCondition(r, o.selection.active, o.document) ||
				!o.selection.isEqual(a)) &&
				((this._ignoreSelectionChangeEvents = !0), (o.selection = a)),
			n
		)
	}
	async open(r, n = {}) {
		if (r.state === "stale") {
			this._logger.debug(`Tried to open stale suggestion. ${r.result.suggestionId}`)
			return
		}
		let i = await this.gotoSuggestion(r, n.animationDelayMs, n.preserveFocus)
		if (i === void 0) return
		let s = Ie.window.activeTextEditor
		if (!s) {
			this._logger.debug(`Unable to open suggestion in ${r.qualifiedPathName.absPath}.`)
			return
		}
		;(this._state.value instanceof _r || this._state.value instanceof Ut) &&
			!r.equals(this._state.value.suggestion) &&
			(await this._hoverProvider.hideHoverAsync(n.eventSource ?? "command")),
			r.state === "accepted" ? (this._state.value = new Ut(r)) : (this._state.value = new _r(r)),
			this._state.value instanceof _r && (n.shouldAutoApply ?? this.nextEditConfig.enableAutoApply)
				? (this._clearAnimatedApply(),
					(this._state.value = new wr(
						r,
						s.selection,
						setTimeout(() => {
							this.accept(void 0, !1, void 0, n.preserveFocus)
						}, i),
					)))
				: this._hoverProvider.showHover()
	}
	openSuggestionAt(r, n) {
		let i = this._suggestionManager
			.getActiveSuggestions()
			.find((s) => ui(s) && s.qualifiedPathName.equals(r) && (s.lineRange.contains(n) || s.lineRange.touches(n)))
		i
			? (this._nextEditSessionEventReporter.reportEventFromSuggestion(i, "suggestion-opened", "gutter-click"),
				this.open(i, {
					animationDelayMs: e._applySuggestionDelayMs.atCursor,
					eventSource: "gutter-click",
				}))
			: (this._logger.error(`No suggestion found for ${r.toString()} at line ${n}.`),
				Ie.window.showInformationMessage("No suggestion found."),
				this._nextEditSessionEventReporter.reportEventWithoutIds("error-no-suggestion-found", "command"))
	}
	_getHintedState() {
		let r = Ie.window.activeTextEditor
		if (!r) return new Kn()
		let n = this.nextAvailableSuggestion(!0)
		if (!n) return new Kn()
		let i = this.nextAvailableSuggestion(!1)
		return i
			? r.visibleRanges.some((s) => s.contains(Ds(i.highlightRange))) &&
				!r.visibleRanges.some((s) => s.contains(Ds(n.highlightRange)))
				? new ls(i, !1)
				: new ls(n, !0)
			: new ls(n, !0)
	}
	get state() {
		return this._state.value
	}
	addStateListener(r) {
		return this._state.listen(r)
	}
	_getSuggestionSelection(r) {
		let n = r.previewTargetCursorLine
		return new Ie.Selection(n, 0, n, 0)
	}
	async incrementKeybindingUsageCount(r) {
		if (r !== "keybinding") return
		let n = this._globalState.get("nextEditKeybindingUsageCount") ?? 0
		if (!(n >= e.maxKeybindingUsageCount)) return this._globalState.update("nextEditKeybindingUsageCount", n + 1)
	}
	get nextEditConfig() {
		return this._nextEditConfigManager.config
	}
}
async function S_e() {
	try {
		await Ie.commands.executeCommand("extension.vim_escape"),
			await Ie.commands.executeCommand("extension.vim_insert"),
			await Ie.commands.executeCommand("extension.vim_escape")
	} catch {}
}
function B_e(e, t, r, n, i) {
	let s = r ? -1 : 1
	if (e.length === 0) return
	let o = Ie.window.activeTextEditor
	if (!o) return
	let a = o.selection
	if (!a) return
	let l = $u(a),
		c = e.filter((f) => f.qualifiedPathName.equals(o.document.uri) && (!n || !f.equals(t)))
	if (c.length === 0 && i)
		return e
			.filter((f) => !n || !f.equals(t))
			.filter((f) => f.scope === "WORKSPACE")
			.reduce((f, p) => (f != null && f.result.localizationScore > p.result.localizationScore ? f : p), void 0)
	n && (c = c.filter((f) => !f.equals(t)))
	let u = c.sort((f, p) => s * f.highlightRange.compareTo(p.highlightRange))
	return t
		? (u.find((f) => s * f.highlightRange.compareTo(t.highlightRange) > 0) ?? u[0])
		: (u.find(
				(f) =>
					s * f.highlightRange.compareTo(l) >= 0 ||
					f.previewBoxRange(o.document).contains(a.active.line) ||
					f.previewBoxRange(o.document).contains(a.anchor.line),
			) ?? u[0])
}
var Fl = W(require("vscode"))
var Ys = W(require("vscode"))
var yQ = W(require("assert")),
	T_e = W(OG()),
	BC = W(require("vscode"))
function CQ(e) {
	return $t(e.rootPath, e.relPath + ".next-edit-results.json5")
}
async function* R_e(e) {
	;(0, yQ.default)(e.pathName)
	let t = await BC.workspace.openTextDocument(Je.from(e.pathName).absPath),
		r = CQ(e.pathName)
	;(0, yQ.default)(Pn(r))
	let n = T_e.default.parse((await BC.workspace.openTextDocument(r)).getText()),
		i = t.getText(),
		s = 0
	for await (let o of n)
		(o.path = o.path ?? e.pathName?.relPath),
			(o.blobName = e.blobName ?? ""),
			(o.suggestionId = o.suggestionId ?? `mock-suggestion-${o.blobName}-${s++}`),
			(o.charStart = o.charStart ?? t.offsetAt(new BC.Position(o.lineStart, 0))),
			(o.charEnd = o.charEnd ?? t.offsetAt(new BC.Position(o.lineEnd, 0))),
			(o.diffSpans =
				o.diffSpans ??
				(o.existingCode != null && o.suggestedCode != null
					? dyt(o.existingCode, o.suggestedCode)
					: [
							{
								original: { start: o.charStart, stop: o.charEnd },
								updated: { start: o.charStart, stop: o.charEnd },
							},
						])),
			(o.existingCode = o.existingCode?.replaceAll("|", "") ?? i.substring(o.charStart, o.charEnd)),
			(o.suggestedCode = o.suggestedCode?.replaceAll("|", "") ?? i.substring(o.charStart, o.charEnd)),
			(o.changeDescription = o.changeDescription ?? ""),
			(o.editingScore = o.editingScore ?? 1),
			(o.localizationScore = o.localizationScore ?? 1),
			(o.editingScoreThreshold = o.editingScoreThreshold ?? 1),
			yield { result: o, unknownBlobNames: [], checkpointNotFound: !1 }
}
function dyt(e, t) {
	let r = [],
		n = e.split("|"),
		i = t.split("|")
	;(0, yQ.default)(n.length === i.length)
	let s = 0,
		o = 0
	for (let a = 0; a < n.length; a++)
		r.push({
			original: { start: s, stop: s + n[a].length },
			updated: { start: o, stop: o + i[a].length },
		}),
			(s += n[a].length),
			(o += i[a].length)
	return r
}
var fyt = 10,
	hyt = 3
function k_e(e, t) {
	return t ? e.getFolderRoot(Je.from(t).absPath) : e.getMostRecentlyChangedFolderRoot()
}
function p8(e, t, r, n) {
	let i = !!t.config.nextEdit.useMockResults && !!r && Pn(CQ(r))
	return (n ?? e.getFileEditEvents(k_e(e, r))).length !== 0 || i
}
async function* M_e(e, t, r, n, i, s, o, a) {
	let l = X("queryNextEditStream")
	if (o.isCancellationRequested) {
		l.debug("Skipping Next Edit with cancelled token."), yield { status: He.cancelled }
		return
	}
	if (!p8(t, s, e.pathName, e.fileEditEvents)) {
		l.debug("Skipping Next Edit with no changes."), yield { status: He.ok }
		return
	}
	let u = s.config.nextEdit.useMockResults && e.pathName && Pn(CQ(e.pathName)),
		f = k_e(t, e.pathName),
		p = e.fileEditEvents ?? t.getFileEditEvents(f),
		g = f ? t.getRepoRootForFolderRoot(f) : void 0,
		m = e.pathName && Je.from(e.pathName),
		y = m?.rootPath ?? g,
		C = t.getContext()
	e = {
		...e,
		blobName: e.blobName ?? (m && t.getBlobName(m)),
		blobs: e.blobs ?? C.blobs,
		recentChanges: e.recentChanges ?? By(C.recentChunks.filter((b) => !b.uploaded)),
		fileEditEvents: p,
		unindexedEditEvents: e.unindexedEditEvents.length > 0 ? e.unindexedEditEvents : C.unindexedEditEvents,
		unindexedEditEventsBaseBlobNames:
			e.unindexedEditEventsBaseBlobNames.length > 0
				? e.unindexedEditEventsBaseBlobNames
				: C.unindexedEditEventsBaseBlobNames,
		diagnostics: await pyt(r, y, i, t),
	}
	let v = new g8(e.requestId, t)
	l.debug(`[${e.requestId}] Starting request for ${m?.relPath} (mode=${e.mode}, scope=${e.scope}).`)
	try {
		let b
		if ((u ? (b = R_e(e)) : (b = await n.nextEditStream(e)), o.isCancellationRequested)) {
			l.debug(`[${e.requestId}] Skipping next edit with cancelled token.`), yield { status: He.cancelled }
			return
		}
		for await (let w of b) {
			let B = `[${e.requestId}/${w.result.suggestionId}]`
			if (
				(w.unknownBlobNames.length > 0 &&
					(t.handleUnknownBlobs(C, w.unknownBlobNames),
					l.warn(`${B} Found ${w.unknownBlobNames.length} unknown blobs.`)),
				w.checkpointNotFound &&
					(t.handleUnknownCheckpoint(e.requestId, e.blobs.checkpointId),
					l.warn(`${B} Checkpoint was not found.`)),
				o.isCancellationRequested)
			) {
				l.debug(`${B} Cancelled by the client.`), yield { status: He.cancelled }
				return
			}
			let M = await gyt(w.result.path, y, t),
				Q = M && t.safeResolvePathName(M.uri)
			if (o.isCancellationRequested) {
				l.debug(`${B} Cancelled by the client.`), yield { status: He.cancelled }
				return
			}
			if (!Q) {
				l.warn(`${B} Response path ${w.result.path} has no document.`),
					a.reportEvent(
						e.requestId,
						w.result.suggestionId,
						Date.now(),
						"error-no-document-for-response",
						"unknown",
					)
				continue
			}
			if (M?.uri.scheme === "file" && !Pn(Q.absPath)) {
				l.warn(`${B} Response path ${Q.relPath} does not exist.`),
					a.reportEvent(
						e.requestId,
						w.result.suggestionId,
						Date.now(),
						"error-response-file-is-deleted",
						"unknown",
					)
				continue
			}
			let O = M.getText(),
				Y = tW(O, w.result.charStart),
				j = tW(O, w.result.charEnd),
				ne = v.updateWithPendingEdits(Q, new bo(Y, j))
			if (!ne) {
				l.debug(`${B} Response was invalidated by pending edits.`), yield { status: He.invalidArgument }
				return
			}
			let q = new Ys.Range(M.positionAt(ne.start), M.positionAt(ne.stop)),
				me = M.lineAt(q.end.line)
			if (
				(me.range.isEqual(me.rangeIncludingLineBreak) &&
					q.end.line === M.lineCount - 1 &&
					q.end.character === me.range.end.character &&
					!q.isEmpty &&
					(q = q.with({ end: new Ys.Position(q.end.line + 1, 0) })),
				q.start.character !== 0 || q.end.character !== 0)
			) {
				if (
					(l.warn(`${B} Response was not line-aligned ${s_e(q)}.`),
					l.debug(`${B} Converting char range ${w.result.charStart}-${w.result.charEnd} to ${Y}-${j}.`),
					l.debug(`${B} Updated char range to ${ne?.start}-${ne?.stop}.`),
					l.debug(
						`${B} The bad line is: "${M.lineAt(q.end.character !== 0 ? q.end.line : q.start.line).text}".`,
					),
					a.reportEvent(
						e.requestId,
						w.result.suggestionId,
						Date.now(),
						"error-response-not-line-aligned",
						"unknown",
					),
					Q.relPath !== e.pathName?.relPath)
				)
					continue
				a.reportEvent(
					e.requestId,
					w.result.suggestionId,
					Date.now(),
					"error-response-not-line-aligned-for-current-file",
					"unknown",
				),
					yield { status: He.invalidArgument }
				return
			}
			if (M.getText(q) !== w.result.existingCode) {
				if (
					(l.warn(`${B} Code in buffer doesn't match code in response.`),
					l.debug(`${B} Converting char range ${w.result.charStart}-${w.result.charEnd} to ${Y}-${j}.`),
					l.debug(`${B} Updated char range to ${ne?.start}-${ne?.stop}.`),
					l.debug(`${B} Buffer code: "${M.getText(q)}", response code: "${w.result.existingCode}".`),
					a.reportEvent(
						e.requestId,
						w.result.suggestionId,
						Date.now(),
						"error-code-in-buffer-doesnt-match-code-in-response",
						"unknown",
					),
					Q.relPath !== e.pathName?.relPath)
				)
					continue
				a.reportEvent(
					e.requestId,
					w.result.suggestionId,
					Date.now(),
					"error-code-in-buffer-doesnt-match-code-in-response-for-current-file",
					"unknown",
				),
					yield { status: He.invalidArgument }
				return
			}
			let Qe = new Na(
				e.requestId,
				e.mode,
				e.scope,
				{ ...w.result, charStart: ne.start, charEnd: ne.stop },
				Q,
				$u(q),
				M.uri.scheme,
			)
			l.debug(`${B} Returning ${Qe.changeType} suggestion for ${Q.relPath}@${Qe.lineRange.toString()}.`),
				yield { status: He.ok, suggestion: Qe }
		}
		l.debug(`[${e.requestId}] Request completed.`)
	} catch (b) {
		if (kr.isAPIErrorWithStatus(b, He.cancelled)) {
			l.debug(`[${e.requestId}] Cancelled by the server.`), yield { status: He.cancelled }
			return
		}
		l.warn(`[${e.requestId}] Next edit failed: ${b}.`),
			a.reportEvent(e.requestId, void 0, Date.now(), "error-api-error", "unknown"),
			yield { status: He.unknown }
		return
	} finally {
		v.dispose()
	}
}
var g8 = class extends z {
	constructor(r, n) {
		super()
		this.requestId = r
		this.workspaceManager = n
		this.addDisposable(
			Ys.workspace.onDidChangeTextDocument((i) => {
				if (i.contentChanges.length === 0) return
				let s = this.workspaceManager.safeResolvePathName(i.document.uri)
				if (!s) return
				let o = this._pendingEdits.get(s.absPath) ?? []
				o.push(...i.contentChanges), this._pendingEdits.set(s.absPath, o)
			}),
		)
	}
	_pendingEdits = new Map()
	updateWithPendingEdits(r, n) {
		let i = this._pendingEdits.get(r.absPath) ?? []
		for (let s of i) {
			let o = s.text.length - s.rangeLength
			if (s.rangeOffset + s.rangeLength < n.start) (n.start += o), (n.stop += o)
			else if (s.rangeOffset <= n.stop) return
		}
		return n
	}
}
async function gyt(e, t, r) {
	if (!t) {
		let n = r.getAllQualifiedPathNames(e)
		n.length === 1 && (t = n[0].rootPath)
	}
	if (t) {
		let n = Ys.Uri.file($t(t, e)),
			i = await Ys.workspace.openTextDocument(n)
		if (i) return i
	}
	return Ys.window.visibleTextEditors.find((n) => n.document.uri.fsPath === e)?.document
}
async function pyt(e, t, r, n) {
	let i = await e.getMostRecentDiagnostics(fyt, hyt, t),
		s = new Map()
	return (
		await Promise.all(
			i.map(async (a) => {
				let l = a.uri.path
				t && l.startsWith(t) && (l = l.substring(t.length))
				let c
				switch (a.diagnostic.severity) {
					case Ys.DiagnosticSeverity.Error:
						c = "ERROR"
						break
					case Ys.DiagnosticSeverity.Warning:
						c = "WARNING"
						break
					case Ys.DiagnosticSeverity.Information:
						c = "INFORMATION"
						break
					case Ys.DiagnosticSeverity.Hint:
						c = "HINT"
						break
				}
				s.has(l) || s.set(l, r.calculateNoThrow(l, (await ho(a.uri.fsPath)).getText()))
				let u = s.get(l)
				if (!u) return
				let f = n.safeResolvePathName(a.uri)
				if (!f) return
				let p = n.getBlobName(f)
				return p
					? {
							location: {
								path: l,
								line_start: a.diagnostic.range.start.line,
								line_end: a.diagnostic.range.end.line,
							},
							message: a.diagnostic.message,
							severity: c,
							current_blob_name: u,
							blob_name: p,
							char_start: a.charStart,
							char_end: a.charEnd,
						}
					: void 0
			}),
		)
	).filter((a) => a !== void 0)
}
var vQ = class extends z {
	constructor(r, n, i, s, o) {
		super()
		this._workspaceManager = r
		this._nextEditRequestManager = n
		this._suggestionManager = i
		this._configListener = s
		this._nextEditSessionEventReporter = o
		this.addDisposable(Fl.workspace.onDidChangeTextDocument(this.handleWorkspaceEditsAvailable)),
			this.addDisposable(Fl.window.onDidChangeActiveTextEditor(this.handleWorkspaceEditsAvailable)),
			this.addDisposable(
				new Fl.Disposable(
					this._nextEditRequestManager.lastFinishedRequest.listen(() => {
						this._handleWorkspaceEditsCached()
					}),
				),
			)
	}
	timeoutMs = 1e3 * 30
	_logger = X("GlobalNextEdits")
	async startGlobalQuery(r) {
		Fl.commands.executeCommand("setContext", "vscode-augment.nextEdit.global.updating", !0)
		try {
			this._nextEditSessionEventReporter.reportEventWithoutIds("global-mode-refreshed", r ?? "command")
			let n = Fl.window.activeTextEditor,
				i = n ? this._workspaceManager.safeResolvePathName(n.document.uri) : void 0,
				s = this._nextEditRequestManager.enqueueRequest(i, "FOREGROUND", "WORKSPACE")
			if (!s) return
			await this._nextEditRequestManager.lastFinishedRequest
				.waitUntil((a) => a !== void 0 && a.requestId === s, this.timeoutMs)
				.catch((a) => {
					this._logger.error(`Global next edit failed: ${a}`),
						this._nextEditSessionEventReporter.reportEvent(
							s,
							void 0,
							Date.now(),
							"error-global-mode-error",
							"command",
						)
				})
			let o = this._suggestionManager.getActiveSuggestions().filter((a) => !Pn(a.qualifiedPathName.absPath))
			this._suggestionManager.remove(o)
		} finally {
			Fl.commands.executeCommand("setContext", "vscode-augment.nextEdit.global.updating", !1)
		}
	}
	cancel() {
		this._nextEditRequestManager.cancelAll(),
			this._nextEditSessionEventReporter.reportEventWithoutIds("global-mode-canceled", "command")
	}
	handleWorkspaceEditsAvailable = () => {
		let { activeTextEditor: r } = Fl.window,
			n = r ? this._workspaceManager.safeResolvePathName(r?.document.uri) : void 0,
			i = p8(this._workspaceManager, this._configListener, n)
		xc("vscode-augment.nextEdit.global.canUpdate", i)
	}
	_handleWorkspaceEditsCached() {
		let { activeTextEditor: r } = Fl.window,
			n = r ? this._workspaceManager.safeResolvePathName(r?.document.uri) : void 0,
			i = this._nextEditRequestManager.shouldNotEnqueueRequestReason(n, "FOREGROUND", "WORKSPACE")
		xc("vscode-augment.nextEdit.global.updateCached", i)
	}
}
var F_e = W(gs()),
	Ql = W(require("vscode"))
var EQ = class e extends z {
		constructor(r, n, i, s, o, a, l, c, u, f, p, g) {
			super()
			this._apiServer = r
			this._configListener = n
			this._workspaceManager = i
			this._diagnosticsManager = s
			this._nextEditSessionEventReporter = o
			this._clientMetricsReporter = a
			this._blobNameCalculator = l
			this._suggestionManager = c
			this._recentSuggestions = u
			this._stateController = f
			this._completionJustAccepted = p
			this._featureFlagManager = g
			this.addDisposable(
				new Ql.Disposable(() => {
					this._inflightRequest?.cancelTokenSource?.cancel(),
						this._inflightRequest?.cancelTokenSource?.dispose(),
						(this._inflightRequest = void 0),
						this.lastFinishedRequest.dispose(),
						this.lastResponse.dispose(),
						this.state.dispose()
				}),
			),
				this.addDisposable(
					new Ql.Disposable(
						this.state.listen((y) => {
							xc("vscode-augment.nextEdit.loading", y === "inflight")
						}),
					),
				)
			let m = (y) => {
				let C = y ?? this._featureFlagManager.currentFlags.nextEditDebounceMs
				this._processPendingRequestsDebounced && this._processPendingRequestsDebounced.cancel(),
					(this._processPendingRequestsDebounced = (0, F_e.debounce)(
						() => void this._processPendingRequests(),
						C,
					))
			}
			m(this._configListener.config.nextEdit.useDebounceMs),
				this.addDisposable(
					this._configListener.onDidChange((y) => {
						y.newConfig.nextEdit.useDebounceMs !== y.previousConfig.nextEdit.useDebounceMs &&
							m(y.newConfig.nextEdit.useDebounceMs)
					}),
				),
				this.addDisposable(
					Ql.workspace.onDidChangeTextDocument((y) => {
						y.contentChanges.length > 0 &&
							this._workspaceManager.safeResolvePathName(y.document.uri) &&
							(this._freshCompletedRequests = []),
							!(
								!Je.equals(this._inflightRequest?.qualifiedPathName, y.document.uri) &&
								!this._pendingRequests.some((C) => Je.equals(C.qualifiedPathName, y.document.uri))
							) &&
								y.contentChanges.length > 0 &&
								!this._suggestionManager.suggestionWasJustAccepted.value &&
								this.cancelAll()
					}),
				)
		}
		_logger = X("NextEditRequestManager")
		static _statusClearTimeoutMs = 2e3
		_pendingRequests = []
		_inflightRequest
		lastFinishedRequest = new ta(void 0)
		lastResponse = new ta(void 0)
		state = new ta("ready")
		_processPendingRequestsDebounced
		_freshCompletedRequests = []
		get hasInflightRequest() {
			return !!this._inflightRequest
		}
		get pendingQueueLength() {
			return this._pendingRequests.length
		}
		shouldNotEnqueueRequestReason(r, n, i, s) {
			let o = this._resolvePath(r),
				a = {
					mode: n,
					scope: i,
					selection: s ?? o?.selection,
					requestBlobName: o?.blobName,
					qualifiedPathName: r,
				},
				l = this._inflightRequest || this._pendingRequests[0]
			if (l && A8(a, l)) return `Skipping ${n}/${i} request because it is subsumed by inflight request ${l.id}.`
			let c = this._freshCompletedRequests.find((f) => A8(a, f)),
				u = `${r?.relPath}@${a.selection?.toString()}`
			if (c)
				return `Skipping ${n}/${i} request at ${u} because it is subsumed by ${c.id}, which was recently completed.`
		}
		enqueueRequest(r, n, i, s) {
			let o = this.shouldNotEnqueueRequestReason(r, n, i, s)
			if (o) {
				this._logger.debug(o)
				return
			}
			let a = this._resolvePath(r)
			s = s ?? a?.selection
			let l = `${r?.relPath}@${s?.toString()}`,
				c = {
					id: this._apiServer.createRequestId(),
					qualifiedPathName: r,
					mode: n,
					scope: i,
					enqueuedAt: Date.now(),
				}
			this._logger.debug(`Starting enqueuing ${n}/${i} request ${c.id} at ${l}.`)
			let u = this._inflightRequest || this._pendingRequests[0]
			u &&
				(c.mode === "FOREGROUND" || c.mode === "FORCED"
					? (this._logger.debug(`Clearing requests for foreground request @ ${l}.`), this.cancelAll())
					: c.mode === "BACKGROUND" &&
						  u.mode === "BACKGROUND" &&
						  !Je.equals(u.qualifiedPathName, c.qualifiedPathName)
						? (this._logger.debug(`Clearing requests for background request @ ${l}.`), this.cancelAll())
						: c.mode === "BACKGROUND" &&
							u.mode === "BACKGROUND" &&
							u.scope === "WORKSPACE" &&
							c.scope === "FILE" &&
							(this._logger.debug(
								`Clearing background workspace requests for background file request @ ${l}.`,
							),
							this.cancelAll()))
			let f = this._pendingRequests.find((p) => A8(c, p))
			return (
				f
					? this._logger.debug(
							`Skipping enqueueing request ${c.id} at ${l} because it is subsumed by ${f.id}, which is already pending.`,
						)
					: this._pendingRequests.push(c),
				(this.state.value = this._inflightRequest ? "inflight" : "pending"),
				this._processPendingRequestsDebounced(),
				(c.mode === "FOREGROUND" ||
					c.mode === "FORCED" ||
					this._suggestionManager.suggestionWasJustAccepted.value ||
					this._completionJustAccepted.value) &&
					this._processPendingRequestsDebounced.flush(),
				c.id
			)
		}
		cancelAll() {
			this._inflightRequest &&
				(this._logger.debug(`Cancelling inflight request ${this._inflightRequest.id}.`),
				this._inflightRequest.cancelTokenSource?.cancel(),
				this._inflightRequest.cancelTokenSource?.dispose(),
				(this._inflightRequest = void 0)),
				this._pendingRequests.length > 0 &&
					(this._logger.debug(
						`Cancelling ${this._pendingRequests.length} pending requests: ${this._pendingRequests
							.map((r) => r.id)
							.toString()}.`,
					),
					(this._pendingRequests = []),
					this._processPendingRequestsDebounced.cancel())
		}
		async _processPendingRequests() {
			if (this._inflightRequest) {
				this._logger.debug("Waiting for inflight request to complete.")
				return
			} else if (!this._pendingRequests.length) {
				this._logger.debug("Waiting for a request to be enqueued.")
				return
			}
			let [r] = this._pendingRequests.splice(0, 1),
				n = this._resolvePath(r.qualifiedPathName),
				i = Date.now() - r.enqueuedAt
			this._logger.debug(`Starting to process ${r.id} after ${i} ms.`)
			let s = n?.blobName,
				o = r.qualifiedPathName,
				a = n?.document,
				l = n?.selection,
				c = r.mode,
				u = r.scope,
				f = this._suggestionManager
					.getRejectedSuggestions()
					.filter(
						(b) =>
							b.changeType !== "noop" &&
							(u === "WORKSPACE" || o === void 0 || b.qualifiedPathName.equals(o)),
					)
					.map((b) => new ZR(b.qualifiedPathName.relPath, b.lineRange, b.result.charStart, b.result.charEnd)),
				p = r.id,
				g = (this._inflightRequest = {
					...r,
					requestBlobName: s,
					selection: l,
					cancelTokenSource: new Ql.CancellationTokenSource(),
				})
			this.state.value = "inflight"
			let m = this._stateController.setState(Jxe),
				y = He.ok,
				C = [],
				v = new Date()
			try {
				let b = Date.now(),
					w = M_e(
						{
							requestId: p,
							clientCreatedAt: new Date(),
							instruction: "",
							selectedCode: a?.getText(l && Ds(l, a)),
							prefix: l && a?.getText(Ds({ start: 0, stop: l.start }, a)),
							suffix: l && a?.getText(Ds({ start: l.stop, stop: a.lineCount }, a)),
							language: a?.languageId,
							pathName: o,
							mode: c,
							scope: u,
							blockedLocations: f,
							unindexedEditEvents: [],
							unindexedEditEventsBaseBlobNames: [],
						},
						this._workspaceManager,
						this._diagnosticsManager,
						this._apiServer,
						this._blobNameCalculator,
						this._configListener,
						g.cancelTokenSource.token,
						this._nextEditSessionEventReporter,
					),
					B = Date.now(),
					M = 0,
					Q = 0,
					O = 0,
					Y = b - g.enqueuedAt
				this._logger.debug(`[${g.id}] queued for ${Y} ms.`)
				for await (let ne of w) {
					if (((y = ne.status), !ne.suggestion)) break
					O++
					let me = Date.now() - g.enqueuedAt
					this._logger.debug(
						`[${ne.suggestion?.requestId}/${
							ne.suggestion?.result.suggestionId
						}] ${ne.suggestion?.changeType?.toString()} took ${me} ms since enqueue.`,
					),
						M === 0 && ne.suggestion !== void 0 && ne.suggestion.changeType !== "noop" && (M = me),
						O === 4 && M === 0 && (Q = me),
						(this.lastResponse.value = ne.suggestion),
						ne.suggestion && C.push(ne.suggestion)
				}
				let j = y === He.ok && C.length === 0
				if ((y === He.ok && !j && this._freshCompletedRequests.push(g), !j && g.mode === "BACKGROUND")) {
					this._clientMetricsReporter.report({
						client_metric: "next_edit_bg_stream_preprocessing_latency_ms",
						value: B - b,
					})
					let ne = Date.now() - g.enqueuedAt
					y === He.ok
						? this._clientMetricsReporter.report({
								client_metric: "next_edit_bg_stream_finish_latency_ms",
								value: ne,
							})
						: M > 0 || Q > 0
							? this._clientMetricsReporter.report({
									client_metric: "next_edit_bg_stream_partial_latency_ms",
									value: ne,
								})
							: y === He.cancelled
								? this._clientMetricsReporter.report({
										client_metric: "next_edit_bg_stream_cancel_latency_ms",
										value: ne,
									})
								: this._clientMetricsReporter.report({
										client_metric: "next_edit_bg_stream_error_latency_ms",
										value: ne,
									}),
						M > 0
							? this._clientMetricsReporter.report({
									client_metric: "next_edit_bg_first_change_latency_ms",
									value: M,
								})
							: Q > 0
								? this._clientMetricsReporter.report({
										client_metric: "next_edit_bg_sufficient_noops_latency_ms",
										value: Q,
									})
								: O < 4 &&
									y === He.ok &&
									this._clientMetricsReporter.report({
										client_metric: "next_edit_bg_sufficient_noops_latency_ms",
										value: ne,
									})
				}
			} catch (b) {
				this._logger.warn(`[${p}] Next edit failed: ${b}.`),
					this._nextEditSessionEventReporter.reportEvent(p, void 0, Date.now(), "error-api-error", "unknown")
			} finally {
				g === this._inflightRequest &&
					((this._inflightRequest = void 0),
					this._pendingRequests.length > 0
						? (this._processPendingRequestsDebounced(), this._processPendingRequestsDebounced.flush())
						: (this._logger.debug("No more pending requests."),
							(this.state.value = "ready"),
							y === He.ok &&
							!this._suggestionManager
								.getActiveSuggestions()
								.some((w) => w.state === "fresh" && w.changeType !== "noop")
								? myt(this._stateController.setState(zxe), e._statusClearTimeoutMs)
								: y !== He.cancelled &&
									y !== He.ok &&
									(this._stateController.setState(Kxe),
									this._logger.debug(`Request ${p} failed with status: ${y}.`))))
				let b = new XR(p, c, u, o, y, C, v)
				this._recentSuggestions.addItem(b),
					(this.lastFinishedRequest.value = b),
					m.dispose(),
					g.cancelTokenSource.dispose()
			}
		}
		clearCompletedRequests(r) {
			this._freshCompletedRequests = this._freshCompletedRequests.filter((n) => r !== void 0 && n.mode !== r)
		}
		_resolvePath(r) {
			let n = r && Je.from(r),
				i = n && this._findEditorForPath(n),
				s = i && i.document,
				o = s && this._blobNameCalculator.calculate(n.relPath, s.getText()),
				a = i && new Rn(i.selection.start.line, i.selection.end.line)
			return { blobName: o, document: s, selection: a }
		}
		_findEditorForPath(r) {
			let n = Je.from(r)
			return Ql.window.activeTextEditor &&
				this._workspaceManager.safeResolvePathName(Ql.window.activeTextEditor.document.uri)?.equals(n)
				? Ql.window.activeTextEditor
				: Ql.window.visibleTextEditors.find((i) =>
						this._workspaceManager.safeResolvePathName(i.document.uri)?.equals(n),
					)
		}
	},
	Ayt = 15
function A8(e, t) {
	return (
		e.mode === t.mode &&
		(e.scope === t.scope || (e.scope === "CURSOR" && t.scope === "FILE")) &&
		(e.scope === "WORKSPACE" || Je.equals(e.qualifiedPathName, t.qualifiedPathName)) &&
		!(
			e.scope !== "WORKSPACE" &&
			e.requestBlobName &&
			t.requestBlobName &&
			e.requestBlobName !== t.requestBlobName
		) &&
		!(
			e.scope === "CURSOR" &&
			e.selection?.start != null &&
			t.selection?.start != null &&
			Math.abs(e.selection.start - t.selection.start) > Ayt
		)
	)
}
function myt(e, t) {
	setTimeout(() => {
		e.dispose()
	}, t)
}
var P_e = W(gs()),
	Ts = W(require("vscode"))
var R_ = W(require("vscode"))
var EA = class extends z {
	_document
	_lastSetAt
	_observable
	constructor(t = void 0, r = 1) {
		super(), (this._observable = this.addDisposable(new ta(t)))
		let n = (i) => {
			this.value === void 0 ||
				(i && this._document && i !== this._document) ||
				(this._lastSetAt && Date.now() - this._lastSetAt < r) ||
				this.clear()
		}
		this.addDisposable(
			R_.window.onDidChangeActiveTextEditor(() => {
				n()
			}),
		),
			this.addDisposable(
				R_.window.onDidChangeTextEditorSelection((i) => {
					n(i.textEditor.document)
				}),
			),
			this.addDisposable(
				R_.workspace.onDidChangeTextDocument((i) => {
					n(i.document)
				}),
			)
	}
	get value() {
		return this._observable.value
	}
	listen(t, r = !1) {
		return this._observable.listen(t, r)
	}
	waitUntil(t, r) {
		return this._observable.waitUntil(t, r)
	}
	set(t, r) {
		;(this._lastSetAt = Date.now()), (this._document = r), (this._observable.value = t)
	}
	clear() {
		;(this._document = void 0), (this._observable.value = void 0)
	}
}
var N_e = W(require("vscode"))
var bA = class {
		constructor(t) {
			this.suggestion = t
		}
	},
	DC = class {
		constructor(t) {
			this.suggestion = t
		}
	},
	k_ = class {
		constructor(t) {
			this.suggestion = t
		}
	},
	TC = class {
		constructor(t) {
			this.suggestion = t
		}
	},
	RC = class {
		constructor(t) {
			this.suggestion = t
		}
	}
function bQ(e, t) {
	if (t.contentChanges.length === 0 || t.document.uri.fsPath !== e.qualifiedPathName.absPath) return new bA(e)
	let r = e.state === "accepted",
		n = t.document,
		i = r ? e.afterLineRange() : e.lineRange,
		s = t.contentChanges.filter((g) => g.range.end.line <= i.start && !Q_e(g, i)),
		o = s
			.map((g) => {
				let m = g.text.match(/\n/g)?.length ?? 0,
					y = g.range.end.line - g.range.start.line
				return m - y
			})
			.reduce((g, m) => g + m, 0),
		a = new Rn(e.lineRange.start + o, e.lineRange.stop + o),
		l = s.map((g) => g.text.length - g.rangeLength).reduce((g, m) => g + m, 0),
		c = n.offsetAt(new N_e.Position(a.start, 0)) - l,
		u = e.with({
			result: {
				...e.result,
				charStart: e.result.charStart + l,
				charEnd: e.result.charEnd + l,
			},
			lineRange: a,
		}),
		f = t.contentChanges
			.filter((g) => Q_e(g, i))
			.map((g) => ({
				rangeOffset: g.rangeOffset - c,
				rangeLength: g.rangeLength,
				text: g.text,
			}))
			.sort((g, m) => g.rangeOffset - m.rangeOffset)
	if (f.length === 0) return l === 0 ? new bA(u) : new DC(u)
	let p = 0
	for (let g of f) {
		if (
			(r ? e.result.existingCode : e.result.suggestedCode).slice(
				p + g.rangeOffset,
				p + g.rangeOffset + g.text.length,
			) !== g.text
		)
			return new TC(e)
		p += g.text.length - g.rangeLength
	}
	return (
		r && (p *= -1),
		p !== e.result.suggestedCode.length - e.result.existingCode.length
			? new TC(e)
			: r
				? new RC(u.with({ state: "fresh" }))
				: new k_(u.with({ state: "accepted" }))
	)
}
function yyt(e) {
	return new Rn(e.start.line, e.end.line + (e.end.character > 0 ? 1 : 0))
}
function Q_e(e, t) {
	let r = yyt(e.range)
	return r.intersects(t) || (t.length === 0 && r.touches(t))
		? !0
		: r.length === 0 && r.start === t.start
			? !e.text.endsWith(`
`) || r.equals(t)
			: !1
}
var xQ = class extends z {
	constructor(r, n, i = 1e3 * 60 * 10) {
		super()
		this._workspaceManager = r
		this._nextEditSessionEventReporter = n
		this.defaultRejectionDurationMs = i
		;(this.suggestionWasJustAccepted = new EA()),
			(this.suggestionWasJustUndone = new EA()),
			this.addDisposable(this.suggestionWasJustAccepted),
			this.addDisposable(this.suggestionWasJustUndone),
			this.addDisposable(new Ts.Disposable(() => this.clear(!0))),
			this.addDisposable(
				Ts.workspace.onDidChangeTextDocument((s) => {
					this.handleChangeEvent(s)
				}),
			)
	}
	_suggestions = []
	_justAcceptedSuggestions = []
	_rejectedSuggestions = []
	_suggestionsChangedListeners = []
	suggestionWasJustAccepted
	suggestionWasJustUndone
	_logger = X("SuggestionManagerImpl")
	onSuggestionsChanged(r) {
		return (
			this._suggestionsChangedListeners.push(r),
			new Ts.Disposable(() => {
				this._suggestionsChangedListeners = this._suggestionsChangedListeners.filter((n) => n !== r)
			})
		)
	}
	dispatchSuggestionsChangedEvent(r) {
		let n = {
			...r,
			newSuggestions: r.newSuggestions,
			oldSuggestions: r.oldSuggestions,
		}
		this._suggestionsChangedListeners.forEach((i) => void i(n))
	}
	add(r, n) {
		if (((this._rejectedSuggestions = this._getCurrentRejectedSuggestions()), n)) {
			let s = this._rejectedSuggestions.length
			;(this._rejectedSuggestions = this._rejectedSuggestions.filter(
				([o, a]) => !r.some((l) => o.intersects(l)),
			)),
				s !== this._rejectedSuggestions.length &&
					this._logger.debug(`Clearing ${s - this._rejectedSuggestions.length} old rejections.`)
		} else {
			let s = r.length
			;(r = r.filter((o) => !this._rejectedSuggestions.some(([a, l]) => a.intersects(o)))),
				s !== r.length &&
					this._logger.debug(`Dropping ${s - r.length} suggestions that overlap with rejected suggestions.`)
		}
		if (!r.length) return !1
		let i = this._suggestions
		this._filterSuggestions((s) => !r.some((o) => s.intersects(o)))
		for (let s of r) this._reportNonemptyEvent(s, "nonempty-suggestion-added")
		return (
			this._suggestions.push(...r),
			this.checkValidity(this._suggestions),
			this.dispatchSuggestionsChangedEvent({
				oldSuggestions: i,
				newSuggestions: this._suggestions,
				accepted: this._justAcceptedSuggestions,
				rejected: [],
				undone: [],
			}),
			!0
		)
	}
	remove(r) {
		if (!r.length) return !1
		let n = this._suggestions,
			i = this._rejectedSuggestions
		return (
			this._filterSuggestions((s) => !r.some((o) => o.equals(s))),
			(this._rejectedSuggestions = this._getCurrentRejectedSuggestions().filter(
				([s, o]) => !r.some((a) => a.equals(s)),
			)),
			this._logger.debug(
				`Removing ${n.length - this._suggestions.length} suggestions and ${
					i.length - this._rejectedSuggestions.length
				} rejections from the manager.`,
			),
			n.length !== this._suggestions.length
				? (this.dispatchSuggestionsChangedEvent({
						oldSuggestions: n,
						newSuggestions: this._suggestions,
						accepted: this._justAcceptedSuggestions,
						rejected: [],
						undone: [],
					}),
					!0)
				: i.length !== this._rejectedSuggestions.length
		)
	}
	clear(r, n) {
		let i = this._suggestions
		for (let s of i) this._reportNonemptyEvent(s, "nonempty-suggestion-cleared")
		n ? (this._suggestions = this._suggestions.filter((s) => s.mode !== n)) : (this._suggestions = []),
			r && (this._rejectedSuggestions = []),
			(this._justAcceptedSuggestions = []),
			this.dispatchSuggestionsChangedEvent({
				oldSuggestions: i,
				newSuggestions: [],
				accepted: this._justAcceptedSuggestions,
				rejected: [],
				undone: [],
			})
	}
	getActiveSuggestions() {
		return [...this._suggestions]
	}
	getJustAcceptedSuggestions() {
		return [...this._justAcceptedSuggestions]
	}
	clearJustAcceptedSuggestions() {
		this._justAcceptedSuggestions.length !== 0 &&
			((this._justAcceptedSuggestions = []),
			this.dispatchSuggestionsChangedEvent({
				oldSuggestions: this._suggestions,
				newSuggestions: this._suggestions,
				accepted: this._justAcceptedSuggestions,
				rejected: [],
				undone: [],
			}))
	}
	findSuggestionById(r) {
		return this._suggestions.find((n) => n.result.suggestionId === r)
	}
	_getCurrentRejectedSuggestions() {
		let r = Date.now(),
			n = this._rejectedSuggestions.filter(([i, s]) => r < s)
		return (
			n.length !== this._rejectedSuggestions.length &&
				this._logger.debug(`Filtering out ${this._rejectedSuggestions.length - n.length} expired rejections.`),
			n
		)
	}
	getRejectedSuggestions() {
		return (
			(this._rejectedSuggestions = this._getCurrentRejectedSuggestions()),
			this._rejectedSuggestions.map(([r, n]) => r)
		)
	}
	getAllSuggestions() {
		return [...this.getActiveSuggestions(), ...this.getRejectedSuggestions()]
	}
	accept(r) {
		if (r.length === 0) return
		let n = new Ts.WorkspaceEdit()
		for (let i of r)
			n.replace(
				Ts.Uri.from({ scheme: i.uriScheme, path: i.qualifiedPathName.absPath }),
				new Ts.Range(new Ts.Position(i.lineRange.start, 0), new Ts.Position(i.lineRange.stop, 0)),
				i.result.suggestedCode,
			)
		Ts.workspace.applyEdit(n)
	}
	reject(r, n = this.defaultRejectionDurationMs) {
		if (r.length === 0) return
		this._logger.debug(`Rejecting ${r.length} suggestions.`),
			(this._justAcceptedSuggestions = this._justAcceptedSuggestions.filter((a) => !r.some((l) => l.equals(a))))
		let i = this._suggestions
		this._filterSuggestions((a) => !r.some((l) => l.equals(a)))
		let s = Date.now() + n,
			o = r.map((a) => [a, s])
		;(this._rejectedSuggestions = this._getCurrentRejectedSuggestions().concat(o)),
			this.dispatchSuggestionsChangedEvent({
				oldSuggestions: i,
				newSuggestions: this._suggestions,
				accepted: this._justAcceptedSuggestions,
				rejected: r,
				undone: [],
			})
	}
	handleChangeEvent(r) {
		if (r.contentChanges.length === 0) return !1
		let n = this._workspaceManager.safeResolvePathName(r.document.uri)
		if (n === void 0) return !1
		let i = this._suggestions,
			[s, o] = (0, P_e.partition)(this._suggestions, (w) => n.equals(w.qualifiedPathName)),
			a = s.map((w) => bQ(w, r)),
			l = this._justAcceptedSuggestions.map((w) => bQ(w, r)),
			c = this._getCurrentRejectedSuggestions().map(([w, B]) => bQ(w, r)),
			u = sg(a, k_),
			f = sg(a, TC),
			p = sg(l, RC),
			g = sg(c, RC)
		this._justAcceptedSuggestions = sg(l, bA).concat(sg(l, DC))
		let m = p.concat(g),
			y = f.filter((w) =>
				m.some(
					(B) =>
						B.lineRange.equals(w.afterLineRange(r.document)) ||
						B.lineRange.intersects(w.afterLineRange(r.document)),
				),
			)
		;(u.length > 0 || f.length > 0 || m.length > 0) &&
			this._logger.debug(
				`Accepting ${u.length} suggestions and invalidating ${f.length} suggestions (of which ${y.length} were invalidated due to undo) and undoing ${m.length} suggestions.`,
			)
		let C = u.length === 0 && m.length === 0 && f.length > y.length,
			v = [...sg(a, bA), ...sg(a, DC)].map((w) => this._markStaleIfNeeded(w, C, "document-changed")),
			b = o.map((w) => this._markStaleIfNeeded(w, C, "document-changed"))
		for (let w of u)
			this._reportNonemptyEvent(
				w,
				r.reason === Ts.TextDocumentChangeReason.Redo
					? "nonempty-suggestion-redone"
					: "nonempty-suggestion-accepted",
				"document-changed",
			)
		for (let w of f) this._reportNonemptyEvent(w, "nonempty-suggestion-invalidated", "document-changed")
		for (let w of m) this._reportNonemptyEvent(w, "nonempty-suggestion-undone", "document-changed")
		return (
			(this._suggestions = b.concat(v, p)),
			this.checkValidity(this._suggestions),
			(this._justAcceptedSuggestions = (C ? [] : this._justAcceptedSuggestions).concat(u)),
			u.length > 0 && this.suggestionWasJustAccepted.set(!0),
			p.length > 0 && this.suggestionWasJustUndone.set(!0),
			this.dispatchSuggestionsChangedEvent({
				oldSuggestions: i,
				newSuggestions: this._suggestions,
				accepted: this._justAcceptedSuggestions,
				rejected: [],
				undone: p,
			}),
			u.length > 0
		)
	}
	_filterSuggestions(r) {
		;(this._suggestions = this._suggestions.filter((n) => {
			let i = r(n)
			return i || this._reportNonemptyEvent(n, "nonempty-suggestion-dropped"), i
		})),
			this.checkValidity(this._suggestions)
	}
	_markStaleIfNeeded(r, n, i) {
		return n
			? (this._reportNonemptyEvent(r, "nonempty-suggestion-becomes-stale", i), r.with({ state: "stale" }))
			: r
	}
	checkValidity(r) {
		if (r.length < 2) return !0
		let n = [...r]
		n.sort(
			(s, o) =>
				s.qualifiedPathName.relPath.localeCompare(o.qualifiedPathName.relPath) ||
				s.lineRange.compareTo(o.lineRange),
		)
		let i = n[0]
		for (let s = 1; s < n.length; s++) {
			let o = n[s]
			if (i.intersects(o))
				return (
					this._logger.error(`Found intersecting suggestions, ${i.toString()} and ${o.toString()}`),
					this._nextEditSessionEventReporter.reportEventFromSuggestion(
						o,
						"error-intersecting-suggestions",
						"unknown",
					),
					!1
				)
		}
		return !0
	}
	_reportNonemptyEvent(r, n, i) {
		r.changeType !== "noop" && this._nextEditSessionEventReporter.reportEventFromSuggestion(r, n, i ?? "unknown")
	}
}
function sg(e, t) {
	return e.filter((r) => r instanceof t).map((r) => r.suggestion)
}
var _Q = W(gs()),
	Ks = W(require("vscode"))
var Cyt = 2,
	vyt = 200,
	Eyt = 80,
	byt = 3,
	xyt = 3,
	_yt = 4,
	kC = class e extends z {
		constructor(r, n, i, s, o) {
			super()
			this._configListener = r
			this._context = n
			this._keybindingWatcher = i
			this._featureFlagManager = s
			this._hints = o
			;(this._decorations = new m8(this._context, this._keybindingWatcher, this._hints)),
				(this._hoverPanel = new y8()),
				(this.showHintDecoration = _Q.debounce((a) => {
					this._decorations.decorate(a)
				}, vyt))
		}
		_decorations
		_previousEditor
		_hoverPanel
		showHintDecoration
		enable() {
			this.dispose(),
				(this._configListener.config.enableDebugFeatures ||
					Gr(this._featureFlagManager.currentFlags.vscodeChatHintDecorationMinVersion)) &&
					(this._hoverPanel.enable(),
					this.addDisposable(
						Ks.window.onDidChangeActiveTextEditor((r) => {
							this._decorations.clearDecorations(this._previousEditor),
								(this._previousEditor = r),
								r && e.canDecorateEditor(r) && this.enableMultilineSelectionHints(r.selection)
						}),
					),
					this.addDisposable(
						Ks.window.onDidChangeTextEditorSelection((r) => {
							if (!e.canDecorateEditor(r.textEditor)) return
							let n = r.selections[0]
							this.enableMultilineSelectionHints(n)
						}),
					))
		}
		dispose() {
			super.dispose(), this._decorations.clearDecorations(), this._hoverPanel.dispose()
		}
		enableMultilineSelectionHints(r) {
			this._decorations.clearDecorations(),
				r.isSingleLine
					? this._hoverPanel.setRange()
					: (this.showHintDecoration(this.getOffsetLine(r)), this._hoverPanel.setRange(r.start, r.end))
		}
		static canDecorateEditor(r) {
			return r.document.uri.scheme === "file" || r.document.uri.scheme === "untitled"
		}
		getOffsetLine(r) {
			let n = Ks.window.activeTextEditor,
				i = r.active.line < r.anchor.line
			if (!n) return i ? r.active.line - 1 : r.active.line + 1
			let s = i ? 1 : -1,
				o = [Math.min(r.anchor.line, r.active.line), Math.max(r.anchor.line, r.active.line)],
				a = r.active.line + s * Cyt,
				l = r.active.line,
				c = [Math.min(a, l), Math.max(a, l)],
				u = _Q.range(Math.max(c[0], o[0]), Math.min(c[1], o[1]) + 1)
			return (
				u.sort((f, p) => {
					let g = n.document.lineAt(f).text.length - n.document.lineAt(p).text.length
					return g === 0 ? (i ? f - p : p - f) : g
				}),
				u[0] === r.active.line ? u[1] : u[0]
			)
		}
	},
	m8 = class {
		constructor(t, r, n) {
			this._context = t
			this._keybindingWatcher = r
			this._hints = n
			;(this._rightSpacerDecorationType = d8()),
				(this._keyHintDecorationTypes = []),
				this._hints.forEach((i, s) => {
					let o = B_(i.keyBindingId, this._keybindingWatcher, this._context)
					this._decorationLength += o.length * xyt
					let a = {
						keyBindingDecorationTypes: f8(),
						textDecorationType: aQ(i.text),
					}
					;(this._decorationLength += i.text.length),
						s < this._hints.length - 1 &&
							((a.gapDecorationType = aQ(" | ")), (this._decorationLength += _yt)),
						this._keyHintDecorationTypes.push(a)
				})
		}
		_rightSpacerDecorationType
		_keyHintDecorationTypes
		_decorationLength = 0
		decorate(t) {
			let r = Ks.window.activeTextEditor
			if (!r || !kC.canDecorateEditor(r) || this._keyHintDecorationTypes.length === 0) return
			let n = ig(r, t),
				i = r.document.lineAt(t).text.length,
				s = Math.max(Eyt - i - this._decorationLength, byt)
			r.setDecorations(this._rightSpacerDecorationType, [
				{ range: n, renderOptions: { after: { margin: `0 0 0 ${s}ch` } } },
			]),
				this._keyHintDecorationTypes.forEach((o, a) => {
					let l = B_(this._hints[a].keyBindingId, this._keybindingWatcher, this._context)
					o.keyBindingDecorationTypes.forEach((c, u) => {
						l[u] && r.setDecorations(c, [{ range: n, renderOptions: l[u] }])
					}),
						r.setDecorations(o.textDecorationType, [{ range: n }]),
						o.gapDecorationType &&
							r.setDecorations(o.gapDecorationType, [
								{
									range: n,
									renderOptions: { after: { margin: "0 0.65em 0 0.5em" } },
								},
							])
				})
		}
		clearDecorations(t) {
			let r = t ?? Ks.window.activeTextEditor
			r &&
				(r.setDecorations(this._rightSpacerDecorationType, []),
				this._keyHintDecorationTypes.forEach((n) => {
					n.keyBindingDecorationTypes.forEach((i) => {
						r.setDecorations(i, [])
					}),
						r.setDecorations(n.textDecorationType, []),
						n.gapDecorationType && r.setDecorations(n.gapDecorationType, [])
				}))
		}
	},
	y8 = class extends z {
		_provider
		_range
		enable() {
			this.registerHoverProvider(Ks.window.activeTextEditor),
				this.addDisposable(
					Ks.window.onDidChangeActiveTextEditor((t) => {
						this.registerHoverProvider(t)
					}),
				)
		}
		setRange(t, r) {
			if (t && r) {
				this._range = new Ks.Range(t, r)
				return
			}
			this._range = void 0
		}
		provideHover(t, r, n) {
			if (this._range && this._range.contains(r)) {
				let i = `
$(augment-icon-simple)
&nbsp;
<a href="command:${Hi.commandID}" title="Open Augment Chat">
    Open in Chat
</a> |
<a href="command:${Gh.commandID}" title="Fix with Augment Chat">
    Fix
</a> |
<a href="command:${iC.commandID}" title="Explain with Augment Chat">
    Explain
</a> | <a href="command:${sC.commandID}" title="Write a test with Augment Chat">
    Write a Test
</a> | <a href="command:${oC.commandID}" title="Document with Augment Chat">
    Document
</a>
            `,
					s = new Ks.MarkdownString(i)
				return (
					(s.isTrusted = !0), (s.supportHtml = !0), (s.supportThemeIcons = !0), new Ks.Hover(s, this._range)
				)
			}
		}
		registerHoverProvider(t) {
			this._provider?.dispose(),
				(this._provider = void 0),
				!(!t || !kC.canDecorateEditor(t)) &&
					(this._provider = Ks.languages.registerHoverProvider({ pattern: t.document.uri.fsPath }, this))
		}
	}
var L_e = W(require("vscode"))
var wQ = class {
	_logger = X("ResolveFileService")
	getOpenDocumentText(t) {
		for (let r of L_e.workspace.textDocuments) if (r.uri.fsPath === t && r.uri.scheme === "file") return r.getText()
		return null
	}
	async resolveFile(t) {
		let r = Je.from(t).absPath,
			n = this.getOpenDocumentText(r)
		if (n == null)
			try {
				n = await Fr(r)
			} catch (i) {
				this._logger.warn(`Could not read file: ${r}`, i), (n = "")
			}
		return n
	}
	register(t) {
		t.registerHandler("read-file-request", async (r) => ({
			type: "read-file-response",
			data: {
				pathName: r.data.pathName,
				content: await this.resolveFile(r.data.pathName),
			},
		}))
	}
}
var IQ = class e {
	constructor(t) {
		this.publish = t
	}
	static _lineLen = 80
	static _indent = "    "
	static _subIndent = "  "
	_content = ""
	_disposed = !1
	get content() {
		return this._content
	}
	addSection(t) {
		let r =
			(this._content.length === 0
				? ""
				: `
`) +
			`================
`
		this._addLine(r + t)
	}
	addObject(t) {
		if (t === void 0) this.addLine(this.formatValue(t))
		else
			for (let r in t) {
				let n = t[r]
				typeof n != "object" ? this.addValue(r, n) : this.addValue(r, JSON.stringify(n))
			}
	}
	formatValue(t) {
		return t === void 0 ? "<undefined>" : t === null ? "<null>" : typeof t == "string" ? `"${t}"` : `${t}`
	}
	addLine(t) {
		this._disposed || this._addLine(e._indent + t)
	}
	addText(t, r) {
		if (this._disposed) return
		let n =
			(this._content.length === 0
				? ""
				: `
`) + ">>>>>>>>>>>>>>>> "
		this._addLine(n + t),
			this._addLine(r, ""),
			r.length > 0 &&
				r[r.length - 1] !==
					`
` &&
				this._addLine("|<---- (ends here)"),
			this._addLine("<<<<<<<<<<<<<<<< " + t)
	}
	addError(t) {
		if (e._indent.length + t.length <= e._lineLen) {
			this._addLine(e._indent + t)
			return
		}
		let r = 0,
			n = e._indent
		for (;;) {
			let i = t.indexOf(": ", r)
			if (i === -1) {
				this._addLine(n + t.substring(r))
				break
			}
			this._addLine(n + t.substring(r, i + 1)), (r = i + 2), (n += e._subIndent)
		}
	}
	addValue(t, r) {
		this._addLine(e._indent + t + ": " + this.formatValue(r))
	}
	addStringValue(t, r, n = !0) {
		this._addLine(e._indent + t + ": " + (n ? `"${r}"` : r))
	}
	_addLine(
		t,
		r = `
`,
	) {
		this._disposed || (this._content += t + r)
	}
	savePoint() {
		return this._content.length
	}
	rollback(t) {
		this._disposed || (this._content.length > t && (this._content = this._content.substring(0, t)))
	}
	dispose() {
		;(this._disposed = !0), (this._content = "")
	}
}
var MC = W(require("vscode"))
var BQ = W(require("vscode"))
var SQ = class {
	constructor(t) {
		this._baseState = t
	}
	_stateEventEmitter = new BQ.EventEmitter()
	_state = { 0: [], 1: [], 2: [], 3: [] }
	onDidChangeState = this._stateEventEmitter.event
	setState(t) {
		this._state[t.priority].push(t)
		let r = !1
		return BQ.Disposable.from({
			dispose: () => {
				if (r) return
				r = !0
				let n = !1
				;(this._state[t.priority] = this._state[t.priority].filter((i) => (n ? !0 : ((n = i === t), !n)))),
					this._stateEventEmitter.fire()
			},
		})
	}
	getPriorityState() {
		for (let t of XG) {
			let r = this._state[t]
			if (r.length > 0) return r[r.length - 1]
		}
		return this._baseState
	}
	reset() {
		for (let t of XG) this._state[t] = []
		this._stateEventEmitter.fire()
	}
}
var wyt = "Augment",
	DQ = class extends z {
		_statusBarItem
		_stateManager = new SQ(Mxe)
		_currentState
		constructor() {
			super(),
				this.addDisposable(new MC.Disposable(() => this.reset())),
				(this._statusBarItem = MC.window.createStatusBarItem(
					"vscode-augment.PrimaryStatusBarItem",
					MC.StatusBarAlignment.Right,
				)),
				(this._statusBarItem.name = "Augment"),
				(this._statusBarItem.command = pC.commandID),
				this.addDisposables(
					this._statusBarItem,
					this._stateManager.onDidChangeState(() => this.updateState()),
				),
				this.updateState(),
				this._statusBarItem.show()
		}
		updateState() {
			let t = this._stateManager.getPriorityState()
			if (t === this._currentState) return
			;(this._currentState = t),
				(this._statusBarItem.tooltip = t.tooltip),
				(this._statusBarItem.backgroundColor = t.colors?.background),
				(this._statusBarItem.color = t.colors?.foreground)
			let r = t.label ? t.label : wyt
			this._statusBarItem.text = `${t.icon} ${r}`
		}
		setState(t) {
			let r = this._stateManager.setState(t)
			return this.updateState(), r
		}
		reset() {
			this._stateManager.reset()
		}
	}
var FC = W(require("vscode"))
var TQ = class extends Lu {
	constructor(r, n, i, s, o, a, l, c, u, f = Ti(i)) {
		super("next-edit-suggestions.html", i)
		this._webviewView = n
		this._suggestionManager = s
		this._globalNextEdit = o
		this._editorEditManager = a
		this._nextEditSessionEventReporter = l
		this._resolveFileService = c
		this._nextEditVSCodeToWebviewMessage = u
		this._asyncMsgHandler = f
		this.loadHTML(r),
			this.addDisposable(this._asyncMsgHandler),
			this._resolveFileService.register(this._asyncMsgHandler),
			this.addDisposable(
				this._suggestionManager.onSuggestionsChanged((p) => {
					let g = $G(
						[this._editorEditManager.state.suggestion]
							.concat(p.newSuggestions)
							.concat(this._suggestionManager.getJustAcceptedSuggestions()),
					).filter(C_(ui, fC))
					this.postMessage({
						type: "next-edit-suggestions-changed",
						data: { suggestions: g },
					}),
						(n.badge = { value: g.length, tooltip: "Next Edit Suggestions" })
				}),
			),
			this.addDisposable(
				new FC.Disposable(
					this._editorEditManager.addStateListener((p, g) => {
						if (p instanceof Ut || p instanceof _r || p instanceof wr) {
							this.postMessage({
								type: "next-edit-preview-active",
								data: p.suggestion,
							})
							return
						}
						if (g instanceof Ut || g instanceof _r || g instanceof wr) {
							this.postMessage({ type: "next-edit-dismiss" })
							return
						}
						if (
							(p.suggestion?.equals(g.suggestion) ?? g.suggestion === void 0) &&
							!(p instanceof Ut) &&
							!(g instanceof Ut)
						)
							return
						let m = $G(
							[this._editorEditManager.state.suggestion]
								.concat(this._suggestionManager.getActiveSuggestions())
								.concat(this._suggestionManager.getJustAcceptedSuggestions()),
						).filter(C_(ui, fC))
						this.postMessage({
							type: "next-edit-suggestions-changed",
							data: { suggestions: m },
						}),
							this.postMessage({
								type: "next-edit-next-suggestion-changed",
								data: p.suggestion,
							})
					}),
				),
			),
			this.addDisposable(
				this._nextEditVSCodeToWebviewMessage.event((p) => {
					this.postMessage(p)
				}),
			),
			this.addDisposable(this._webview.onDidReceiveMessage(this.onDidReceiveMessage)),
			(n.badge = {
				value: this._suggestionManager.getActiveSuggestions().filter(C_(ui)).length,
				tooltip: "Next Edit Suggestions",
			}),
			this._nextEditSessionEventReporter.reportEventWithoutIds("panel-created", "unknown")
	}
	logger = X("NextEditSuggestionsPanel")
	wrapAsyncMsg(r, n, i = null) {
		return this.postMessage({
			type: "async-wrapper",
			requestId: r.requestId,
			error: i,
			baseMsg: n,
		})
	}
	postMessage = async (r) => this._webview.postMessage(r)
	onDidReceiveMessage = async (r) => {
		switch (r.type) {
			case "next-edit-suggestions-action":
				if ("accept" in r.data) {
					await this._editorEditManager.acceptSuggestion(
						Na.from(r.data.accept),
						"next-edit-panel-item-click",
						void 0,
						!0,
					)
					return
				}
				if ("reject" in r.data) {
					this._editorEditManager.rejectSuggestion(Na.from(r.data.reject), "next-edit-panel-item-click")
					return
				}
				if ("undo" in r.data && r.data.undo) {
					this._editorEditManager.undoAcceptSuggestion(Na.from(r.data.undo), "next-edit-panel-item-click")
					return
				}
				if ("acceptAllInFile" in r.data) {
					if (r.data.acceptAllInFile.length === 0) {
						FC.window.showInformationMessage("No Next Edits to accept.")
						return
					}
					this._editorEditManager.acceptAllSuggestionsInFile(
						r.data.acceptAllInFile[0].qualifiedPathName,
						"next-edit-panel-item-click",
					)
					return
				}
				if ("rejectAllInFile" in r.data) {
					if (r.data.rejectAllInFile.length === 0) {
						FC.window.showInformationMessage("No Next Edits to reject.")
						return
					}
					this._editorEditManager.rejectAllSuggestionsInFile(
						r.data.rejectAllInFile[0].qualifiedPathName,
						"next-edit-panel-item-click",
					)
					return
				}
				if ("undoAllInFile" in r.data) {
					if (r.data.undoAllInFile.length === 0) {
						FC.window.showInformationMessage("No Next Edits to undo.")
						return
					}
					this._editorEditManager.undoAllSuggestionsInFile(
						r.data.undoAllInFile[0].qualifiedPathName,
						"next-edit-panel-item-click",
					)
					return
				}
				this.logger.error("Unknown action message: " + JSON.stringify(r))
				return
			case "next-edit-dismiss":
				this._editorEditManager.dismiss("next-edit-panel-item-click", !0, !1)
				return
			case "next-edit-loaded":
				this._nextEditSessionEventReporter.reportEventWithoutIds("panel-opened", "unknown"),
					await this.postMessage({
						type: "next-edit-suggestions-changed",
						data: {
							suggestions: this._suggestionManager
								.getActiveSuggestions()
								.concat(this._suggestionManager.getJustAcceptedSuggestions())
								.filter(C_(ui, fC)),
						},
					}),
					this.postMessage({
						type: "next-edit-next-suggestion-changed",
						data: this._editorEditManager.state.suggestion,
					}),
					this._globalNextEdit.handleWorkspaceEditsAvailable()
				return
			case "next-edit-open-suggestion":
				await this._editorEditManager.open(Na.from(r.data), {
					shouldAutoApply: !1,
					preserveFocus: !0,
					eventSource: "next-edit-panel-item-click",
					animationDelayMs: 0,
				}),
					this._nextEditSessionEventReporter.reportEvent(
						r.data.requestId,
						r.data.result.suggestionId,
						Date.now(),
						"panel-suggestion-clicked",
						"click",
					)
				return
			case "next-edit-refresh-started":
				await this._globalNextEdit.startGlobalQuery(),
					await this.postMessage({ type: "next-edit-refresh-finished" })
				return
			case "next-edit-cancel":
				this._globalNextEdit.cancel()
				return
			case "next-edit-active-suggestion":
				this.postMessage({ type: "next-edit-active-suggestion", data: r.data })
				return
		}
	}
	generateCSPPolicy() {
		return wl(Sl(this._webview), Il(), tF(Xy()), Bl(), Dl(), rF())
	}
}
var RQ = class {
	constructor(t, r, n) {
		this.storage = t
		this.toolsModel = r
		this.getSettingsMcpServers = n
	}
	logger = X("ToolConfigStore")
	async get() {
		try {
			return (
				(await this.storage.load("toolsConfiguration")) ?? {
					version: jG,
					tools: [],
				}
			)
		} catch (t) {
			return this.logger.error(`Failed to load tool configurations: ${Ye(t)}`), { version: jG, tools: [] }
		}
	}
	async save(t) {
		try {
			await this.storage.save("toolsConfiguration", t)
		} catch (r) {
			let n = `Failed to save tool configurations: ${Ye(r)}`
			throw (this.logger.error(n), new Ml(n))
		}
	}
	async getMCPServers() {
		try {
			let t = await this.storage.load("mcpServers")
			return Array.isArray(t) ? t : []
		} catch (t) {
			return this.logger.error(`Failed to load MCP servers: ${Ye(t)}`), []
		}
	}
	async saveMCPServers(t) {
		try {
			await this.storage.save("mcpServers", t), await this.updateSidecarMCPServers()
		} catch (r) {
			let n = `Failed to save MCP servers: ${Ye(r)}`
			throw (this.logger.error(n), new Ml(n))
		}
	}
	async updateSidecarMCPServers() {
		try {
			let r = (await this.getMCPServers()).map((s) => ({
					name: s.name,
					command: s.command,
					args: [],
					useShellInterpolation: !0,
				})),
				n = this.getSettingsMcpServers ? this.getSettingsMcpServers() : [],
				i = [...r]
			n && n.length > 0 && i.push(...n), this.toolsModel && this.toolsModel.setMcpServers(i)
		} catch (t) {
			this.logger.error(`Failed to update sidecar MCP servers: ${Ye(t)}`)
		}
	}
}
var U_e = W(require("vscode"))
var kQ = class extends Lu {
	_currentApp
	constructor(t) {
		super("main-panel.html", t),
			this.addDisposable(this._webview.onDidReceiveMessage((r) => this.onDidReceiveMessage(r)))
	}
	changeApp(t) {
		;(this._currentApp = t),
			this._currentApp &&
				(this._currentApp.register(this._webview),
				xc("vscode-augment.mainPanel.app", this._currentApp.appType())),
			this._postAppTypeMsg()
	}
	onDidReceiveMessage(t) {
		switch (t.type) {
			case "main-panel-loaded":
				this._postAppTypeMsg()
				break
		}
	}
	_postAppTypeMsg() {
		this._webview.postMessage({
			type: "main-panel-display-app",
			data: this._currentApp?.appType(),
		})
	}
}
var MQ = class extends z {
	constructor(r) {
		super()
		this._extensionUri = r
		this.addDisposable(this.visibilityEventEmitter)
	}
	_logger = X("MainPanelWebviewProvider")
	_webviewView = void 0
	_mainPanelWebview = void 0
	currentApp = void 0
	visibilityEventEmitter = new U_e.EventEmitter()
	get onVisibilityChange() {
		return this.visibilityEventEmitter.event
	}
	isVisible() {
		return !!this._webviewView?.visible
	}
	changeApp(r) {
		this.currentApp?.dispose(),
			r && this.addDisposable(r),
			this._setViewTitle(r?.title() || ""),
			(this.currentApp = r),
			this._mainPanelWebview?.changeApp(r)
	}
	_setViewTitle(r) {
		this._webviewView && (this._webviewView.title = r)
	}
	async resolveWebviewView(r, n, i) {
		r.onDidDispose(() => {
			this._webviewView === r &&
				(this._logger.debug("Disposing of main panel webview view"), (this._webviewView = void 0))
		}),
			(this._webviewView = r),
			this._setViewTitle(this.currentApp?.title() || ""),
			this._mainPanelWebview?.dispose(),
			(this._mainPanelWebview = new kQ(this._webviewView.webview)),
			this.addDisposable(this._mainPanelWebview),
			this._mainPanelWebview.changeApp(this.currentApp),
			this._mainPanelWebview.addDisposable(
				this._webviewView.onDidChangeVisibility(() => {
					this.visibilityEventEmitter.fire(!!this._webviewView?.visible)
				}),
			),
			await this._mainPanelWebview.loadHTML(this._extensionUri)
	}
}
var FQ = class extends z {
	constructor(r, n, i) {
		super()
		this._config = r
		this._featureFlagsManager = n
		this.onWebviewCreated = i
		this.maybeRegisterWebview()
	}
	webviewView = void 0
	nextEditWebview = void 0
	maybeRegisterWebview = () => {
		!this.webviewView ||
			!Rl(this._config.config, this._featureFlagsManager.currentFlags.vscodeNextEditMinVersion) ||
			(this.nextEditWebview?.dispose(),
			(this.nextEditWebview = this.onWebviewCreated(this.webviewView)),
			this.addDisposable(this.nextEditWebview))
	}
	resolveWebviewView(r, n, i) {
		;(this.webviewView = r), this.maybeRegisterWebview()
	}
}
var C8 = class extends Error {
		constructor() {
			super("SingletonExecutor has been disposed")
		}
	},
	Ku = class e extends z {
		constructor(r) {
			super()
			this._execute = r
			this.addDisposable({ dispose: () => (this._stopping = !0) })
		}
		static _disposedError = new C8()
		_nextExecutionScheduled = !1
		_kickPromise = Promise.resolve()
		_stopping = !1
		kick() {
			return this._nextExecutionScheduled
				? this._kickPromise
				: ((this._nextExecutionScheduled = !0),
					(this._kickPromise = this._kickPromise.then(
						async () => (
							(this._nextExecutionScheduled = !1),
							this._stopping ? Promise.reject(e._disposedError) : this._execute()
						),
					)),
					this._kickPromise)
		}
	}
var QQ = class e {
	constructor(t) {
		this._workspaceStorage = t
		;(this._persistedFolders = this._readFolders()),
			(this._toPersist = new Map(this._persistedFolders)),
			(this._persister = new Ku(async () => await this._persistFolders()))
	}
	static storageKey = "external-source-folders:original"
	_persistedFolders
	_toPersist
	_persister
	getFolders() {
		return new Map(this._persistedFolders)
	}
	async setFolders(t) {
		O_e(this._persistedFolders, t) || ((this._toPersist = new Map(t)), await this._persister.kick())
	}
	async _persistFolders() {
		if (O_e(this._persistedFolders, this._toPersist)) return
		let t = new Map(this._toPersist),
			r = new Array()
		for (let [n, i] of t) r.push({ folderRoot: n, folderName: i })
		await this._workspaceStorage.update(e.storageKey, r), (this._persistedFolders = t)
	}
	_readFolders() {
		let t = this._workspaceStorage.get(e.storageKey)
		if (t === void 0) return new Map()
		if (!Array.isArray(t)) return new Map()
		let r = new Map()
		for (let n of t)
			n.folderRoot === void 0 ||
				typeof n.folderRoot != "string" ||
				n.folderName === void 0 ||
				typeof n.folderName != "string" ||
				r.set(n.folderRoot, n.folderName)
		return r
	}
}
function O_e(e, t) {
	if (e.size !== t.size) return !1
	for (let [r, n] of e) if (t.get(r) !== n) return !1
	return !0
}
var q_e = W(require("vscode"))
var NQ = class extends z {
	constructor(r, n) {
		super()
		this._globalState = r
		this._syncingStatus = n
		this.loadWorkspaceMessageState(),
			this.addDisposable(this._syncingStatus.onDidChangeSyncingStatus((i) => this._handleSyncingProgress()))
	}
	_workspaceMessageState = new Map()
	_shouldShowSummary = !1
	shouldShowSummaryEmitter = new q_e.EventEmitter()
	get shouldShowSummary() {
		return this._shouldShowSummary
	}
	get onShouldShowSummary() {
		return this.shouldShowSummaryEmitter.event
	}
	setShouldShowSummary(r) {
		this._shouldShowSummary = r
	}
	async _handleSyncingProgress() {
		let r = this._syncingStatus.status
		r.foldersProgress.length !== 0 && (await this.handleShowingSummaryMsg(r))
	}
	async handleShowingSummaryMsg(r) {
		if (
			!(
				r.status !== "done" ||
				r.foldersProgress.every((s) => s.progress?.trackedFiles === void 0 || s.progress.trackedFiles === 0) ||
				r.foldersProgress.find((s) => this._workspaceMessageState.get(s.folderRoot)?.workspaceSummary) ||
				!r.foldersProgress.find((s) => s.progress?.newlyTracked)
			)
		) {
			this.showSummaryMessage()
			for (let s of r.foldersProgress)
				this._workspaceMessageState.set(s.folderRoot, {
					folderRoot: s.folderRoot,
					workspaceSummary: !0,
				})
			await this.saveWorkspaceMessageState()
		}
	}
	showSummaryMessage() {
		;(this._shouldShowSummary = !0), this.shouldShowSummaryEmitter.fire(!0)
	}
	async saveWorkspaceMessageState() {
		await this._globalState.update("workspaceMessageStates", Array.from(this._workspaceMessageState.values()))
	}
	loadWorkspaceMessageState() {
		let r = this._globalState.get("workspaceMessageStates")
		r && (this._workspaceMessageState = new Map(r.map((n) => [n.folderRoot, n])))
	}
	dispose() {
		this.shouldShowSummaryEmitter.dispose()
	}
}
var LQ = W(require("vscode"))
var PQ = class extends z {
	constructor(r, n) {
		super()
		this._statusBar = r
		this.addDisposables(
			n((i) => this._handleSyncingStatusChanged(i)),
			new LQ.Disposable(() => {
				this._syncingStatusBarDisposable?.dispose(), (this._syncingStatusBarDisposable = void 0)
			}),
		)
	}
	static syncingMessage =
		"Augment is synchronizing with your codebase to make better suggestions. The first time typically takes a few minutes."
	_syncingStatusBarDisposable
	_syncingNotificationShown = !1
	_handleSyncingStatusChanged(r) {
		switch (r.status) {
			case "longRunning":
				this._syncingNotificationShown ||
					(r.foldersProgress.find((i) => i.progress?.newlyTracked) &&
						((this._syncingNotificationShown = !0), LQ.commands.executeCommand(Hi.commandID)))
			case "running":
				this._syncingStatusBarDisposable || (this._syncingStatusBarDisposable = this._statusBar.setState(Nxe))
				break
			case "done":
				;(this._syncingNotificationShown = !1),
					this._syncingStatusBarDisposable?.dispose(),
					(this._syncingStatusBarDisposable = void 0)
				break
		}
	}
}
var UQ = class extends z {
	constructor(r, n) {
		super()
		this._statusBarManager = r
		this._syncingEnabledTracker = n
		this.addDisposable(
			this._syncingEnabledTracker.onDidChangeSyncingEnabled((s) => this._updateSyncingState(s === "enabled")),
		)
		let i = this._syncingEnabledTracker.syncingEnabledState
		i !== "initializing" && this._updateSyncingState(i === "enabled")
	}
	_syncingDisabledDisp = void 0
	_updateSyncingState(r) {
		r
			? (this._syncingDisabledDisp?.dispose(), (this._syncingDisabledDisp = void 0))
			: this._syncingDisabledDisp || (this._syncingDisabledDisp = this._statusBarManager.setState(jxe))
	}
}
var qQ = W(require("vscode"))
var OQ = class extends z {
	_workspaceManager = void 0
	_syncingEnabledChangedEmitter = new qQ.EventEmitter()
	_publishStateExecutor
	constructor() {
		super(),
			(this._publishStateExecutor = new Ku(async () => {
				await this._publishSyncingState()
			}))
	}
	get syncingEnabledState() {
		return this._workspaceManager ? this._workspaceManager.syncingEnabledState : "initializing"
	}
	get onDidChangeSyncingEnabled() {
		return this._syncingEnabledChangedEmitter.event
	}
	enableSyncing() {
		if (this.syncingEnabledState === "initializing") throw new Error("Syncing enabled state not initialized")
		this.syncingEnabledState !== "enabled" && this._workspaceManager.enableSyncing()
	}
	disableSyncing() {
		if (this.syncingEnabledState === "initializing") throw new Error("Syncing enabled state not initialized")
		this.syncingEnabledState !== "disabled" && this._workspaceManager.disableSyncing()
	}
	set workspaceManager(t) {
		;(this._workspaceManager = t),
			this.addDisposable(
				this._workspaceManager.onDidChangeSyncingState((r) => void this._publishStateExecutor.kick()),
			)
	}
	async _publishSyncingState() {
		await qQ.commands.executeCommand("setContext", "vscode-augment.syncingEnabledState", this.syncingEnabledState),
			this._syncingEnabledChangedEmitter.fire(this.syncingEnabledState)
	}
}
var VQ = class e extends z {
	constructor(r) {
		super()
		this._workspaceStorage = r
		;(this._currentPermission = this._getStoredPermission()),
			(this._persister = new Ku(async () => await this._persistCurrentPermission())),
			this._logPermission("Initial syncing permission", this._currentPermission)
	}
	static storageKey = "syncingPermission.2024102300"
	_currentPermission
	_persister
	_logger = X("SyncingPermissionTracker")
	get syncingPermissionDenied() {
		return this._currentPermission?.state === 1
	}
	getFolderSyncingPermission(r) {
		let n = this._currentPermission
		if (n === void 0)
			return (
				this._logger.info(`Permission to sync folder ${r} unknown: no permission information recorded`),
				"unknown"
			)
		if (n.state === 1) {
			let i = new Date(n.timestamp).toLocaleString()
			return this._logger.info(`Permission to sync folder ${r} denied at ${i}`), "denied"
		}
		for (let i of n.permittedFolders)
			if (r === i.sourceFolder) {
				let s = new Date(i.timestamp).toLocaleString()
				return this._logger.info(`Permission to sync folder ${r} granted at ${s}; type = ${i.type}`), "granted"
			}
		return this._logger.info(`Permission to sync folder ${r} unknown: no current permission for folder`), "unknown"
	}
	setDefaultPermissions(r) {
		if (this._currentPermission !== void 0 || r.length === 0) return
		let n = Date.now()
		this._setSyncingPermission({
			state: 0,
			permittedFolders: r.map((i) => ({
				sourceFolder: i,
				type: "implicit",
				timestamp: n,
			})),
		})
	}
	setPermittedFolders(r) {
		let n = Date.now()
		this._setSyncingPermission({
			state: 0,
			permittedFolders: r.map((i) => ({
				sourceFolder: i,
				type: "explicit",
				timestamp: n,
			})),
		})
	}
	addPermittedFolder(r) {
		let n = this._currentPermission
		;(n === void 0 || n.state === 1) && (n = { state: 0, permittedFolders: [] })
		let i = { sourceFolder: r, type: "explicit", timestamp: Date.now() }
		this._setSyncingPermission({
			...n,
			permittedFolders: [...n.permittedFolders, i],
		})
	}
	addImplicitlyPermittedFolder(r) {
		let n = this._currentPermission
		if (n?.state === 1) return
		if (n === void 0) n = { state: 0, permittedFolders: [] }
		else if (n.permittedFolders.find((o) => o.sourceFolder === r) !== void 0) return
		let i = { sourceFolder: r, type: "implicit", timestamp: Date.now() }
		this._setSyncingPermission({
			...n,
			permittedFolders: [...n.permittedFolders, i],
		})
	}
	dropPermission(r) {
		if (r.length === 0 || this._currentPermission === void 0 || this._currentPermission.state === 1) return
		let n = this._currentPermission.permittedFolders.filter((i) => !r.includes(i.sourceFolder))
		this._setSyncingPermission({
			...this._currentPermission,
			permittedFolders: n,
		})
	}
	dropStaleFolders(r) {
		if (this._currentPermission === void 0 || this._currentPermission.state === 1) return
		let n = this._currentPermission.permittedFolders.filter((i) => r.includes(i.sourceFolder))
		this._setSyncingPermission({
			...this._currentPermission,
			permittedFolders: n,
		})
	}
	denyPermission() {
		this._setSyncingPermission({ state: 1, timestamp: Date.now() })
	}
	_getStoredPermission() {
		return this._workspaceStorage.get(e.storageKey)
	}
	_setSyncingPermission(r) {
		;(this._currentPermission = r), this._logPermission("Updating syncing permission", r), this._persister.kick()
	}
	async persistCurrentPermission() {
		await this._persister.kick()
	}
	async _persistCurrentPermission() {
		await this._workspaceStorage.update(e.storageKey, this._currentPermission)
	}
	_logPermission(r, n) {
		if (n === void 0) {
			this._logger.info(`${r}: undefined`)
			return
		}
		if (n.state === 1) {
			let s = new Date(n.timestamp).toLocaleString()
			this._logger.info(`${r}: syncing permission denied for workspace at ${s}`)
			return
		}
		let i =
			n.permittedFolders.length === 0
				? "none"
				: n.permittedFolders
						.map((s) => {
							let o = new Date(s.timestamp).toLocaleString()
							return `
    ${s.sourceFolder} (${s.type}) at ${o}`
						})
						.join("")
		this._logger.info(`${r}: syncing permission granted for workspace. Folders:${i}`)
	}
}
var V_e = W(require("vscode"))
var HQ = class extends z {
	constructor(r, n) {
		super()
		this._featureFlagManager = r
		this._workspaceManager = n
		this.addDisposable(this._workspaceManager.onDidChangeSourceFolders(() => this._handleSourceFoldersChanged())),
			this.addDisposable(
				this._workspaceManager.onDidChangeSyncingProgress((i) => this._handleSyncingProgressChanged(i)),
			),
			this._handleSourceFoldersChanged()
	}
	_newFolders = new Set()
	_folderBacklogSize = new Map()
	_folderTrackedFilesSize = new Map()
	_syncingStatusEmitter = new V_e.EventEmitter()
	_status = { status: "done", foldersProgress: [] }
	get status() {
		return this._status
	}
	get onDidChangeSyncingStatus() {
		return this._syncingStatusEmitter.event
	}
	_handleSourceFoldersChanged() {
		this._newFolders.clear(),
			this._folderBacklogSize.clear(),
			this._folderTrackedFilesSize.clear(),
			this._workspaceManager.getSyncingProgress().forEach((r) => this._updateFolderState(r)),
			this._reportSyncingStatus()
	}
	_handleSyncingProgressChanged(r) {
		this._updateFolderState(r), this._reportSyncingStatus()
	}
	_updateFolderState(r) {
		r.progress !== void 0 &&
			(r.progress.newlyTracked ? this._newFolders.add(r.folderRoot) : this._newFolders.delete(r.folderRoot),
			this._folderBacklogSize.set(r.folderRoot, r.progress.backlogSize),
			this._folderTrackedFilesSize.set(r.folderRoot, r.progress.trackedFiles))
	}
	_reportSyncingStatus() {
		let r = !1,
			n = 0,
			i = 0,
			s = this._featureFlagManager.currentFlags
		this._folderBacklogSize.forEach((a, l) => {
			a >= s.bigSyncThreshold && (r = !0), (n += a)
		}),
			this._folderTrackedFilesSize.forEach((a, l) => {
				i += a
			})
		let o = "done"
		r ? (o = "longRunning") : (n > s.smallSyncThreshold || n / i >= 0.1) && (o = "running"),
			(this._status = {
				status: o,
				foldersProgress: this._workspaceManager.getSyncingProgress(),
			}),
			this._syncingStatusEmitter.fire(this._status)
	}
}
var Ll = W(gs()),
	Ot = W(require("vscode"))
var v8 = class {
	async read(t) {
		try {
			return await Ak(t)
		} catch {
			return
		}
	}
	stat(t) {
		try {
			return Fh(t)
		} catch {
			return
		}
	}
}
function H_e() {
	return new v8()
}
var Syt = "file-edit-events.json",
	WQ = class {
		save(t) {
			return Promise.resolve()
		}
		load() {
			return Promise.resolve([])
		}
		clear() {}
	},
	GQ = class {
		_logger = X("FileEditEventsStore")
		_version = "1"
		_storeFile
		constructor(t) {
			this._logger.debug(`Using [${t.directory}] to store events`), (this._storeFile = $t(t.directory, Syt))
		}
		save(t) {
			this._logger.debug(`Saving ${t.length} events to ${this._storeFile}`),
				lme(this._storeFile, JSON.stringify({ version: this._version, events: t }))
		}
		async load() {
			this._logger.debug(`Loading events from ${this._storeFile}`)
			try {
				if (!Pn(this._storeFile))
					return this._logger.debug(`File ${this._storeFile} does not exist. Not loading events.`), []
				let t = await Fr(this._storeFile),
					r = JSON.parse(t)
				return r.version !== this._version
					? (this._logger.debug(
							`Version mismatch: ${r.version} !== ${this._version}. Not loading events from ${this._storeFile}`,
						),
						[])
					: (this._logger.debug(`Loaded ${r.events.length} events from ${this._storeFile}`), r.events)
			} catch (t) {
				return this._logger.debug(`Failed to load events from ${this._storeFile}`, t), []
			}
		}
		clear() {
			this.save([])
		}
	}
function W_e(e, t) {
	let r = Math.min(e.length, t.length),
		n = 1024,
		i = 0
	for (; i < r; ) {
		let s = e.slice(i, i + n),
			o = t.slice(i, i + n)
		if (s !== o) break
		if (s.length === 0) throw new Error(`unexpected empty block: s1=${e}, s2=${t}`)
		i += s.length
	}
	for (; i < r && e[i] === t[i]; ) i++
	return i
}
function G_e(e, t) {
	let r = Math.min(e.length, t.length),
		n = 1024,
		i = 0
	for (; i < r; ) {
		let a = e.slice(Math.max(0, e.length - i - n), e.length - i),
			l = t.slice(Math.max(0, t.length - i - n), t.length - i)
		if (a !== l) break
		if (a.length === 0) throw new Error(`unexpected empty block: s1=${e}, s2=${t}`)
		i += a.length
	}
	let s = e.length - 1,
		o = t.length - 1
	for (; i < r && e[s - i] === t[o - i]; ) i++
	return i
}
var Nl = class e {
	beforeStart
	afterStart
	beforeText
	afterText
	constructor(t) {
		;(this.beforeStart = t.beforeStart),
			(this.afterStart = t.afterStart),
			(this.beforeText = t.beforeText),
			(this.afterText = t.afterText)
	}
	static from(t) {
		return new e({
			beforeStart: t.beforeStart ?? 0,
			afterStart: t.afterStart ?? 0,
			beforeText: t.beforeText ?? "",
			afterText: t.afterText ?? "",
		})
	}
	get beforeEnd() {
		return this.beforeStart + this.beforeText.length
	}
	get afterEnd() {
		return this.afterStart + this.afterText.length
	}
	get beforeCRange() {
		return new bo(this.beforeStart, this.beforeEnd)
	}
	get afterCRange() {
		return new bo(this.afterStart, this.afterEnd)
	}
	toString() {
		return `SingleEdit{before=${this.beforeStart}:${this.beforeEnd}, after=${
			this.afterStart
		}:${this.afterEnd}, beforeText=${JSON.stringify(this.beforeText)}, afterText=${JSON.stringify(this.afterText)}}`
	}
	mergeNext(t) {
		if (t.afterText === "" && t.beforeStart >= this.afterStart && t.beforeEnd <= this.afterEnd) {
			let r =
				this.afterText.slice(0, t.beforeStart - this.afterStart) +
				this.afterText.slice(t.beforeEnd - this.afterStart)
			return new e({
				beforeStart: this.beforeStart,
				afterStart: this.afterStart,
				beforeText: this.beforeText,
				afterText: r,
			})
		} else {
			if (this.afterEnd === t.beforeStart)
				return new e({
					beforeStart: this.beforeStart,
					afterStart: this.afterStart,
					beforeText: this.beforeText + t.beforeText,
					afterText: this.afterText + t.afterText,
				})
			if (t.beforeEnd === this.afterStart)
				return new e({
					beforeStart: t.beforeStart,
					afterStart: t.afterStart,
					beforeText: t.beforeText + this.beforeText,
					afterText: t.afterText + this.afterText,
				})
		}
	}
	normalize() {
		let t = this.beforeStart,
			r = this.afterStart,
			n = this.beforeText,
			i = this.afterText,
			s = W_e(n, i)
		s > 0 && ((t += s), (r += s), (n = n.slice(s)), (i = i.slice(s)))
		let o = G_e(n, i)
		return (
			o > 0 && ((n = n.slice(0, -o)), (i = i.slice(0, -o))),
			new e({ beforeStart: t, afterStart: r, beforeText: n, afterText: i })
		)
	}
}
var og = class e {
	path
	beforeBlobName
	afterBlobName
	edits
	constructor(t) {
		;(this.path = t.path),
			(this.beforeBlobName = t.beforeBlobName),
			(this.afterBlobName = t.afterBlobName),
			(this.edits = t.edits)
	}
	static from(t) {
		return new e({
			path: t.path ?? "",
			beforeBlobName: t.beforeBlobName ?? "",
			afterBlobName: t.afterBlobName ?? "",
			edits: t.edits?.map((n) => Nl.from(n)) ?? [],
		})
	}
	changedChars() {
		return this.edits.reduce((t, r) => t + r.beforeText.length + r.afterText.length, 0)
	}
	isRepeatedChange() {
		if (this.edits.length <= 1) return !0
		let t = this.edits[0]
		return this.edits.every((r) => r.beforeText === t.beforeText && r.afterText === t.afterText)
	}
	mergeNext(t) {
		if (this.edits.length !== t.edits.length || this.path !== t.path || !t.isRepeatedChange()) return
		let r = [],
			n = 0,
			i = 0
		for (let s = 0; s < this.edits.length; s++) {
			let o = this.edits[s],
				a = o.mergeNext(t.edits[s])
			if (a === void 0) return
			r.push(
				new Nl({
					beforeStart: a.beforeStart + n,
					afterStart: a.afterStart + i,
					beforeText: a.beforeText,
					afterText: a.afterText,
				}),
			),
				(n += a.beforeText.length - o.beforeText.length),
				(i += a.afterText.length - o.afterText.length)
		}
		if (r.length >= 2) {
			let s = r.map((a) => a.beforeCRange)
			if (bo.anyOverlaps(s)) return
			let o = r.map((a) => a.afterCRange)
			if (bo.anyOverlaps(o)) return
		}
		return new e({
			path: this.path,
			beforeBlobName: this.beforeBlobName,
			afterBlobName: t.afterBlobName,
			edits: r,
		}).normalize()
	}
	normalize() {
		let t = this.edits
			.map((r) => r.normalize())
			.filter((r) => r.beforeText !== r.afterText)
			.sort((r, n) => r.beforeStart - n.beforeStart)
		return new e({
			path: this.path,
			beforeBlobName: this.beforeBlobName,
			afterBlobName: this.afterBlobName,
			edits: t,
		})
	}
	hasChange() {
		return this.edits.some((t) => t.beforeText !== t.afterText)
	}
}
var Y_e = W(E8())
var M_ = class {
	_events = new Y_e.default()
	_queueSizeChars = 0
	constructor() {}
	add(t) {
		return this._events.push(t), this._updateState(t, "ADDED")
	}
	_updateState(t, r) {
		return t === void 0
			? 0
			: (r === "ADDED"
					? (this._queueSizeChars += t.changedChars() ?? 0)
					: (this._queueSizeChars -= t.changedChars() ?? 0),
				t.changedChars() ?? 0)
	}
	removeOld() {
		let t = this._events.shift()
		return this._updateState(t, "REMOVED"), t
	}
	removeNew() {
		let t = this._events.pop()
		return this._updateState(t, "REMOVED"), t
	}
	newest() {
		if (this._events.length !== 0) return this.at(this._events.length - 1)
	}
	asArray() {
		return this._events.toArray()
	}
	get numEvents() {
		return this._events.length
	}
	get sizeChars() {
		return this._queueSizeChars
	}
	at(t) {
		return this._events.get(t)
	}
	removeAt(t) {
		let r = this._events.get(t)
		this._updateState(r, "REMOVED"), this._events.removeOne(t)
	}
	clear() {
		this._events.clear(), (this._queueSizeChars = 0)
	}
}
var xA = class {
	constructor(t, r = new M_()) {
		this.maxQueueSizeChars = t
		this._queue = r
	}
	addEvent(t, r) {
		let n = this._queue.newest(),
			i = n?.afterBlobName === r,
			s = 0,
			o = i ? void 0 : n?.mergeNext(t)
		if (o !== void 0) {
			let a = this._queue.removeNew()
			;(s -= a?.changedChars() ?? 0), o.hasChange() && (s += this._queue.add(o))
		} else s += this._queue.add(t)
		for (; this._queue.sizeChars > this.maxQueueSizeChars; ) this._queue.removeOld()
		return s
	}
	removeEventsForFile(t) {
		for (let r = this._queue.numEvents - 1; r >= 0; r--) {
			let n = this._queue.at(r)
			n !== void 0 && n.path === t && this._queue.removeAt(r)
		}
	}
	removeEventsPriorToBlob(t) {
		let r = null
		for (let n = this._queue.numEvents - 1; n >= 0; n--) {
			let i = this._queue.at(n)
			if (!r && i?.beforeBlobName === t) {
				r = i.path
				continue
			}
			r && i?.path === r && this._queue.removeAt(n)
		}
	}
	updatePath(t, r) {
		for (let n = 0; n < this._queue.numEvents; n++) {
			let i = this._queue.at(n)
			i !== void 0 && i.path === t && (i.path = r)
		}
	}
	getEvents() {
		return this._queue.asArray()
	}
	clear() {
		this._queue.clear()
	}
}
var b8 = ["file".toString(), "untitled".toString()]
var F_ = class extends z {
	constructor(r, n, i, s, o = 5e3) {
		super()
		this._folderName = r
		this._blobNameCalculator = n
		this._maxBlobSizeBytes = i
		this._store = s
		this.maxEventCharsToReturn = o
		;(this._logger = X(`FileEditEventsWatcher[${this._folderName}]`)),
			(this._eventsQueue = new xA(this.maxEventCharsToReturn * 2))
	}
	_eventsQueue
	_lastKnownText = new Map()
	_lastEventTimestamp = 0
	_logger
	_swapLastKnownText(r, n) {
		if (!this._lastKnownText.has(r)) throw new Error(`no known text for [${r}]`)
		let i = this._lastKnownText.get(r)
		return this._lastKnownText.set(r, n), i
	}
	_vscodeEventToFileEditEvent(r, n) {
		let i = n.document.getText(),
			s = this._swapLastKnownText(r, i),
			o = n.contentChanges.map(
				(a) =>
					new Nl({
						beforeStart: a.rangeOffset,
						afterStart: a.rangeOffset,
						beforeText: s.substring(a.rangeOffset, a.rangeOffset + a.rangeLength),
						afterText: a.text,
					}),
			)
		if (o.length > 1) {
			o.sort((l, c) => l.beforeStart - c.beforeStart)
			let a = 0
			o = o.map((l) => {
				let c = l.afterStart + a
				return (
					(a += l.afterText.length - l.beforeText.length),
					new Nl({
						beforeStart: l.beforeStart,
						afterStart: c,
						beforeText: l.beforeText,
						afterText: l.afterText,
					})
				)
			})
		}
		return new og({
			path: r,
			edits: o,
			beforeBlobName: this._blobNameCalculator.calculateNoThrow(r, s),
			afterBlobName: this._blobNameCalculator.calculateNoThrow(r, i),
		}).normalize()
	}
	handleChangedDocument(r) {
		let n = r.relPath,
			i = r.event
		if (!b8.includes(i.document.uri.scheme)) return
		if (i.document.getText().length > this._maxBlobSizeBytes) {
			this._logger.debug(`Ignoring event for ${n} because it is too large`)
			return
		}
		if (!this._lastKnownText.has(n)) {
			this._logger.debug(
				i.contentChanges.length > 0
					? `Last known text is not for the same file. Missing last known text for [${n}].  This is ok if we have recently cleared.`
					: `Updating last known text for ${n} - based on empty event`,
			),
				this._lastKnownText.set(n, i.document.getText())
			return
		}
		if (i.contentChanges.length === 0) {
			this._logger.verbose(`Ignoring event for ${n} - no content changes`)
			return
		}
		let s = this._vscodeEventToFileEditEvent(n, i)
		s.hasChange() && (this._eventsQueue.addEvent(s), (this._lastEventTimestamp = Date.now()))
	}
	get lastEventTimestamp() {
		return this._lastEventTimestamp
	}
	handleOpenedDocument(r) {
		if (b8.includes(r.document.uri.scheme)) {
			if (r.document.getText().length > this._maxBlobSizeBytes) {
				this._logger.debug(`Ignoring event for ${r.relPath} because it is too large`)
				return
			}
			this._logger.debug(`Adding last known text for ${r.relPath}. size before = ${this._lastKnownText.size}`),
				this._lastKnownText.set(r.relPath, r.document.getText())
		}
	}
	handleClosedDocument(r) {
		this._logger.debug(`Removing last known text for ${r.relPath}. size before = ${this._lastKnownText.size}`),
			this._lastKnownText.delete(r.relPath)
	}
	getEvents() {
		let r = [],
			n = 0,
			i = this._eventsQueue.getEvents()
		for (let s = i.length - 1; s >= 0; s--) {
			let o = i[s]
			if (n + o.changedChars() > this.maxEventCharsToReturn) break
			r.push(o), (n += o.changedChars())
		}
		return r.reverse(), r
	}
	handleFileDeleted(r) {
		this._logger.debug(`Deleting events for ${r.relPath}`),
			this._lastKnownText.delete(r.relPath),
			this._eventsQueue.removeEventsForFile(r.relPath)
	}
	_handleFileWillRename(r, n) {
		this._logger.debug(`Renaming events for file [${r}] to [${n}]`),
			this._lastKnownText.has(r) &&
				(this._lastKnownText.set(n, this._lastKnownText.get(r)), this._lastKnownText.delete(r)),
			this._eventsQueue.updatePath(r, n)
	}
	handleFileWillRename(r) {
		if (
			(this._logger.debug(`Renaming events for file/folder [${r.oldRelPath}] to [${r.newRelPath}]`),
			r.type === "File")
		)
			this._handleFileWillRename(r.oldRelPath, r.newRelPath)
		else if (r.type === "Directory") {
			for (let n of this._lastKnownText.keys())
				if (Ss(r.oldRelPath, n)) {
					let i = r.newRelPath + n.slice(r.oldRelPath.length)
					this._handleFileWillRename(n, i)
				}
		}
	}
	clear(r) {
		this._eventsQueue.clear(),
			r.clearLastKnown && this._lastKnownText.clear(),
			(this._lastEventTimestamp = 0),
			this._store.clear()
	}
	async loadEvents() {
		;(await this._store.load()).forEach((n) => this._eventsQueue.addEvent(og.from(n)))
	}
	dispose() {
		super.dispose(),
			this._store.save(this._eventsQueue.getEvents()),
			this._logger.debug("Disposing FileEditEventsWatcher")
	}
}
/**
 * Handles all the events related to file edits, and stores them in a
 * FileEditEventsWatcher per folder.
 *
 * This class is responsible for:
 * - Listening to events for text documents, file deletions, and file renames
 * - Creating a FileEditEventsWatcher for each folder that is being tracked
 * - Storing the events in the FileEditEventsWatcher
 * - Returning the events for a given folder
 * - Clearing all the events for a given folder
 * - Disposing of all the FileEditEventsWatcher objects
 */
var Q_ = class extends z {
	constructor(r, n, i, s, o, a, l, c, u = 5e3) {
		super()
		this._blobNameCalculator = r
		this._maxBlobSizeBytes = n
		this._onFolderTextDocumentChanged = i
		this._onFolderTextDocumentOpened = s
		this._onFolderTextDocumentClosed = o
		this._onFolderFileDeleted = a
		this._onFolderFileWillRename = l
		this._debugFeaturesEnabled = c
		this._maxEventCharsToReturn = u
	}
	_watcher = new Map()
	_logger = X("FileEditManager")
	listenToEvents() {
		this._logger.debug("Listening to events"),
			this.addDisposable(this._onFolderTextDocumentChanged((r) => this._handleTextDocumentChanged(r))),
			this.addDisposable(this._onFolderTextDocumentOpened((r) => this._handleTextDocumentOpened(r))),
			this.addDisposable(this._onFolderTextDocumentClosed((r) => this._handleTextDocumentClosed(r))),
			this.addDisposable(this._onFolderFileDeleted((r) => this._handleFileDeleted(r))),
			this.addDisposable(this._onFolderFileWillRename((r) => this._handleFileWillRename(r))),
			this.addDisposable(
				sQ((r) => {
					this._logger.debug(`Stash changed for repo ${r.repoId}`),
						this._watcher.get(r.repoId)?.clear({ clearLastKnown: !0 })
				}),
			),
			this.addDisposable(
				vA((r) => {
					this._logger.debug(`Head changed for repo ${r.repoId}`),
						this._watcher.get(r.repoId)?.clear({ clearLastKnown: !0 })
				}),
			)
	}
	_handleTextDocumentChanged(r) {
		let n = this._watcher.get(r.folderId)
		n && n.handleChangedDocument(r)
	}
	_handleTextDocumentOpened(r) {
		let n = this._watcher.get(r.folderId)
		n && n.handleOpenedDocument(r)
	}
	_handleTextDocumentClosed(r) {
		let n = this._watcher.get(r.folderId)
		n && n.handleClosedDocument(r)
	}
	_handleFileDeleted(r) {
		let n = this._watcher.get(r.folderId)
		n && n.handleFileDeleted(r)
	}
	_handleFileWillRename(r) {
		let n = this._watcher.get(r.folderId)
		n && n.handleFileWillRename(r)
	}
	findFolderIdWithMostRecentChanges() {
		let r,
			n = -1,
			i = -1
		for (let [s, o] of this._watcher) o.lastEventTimestamp > n && ((r = o), (n = o.lastEventTimestamp), (i = s))
		return r === void 0 ? -1 : i
	}
	findEventsForFolder(r) {
		let n = this._watcher.get(r)
		return n === void 0 ? [] : n.getEvents()
	}
	addInitialDocument(r) {
		this._handleTextDocumentOpened(r)
	}
	startTracking(r, n, i) {
		this._logger.debug(`Tracking folder ${r} with store at ${i.directory}`)
		let s = new F_(
			n,
			this._blobNameCalculator,
			this._maxBlobSizeBytes,
			this._debugFeaturesEnabled ? new GQ(i) : new WQ(),
			this._maxEventCharsToReturn,
		)
		return this._watcher.set(r, s), s.loadEvents(), s
	}
	clearAll(r) {
		this._watcher.forEach((n) => n.clear(r))
	}
	dispose() {
		super.dispose(), this._logger.debug("Disposing FileEditManager"), this._watcher.forEach((r) => r.dispose())
	}
}
var P_ = W(require("vscode")),
	k8 = W(nwe())
var N_ = class {
		accepted = !0
	},
	ag = class {
		accepted = !1
	}
var lg = class extends N_ {
		explicit = !1
		format() {
			return "Tracked"
		}
	},
	B8 = class extends N_ {
		constructor(r) {
			super()
			this.ignoreSourceName = r
		}
		explicit = !0
		format() {
			return `Tracked (${this.ignoreSourceName})`
		}
	},
	D8 = class extends ag {
		constructor(r) {
			super()
			this.ignoreSourceName = r
		}
		explicit = !0
		format() {
			return `Not tracked (${this.ignoreSourceName})`
		}
	},
	YQ = class {
		constructor(t, r, n, i) {
			this.dirName = t
			this.ignoreSource = r
			this.rules = n
			this.next = i
		}
	},
	T8 = class e {
		constructor(t, r, n) {
			this._rootUri = t
			this._ignoreSource = r
			this._top = n
		}
		static async buildNew(t, r, n) {
			let i = new Array()
			if (Yd(n, r) !== "") {
				let o = r
				for (;;) {
					o = _x(o)
					let a = Yd(n, o),
						l = await t.getRules(o)
					if ((l && i.push([a, t, l]), a === "")) break
				}
			}
			let s
			for (let o = i.length - 1; o >= 0; o--) {
				let [a, l, c] = i[o]
				s = new YQ(a, l, c, s)
			}
			return new e(n, t, s)
		}
		async buildAtop(t, r) {
			let n = await this._ignoreSource.getRules(t, r)
			if (n === void 0) return this
			let i = Yd(this._rootUri, t),
				s = new YQ(i, this._ignoreSource, n, this._top)
			return new e(this._rootUri, this._ignoreSource, s)
		}
		getPathInfo(t) {
			for (let r = this._top; r !== void 0; r = r.next) {
				if (!Ss(r.dirName, t))
					throw new Error(`candidatePath "${t}" is not below ignore file's parent "${r.dirName}"`)
				let n = t.slice(r.dirName.length),
					i = r.rules.test(n)
				if (i.ignored) return new D8(r.ignoreSource.getName(P_.Uri.joinPath(this._rootUri, r.dirName)))
				if (i.unignored) return new B8(r.ignoreSource.getName(P_.Uri.joinPath(this._rootUri, r.dirName)))
			}
			return new lg()
		}
	},
	R8 = class e {
		constructor(t, r) {
			this._ignoreSources = t
			this._ignoreStacks = r
		}
		static async buildNew(t, r, n) {
			let i = new Array()
			for (let s of t) {
				let o = await T8.buildNew(s, r, n)
				i.push(o)
			}
			return new e(t, i)
		}
		async buildAtop(t, r) {
			let n = new Array(),
				i = 0
			for (let s = 0; s < this._ignoreStacks.length; s++) {
				let o = this._ignoreStacks[s],
					a = await o.buildAtop(t, r)
				a !== o && i++, n.push(a)
			}
			return i === 0 ? this : new e(this._ignoreSources, n)
		}
		getPathInfo(t) {
			for (let r = this._ignoreStacks.length - 1; r >= 0; r--) {
				let i = this._ignoreStacks[r].getPathInfo(t)
				if (i.explicit) return i
			}
			return new lg()
		}
	}
async function Gyt(e, t) {
	let r = P_.Uri.joinPath(e, t)
	try {
		let n = await Fr(r.fsPath),
			i = (0, k8.default)({ ignorecase: !1 })
		return i.add(n), i
	} catch {}
}
var QC = class {
		constructor(t = []) {
			this._ignoreSources = t
		}
		async build(t, r) {
			return await R8.buildNew(this._ignoreSources, t, r)
		}
	},
	L_ = class {
		constructor(t) {
			this.filename = t
		}
		getName(t) {
			return z1(P_.Uri.joinPath(t, this.filename))
		}
		async getRules(t, r) {
			if (!(r !== void 0 && !(r.find(([i, s]) => s === "File" && this.filename === i) !== void 0)))
				return Gyt(t, this.filename)
		}
	},
	KQ = class {
		constructor(t) {
			this._sourceFolderRootPath = t
		}
		getName() {
			return "default Augment rules"
		}
		getRules(t) {
			return new Promise((r) => {
				if (as(t) !== this._sourceFolderRootPath) r(void 0)
				else {
					let n = (0, k8.default)({ ignorecase: !1 })
					n.add([
						".git",
						"*.pem",
						"*.key",
						"*.pfx",
						"*.p12",
						"*.jks",
						"*.keystore",
						"*.pkcs12",
						"*.crt",
						"*.cer",
						"id_rsa",
						"id_ed25519",
						"id_ecdsa",
						"id_dsa",
						".augment-guidelines",
						".env",
					]),
						r(n)
				}
			})
		}
	}
var JQ = class {
		constructor(t) {
			this.name = t
		}
		start = Date.now()
		increments = []
		charge(t) {
			this.increments.push({ name: t, end: Date.now() })
		}
		*[Symbol.iterator]() {
			let t = this.start
			for (let { name: r, end: n } of this.increments) yield [r, n - t], (t = n)
			yield ["total", t - this.start]
		}
		format() {
			return (
				(this.name
					? `${this.name}:
`
					: "") +
				Array.from(this).map(([r, n]) => `  - ${r}: ${n} ms`).join(`
`)
			)
		}
	},
	zQ = class {
		_value = 0
		_add(t = 1) {
			this._value += t
		}
		_invalidate() {
			this._value = Number.NaN
		}
		get value() {
			return this._value
		}
	},
	M8 = class extends zQ {
		increment(t = 1) {
			this._add(t)
		}
	},
	F8 = class extends zQ {
		_start = void 0
		start() {
			this._start = Date.now()
		}
		stop() {
			this._start === void 0 ? this._invalidate() : this._add(Date.now() - this._start)
		}
	},
	NC = class {
		constructor(t) {
			this.name = t
		}
		counters = new Map()
		timings = new Map()
		counterMetric(t) {
			let r = this.counters.get(t)
			return r === void 0 && ((r = new M8()), this.counters.set(t, r)), r
		}
		timingMetric(t) {
			let r = this.timings.get(t)
			return r === void 0 && ((r = new F8()), this.timings.set(t, r)), r
		}
		format() {
			let t = this.name ? `${this.name}:` : "",
				r = Array.from(this.counters.entries()).map(([s, o]) => `  - ${s}: ${o.value}`).join(`
`),
				n = "  - timing stats:",
				i = Array.from(this.timings.entries()).map(([s, o]) => `    - ${s}: ${o.value} ms`).join(`
`)
			return (
				t +
				`
` +
				r +
				`
` +
				n +
				`
` +
				i
			)
		}
	}
var iwe = W(require("os"))
function swe(e) {
	let t = iwe.default.homedir()
	return Iy(e, t)
}
var U_ = W(require("path")),
	L8 = W(require("vscode"))
async function ZQ(e, t, r, n) {
	let i = await r.build(e, t),
		s = new Map()
	s.set("", i), s.set(".", i)
	let o = 200,
		a = Date.now(),
		l = []
	l.push([e, i])
	let c
	for (; (c = l.pop()) !== void 0; ) {
		Date.now() - a >= o && (await new Promise((C) => setTimeout(C, 0)), (a = Date.now()))
		let [f, p] = c,
			g = Yd(t, f),
			m = bx(f.fsPath),
			y = await p.buildAtop(f, m)
		y !== p && s.set(g, y)
		for (let [C, v] of m) {
			if (
				(Date.now() - a >= o && (await new Promise((Q) => setTimeout(Q, 0)), (a = Date.now())),
				C === "." || C === ".." || v !== "Directory")
			)
				continue
			let w = L8.Uri.joinPath(f, C),
				B = $t(g, C, !0)
			y.getPathInfo(B).accepted && l.push([w, y])
		}
	}
	return new N8(s, n)
}
var PC = class {
		constructor(t, r, n, i) {
			this._name = t
			this._startUri = r
			this._rootUri = n
			this._pathFilter = i
			if (!U_.isAbsolute(r.fsPath))
				throw new Error(`PathIterator[${this._name}]: startUri ${this._name} must contain an absolute pathname`)
			if (!U_.isAbsolute(n.fsPath))
				throw new Error(
					`PathIterator[${this._name}]: rootUri ${n.toString()} must contain an absolute pathname`,
				)
			if (!Ss(as(n), as(r)))
				throw new Error(
					`PathIterator[${this._name}]: startUri ${as(
						this._startUri,
					)} must be inside rootUri ${as(this._rootUri)}`,
				)
			this._logger.verbose(
				`Created PathIterator for startUri ${this._startUri.fsPath}, rootUri ${this._rootUri.fsPath}`,
			)
		}
		stats = new NC("Path metrics")
		_logger = X("PathIterator")
		_dirsEmitted = this.stats.counterMetric("directories emitted")
		_filesEmitted = this.stats.counterMetric("files emitted")
		_otherEmitted = this.stats.counterMetric("other paths emitted")
		_totalEmitted = this.stats.counterMetric("total paths emitted")
		_readDirMs = this.stats.timingMetric("readDir")
		_filterMs = this.stats.timingMetric("filter")
		_yieldMs = this.stats.timingMetric("yield")
		_totalMs = this.stats.timingMetric("total")
		async *[Symbol.asyncIterator]() {
			this._totalMs.start()
			let t = 200,
				r = Date.now(),
				n = new Array()
			n.push(this._startUri)
			let i
			for (; (i = n.pop()) !== void 0; ) {
				Date.now() - r >= t && (await new Promise((c) => setTimeout(c, 0)), (r = Date.now()))
				let o = Yd(this._rootUri, i),
					a = this._pathFilter.makeLocalPathFilter(o)
				this._readDirMs.start()
				let l = bx(i.fsPath)
				this._readDirMs.stop()
				for (let [c, u] of l) {
					if (
						(Date.now() - r >= t && (await new Promise((C) => setTimeout(C, 0)), (r = Date.now())),
						c === "." || c === "..")
					)
						continue
					this._filterMs.start()
					let p = L8.Uri.joinPath(i, c),
						g = $t(o, c, u === "Directory"),
						m = a.getPathInfo(g, u)
					this._filterMs.stop()
					let y = g
					u === "File"
						? this._filesEmitted.increment()
						: u === "Directory"
							? ((y = wy(g)), this._dirsEmitted.increment())
							: this._otherEmitted.increment(),
						this._totalEmitted.increment(),
						this._yieldMs.start(),
						yield [p, y, u, m],
						this._yieldMs.stop(),
						u === "Directory" && m.accepted && n.push(p)
				}
			}
			this._totalMs.stop()
		}
	},
	Q8 = class extends ag {
		constructor(r) {
			super()
			this.extension = r
		}
		format() {
			return `Unsupported file extension (${this.extension})`
		}
	},
	jQ = class {
		_fileExtensions
		constructor(t) {
			if (t) {
				this._fileExtensions = new Set()
				for (let r of t) this._fileExtensions.add(r.toLowerCase())
			} else this._fileExtensions = void 0
		}
		acceptsPath(t, r = "File") {
			return this.getPathInfo(t, r).accepted
		}
		getPathInfo(t, r = "File") {
			if (r === "File") {
				let i = U_.extname(t)
				if (this._fileExtensions !== void 0 && !this._fileExtensions.has(i.toLowerCase())) return new Q8(i)
			} else r === "Directory" && !t.endsWith("/") && (t += "/")
			let n = this._getIgnoreStack(_c(t))
			return n === void 0 ? new lg() : n.getPathInfo(t)
		}
	},
	N8 = class extends jQ {
		constructor(r, n) {
			super(n)
			this._ignorePathMap = r
		}
		makeLocalPathFilter(r) {
			let n = this._getIgnoreStack(r)
			return new P8(n, this._fileExtensions)
		}
		_getIgnoreStack(r) {
			if (Qh(r)) throw new Error(`Absolute path ${r} passed to PathFilter`)
			let n = r
			for (let i = 0; i < 1e4; i++) {
				let s = this._ignorePathMap.get(n)
				if (s) return s
				if (_c(n) === n) return
				n = _c(n)
			}
			throw new Error(`Too-deep or malformed directory name ${r}`)
		}
	},
	P8 = class extends jQ {
		constructor(r, n) {
			super(n)
			this._ignoreStack = r
		}
		_getIgnoreStack(r) {
			return this._ignoreStack
		}
	}
var XQ = class e {
	static defaultStartSeq = 1e4
	_next
	constructor(t = e.defaultStartSeq) {
		this._next = t
	}
	next() {
		return this._next++
	}
}
var eN = class {
	constructor(t, r = Eo) {
		this.root = t
		this.commandExecutor = r
	}
	async version() {
		return await this.commandExecutor("git --version")
	}
	async diff(t) {
		let r = ["git", "diff"]
		t.nameStatus && r.push("--name-status"),
			t.hash1 && r.push(t.hash1),
			t.hash2 && r.push(t.hash2),
			t.relPath && (r.push("--"), r.push(t.relPath))
		let n = r.join(" ")
		return await this.commandExecutor(n, { cwd: this.root.fsPath })
	}
	async lsFiles(t) {
		let r = ["git", "ls-files"]
		t.others && r.push("--others"),
			t.excludeStandard && r.push("--exclude-standard"),
			t.relPath && (r.push("--"), r.push(t.relPath))
		let n = r.join(" ")
		return await this.commandExecutor(n, { cwd: this.root.fsPath })
	}
	async show(t) {
		let r = ["git", "show"]
		t.nameStatus && r.push("--name-status"), t.oneLine && r.push("--oneline"), t.object && r.push(`"${t.object}"`)
		let n = r.join(" ")
		return await this.commandExecutor(n, { cwd: this.root.fsPath })
	}
	async symbolicRef(t) {
		let r = ["git", "symbolic-ref"]
		t.name && r.push(t.name)
		let n = r.join(" ")
		return await this.commandExecutor(n, { cwd: this.root.fsPath })
	}
	async log(t) {
		let r = ["git", "log"]
		t.commit1 && r.push(t.commit1),
			t.commit2 && r.push(t.commit2),
			t.noMerges && r.push("--no-merges"),
			t.format && r.push(`--format="${t.format}"`),
			t.not && r.push(`--not "${t.not}"`)
		let n = r.join(" ")
		return await this.commandExecutor(n, { cwd: this.root.fsPath })
	}
}
var _A = {}
z2(_A, {
	BlobNameRetrieverImpl: () => U8,
	FileChangeWatcherImpl: () => O8,
	FileUploaderImpl: () => q8,
	FileUtilsImpl: () => V8,
	HeadChangeWatcher: () => S_,
	onDidChange: () => vA,
})
var owe = W(require("vscode"))
var U8 = class {
	constructor(t, r, n) {
		this._rootPath = t
		this._workspaceManager = r
		this._blobNameCalculator = n
	}
	async getBufferBlobName(t) {
		let r = owe.Uri.file($t(this._rootPath, t)),
			i = (await ho(r)).getText()
		return this._blobNameCalculator.calculate(t, i)
	}
	getIndexedBlobName(t) {
		return this._workspaceManager.getBlobName(new Je(this._rootPath, t))
	}
}
var tN = require("vscode")
var O8 = class {
	constructor(t, r) {
		this._rootPath = t
		this.onDidChangeFile = r
	}
	async _getOpenTabs() {
		let t = []
		for (let r of tN.window.tabGroups.all)
			for (let n of r.tabs) {
				let i = n.input
				if (!ek(i, "uri")) continue
				let s = i.uri
				if (!(await ome(s.fsPath))) continue
				let a = null
				try {
					a = await tN.workspace.openTextDocument(s)
				} catch {
					continue
				}
				let l = a.isDirty
				t.push({ label: n.label, uri: s, isDirty: l })
			}
		return t
	}
	async getPathsWithBufferChanges() {
		let r = (await this._getOpenTabs()).filter((i) => i.isDirty && Ss(this._rootPath.fsPath, i.uri.fsPath)),
			n = []
		for (let i of r) {
			let s = Nh(this._rootPath.fsPath, i.uri.fsPath)
			s !== void 0 && n.push(s)
		}
		return n
	}
}
var awe = require("vscode")
var q8 = class extends z {
	constructor(r, n) {
		super()
		this._blobNameCalculator = r
		this._apiServer = n
		;(this._uploadQueue = new Ia(async (i) => {
			i !== void 0 && (await this._processUpload(i))
		})),
			this.addDisposable(this._uploadQueue)
	}
	_emitter = new awe.EventEmitter()
	_uploadQueue
	_logger = X("FileUploaderImpl")
	get onDidChange() {
		return this._emitter.event
	}
	upload(r, n) {
		let i = this._blobNameCalculator.calculate(r, n)
		if (i === void 0) throw new Error(`blobNameCalculator returned undefined for ${r}`)
		return (
			this._uploadQueue.insert({ path: r, content: n, blobName: i }), this._uploadQueue.kick(), Promise.resolve(i)
		)
	}
	async _processUpload(r) {
		try {
			this._logger.debug(`Upload started: path [${r.path}] with blob name [${r.blobName}]`),
				await this._apiServer.batchUpload([
					{
						pathName: r.path,
						text: r.content,
						blobName: r.blobName,
						metadata: [],
					},
				]),
				this._logger.debug(`Upload complete: path [${r.path}] with blob name [${r.blobName}]`)
		} catch (n) {
			this._logger.debug(`Failed upload for [${r.path}]. Caused by: ${n.stack}.`)
		}
	}
}
var V8 = class {
	constructor(t) {
		this._pathFilter = t
	}
	isUploadable(t) {
		return this._pathFilter.acceptsPath(t)
	}
}
var H8 = W(require("vscode"))
var lwe = ((i) => ((i.added = "A"), (i.deleted = "D"), (i.modified = "M"), (i.renamed = "R"), i))(lwe || {}),
	$yt = Object.freeze({
		A: "ADDED",
		D: "DELETED",
		M: "MODIFIED",
		R: "RENAMED",
	}),
	Yyt = new RegExp("^R\\d{3}$"),
	Kyt = `
`,
	Jyt = "	"
function zyt(e, t) {
	for (let r in e) if (e[r] === t) return e[r]
}
function jyt(e) {
	let r = Yyt.test(e) ? "R" : zyt(lwe, e)
	if (!r) throw new Error(`Unknown diff change type [${e}]`)
	return r
}
function Zyt(e) {
	return $yt[jyt(e)]
}
function Xyt(e, t, r) {
	return { ADDED: void 0, DELETED: e, MODIFIED: e, RENAMED: e }[r]
}
function eCt(e, t, r) {
	return { ADDED: e, DELETED: void 0, MODIFIED: e, RENAMED: t }[r]
}
function rN(e) {
	let t = [],
		r = e.split(Kyt)
	for (let n of r) {
		if (!n || n.trim().length === 0) continue
		let [i, s, o] = n.split(Jyt),
			a = Zyt(i),
			l = { beforePath: Xyt(s, o, a), afterPath: eCt(s, o, a), changeType: a }
		t.push(l)
	}
	return t
}
var nN = class {
	constructor(t) {
		this._git = t
	}
	async getWorkingDirectoryChanges() {
		let t = `
`,
			r = [],
			n = new Set(),
			i = await this._git.diff({ hash1: "HEAD", nameStatus: !0 })
		if (i) {
			r = rN(i)
			for (let o of r.slice(0, 50)) o.afterPath !== void 0 && n.add(o.afterPath)
		}
		let s = await this._git.lsFiles({ others: !0, excludeStandard: !0 })
		if (s) {
			let o = s
				.split(t)
				.filter((a) => a.trim().length > 0 && !n.has(a))
				.map((a) => ({
					afterPath: a,
					beforePath: void 0,
					changeType: "ADDED",
				}))
			r = r.concat(o)
		}
		return r
	}
	async _getDefaultBranch() {
		let t = "refs/remotes/origin",
			r = await this._git.symbolicRef({ name: `${t}/HEAD` })
		if (r) return r.trim().replace(t + "/", "")
	}
	async _getCommitHashes() {
		let t = "%H",
			r = `
`,
			n = await this._getDefaultBranch()
		return (
			(
				await this._git.log({
					commit1: n,
					commit2: "HEAD",
					noMerges: !0,
					format: t,
					not: n,
				})
			)?.split(r) ?? []
		)
	}
	async getCommitChanges() {
		let t = `
`,
			r = {},
			n = await this._getCommitHashes()
		for (let i of n) {
			let s = await this._git.show({ object: i, nameStatus: !0, oneLine: !0 }),
				o = s?.slice(s.indexOf(t) + 1)
			if (o == null) throw new Error(`Could not get commit changes for commit ${i}`)
			let a = rN(o)
			r[i] = a
		}
		return r
	}
	async getFileWorkingDirectoryChange(t) {
		let r = await this._git.diff({ hash1: "HEAD", nameStatus: !0, relPath: t })
		if (r) {
			let i = rN(r)
			if (i.length > 0) return i[0]
		}
		if ((await this._git.lsFiles({ others: !0, excludeStandard: !0, relPath: t }))?.trim() === t)
			return { afterPath: t, beforePath: void 0, changeType: "ADDED" }
	}
	async getFileContentForCommit(t, r) {
		let n = await this._git.show({ object: `${r}:${t}` })
		if (n === void 0) throw new Error(`Could not find file ${t} in commit ${r}`)
		return n
	}
	async getFileContentBeforeCommit(t, r) {
		return this.getFileContentForCommit(t, `${r}^`)
	}
}
var cwe = W(gs())
var iN = class extends z {
	constructor(r, n, i, s, o, a, l) {
		super()
		this._workspaceName = r
		this._vcs = n
		this._fileUtils = i
		this._fileUploader = s
		this._fileChangeWatcher = o
		this._blobNameRetriever = a
		this._configListener = l
		;(this._logger = X(`VCSRepoWatcher[${r}]`)),
			(this._changes = { commits: [], workingDirectory: [] }),
			this.addDisposable(s.onDidChange((c) => this.handleFileUploaded(c))),
			this.addDisposable(o.onDidChangeFile((c) => this.handleFileChange(c)))
	}
	_changes
	_workingDirectoryTrackedPaths = new Set()
	_trackedBlobs = new Map()
	_logger
	async _uploadFile(r) {
		let n = await r.readContent(),
			i = await this._fileUploader.upload(r.path, n)
		return this._trackedBlobs.set(i, r), i
	}
	_clear() {
		;(this._changes = { commits: [], workingDirectory: [] }),
			this._workingDirectoryTrackedPaths.clear(),
			this._trackedBlobs.clear()
	}
	async handleHeadChange() {
		this._logger.debug("Handling head changes"), this._clear()
		try {
			let i = await this.collectCommitChanges()
			this._changes.commits = i
		} catch (i) {
			this._logger.error("Error collecting commit changes", i)
		}
		let r = await this.collectWorkingDirectoryChanges(),
			n = await this.collectBufferChanges()
		this._changes.workingDirectory = r.concat(n)
	}
	handleFileUploaded(r) {
		throw new Error("Method not implemented.")
	}
	async handleFileChange(r) {
		if (
			(this._logger.debug(`Handling file change [${r.relPath}]`),
			r.origin === "buffer" && this._workingDirectoryTrackedPaths.has(r.relPath))
		)
			return
		r.origin === "disk" &&
			(this._changes.workingDirectory = this._changes.workingDirectory.filter((s) => s.afterPath !== r.relPath)),
			this._workingDirectoryTrackedPaths.add(r.relPath)
		let n
		if (r.origin === "disk") n = await this._vcs.getFileWorkingDirectoryChange(r.relPath)
		else if (r.origin === "buffer")
			n = {
				afterPath: r.relPath,
				beforePath: r.relPath,
				changeType: "MODIFIED",
			}
		else {
			this._logger.debug(`Unknown file change origin ${JSON.stringify(r)}`)
			return
		}
		if (!n) {
			this._changes.workingDirectory = this._changes.workingDirectory.filter((s) => {
				let o = s.changeType === "RENAMED" && s.afterPath === r.relPath,
					a = s.changeType === "DELETED" && s.beforePath === r.relPath,
					l = s.changeType === "ADDED" && s.afterPath === r.relPath
				return !o && !a && !l
			})
			return
		}
		let i = { changeType: n.changeType }
		n.beforePath && (i.beforePath = n.beforePath),
			n.afterPath && (i.afterPath = n.afterPath),
			["DELETED", "MODIFIED", "RENAMED"].includes(n.changeType) &&
				(i.headBlobName = await this._uploadFile({
					path: n.afterPath,
					readContent: () => this._vcs.getFileContentForCommit(n.beforePath, "HEAD"),
				})),
			"RENAMED".includes(n.changeType) &&
				(this._changes.workingDirectory = this._changes.workingDirectory.filter(
					(s) => s.afterPath !== n.beforePath,
				)),
			this._changes.workingDirectory.push(i)
	}
	async collectCommitChanges() {
		let r = []
		this._logger.debug("Collecting disk changes")
		let n = await this._vcs.getCommitChanges()
		for (let i in n) {
			let s = { hash: i, files: [] }
			for (let o of n[i]) {
				let a = { changeType: o.changeType }
				if (o.afterPath !== void 0) {
					if (!this._fileUtils.isUploadable(o.afterPath)) continue
					;(a.afterPath = o.afterPath),
						(a.afterBlobName = await this._uploadFile({
							path: o.afterPath,
							readContent: () => this._vcs.getFileContentForCommit(o.afterPath, i),
						}))
				}
				if (o.beforePath !== void 0) {
					if (!this._fileUtils.isUploadable(o.beforePath)) continue
					;(a.beforePath = o.beforePath),
						(a.beforeBlobName = await this._uploadFile({
							path: o.beforePath,
							readContent: () => this._vcs.getFileContentBeforeCommit(o.beforePath, i),
						}))
				}
				s.files.push(a)
			}
			r.push(s)
		}
		return r
	}
	async collectWorkingDirectoryChanges() {
		let r = [],
			n = await this._vcs.getWorkingDirectoryChanges()
		for (let i of n) {
			;["ADDED", "MODIFIED"].includes(i.changeType) && this._workingDirectoryTrackedPaths.add(i.afterPath)
			let s = { changeType: i.changeType }
			if (i.afterPath !== void 0) {
				if (!this._fileUtils.isUploadable(i.afterPath)) continue
				s.afterPath = i.afterPath
			}
			if (i.beforePath !== void 0) {
				if (!this._fileUtils.isUploadable(i.beforePath)) continue
				;(s.beforePath = i.beforePath),
					(s.headBlobName = await this._uploadFile({
						path: i.beforePath,
						readContent: () => this._vcs.getFileContentForCommit(i.beforePath, "HEAD"),
					}))
			}
			r.push(s)
		}
		return r
	}
	async collectBufferChanges() {
		let r = [],
			n = await this._fileChangeWatcher.getPathsWithBufferChanges()
		for (let i of n) {
			if (!this._fileUtils.isUploadable(i) || this._workingDirectoryTrackedPaths.has(i)) continue
			this._workingDirectoryTrackedPaths.add(i)
			let s = { changeType: "MODIFIED", afterPath: i, beforePath: i }
			;(s.headBlobName = await this._uploadFile({
				path: i,
				readContent: () => this._vcs.getFileContentForCommit(i, "HEAD"),
			})),
				r.push(s)
		}
		return r
	}
	async getChanges() {
		let r = (0, cwe.cloneDeep)(this._changes),
			n = []
		for (let i of r.workingDirectory.slice(-50)) {
			if (!i.afterPath) {
				n.push(i)
				continue
			}
			;(i.indexedBlobName = this._blobNameRetriever.getIndexedBlobName(i.afterPath)),
				i.indexedBlobName !== void 0 &&
					((i.currentBlobName = await this._blobNameRetriever.getBufferBlobName(i.afterPath)), n.push(i))
		}
		return (r.workingDirectory = n), r
	}
	handleUnknownBlobs(r) {
		for (let n of r) {
			let i = this._trackedBlobs.get(n)
			i !== void 0 && this._uploadFile(i)
		}
	}
}
var sN = class {
	constructor(t, r) {
		this._fileUploader = t
		this.configListener = r
	}
	_repoWatchers = new Map()
	_disposables = new Map()
	_logger = X("VCSWatcher")
	_headChangeListener
	_createFacade(t) {
		if (t.toolName === "git") return new nN(new eN(t.root))
		throw new Error("only git is supported for now")
	}
	startTracking(t, r, n, i, s, o) {
		if ((this._logger.debug(`startTracking folderId ${r}`), this._repoWatchers.has(r)))
			return this._logger.debug(`folderId ${r} is already being tracked`), new H8.Disposable(() => {})
		let a = new iN(t, this._createFacade(n), o, this._fileUploader, i, s, this.configListener)
		return (
			this._repoWatchers.set(r, a),
			this._disposables.set(r, [a]),
			a.handleHeadChange(),
			new H8.Disposable(() => this._stopTracking(r))
		)
	}
	_stopTracking(t) {
		this._logger.debug(`stopTracking folderId ${t}`)
		let r = this._disposables.get(t)
		if (r) {
			for (let n of r) n.dispose()
			this._disposables.delete(t)
		}
		this._repoWatchers.delete(t)
	}
	dispose() {
		this._logger.debug("Disposing VCSWatcher")
		for (let t of this._repoWatchers.keys()) this._stopTracking(t)
		this._repoWatchers.clear(), this._disposables.clear()
	}
	getWatchedFolderIds() {
		return Array.from(this._repoWatchers.keys())
	}
	async getChanges() {
		let t = { commits: [], workingDirectory: [] }
		for (let r of this._repoWatchers.values()) {
			let n = await r.getChanges()
			;(t.commits = t.commits.concat(n.commits)),
				(t.workingDirectory = t.workingDirectory.concat(n.workingDirectory))
		}
		return t
	}
	handleUnknownBlobs(t) {
		for (let r of this._repoWatchers.values()) r.handleUnknownBlobs(t)
	}
	listenForEvents() {
		this._logger.debug("Registering for events"),
			this._headChangeListener !== void 0 && this._headChangeListener.dispose(),
			(this._headChangeListener = vA((t) => {
				this._logger.debug(`Head changed for repo ${t.repoId}`),
					this._repoWatchers
						.get(t.repoId)
						?.handleHeadChange()
						.catch((r) => {
							r instanceof Error
								? this._logger.error(`Error handling head change: ${r.message ?? ""} ${r.stack}`)
								: this._logger.error(`Error handling head change: ${r}`)
						})
			}))
	}
}
var W8 = W(gs())
var oN = class {
	constructor(t, r, n) {
		this._configListener = t
		this._openFileManagerV1 = r
		this._openFileManagerV2 = n
	}
	_logger = X("OpenFileManagerProxy")
	get isV2Enabled() {
		return this._configListener.config.openFileManager.v2Enabled
	}
	startTrackingFolder(t, r) {
		return this.isV2Enabled
			? [this._openFileManagerV2.startTrackingFolder(t, r), this._openFileManagerV1.openSourceFolder(r)]
			: [this._openFileManagerV1.openSourceFolder(r)]
	}
	addOpenedDocument(t, r) {
		this._openFileManagerV1.startTracking(t.folderId, t.relPath, t.document),
			this.isV2Enabled && this._openFileManagerV2.addOpenedDocument(t, r)
	}
	getBlobName(t, r) {
		if (this.isV2Enabled) {
			let n = this._openFileManagerV2.getBlobName(t, r),
				i = this._openFileManagerV1.getBlobName(t, r)
			return (
				((n === void 0 && i !== void 0) || (n !== void 0 && i === void 0)) &&
					this._logger.debug(`[WARN] getBlobName returned different results between v1 and v2 [${t}:${r}]
[${JSON.stringify(n)}]
[${JSON.stringify(i)}]`),
				i
			)
		} else return this._openFileManagerV1.getBlobName(t, r)
	}
	handleMissingBlob(t, r, n) {
		if (this.isV2Enabled) {
			let i = this._openFileManagerV2.handleMissingBlob(t, r, n)
			return this._openFileManagerV1.notifyMissingBlob(t, r, n) || i
		} else return this._openFileManagerV1.notifyMissingBlob(t, r, n)
	}
	loseFocus() {
		this._openFileManagerV1.loseFocus()
	}
	stopTracking(t, r) {
		this._openFileManagerV1.stopTracking(t, r), this.isV2Enabled && this._openFileManagerV2.stopTracking(t, r)
	}
	handleClosedDocument(t) {
		let r = tf(t.document)
		this._openFileManagerV1.stopTracking(t.folderId, t.relPath, r ? 1 : 0),
			this.isV2Enabled && this._openFileManagerV2.handleClosedDocument(t)
	}
	handleChangedDocument(t) {
		Object.prototype.hasOwnProperty.call(t.event, "notebook")
			? this._openFileManagerV1.applyNotebookChange(t.folderId, t.relPath, t.event)
			: this._openFileManagerV1.applyTextDocumentChange(t.folderId, t.relPath, t.event),
			this.isV2Enabled && this._openFileManagerV2.handleChangedDocument(t)
	}
	isTracked(t, r) {
		if (this.isV2Enabled) {
			let n = this._openFileManagerV2.isTracked(t, r),
				i = this._openFileManagerV1.isTracked(t, r)
			return (
				n !== i &&
					this._logger.debug(`[WARN] isTracked returned different results between v1 and v2 [${t}:${r}]
[${JSON.stringify(n)}]
[${JSON.stringify(i)}]`),
				i
			)
		} else return this._openFileManagerV1.isTracked(t, r)
	}
	getTrackedPaths(t) {
		if (this.isV2Enabled) {
			let r = this._openFileManagerV2.getTrackedPaths(t),
				n = this._openFileManagerV1.getTrackedPaths(t),
				i = (0, W8.difference)(r, n)
			i.length > 0 &&
				this._logger.debug(`[WARN] getTrackedPaths in new but not in old [${t}]
[${JSON.stringify(i)}]`)
			let s = (0, W8.difference)(n, r)
			return (
				s.length > 0 &&
					this._logger.debug(`[WARN] getTrackedPaths in old but not in new [${t}]
[${JSON.stringify(s)}]`),
				n
			)
		} else return this._openFileManagerV1.getTrackedPaths(t)
	}
	getRecencySummary(t) {
		return this._openFileManagerV1.getRecencySummary(t)
	}
	getAllEditEvents() {
		return this.isV2Enabled ? this._openFileManagerV2.getAllEditEvents() : new Map()
	}
	getAllPathToIndexedBlob() {
		return this.isV2Enabled ? this._openFileManagerV2.getAllPathToIndexedBlob() : new Map()
	}
	translateRange(t, r, n, i) {
		if (this.isV2Enabled) {
			let s = this._openFileManagerV2.translateRange(t, r, n, i),
				o = this._openFileManagerV1.translateRange({
					folderId: t,
					relPath: r,
					beginOffset: n,
					endOffset: i,
				})
			return (
				(s?.blobName !== o?.blobName || s?.beginOffset !== o?.beginOffset || s?.endOffset !== o?.endOffset) &&
					this._logger.debug(`[WARN] translateRange returned different results between v1 and v2 [${t}:${r}]
[${JSON.stringify(s)}]
[${JSON.stringify(o)}]`),
				o
			)
		} else
			return this._openFileManagerV1.translateRange({
				folderId: t,
				relPath: r,
				beginOffset: n,
				endOffset: i,
			})
	}
}
var G8 = W(gs()),
	aN = class {
		store
		primaryKey
		constructor(t) {
			;(this.store = {}), (this.primaryKey = t)
		}
		add(t) {
			let r = t[this.primaryKey]
			if (this.get(r)) throw new Error(`Record with primary key ${r} already exists.`)
			this.store[r] = Object.assign({}, t)
		}
		update(t, r) {
			this.store[t] = { ...this.store[t], ...r }
		}
		delete(t) {
			let r = this.store[t]
			return delete this.store[t], r
		}
		deleteBy(t) {
			let r = this.search(t)
			for (let n of r) this.delete(n[this.primaryKey])
		}
		get(t) {
			return this.store[t]
		}
		search(t, { limit: r } = {}) {
			let n = 0,
				i = []
			for (let s of Object.values(this.store))
				if (G8.default.every(t, (o, a) => G8.default.isEqual(s[a], o)) && (i.push(s), n++, r && n >= r)) break
			return i
		}
		getAll() {
			return Object.values(this.store)
		}
		clear() {
			this.store = {}
		}
	}
var lN = class {
	_logger = X("BlobStatusStore")
	_store = new aN("blobName")
	_embargoedPaths = new Set()
	getIndexedBlobName(t) {
		if (this._embargoedPaths.has(t)) {
			this._logger.debug(`Path [${t}] is embargoed`)
			return
		}
		let r = this._store.search({ pathName: t, status: "indexed" })
		if (r.length === 0) {
			this._logger.debug(`No indexed blob found for ${t}`)
			return
		}
		return r.length > 1
			? (this._logger.warn(`Multiple indexed blobs found for ${t}`),
				r.sort((n, i) => (n.indexedAt ?? 0) - (i.indexedAt ?? 0)),
				r[r.length - 1].blobName)
			: r[0].blobName
	}
	isTrackingBlob(t) {
		return this._store.get(t) !== void 0
	}
	removePath(t) {
		this._store.deleteBy({ pathName: t }), this._embargoedPaths.delete(t)
	}
	isTrackingPath(t) {
		return this._embargoedPaths.has(t) || this._store.search({ pathName: t }, { limit: 1 }).length > 0
	}
	clear() {
		this._store.clear(), this._embargoedPaths.clear()
	}
	getTrackedPaths() {
		return [...new Set(...this._store.getAll().map((t) => t.pathName), ...this._embargoedPaths)]
	}
	addIndexedBlob(t, r) {
		this.addUploadedBlob(t, r), this.updateBlobIndexed(t)
	}
	addUploadedBlob(t, r) {
		this._store.add({
			blobName: t,
			pathName: r,
			status: "uploaded",
			uploadRequestedAt: Date.now(),
		})
	}
	getLastBlobNameForPath(t) {
		return this._store
			.search({ pathName: t })
			.reduce((n, i) => (n === void 0 ? i : (n.uploadRequestedAt ?? 0) > (i.uploadRequestedAt ?? 0) ? n : i))
			?.blobName
	}
	updateBlobIndexed(t) {
		let r = Date.now(),
			n = this._store.get(t)
		if (!n) {
			this._logger.debug(`[ERROR] Failed to find record for ${t}`)
			return
		}
		if (n.status === "indexed") {
			this._logger.debug(`[WARN] Blob ${t} is already indexed`)
			return
		}
		let i = this._store.search({ pathName: n.pathName, status: "indexed" })
		if (i.length === 0) {
			;(n.status = "indexed"), (n.indexedAt = r)
			return
		}
		if (
			(i.reduce((o, a) => ((o.uploadRequestedAt ?? 0) > (a.uploadRequestedAt ?? 0) ? o : a)).uploadRequestedAt ??
				0) > (n.uploadRequestedAt ?? 0)
		) {
			this._logger.info(`Blob ${t} is indexed but there is a newer blob to upload for ${n.pathName}`),
				this._store.delete(t)
			return
		}
		for (let o of i) this._store.delete(o.blobName)
		;(n.status = "indexed"), (n.indexedAt = r)
	}
	embargoPath(t) {
		if (this._embargoedPaths.has(t)) {
			this._logger.debug(`Path [${t}] is already embargoed`)
			return
		}
		this._logger.debug(`Embargoing path [${t}]`), this._store.deleteBy({ pathName: t }), this._embargoedPaths.add(t)
	}
	isEmbargoed(t) {
		return this._embargoedPaths.has(t)
	}
	updateBlobName(t, r) {
		let n = this._store.get(t)
		if (!n) {
			this._logger.debug(`[ERROR] Failed to find record for ${t}`)
			return
		}
		this._store.delete(t), (n.blobName = r), this._store.add(n)
	}
	getAllPathToIndexedBlob() {
		return this._store.search({ status: "indexed" }).reduce((t, r) => (t.set(r.pathName, r.blobName), t), new Map())
	}
}
var q_ = require("vscode")
var cN = require("vscode"),
	$8 = new cN.EventEmitter(),
	Y8 = $8.event,
	K8 = new cN.EventEmitter(),
	J8 = K8.event,
	z8 = new cN.EventEmitter(),
	j8 = z8.event
var uwe = W(E8())
var uN = class {
	_queue = new uwe.default()
	config
	constructor(t = {}) {
		this.config = {
			sizeLimit: t.sizeLimit ?? 1e6,
			queueSizeManagement: t.queueSizeManagement ?? "REMOVE_OLDEST",
		}
	}
	enqueue(t) {
		if (this._queue.length >= this.config.sizeLimit) {
			if (this.config.queueSizeManagement === "REJECT_NEW_ITEMS") return !1
			this.config.queueSizeManagement === "REMOVE_OLDEST" && this._queue.shift()
		}
		return this._queue.push(t), !0
	}
	dequeue() {
		return this._queue.shift()
	}
	isEmpty() {
		return this._queue.isEmpty()
	}
	clear() {
		this._queue.clear()
	}
	peek() {
		return this.peek()
	}
	getItems() {
		return Object.freeze(this._queue.toArray())
	}
	size() {
		return this._queue.length
	}
}
var dwe = X("SimpleQueueProcessor"),
	O_ = class {
		queue
		_inProgress = !1
		_disposed = !1
		constructor(t = new uN()) {
			this.queue = t
		}
		enqueue(t) {
			return this.queue.enqueue(t)
		}
		dequeue() {
			return this.queue.dequeue()
		}
		isEmpty() {
			return this.queue.isEmpty()
		}
		clear() {
			this.queue.clear()
		}
		peek() {
			return this.queue.peek()
		}
		getItems() {
			return this.queue.getItems()
		}
		size() {
			return this.queue.size()
		}
		dispose() {
			this._disposed = !0
		}
		retry(t, r) {
			setTimeout(() => {
				for (let n of t) this.enqueue(n)
				this.startProcess()
			}, r)
		}
		startProcess() {
			this._inProgress ||
				((this._inProgress = !0),
				Promise.resolve()
					.then(async () => {
						for (; !this.isEmpty() && !this.isDisposed(); ) {
							let t = this.peek()
							if ((await this.internalProcess(), t === this.peek())) break
						}
					})
					.catch((t) => {
						t instanceof Error
							? dwe.info(`Unhandled error while processing task: ${t.message} ${t.stack}`)
							: dwe.info(`Unhandled error while processing task: ${t}`)
					})
					.finally(() => {
						this._inProgress = !1
					}))
		}
		isDisposed() {
			return this._disposed
		}
	}
function nCt(e, t) {
	let r = new Set(t.unknownBlobNames.concat(t.nonindexedBlobNames)),
		n = []
	for (let i of e) r.has(i) || n.push(i)
	return n
}
var Z8 = class extends O_ {
		constructor(r, n) {
			super()
			this._apiServer = r
			this._config = n
		}
		_onFoundIndexedBlobNamesEmitter = new q_.EventEmitter()
		_onFoundUnknownBlobNamesEmitter = new q_.EventEmitter()
		_pollingStartTime = new Map()
		_logger = X("FileUploader#BlobStatusExecutor")
		dispose() {
			super.dispose(),
				this._pollingStartTime.clear(),
				this._onFoundIndexedBlobNamesEmitter.dispose(),
				this._onFoundUnknownBlobNamesEmitter.dispose()
		}
		get onFoundIndexedBlobNames() {
			return this._onFoundIndexedBlobNamesEmitter.event
		}
		get onFoundUnknownBlobNames() {
			return this._onFoundUnknownBlobNamesEmitter.event
		}
		retryBlobNames(r) {
			let [s, o] = r.reduce(
				(a, l) => {
					let c = this._pollingStartTime.get(l)
					return c === void 0
						? (this._logger.debug(`[WARN] retryBlobNames: missing start time for ${l}`), a[1].push(l), a)
						: (Date.now() - c < this._config.oldBlobNameThresholdMs ? a[1].push(l) : a[0].push(l), a)
				},
				[[], []],
			)
			s.length > 0 && this.retry(s, this._config.newBlobNameRetryMs),
				o.length > 0 && this.retry(o, this._config.oldBlobNameRetryMs)
		}
		async internalProcess() {
			let r = new Set(),
				n = 0
			for (; n < this._config.maxBatchCount; ) {
				let o = this.dequeue()
				if (o === void 0) break
				r.add(o), this._pollingStartTime.has(o) || this._pollingStartTime.set(o, Date.now()), n++
			}
			this._logger.verbose(`FindMissingProcess started: for [${r.size}] items`)
			let i
			try {
				i = await xi(() => this._apiServer.findMissing([...r]), this._logger)
			} catch {
				this._logger.debug(`[ERROR] FindMissingProcess failed: for [${r.size}] items`),
					this.retryBlobNames([...r])
				return
			}
			if (i.unknownBlobNames.length > 0) {
				this._logger.debug(`FindMissingProcess found unknown: for [${i.unknownBlobNames.length}] items`)
				for (let o of i.unknownBlobNames) this._pollingStartTime.delete(o)
				this._onFoundUnknownBlobNamesEmitter.fire(i.unknownBlobNames)
			}
			i.nonindexedBlobNames.length > 0 &&
				(this._logger.debug(`FindMissingProcess found nonindexed: for [${i.nonindexedBlobNames.length}] items`),
				this.retryBlobNames(i.nonindexedBlobNames))
			let s = nCt(r, i)
			for (let o of s) this._pollingStartTime.delete(o)
			s.length > 0 &&
				(this._logger.verbose(`FindMissingProcess found not missing: for [${s.length}] items`),
				this._onFoundIndexedBlobNamesEmitter.fire(s))
		}
	},
	X8 = class extends O_ {
		constructor(r, n) {
			super()
			this._apiServer = r
			this._config = n
		}
		_onUploadedEmitter = new q_.EventEmitter()
		_onFailedEmitter = new q_.EventEmitter()
		_logger = X("FileUploader#UploadExecutor")
		dispose() {
			super.dispose(), this._onUploadedEmitter.dispose(), this._onFailedEmitter.dispose()
		}
		get onDidUpload() {
			return this._onUploadedEmitter.event
		}
		get onFailed() {
			return this._onFailedEmitter.event
		}
		async _processUpload(r) {
			let n = Date.now(),
				i
			this._logger.verbose(`Upload started [${n}]: for [${r.length}] items`),
				(i = await xi(() => this._apiServer.batchUpload(r), this._logger)),
				this._logger.debug(`Upload complete [${n}]: for [${i.blobNames.length} / ${r.length}] items`)
			let s = new Map()
			if (i !== void 0)
				for (let a = 0; a < i.blobNames.length; a++) {
					let l = r[a].blobName,
						c = i.blobNames[a]
					s.set(l, c), l !== c && this._logger.debug(`[WARN]Upload blob name mismatch: ${l} -> ${c}`)
				}
			let o = r.length - (i?.blobNames.length ?? 0)
			return { expectedToActualBlobNameMap: s, failedCount: o }
		}
		processResult(r, n) {
			let { expectedToActualBlobNameMap: i, failedCount: s } = r
			s > 0 &&
				(this._logger.debug(`[WARN] Scheduling for retry [${s}] items`),
				this.retry(n.slice(n.length - s), this._config.retryMs)),
				i.size > 0 && this._onUploadedEmitter.fire(i)
		}
		async internalProcess() {
			let r = 0,
				n = [],
				i = [],
				s = 0
			for (; !this.isDisposed() && s < this._config.maxBatchCount; ) {
				let o = this.peek()
				if (o === void 0) break
				let a = await o.readContent()
				if (a.length > this._config.maxUploadSize) {
					this._logger.debug(`[WARN] UploadExecutor: skipping upload for ${o.path} because it is too large`),
						this.dequeue()
					continue
				}
				if (r + a.length > this._config.maxUploadSize) break
				;(r += a.length),
					n.push({
						pathName: o.path,
						text: a,
						blobName: o.blobName,
						metadata: [],
					}),
					i.push(o),
					this.dequeue(),
					s++
			}
			if (n.length === 0) {
				this._logger.debug("UploadExecutor: no items to upload")
				return
			}
			try {
				let o = await this._processUpload(n)
				this.processResult(o, i)
			} catch (o) {
				this._logger.debug(
					`[ERROR] UploadExecutor failed: for [${n.length}] items. Caused by: ${o.message} ${o.stack}`,
				),
					await this.processIndividualUploads(i, n)
			}
		}
		async processIndividualUploads(r, n) {
			for (let i = 0; i < r.length; i++) {
				let s = r[i],
					o = n[i]
				try {
					let a = await this._processUpload([o])
					this.processResult(a, [s])
				} catch {
					this._logger.debug(`[ERROR] UploadExecutor failed: for [${s.blobName}]`),
						this._onFailedEmitter.fire(s)
				}
			}
		}
	},
	iCt = {
		uploadConfig: { maxUploadSize: 1e7, maxBatchCount: 128, retryMs: 6e4 },
		blobStatusConfig: {
			maxBatchCount: 1e3,
			oldBlobNameThresholdMs: 6e4,
			oldBlobNameRetryMs: 6e4,
			newBlobNameRetryMs: 3e3,
		},
	},
	dN = class extends z {
		constructor(r, n, i = iCt) {
			super()
			this._blobNameCalculator = r
			this._apiServer = n
			this._config = i
			;(this._uploadExecutor = new X8(n, i.uploadConfig)),
				(this._blobStatusExecutor = new Z8(n, i.blobStatusConfig)),
				this.addDisposables(
					{
						dispose: () => {
							this._handledItems.clear()
						},
					},
					this._uploadExecutor,
					this._blobStatusExecutor,
					this._uploadExecutor.onDidUpload((s) => {
						K8.fire({ expectedToActualBlobNameMap: s })
						for (let [o, a] of s)
							this._handledItems.has(o) &&
								(o !== a &&
									(this._handledItems.set(a, this._handledItems.get(o)),
									this._handledItems.delete(o)),
								this._blobStatusExecutor.enqueue(a))
						this._blobStatusExecutor.startProcess()
					}),
					this._uploadExecutor.onFailed((s) => {
						this._logger.debug(`[ERROR] Upload failed: ${s.path}`),
							this._handledItems.delete(s.blobName),
							$8.fire({ blobName: s.blobName })
					}),
					this._blobStatusExecutor.onFoundIndexedBlobNames((s) => {
						for (let o of s) this._handledItems.delete(o)
						z8.fire({ blobNames: s })
					}),
					this._blobStatusExecutor.onFoundUnknownBlobNames((s) => {
						for (let o of s) {
							let a = this._handledItems.get(o)
							a && this._uploadExecutor.enqueue(a)
						}
						this._uploadExecutor.startProcess()
					}),
				)
		}
		_logger = X("BlobUploaderImpl")
		_uploadExecutor
		_blobStatusExecutor
		_handledItems = new Map()
		enqueueUpload(r, n) {
			let i = this._blobNameCalculator.calculate(r.path, n)
			if (i === void 0) {
				this._logger.debug(`blobNameCalculator returned undefined for ${r.path}`)
				return
			}
			let s = { ...r, blobName: i }
			return (
				this._handledItems.set(i, s),
				this._logger.debug(`upload: ${r.path}. total: ${this._handledItems.size}`),
				this._blobStatusExecutor.enqueue(i),
				i
			)
		}
		startUpload() {
			this._blobStatusExecutor.startProcess()
		}
	}
var e6 = class {
		constructor(t) {
			this._blobNameCalculator = t
		}
		_logger = X("OpenDocumentSnapshotCache")
		_lastKnownText = new Map()
		handleDocumentOpened(t) {
			tf(t.document) || this._lastKnownText.set(t.relPath, t.document.getText())
		}
		handleDocumentClosed(t) {
			this._lastKnownText.delete(t.relPath)
		}
		handleFileRename(t) {
			for (let r of this._lastKnownText.keys())
				if (Ss(t.oldRelPath, r)) {
					let n = t.newRelPath + r.slice(t.oldRelPath.length)
					this._lastKnownText.set(n, this._lastKnownText.get(r)), this._lastKnownText.delete(r)
				}
		}
		handleFileDeletion(t) {
			this._lastKnownText.delete(t.relPath)
		}
		_swapLastKnownText(t, r) {
			if (!this._lastKnownText.has(t)) {
				this._logger.verbose(`[WARN] no known last text for path [${t}]. initializing.`),
					this._lastKnownText.set(t, r)
				return
			}
			let n = this._lastKnownText.get(t)
			return this._lastKnownText.set(t, r), n
		}
		handleDocumentChange(t) {
			if (Object.prototype.hasOwnProperty.call(t.event, "notebook")) return
			t = t
			let r = t.event.document.getText(),
				n = this._swapLastKnownText(t.relPath, r)
			if (!n || t.event.contentChanges.length === 0) return
			let i = t.event.contentChanges.map(
				(s) =>
					new Nl({
						beforeStart: s.rangeOffset,
						afterStart: s.rangeOffset,
						beforeText: n.substring(s.rangeOffset, s.rangeOffset + s.rangeLength),
						afterText: s.text,
					}),
			)
			if (i.length > 1) {
				i.sort((o, a) => o.beforeStart - a.beforeStart)
				let s = 0
				i = i.map((o) => {
					let a = o.afterStart + s
					return (
						(s += o.afterText.length - o.beforeText.length),
						new Nl({
							beforeStart: o.beforeStart,
							afterStart: a,
							beforeText: o.beforeText,
							afterText: o.afterText,
						})
					)
				})
			}
			return new og({
				path: t.relPath,
				edits: i,
				beforeBlobName: this._blobNameCalculator.calculateNoThrow(t.relPath, n),
				afterBlobName: this._blobNameCalculator.calculateNoThrow(t.relPath, r),
			}).normalize()
		}
		getLastKnownText(t) {
			return this._lastKnownText.get(t)
		}
	},
	fN = class {
		constructor(t) {
			this._blobNameCalculator = t
			;(this._openDocumentSnapshotCache = new e6(this._blobNameCalculator)), (this._fileEditsStore = new xA(1e6))
		}
		_openDocumentSnapshotCache
		_fileEditsStore
		handleDocumentOpened(t) {
			this._openDocumentSnapshotCache.handleDocumentOpened(t)
		}
		handleDocumentClosed(t) {
			this._openDocumentSnapshotCache.handleDocumentClosed(t)
		}
		handleFileWillRename(t) {
			this._openDocumentSnapshotCache.handleFileRename(t)
		}
		handleFileDeletion(t) {
			this._openDocumentSnapshotCache.handleFileDeletion(t)
		}
		handleDocumentChange(t, r) {
			let n = this._openDocumentSnapshotCache.handleDocumentChange(t)
			return n === void 0 ? 0 : this._fileEditsStore.addEvent(n, r)
		}
		getEvents() {
			return this._fileEditsStore.getEvents()
		}
		removeEventsPriorToBlob(t) {
			this._fileEditsStore.removeEventsPriorToBlob(t)
		}
		getLastKnownText(t) {
			return this._openDocumentSnapshotCache.getLastKnownText(t)
		}
	}
var t6 = class {
	constructor(t, r, n, i, s) {
		this.blobStatusStore = t
		this.fileEditProcessor = r
		this.fileChangeSizeCounter = n
		this.workspaceName = i
		this.folderId = s
	}
	dispose() {
		this.blobStatusStore.clear()
	}
}
var r6 = class {
	_size = 0
	_relPath = ""
	get size() {
		return this._size
	}
	add(t, r) {
		return this._relPath !== r ? ((this._size = t), (this._relPath = r)) : (this._size += t), this._size
	}
	clear() {
		;(this._size = 0), (this._relPath = "")
	}
}
function fwe(e) {
	return tf(e)
		? e.getCells().map((t) => t.document.getText()).join(`
`)
		: e.getText()
}
var sCt = 1e3
function oCt(e) {
	return Object.prototype.hasOwnProperty.call(e.event, "notebook") ? e.event.notebook : e.event.document
}
var hN = class extends z {
	constructor(r, n) {
		super()
		this._blobUploader = r
		this._blobNameCalculator = n
		this.addDisposables(
			j8((i) => this.handleBlobIndexed(i)),
			J8((i) => this.handleBlobUploaded(i)),
			Y8((i) => this.handleBlobUploadFailed(i)),
		)
	}
	_folderResources = new Map()
	_logger = X("OpenFileManagerV2")
	_uploadingBlobToFolder = new Map()
	startTrackingFolder(r, n) {
		let i = new fN(this._blobNameCalculator),
			s = new t6(new lN(), i, new r6(), r, n)
		return this._folderResources.set(n, s), this.addDisposable(s), s
	}
	handleBlobIndexed(r) {
		for (let n of r.blobNames) {
			this._logger.verbose(`Blob ${n} indexed`)
			let i = this._uploadingBlobToFolder.get(n)
			if (i === void 0) {
				this._logger.debug(`[WARN] Blob ${n} was indexed but not tracked. Ignoring.`)
				return
			}
			this._uploadingBlobToFolder.delete(n),
				this._folderResources.get(i)?.blobStatusStore.updateBlobIndexed(n),
				this._folderResources.get(i)?.fileEditProcessor.removeEventsPriorToBlob(n)
		}
	}
	handleBlobUploadFailed(r) {
		let n = r.blobName
		this._uploadingBlobToFolder.has(n) &&
			(this._logger.debug(`Blob ${n} failed to upload`), this._uploadingBlobToFolder.delete(n))
	}
	handleBlobUploaded(r) {
		this._logger.verbose(`Handling ${r.expectedToActualBlobNameMap.size} uploaded blobs`)
		for (let [n, i] of r.expectedToActualBlobNameMap) {
			if (n === i) continue
			let s = this._uploadingBlobToFolder.get(n)
			if (s === void 0) {
				this._logger.debug(`Blob ${n} was uploaded but not tracked. Ignoring.`)
				continue
			}
			this._logger.debug(`[WARN] Blob name mismatch. Expected ${n} but got ${i}.`),
				this._uploadingBlobToFolder.set(i, s),
				this._uploadingBlobToFolder.delete(n)
			let o = this._folderResources.get(s)
			if (o === void 0) {
				this._logger.debug(`[WARN] Blob ${n} was uploaded but folder ${s} is not tracked. Ignoring.`)
				continue
			}
			o.blobStatusStore.updateBlobName(n, i)
		}
	}
	_upload(r, n, i, s) {
		let o = this._folderResources.get(r)?.workspaceName
		this._logger.info(`[${o}] Uploading [${i}] because [${s}]`)
		let a = this._blobUploader.enqueueUpload({ path: i, readContent: async () => n }, n)
		a &&
			(this._uploadingBlobToFolder.set(a, r), this._folderResources.get(r)?.blobStatusStore.addUploadedBlob(a, i))
	}
	stopTracking(r, n) {
		this._logger.info(`[${this._folderResources.get(r)?.workspaceName}] Stopping tracking [${n}]`),
			this._folderResources.get(r)?.blobStatusStore.removePath(n)
	}
	addOpenedDocument(r, n) {
		let i = this._folderResources.get(r.folderId)
		if (i === void 0) throw new Error(`Source folder [${r.folderId}] is not open`)
		let s = i.workspaceName
		tf(r.document) && this._logger.info(`TODO [${s}] Ignoring notebook document ${r.relPath}`)
		let o = fwe(r.document),
			a = this._blobNameCalculator.calculate(r.relPath, o)
		if (!a) {
			i.blobStatusStore.embargoPath(r.relPath),
				this._logger.debug(`[WARN] Failed to calculate blob name for ${r.relPath}`)
			return
		}
		a !== n
			? (this._upload(r.folderId, o, r.relPath, "new file"),
				this._logger.debug(`[INFO] Blob name mismatch. Expected ${n} but got ${a}.`))
			: i.blobStatusStore.addIndexedBlob(n, r.relPath)
	}
	getBlobName(r, n) {
		return this._folderResources.get(r)?.blobStatusStore?.getIndexedBlobName(n)
	}
	handleMissingBlob(r, n, i) {
		let s = this._folderResources.get(r)
		if (s === void 0) return !1
		let o = s.blobStatusStore.isTrackingBlob(i),
			a = s.workspaceName
		if (!o) return !1
		this._logger.info(`[${a}] Re-uploading ${i} for ${n} in ${r}`)
		let l = s.fileEditProcessor.getLastKnownText(n)
		return l === void 0 ? !1 : (this._upload(r, l, n, "missing blob"), !0)
	}
	handleClosedDocument(r) {
		let n = this._folderResources.get(r.folderId)?.workspaceName
		this._logger.info(`[${n}] Handling closed document ${r.relPath}`), this.stopTracking(r.folderId, r.relPath)
	}
	handleChangedDocument(r) {
		let n = this._folderResources.get(r.folderId)
		if (n === void 0) {
			this._logger.debug(`Ignoring change event for ${r.relPath} because folder is not tracked`)
			return
		}
		if (n.blobStatusStore.isEmbargoed(r.relPath)) return
		let i = n.workspaceName
		if (Object.prototype.hasOwnProperty.call(r.event, "notebook")) {
			this._logger.debug(`[${i}] Ignoring notebook document ${r.relPath}`)
			return
		}
		let s = n.fileEditProcessor
		if (s === void 0) {
			this._logger.debug(`[${i}] Ignoring change event for ${r.relPath} because folder is not tracked`)
			return
		}
		let o = n.blobStatusStore.getLastBlobNameForPath(r.relPath),
			a = s.handleDocumentChange(r, o)
		;(n.fileChangeSizeCounter.add(a, r.relPath) ?? 0) > sCt &&
			(this._upload(r.folderId, fwe(oCt(r)), r.relPath, "large change"), n.fileChangeSizeCounter.clear())
	}
	isTracked(r, n) {
		return this._folderResources.get(r)?.blobStatusStore.isTrackingPath(n) ?? !1
	}
	getTrackedPaths(r) {
		return this._folderResources.get(r)?.blobStatusStore.getTrackedPaths() ?? []
	}
	translateRange(r, n, i, s) {
		let o = this.getBlobName(r, n)
		if (o === void 0) return
		let a = { blobName: o, beginOffset: i, endOffset: s },
			l = (u, f) => {
				if (u.afterStart > f.endOffset) return f
				if (u.afterEnd < f.beginOffset) {
					let p = u.afterText.length - u.beforeText.length
					return {
						blobName: f.blobName,
						beginOffset: f.beginOffset - p,
						endOffset: f.endOffset - p,
					}
				}
				return {
					blobName: f.blobName,
					beginOffset: Math.min(u.afterStart, f.beginOffset),
					endOffset: Math.max(u.afterEnd, f.endOffset),
				}
			},
			c =
				this._folderResources
					.get(r)
					?.fileEditProcessor.getEvents()
					.filter((u) => u.path === n) ?? []
		for (let u of c) for (let f of u.edits) a = l(f, a)
		return a
	}
	getAllEditEvents() {
		let r = new Map()
		return Array.from(this._folderResources.keys()).reduce((n, i) => {
			let s = Number(i)
			return n.set(s, this._folderResources.get(s)?.fileEditProcessor.getEvents() ?? []), n
		}, r)
	}
	getAllPathToIndexedBlob() {
		let r = new Map()
		return Array.from(this._folderResources.keys()).reduce((n, i) => {
			let s = Number(i)
			return n.set(s, this._folderResources.get(s)?.blobStatusStore.getAllPathToIndexedBlob() ?? new Map()), n
		}, r)
	}
}
var hwe = W(require("vscode"))
var n6 = require("vscode")
var V_ = class extends Error {
		constructor(r, n) {
			let i = r instanceof Error ? r.message : `${r}`
			super(`WorkQueueItemFailed: ${i}, retry = ${n}`)
			this.toThrow = r
			this.retry = n
		}
	},
	i6 = class {
		throwError(t, r) {
			throw new V_(t, r)
		}
	},
	s6 = class {
		progressReporter
		completedItems = 0
		totalItems
		constructor(t, r) {
			;(this.progressReporter = t), (this.totalItems = r), this.update(0, this.totalItems)
		}
		update(t, r) {
			;(this.completedItems += t),
				(this.totalItems = this.completedItems + r),
				this.progressReporter.update(this.completedItems, this.totalItems)
		}
		cancel() {
			this.progressReporter.cancel()
		}
	},
	o6 = class {
		constructor(t, r) {
			this.item = t
			this.process = r
		}
		itemCount() {
			return 1
		}
		start(t) {
			return this.process(this.item, t)
		}
	},
	a6 = class {
		constructor(t, r) {
			this.items = t
			this.process = r
		}
		itemCount() {
			return this.items.size
		}
		start(t) {
			return this.process(this.items, t)
		}
	},
	gN = class {
		queue = new Set()
		get size() {
			return this.queue.size
		}
		add(t) {
			this.queue.add(t)
		}
		delete(t) {
			this.queue.delete(t)
		}
	},
	l6 = class extends gN {
		constructor(r) {
			super()
			this.process = r
		}
		dequeue() {
			let r = this.queue.values().next()
			if (r.done) throw new Error("Cannot dequeue from empty queue")
			let n = r.value
			return this.queue.delete(n), new o6(n, this.process)
		}
	},
	c6 = class extends gN {
		constructor(r, n) {
			super()
			this.process = r
			this._maxBatchSize = n
		}
		dequeue() {
			let r
			if (this._maxBatchSize === void 0 || this.queue.size <= this._maxBatchSize)
				(r = this.queue), (this.queue = new Set())
			else {
				r = new Set()
				let n = this.queue.values()
				for (let i = 0; i < this._maxBatchSize; i++) {
					let s = n.next()
					if (s.done) break
					let o = s.value
					this.queue.delete(o), r.add(o)
				}
			}
			return new a6(r, this.process)
		}
	},
	pN = class e {
		constructor(t, r, n, i) {
			this.name = t
			this.shutdownError = n
			if ("processOne" in r) this.queue = new l6(r.processOne)
			else if ("processBatch" in r) this.queue = new c6(r.processBatch, r.maxBatchSize)
			else throw new Error("Invalid processor type")
			;(this.backoffParams = i || e.defaultBackoffParams),
				(this.logger = X(`WorkQueue[${t}]`)),
				(this.errorHandler = new i6())
		}
		static queueStatusChanged = "QueueStatusChanged"
		static itemFailed = "ItemFailed"
		static defaultBackoffParams = { initialMS: 100, mult: 2, maxMS: 3e4 }
		eventEmitters = {
			[e.queueStatusChanged]: new n6.EventEmitter(),
			[e.itemFailed]: new n6.EventEmitter(),
		}
		queue
		countReporters = new Set()
		progressReporters = new Set()
		errorHandler
		backoffParams
		itemsInProgress = 0
		stopping = !1
		logger
		stop() {
			;(this.stopping = !0), this.update(), this.notifyStatusChanged()
		}
		add(t) {
			this.stopping || (this.queue.add(t), this.update(), this.kick())
		}
		delete(t) {
			this.stopping || (this.queue.delete(t), this.update())
		}
		size() {
			return this.queue.size + this.itemsInProgress
		}
		reportQueueSize(t) {
			let r = this.size()
			t.update(r), this.countReporters.add(t)
		}
		awaitEmpty(t, r = !0) {
			if (this.stopping) return Promise.resolve()
			let n = this.size()
			return n === 0
				? Promise.resolve()
				: (t && this.progressReporters.add(new s6(t, n)),
					new Promise((i, s) => {
						let o = []
						function a() {
							for (let l of o) l.dispose()
						}
						o.push(
							this.eventEmitters[e.queueStatusChanged].event(() => {
								a(), this.stopping ? s(this.shutdownError) : i()
							}),
						),
							r &&
								o.push(
									this.eventEmitters[e.itemFailed].event((l) => {
										a(), s(l)
									}),
								)
					}))
		}
		update(t = 0) {
			if (this.stopping) {
				for (let r of this.countReporters) r.cancel()
				for (let r of this.progressReporters) r.cancel()
			} else {
				this.itemsInProgress -= t
				let r = this.size()
				for (let n of this.countReporters) n.update(r)
				for (let n of this.progressReporters) n.update(t, r)
			}
		}
		notifyStatusChanged() {
			this.eventEmitters[e.queueStatusChanged].fire(null), this.progressReporters.clear()
		}
		notifyItemFailed(t) {
			let r = t instanceof V_ ? t.toThrow : t
			this.eventEmitters[e.itemFailed].fire(r)
		}
		delay(t) {
			return new Promise((r) => setTimeout(r, t))
		}
		async kick() {
			if (!this.itemsInProgress) {
				for (; !this.stopping && this.queue.size !== 0; ) {
					let t = this.queue.dequeue()
					this.itemsInProgress = t.itemCount()
					let r = 0,
						n = 0
					do {
						try {
							await t.start(this.errorHandler), n && this.logger.debug(`item succeeded; retries = ${n}`)
							break
						} catch (i) {
							if ((this.notifyItemFailed(i), !(i instanceof V_ && i.retry))) {
								this.logger.debug(`item failed, not retrying; retries = ${n}`)
								break
							}
						}
						this.logger.debug(`item failed, retrying in ${r} ms; retries = ${n}`),
							await this.delay(r),
							this.logger.debug("retrying"),
							r === 0
								? (r = this.backoffParams.initialMS)
								: (r = Math.min(r * this.backoffParams.mult, this.backoffParams.maxMS)),
							n++
					} while (!this.stopping)
					this.stopping || this.update(this.itemsInProgress)
				}
				this.notifyStatusChanged()
			}
		}
	}
function LC(e, t) {
	let r = new Set(t)
	return e.filter((n) => !r.has(n))
}
var AN = class e extends z {
	static defaultCheckpointThreshold = 1e3
	_checkpointId
	_checkpointBlobNames = new Map()
	_toAdd = new Map()
	_toRemove = new Set()
	_apiServer
	_logger
	_checkpointQueue
	_checkpointThreshold
	_maxCheckpointBatchSize = 1e4
	_featureFlagManager
	_onContextChange = new hwe.EventEmitter()
	onContextChange = this._onContextChange.event
	get _flags() {
		return this._featureFlagManager.currentFlags
	}
	constructor(t, r, n, i) {
		super(),
			(this._logger = X("BlobsCheckpointManager")),
			(this._checkpointId = void 0),
			(this._apiServer = t),
			(this._featureFlagManager = r),
			(this._checkpointThreshold = i ?? e.defaultCheckpointThreshold),
			this.addDisposable(
				n((s) => {
					this.updateBlob(s.absPath, s.prevBlobName, s.newBlobName)
				}),
			),
			(this._checkpointQueue = new pN("checkpoint", {
				processOne: async (s, o) => await this._checkpoint(s, o),
			})),
			this._logger.info(`BlobsCheckpointManager created. checkpointThreshold: ${this._checkpointThreshold}`)
	}
	refBlob(t) {
		let r = this._checkpointBlobNames.get(t)
		r !== void 0
			? (this._checkpointBlobNames.set(t, r + 1), r === 0 && this._toRemove.delete(t))
			: this._toAdd.set(t, (this._toAdd.get(t) ?? 0) + 1)
	}
	derefBlob(t) {
		!this.derefFromCheckpoint(t) &&
			!this.derefFromAdded(t) &&
			this._logger.error(`derefBlob: blob ${t} not found in checkpoint or toAdd`)
	}
	derefFromCheckpoint(t) {
		let r = this._checkpointBlobNames.get(t)
		return r === void 0 || r <= 0
			? (r !== void 0 &&
					this._logger.error(
						`derefFromCheckpoint: blob ${t} has reference count ${r}. In toRemove? ${this._toRemove.has(
							t,
						)}`,
					),
				!1)
			: (this._checkpointBlobNames.set(t, r - 1), r === 1 && this._toRemove.add(t), !0)
	}
	derefFromAdded(t) {
		let r = this._toAdd.get(t)
		return r === void 0 ? !1 : r <= 1 ? (this._toAdd.delete(t), r === 1) : (this._toAdd.set(t, r - 1), !0)
	}
	getCheckpointedBlobNames() {
		return Array.from(this._checkpointBlobNames.keys())
	}
	getContext() {
		return {
			checkpointId: this._checkpointId,
			addedBlobs: Array.from(this._toAdd.keys()),
			deletedBlobs: Array.from(this._toRemove),
		}
	}
	getContextAdjusted(t, r) {
		let n = new Set(this._toAdd.keys()),
			i = new Set(this._toRemove)
		for (let s of t) this._checkpointBlobNames.has(s) || n.add(s), i.delete(s)
		for (let s of r) this._checkpointBlobNames.has(s) && i.add(s), n.delete(s)
		return {
			checkpointId: this._checkpointId,
			addedBlobs: Array.from(n),
			deletedBlobs: Array.from(i),
		}
	}
	blobsPayload(t) {
		let r = this.getCheckpointedBlobNames(),
			n = LC(t, r),
			i = LC(r, t)
		return { checkpointId: this._checkpointId, addedBlobs: n, deletedBlobs: i }
	}
	expandBlobs(t) {
		if (t.checkpointId === void 0) return t.addedBlobs
		if (t.checkpointId !== this._checkpointId)
			throw new Error(`expandBlobs: checkpointId mismatch: ${t.checkpointId} != ${this._checkpointId}`)
		let r = this.getCheckpointedBlobNames()
		if ((r.push(...t.addedBlobs), t.deletedBlobs.length > 0)) {
			let n = new Set(t.deletedBlobs)
			return r.filter((i) => !n.has(i))
		}
		return r
	}
	validateMatching(t, r, n = !1) {
		if (t.checkpointId !== r.checkpointId)
			return this._logger.error(`checkpointId mismatch: ${t.checkpointId} vs ${r.checkpointId}`), !1
		let i = !0,
			s = LC(t.addedBlobs, r.addedBlobs),
			o = LC(r.addedBlobs, t.addedBlobs)
		return (
			(s.length > 0 || o.length > 0) &&
				((i = !1),
				this._logger.error(`addedBlobs mismatch: -${s.length}/+${o.length}`),
				n &&
					(this._logger.error(`left-added: ${s.slice(0, 5).join(",")}`),
					this._logger.error(`right-added: ${o.slice(0, 5).join(",")}`))),
			(s = LC(t.deletedBlobs, r.deletedBlobs)),
			(o = LC(r.deletedBlobs, t.deletedBlobs)),
			(s.length > 0 || o.length > 0) &&
				((i = !1),
				this._logger.error(`deletedBlobs mismatch: -${s.length}/+${o.length}`),
				n &&
					(this._logger.error(`left-deleted: ${s.slice(0, 5).join(",")}`),
					this._logger.error(`right-deleted: ${o.slice(0, 5).join(",")}`))),
			i
		)
	}
	updateBlob(t, r, n) {
		this._logger.verbose(`notifyBlobChange ${t}: ${r} to ${n}`),
			n && n !== r && this.refBlob(n),
			r && n !== r && this.derefBlob(r),
			this._toAdd.size + this._toRemove.size >= this._checkpointThreshold &&
				this._checkpointQueue.size() === 0 &&
				this._queueCheckpoint()
	}
	resetCheckpoint() {
		for (let [t, r] of this._checkpointBlobNames)
			r > 0
				? this._toAdd.set(t, r)
				: this._toRemove.delete(t) ||
					this._logger.warn(`blob with 0 references was not found in toRemove: ${t}`)
		for (let t of this._toRemove) this._logger.warn(`blob in toRemove was not found in checkpoint: ${t}`)
		this._toRemove.clear(),
			(this._checkpointId = void 0),
			this._checkpointBlobNames.clear(),
			this._onContextChange.fire(this.getContext())
	}
	async awaitEmptyQueue() {
		await this._checkpointQueue.awaitEmpty(void 0, !1)
	}
	async _checkpoint(t, r) {
		let { checkpointId: n, addedBlobs: i, deletedBlobs: s } = t
		this._logger.debug(`Begin checkpoint of working set into ${n}`),
			this._logger.debug(`add ${i.length} blobs, remove ${s.length} blobs into ${n}`)
		let o = { newCheckpointId: "" }
		try {
			o = await this._apiServer.checkpointBlobs(t)
		} catch (a) {
			let l = a instanceof Error ? a.message : `${a}`,
				c = this._checkpointId ? this._checkpointId : "{initial}"
			kr.isAPIErrorWithStatus(a, He.invalidArgument) || kr.isAPIErrorWithStatus(a, He.unimplemented)
				? (this._logger.warn(
						`checkpoint-blobs from ${c} failed with invalid argument: ${l}. Recreating checkpoint.`,
					),
					this.resetCheckpoint(),
					this._queueCheckpoint(),
					r.throwError(a, !1))
				: (this._logger.error(`checkpoint-blobs failed with error: ${l}.`), r.throwError(a, !1))
		}
		if (n !== this._checkpointId)
			this._logger.warn(
				`original checkpointId ${n} does not match current checkpointId ${this._checkpointId}. Abandoning new checkpoint.`,
			)
		else {
			this._logger.debug(`checkpointId ${n} advanced to ${o.newCheckpointId}`),
				(this._checkpointId = o.newCheckpointId)
			for (let a of i) {
				let l = this._toAdd.get(a)
				l === void 0
					? (this._checkpointBlobNames.set(a, 0), this._toRemove.add(a))
					: (this._checkpointBlobNames.set(a, l), this._toAdd.delete(a))
			}
			for (let a of s) {
				let l = this._checkpointBlobNames.get(a)
				l === void 0
					? this._logger.warn(`In _checkpoint: deleted blob ${a} not found in checkpoint`)
					: l > 0 && this._toAdd.set(a, l),
					this._checkpointBlobNames.delete(a),
					this._toRemove.delete(a)
			}
			this._onContextChange.fire(this.getContext())
		}
		this._toAdd.size + this._toRemove.size >= this._checkpointThreshold &&
			(this._logger.debug(
				`starting a new round of checkpointing due to size ${this._toAdd.size} + ${this._toRemove.size}`,
			),
			this._queueCheckpoint())
	}
	_queueCheckpoint() {
		this._logger.debug("queue checkpoint")
		let t = Array.from(this._toAdd.keys()).slice(0, this._maxCheckpointBatchSize),
			r = Array.from(this._toRemove).slice(0, this._maxCheckpointBatchSize),
			n = { checkpointId: this._checkpointId, addedBlobs: t, deletedBlobs: r }
		this._logger.debug(
			`queue checkpoint: version: ${n.checkpointId}, add: ${n.addedBlobs.length} blobs, rm: ${n.deletedBlobs.length} blob`,
		),
			this._checkpointQueue.add(n)
	}
}
var H_ = W(require("vscode"))
function cg(e, t, r, n) {
	let i = 0
	for (let s of r)
		if ((e.log(t, `  ${s}`), i++, n !== void 0 && i >= n)) {
			e.log(t, "  ...")
			break
		}
}
var u6 = class {
		constructor(t, r) {
			this.maxItems = t
			this.maxByteSize = r
		}
		items = new Map()
		byteSize = 0
		addItem(t, r) {
			let n = this.items.get(t)
			if (n === void 0) {
				if (this.items.size >= this.maxItems || this.byteSize + r.byteSize >= this.maxByteSize) return !1
				this.items.set(t, [r]), (this.byteSize += r.byteSize)
			} else n.push(r)
			return !0
		}
	},
	d6 = class {
		constructor(t) {
			this.maxItemCount = t
		}
		items = new Map()
		get full() {
			return this.items.size >= this.maxItemCount
		}
		addItem(t, r) {
			if (this.items.has(t)) return !1
			this.items.set(t, r)
		}
	},
	mN = class e extends z {
		constructor(r, n, i, s, o) {
			super()
			this.workspaceName = r
			this._apiServer = n
			this._pathHandler = i
			this._pathMap = s
			;(this._logger = X(`DiskFileManager[${r}]`)),
				o === void 0
					? (this._probeBatchSize = e.maxProbeBatchSize)
					: (o < e.minProbeBatchSize
							? this._logger.verbose(
									`Rejecting requested probe batch size of ${o} (min = ${e.minProbeBatchSize})`,
								)
							: o > e.maxProbeBatchSize &&
								this._logger.verbose(
									`Rejecting requested probe batch size of ${o} (max = ${e.maxProbeBatchSize})`,
								),
						(this._probeBatchSize = Math.max(Math.min(o, e.maxProbeBatchSize), e.minProbeBatchSize))),
				(this._toCalculate = new $o(this._calculate.bind(this))),
				this.addDisposable(this._toCalculate),
				(this._toProbe = new $o(this._probe.bind(this))),
				this.addDisposable(this._toProbe),
				(this._probeBatch = this._newProbeBatch()),
				(this._toUpload = new $o(this._upload.bind(this))),
				this.addDisposable(this._toUpload),
				(this._uploadBatch = this._newUploadBatch()),
				(this._probeRetryWaiters = new $o(this._enqueueForProbe.bind(this))),
				this.addDisposable(this._probeRetryWaiters),
				(this._probeRetryKicker = new vc(this._probeRetryWaiters, e.probeRetryPeriodMs)),
				this.addDisposable(this._probeRetryKicker),
				(this._probeRetryBackoffWaiters = new $o(this._enqueueForProbe.bind(this))),
				(this._probeRetryBackoffKicker = new vc(this._probeRetryBackoffWaiters, e.probeRetryBackoffPeriodMs)),
				this.addDisposable(this._probeRetryBackoffKicker)
		}
		static minProbeBatchSize = 1
		static maxProbeBatchSize = 1e3
		static maxUploadBatchBlobCount = 128
		static maxUploadBatchByteSize = 1e6
		static probeRetryPeriodMs = 3 * 1e3
		static probeBackoffAfterMs = 60 * 1e3
		static probeRetryBackoffPeriodMs = 60 * 1e3
		_notAPlainFile = "Not a file"
		_fileNotAccessible = "File not readable"
		_fileNotText = "Binary file"
		_fileUploadFailure = "Upload failed"
		_onDidChangeInProgressItemCountEmitter = new H_.EventEmitter()
		onDidChangeInProgressItemCount = this._onDidChangeInProgressItemCountEmitter.event
		_onQuiescedEmitter = new H_.EventEmitter()
		_onQuiesced = this._onQuiescedEmitter.event
		_textDecoder = new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 })
		_toCalculate
		_toProbe
		_probeBatch
		_probeBatchSize
		_probeRetryWaiters
		_probeRetryKicker
		_probeRetryBackoffWaiters
		_probeRetryBackoffKicker
		_toUpload
		_uploadBatch
		_itemsInFlight = new Map()
		_seq = 1e3
		metrics = new NC("File metrics")
		_logger
		_stopping = !1
		_pathsAccepted = this.metrics.counterMetric("paths accepted")
		_pathsNotAccessible = this.metrics.counterMetric("paths not accessible")
		_nonFiles = this.metrics.counterMetric("not plain files")
		_largeFiles = this.metrics.counterMetric("large files")
		_blobNameCalculationFails = this.metrics.counterMetric("blob name calculation fails")
		_encodingErrors = this.metrics.counterMetric("encoding errors")
		_mtimeCacheHits = this.metrics.counterMetric("mtime cache hits")
		_mtimeCacheMisses = this.metrics.counterMetric("mtime cache misses")
		_probeBatches = this.metrics.counterMetric("probe batches")
		_blobNamesProbed = this.metrics.counterMetric("blob names probed")
		_filesRead = this.metrics.counterMetric("files read")
		_blobsUploaded = this.metrics.counterMetric("blobs uploaded")
		_ingestPathMs = this.metrics.timingMetric("ingestPath")
		_probeMs = this.metrics.timingMetric("probe")
		_statMs = this.metrics.timingMetric("stat")
		_readMs = this.metrics.timingMetric("read")
		_uploadMs = this.metrics.timingMetric("upload")
		stop() {
			this.dispose()
		}
		dispose() {
			;(this._stopping = !0), super.dispose()
		}
		get probeBatchSize() {
			return this._probeBatchSize
		}
		get itemsInFlight() {
			return this._itemsInFlight.size
		}
		ingestPath(r, n) {
			this._ingestPathMs.start(),
				!this._stopping && ((n = ume(n)), this._enqueueForCalculate(r, n), this._ingestPathMs.stop())
		}
		async awaitQuiesced() {
			if (!(this._stopping || this._itemsInFlight.size === 0)) return $p(this._onQuiesced)
		}
		_nextSeq() {
			return this._seq++
		}
		_makeAbsPath(r, n) {
			let i = this._pathMap.getRepoRoot(r)
			if (i !== void 0) return $t(i, n)
		}
		_fileTooLargeString(r) {
			return `File too large (${r} > ${this._pathHandler.maxBlobSize})`
		}
		_getMtime(r, n, i, s) {
			this._statMs.start()
			let o = this._pathHandler.classifyPath(r)
			switch ((this._statMs.stop(), o.type)) {
				case "inaccessible":
					this._pathsNotAccessible.increment(), this._pathMapInvalidate(n, i, s, this._fileNotAccessible)
					return
				case "not a file":
					this._nonFiles.increment(), this._pathMapInvalidate(n, i, s, this._notAPlainFile)
					return
				case "large file":
					this._largeFiles.increment(), this._pathMapInvalidate(n, i, s, this._fileTooLargeString(o.size))
					return
				case "accepted":
					return o.mtime
			}
		}
		async _readAndValidate(r, n, i, s) {
			this._readMs.start()
			let o = await this._pathHandler.readText(r)
			switch ((this._readMs.stop(), this._filesRead.increment(), o.type)) {
				case "inaccessible":
					this._pathsNotAccessible.increment(), this._pathMapInvalidate(n, i, s, this._fileNotAccessible)
					return
				case "large file":
					this._largeFiles.increment(), this._pathMapInvalidate(n, i, s, this._fileTooLargeString(o.size))
					return
				case "binary":
					this._pathMapInvalidate(n, i, s, this._fileNotText)
					return
				case "text":
					return o.contents
			}
		}
		_calculateBlobName(r, n, i, s) {
			try {
				return this._pathHandler.calculateBlobName(r, n)
			} catch (o) {
				if (o instanceof fE) {
					this._largeFiles.increment()
					let a = this._fileTooLargeString(n.length)
					this._pathMapInvalidate(i, r, s, a)
				} else this._blobNameCalculationFails.increment(), this._pathMapInvalidate(i, r, s, Ye(o))
				return
			}
		}
		async _calculate(r) {
			if (r === void 0) return
			let [n, [i, s]] = r
			if (!this._pathMapVerify(i, s, n)) return
			let o = this._makeAbsPath(i, s)
			if (o === void 0) {
				this._inflightItemRemove(n)
				return
			}
			let a = this._getMtime(o, i, s, n)
			if (a === void 0) return
			let l,
				c = this._pathMap.getBlobInfo(i, s, a)
			if (c !== void 0) {
				this._mtimeCacheHits.increment()
				let [f, p] = c
				if (p > 0) {
					this._pathMapUpdate(i, s, n, f, a)
					return
				}
				l = f
			} else {
				let f = await this._readAndValidate(o, i, s, n)
				if (
					f === void 0 ||
					(this._mtimeCacheMisses.increment(), (l = this._calculateBlobName(s, f, i, n)), l === void 0)
				)
					return
			}
			this._pathsAccepted.increment()
			let u = {
				folderId: i,
				relPath: s,
				blobName: l,
				mtime: a,
				startTime: Date.now(),
			}
			this._enqueueForProbeRetry(n, u)
		}
		_newProbeBatch() {
			return new d6(this._probeBatchSize)
		}
		_grabProbeBatch() {
			if (this._probeBatch.items.size === 0) return
			let r = this._probeBatch
			return (this._probeBatch = this._newProbeBatch()), r
		}
		async _probe(r) {
			if (r !== void 0) {
				let [o, a] = r
				if (
					!this._pathMapVerify(a.folderId, a.relPath, o) ||
					(this._probeBatch.addItem(o, a), !this._probeBatch.full)
				)
					return
			}
			let n = this._grabProbeBatch()
			if (n === void 0) return
			let i = new Set()
			for (let [o, a] of n.items) i.add(a.blobName)
			this._probeBatches.increment(),
				this._blobNamesProbed.increment(n.items.size),
				this._logger.verbose(`probe ${i.size} blobs`),
				this._probeMs.start()
			let s
			try {
				s = await xi(async () => this._apiServer.findMissing([...i]), this._logger)
			} catch {}
			if ((this._probeMs.stop(), s !== void 0)) {
				this._logger.verbose(
					`find-missing reported ${s.unknownBlobNames.length} unknown blob names and ${s.nonindexedBlobNames.length} nonindexed blob names.`,
				),
					s.unknownBlobNames.length > 0 &&
						(this._logger.verbose("unknown blob names:"),
						cg(this._logger, "verbose", s.unknownBlobNames, 5)),
					s.nonindexedBlobNames.length > 0 &&
						(this._logger.verbose("nonindexed blob names:"),
						cg(this._logger, "verbose", s.nonindexedBlobNames, 5))
				let o = new Set(s.unknownBlobNames),
					a = new Set(s.nonindexedBlobNames),
					l = this._beginUploadBatch()
				for (let [c, u] of n.items)
					this._pathMapVerify(u.folderId, u.relPath, c) &&
						(o.has(u.blobName)
							? this._enqueueForUpload(c, u.folderId, u.relPath, !1)
							: a.has(u.blobName)
								? this._enqueueForProbeRetry(c, u)
								: this._pathMapUpdate(u.folderId, u.relPath, c, u.blobName, u.mtime))
				l.dispose()
			} else for (let [o, a] of n.items) this._enqueueForProbeRetry(o, a)
		}
		_newUploadBatch() {
			return new u6(e.maxUploadBatchBlobCount, e.maxUploadBatchByteSize)
		}
		_grabUploadBatch() {
			if (this._uploadBatch.items.size === 0) return
			let r = this._uploadBatch
			return (this._uploadBatch = this._newUploadBatch()), r
		}
		async _upload(r) {
			let n
			if (r !== void 0) {
				let [a, { seq: l, folderId: c, relPath: u }] = r
				if (!this._pathMapVerify(c, u, l)) return
				let f = this._getMtime(a, c, u, l)
				if (f === void 0) return
				let p = await this._readAndValidate(a, c, u, l)
				if (p === void 0) return
				let g = this._calculateBlobName(u, p, c, l)
				if (g === void 0) return
				let m
				try {
					m = this._textDecoder.decode(p)
				} catch (C) {
					this._pathMapInvalidate(c, u, l, Ye(C)), this._encodingErrors.increment()
					return
				}
				let y = {
					seq: l,
					folderId: c,
					pathName: u,
					text: m,
					blobName: g,
					mtime: f,
					byteSize: p.length,
					metadata: [],
				}
				if (this._uploadBatch.addItem(g, y)) return
				n = y
			}
			let i = this._grabUploadBatch()
			if (i === void 0) return
			n !== void 0 && this._uploadBatch.addItem(n.blobName, n),
				this._logger.verbose(`upload ${i.items.size} blobs`)
			let s = new Array()
			for (let [a, l] of i.items) s.push(l[0])
			this._uploadMs.start()
			let o = await this._uploadBlobBatch(s)
			this._uploadMs.stop(), this._blobsUploaded.increment(o.size)
			for (let [a, l] of i.items) {
				let c = o.get(a)
				if (c === void 0)
					for (let u of l) this._pathMapInvalidate(u.folderId, u.pathName, u.seq, this._fileUploadFailure)
				else
					for (let u of l) {
						let f = {
							folderId: u.folderId,
							relPath: u.pathName,
							blobName: c,
							mtime: u.mtime,
							startTime: Date.now(),
						}
						this._enqueueForProbeRetry(u.seq, f)
					}
			}
		}
		async _uploadBlobBatch(r) {
			this._logger.verbose(`upload begin: ${r.length} blobs`)
			for (let s of r) this._logger.verbose(`    - ${s.folderId}:${s.pathName}; expected blob name ${s.blobName}`)
			let n
			try {
				n = await xi(async () => await this._apiServer.batchUpload(r), this._logger)
			} catch (s) {
				this._logger.error(`batch upload failed: ${Ye(s)}`)
			}
			let i = new Map()
			if (n !== void 0) for (let s = 0; s < n.blobNames.length; s++) i.set(r[s].blobName, n.blobNames[s])
			return await this._uploadBlobsSequentially(r, n?.blobNames.length ?? 0, i), i
		}
		async _uploadBlobsSequentially(r, n, i) {
			for (let s = n; s < r.length; s++) {
				let o = r[s]
				try {
					this._logger.verbose(`sequential upload of ${o.pathName} -> ${o.blobName}`)
					let a = await xi(
						async () => this._apiServer.memorize(o.pathName, o.text, o.blobName, []),
						this._logger,
					)
					i.set(o.blobName, a.blobName)
				} catch {}
			}
		}
		_inflightItemAdd(r, n, i) {
			this._itemsInFlight.set(r, [n, i])
		}
		_inflightItemRemove(r) {
			this._itemsInFlight.delete(r),
				this._onDidChangeInProgressItemCountEmitter.fire(this._itemsInFlight.size),
				this._itemsInFlight.size === 0 &&
					(this._logger.verbose("inflight items signaling empty"), this._onQuiescedEmitter.fire())
		}
		_pathMapVerify(r, n, i) {
			if (!this._pathMap.shouldTrack(r, n)) return this._inflightItemRemove(i), !1
			let s = this._pathMap.getContentSeq(r, n)
			return s !== void 0 && s >= i ? (this._inflightItemRemove(i), !1) : !0
		}
		_pathMapUpdate(r, n, i, s, o) {
			this._inflightItemRemove(i), this._pathMap.update(r, n, i, s, o)
		}
		_pathMapInvalidate(r, n, i, s) {
			this._logger.verbose(`path map invalidate: ${r}:${n} (${s})`),
				this._pathMap.markUntrackable(r, n, i, s),
				this._inflightItemRemove(i),
				this._pathMap.markUntrackable(r, n, i, s)
		}
		_enqueueForCalculate(r, n) {
			let i = this._nextSeq()
			this._inflightItemAdd(i, r, n),
				this._toCalculate.insert(i, [r, n]) ? this._toCalculate.kick() : this._inflightItemRemove(i)
		}
		_enqueueForProbe(r) {
			if (r === void 0) this._toProbe.kick()
			else {
				let [n, i] = r
				this._logger.verbose(`probe enqueue ${i.blobName} -> ${n}, ${i.folderId}:${i.relPath}`),
					this._toProbe.insert(n, i)
			}
			return Promise.resolve()
		}
		_beginUploadBatch() {
			return new H_.Disposable(() => this._toUpload.kick())
		}
		_enqueueForUpload(r, n, i, s = !0) {
			this._logger.verbose(`upload enqueue ${n}:${i} -> ${r}`)
			let o = this._makeAbsPath(n, i)
			if (o === void 0) {
				this._inflightItemRemove(r)
				return
			}
			let a = this._toUpload.get(o)
			if (a !== void 0) {
				let l = a.seq
				if (l > r) this._inflightItemRemove(l)
				else if (l < r) {
					this._inflightItemRemove(r)
					return
				}
			}
			this._toUpload.insert(o, { seq: r, folderId: n, relPath: i }, !0), s && this._toUpload.kick()
		}
		_enqueueForProbeRetry(r, n) {
			Date.now() - n.startTime < e.probeBackoffAfterMs
				? (this._logger.verbose(`probe-retry enqueue ${n.blobName} -> ${r}, ${n.folderId}:${n.relPath}`),
					this._probeRetryWaiters.insert(r, n))
				: (this._logger.verbose(
						`probe-retry enqueue backoff ${n.blobName} -> ${r}, ${n.folderId}:${n.relPath}`,
					),
					this._probeRetryBackoffWaiters.insert(r, n))
		}
	}
var pf = class {
		static cacheFileName = "mtime-cache.json"
		static tmpFileName = "mtime-cache.json.tmp"
	},
	f6 = class {
		constructor(t = hE) {
			this.namingVersion = t
		}
		entries = new Array()
	}
function lCt(e) {
	if (
		!(e.mtime === void 0 || typeof e.mtime != "number" || !e.mtime) &&
		!(e.name === void 0 || typeof e.name != "string" || !e.name)
	)
		return { mtime: e.mtime, name: e.name }
}
function cCt(e) {
	return $t(e, pf.cacheFileName)
}
function CN(e) {
	let t = cCt(e)
	return Pn(t)
}
async function pwe(e, t) {
	let r = $t(e, pf.cacheFileName),
		n = $t(t, pf.cacheFileName)
	await Su(t), await cW(r, n)
}
async function Awe(e, t) {
	let r = new Map(),
		n = X(`MtimeCache[${e}]`),
		i = $t(t, pf.cacheFileName)
	n.info(`reading blob name cache from ${i}`)
	try {
		let s = 0,
			o = await Fr(i),
			a = JSON.parse(o)
		if (a.namingVersion === void 0 || a.namingVersion !== hE)
			n.info(`blob naming version ${a.namingVersion} !== ${hE}`)
		else if (Array.isArray(a.entries))
			for (let [l, c] of a.entries) {
				let u = lCt(c)
				u !== void 0 && (r.set(l, { mtime: u.mtime, name: u.name }), s++)
			}
		n.info(`read ${s} entries from ${i}`)
	} catch (s) {
		let o = Ye(s)
		s instanceof Error && "code" in s && s.code === "ENOENT"
			? n.info(`no blob name cache found at ${i} (probably new source folder); error = ${o}`)
			: n.error(`failed to read blob name cache ${i}: ${o}`)
	}
	return r
}
var yN = class extends pf {
	constructor(r, n) {
		super()
		this._name = r
		this._cacheDirName = n
		;(this._cacheFileName = $t(this._cacheDirName, pf.cacheFileName)),
			(this._tmpFileName = $t(this._cacheDirName, pf.tmpFileName))
	}
	_cacheFileName
	_tmpFileName
	_logger = X("MTimeCacheWriter")
	get cacheFileName() {
		return this._cacheFileName
	}
	async write(r) {
		this._logger.debug(`persisting to ${this._cacheFileName}`)
		let n = new f6()
		for (let [i, s, o] of r) n.entries.push([i, { mtime: s, name: o }])
		await Su(this._cacheDirName),
			await Bu(this._tmpFileName, JSON.stringify(n, void 0, 4)),
			await cW(this._tmpFileName, this._cacheFileName),
			this._logger.debug(
				`persisted ${n.entries.length} entries at naming version ${hE} to ${this._cacheFileName}`,
			)
	}
}
var ywe = W(gs()),
	G_ = W(require("vscode"))
var mwe = require("console")
var h6 = class {
		constructor(t, r, n, i) {
			this.seq = t
			this.start = r
			this.length = n
			this.origLength = i
		}
		get end() {
			return this.start + this.length
		}
		get localShift() {
			return this.origLength - this.length
		}
	},
	UC = class e {
		constructor(t, r, n, i, s) {
			this.seq = t
			this.start = r
			this.length = n
			this.origStart = i
			this.origLength = s
		}
		static fromMod(t, r) {
			return new e(t.seq, t.start, t.length, t.start + r, t.origLength)
		}
		get end() {
			return this.start + this.length
		}
		get origEnd() {
			return this.origStart + this.origLength
		}
		setStart(t) {
			let r = this.start - t
			;(this.start -= r), (this.length += r), (this.origStart -= r), (this.origLength += r)
		}
		setEnd(t) {
			let r = t - this.end
			;(this.length += r), (this.origLength += r)
		}
	},
	OC = class e {
		static _logger = X("ChangeTracker")
		_modifications = []
		_seq = 0
		get seq() {
			return this._seq
		}
		get empty() {
			return this._modifications.length === 0
		}
		get length() {
			return this._modifications.length
		}
		translate(t, r) {
			let n = t + Math.max(r, 0),
				i = 0,
				s = 0
			for (; i < this._modifications.length && this._modifications[i].end < t; )
				(s += this._modifications[i].localShift), i++
			let a =
				(i === this._modifications.length || t < this._modifications[i].start
					? t
					: this._modifications[i].start) + s
			for (; i < this._modifications.length && this._modifications[i].end < n; )
				(s += this._modifications[i].localShift), i++
			let c =
				(i === this._modifications.length || n < this._modifications[i].start
					? n
					: this._modifications[i].start + this._modifications[i].origLength) + s
			return [a, c - a]
		}
		apply(t, r, n, i) {
			let s = 0,
				o,
				a,
				l,
				c = r,
				u = 0,
				f
			for (; s < this._modifications.length && this._modifications[s].end < r; ) s++
			if (((f = s), s < this._modifications.length && this._modifications[s].start <= r)) {
				;(o = this._modifications[s]), (a = o.length), (l = o.origLength)
				let p = c - o.start
				;(0, mwe.assert)(p <= o.length)
				let g = Math.min(o.length - p, n - u)
				;(a -= g), (u += g), (c = o.end), ++s
			} else (o = new h6(t, r, 0, 0)), (a = 0), (l = 0)
			for (; s < this._modifications.length && u < n; s++) {
				let p = this._modifications[s],
					g = p.start - c,
					m = Math.min(g, n - u)
				if (((l += m), (u += m), c + m < p.start)) break
				let y = Math.min(p.length, n - u)
				;(a += p.length - y), (u += y), (l += p.origLength), (c = p.end)
			}
			for (
				o.length = a + i,
					o.origLength = l + (n - u),
					o.seq = t,
					this._modifications.splice(f, s - f, o),
					s = f + 1;
				s < this._modifications.length;
				s++
			)
				this._modifications[s].start += i - n
			this._seq = t
		}
		merge(t) {
			for (let r of t._modifications) this.apply(r.seq, r.start, r.origLength, r.length)
		}
		advance() {
			for (let t of this._modifications) t.origLength = t.length
		}
		getEdits() {
			let t = [],
				r = 0
			for (let n of this._modifications)
				t.push(new UC(n.seq, n.start, n.length, n.start + r, n.origLength)), (r += n.localShift)
			return t
		}
		countChunks(t) {
			if (this._modifications.length === 0) return 0
			let r = this._modifications.at(-1).end
			return this.getChunks(t, r).length
		}
		getChunks(t, r) {
			if (this._modifications.length === 0) return []
			let n = new Array(),
				i,
				s = 0
			for (let a of this._modifications) {
				let l = UC.fromMod(a, s)
				if (
					((s += a.localShift),
					i !== void 0 &&
						(l.start - i.start >= t || (l.end - i.start > t && l.length <= t)) &&
						(n.push(i), (i = void 0)),
					i === void 0)
				)
					i = new UC(l.seq, l.start, 0, l.origStart, 0)
				else {
					let f = l.start - i.end
					;(i.length += f), (i.origLength += f)
				}
				let c = l.length,
					u = Math.min(c, t - i.length)
				;(i.length += u), (i.origLength += l.origLength), (i.seq = Math.max(i.seq, l.seq))
				for (let f = u; f < c; f += u) {
					n.push(i)
					let p = l.start + f
					;(i = new UC(l.seq, p, 0, l.origEnd, 0)), (u = Math.min(c - f, t)), (i.length += u)
				}
			}
			return i !== void 0 && n.push(i), this._widen(n, t, r), this._validateChunks(n)
		}
		_widen(t, r, n) {
			let i = 0
			for (let s = 0; s < t.length; s++) {
				let o = t[s],
					a = s + 1 === t.length ? n : t[s + 1].start,
					l = r - o.length,
					c,
					u,
					f = Math.floor(o.start - l / 2)
				f <= i ? ((c = i), (u = Math.min(c + r, a))) : ((u = Math.min(f + r, a)), (c = Math.max(u - r, i))),
					o.setStart(c),
					o.setEnd(u),
					(i = u)
			}
		}
		_validateChunks(t) {
			let r = new Array()
			for (let n of t) n.origStart > n.origEnd ? e._logger.error("invalid chunk: ", JSON.stringify(n)) : r.push(n)
			return r
		}
	}
var Cwe = 6,
	vwe = 6,
	W_ = Cwe * vwe,
	uCt = 1e3,
	dCt = 2e3,
	fCt = 60 * 1e3,
	hCt = 200,
	gCt = 30 * 1e3,
	pCt = 30 * 1e3,
	ACt = 60 * 1e3,
	vN = class {
		constructor(t, r, n, i) {
			this.folderId = t
			this.pathName = r
			this.key = n
			this.appliedSeq = i
			;(this.recentChangesets = new Gc(vwe)), this.addChangeset(i), (this.changesSinceUpload = new OC())
		}
		uploadedBlobName
		uploadedSeq
		recentChangesets
		changesSinceUpload
		uploadRequested = !1
		inProgressUpload
		_embargoed = !1
		invalidateUploadState() {
			;(this.uploadedBlobName = void 0), (this.uploadedSeq = void 0)
		}
		_clear() {
			;(this.uploadedBlobName = void 0),
				(this.uploadedSeq = void 0),
				this.recentChangesets.clear(),
				(this.changesSinceUpload = void 0),
				(this.uploadRequested = !1),
				(this.inProgressUpload = void 0)
		}
		embargo() {
			this._clear(), (this._embargoed = !0)
		}
		get embargoed() {
			return this._embargoed
		}
		get uploadInProgress() {
			return this.inProgressUpload !== void 0
		}
		getBlobName() {
			return this.recentChanges(!1)?.blobName
		}
		longestHistory(t) {
			if (this.uploadedSeq === void 0) return
			let r = this.recentChangesets.at(0)
			if (r !== void 0) {
				if (t)
					return {
						changeTracker: r.changeTracker,
						blobName: this.uploadedBlobName,
					}
				if (this.uploadedBlobName !== void 0 && !(r.initialSeq > this.uploadedSeq))
					return {
						changeTracker: r.changeTracker,
						blobName: this.uploadedBlobName,
					}
			}
		}
		recentChanges(t) {
			return this.inProgressUpload !== void 0 ? this.inProgressUpload.savedChangeset : this.longestHistory(t)
		}
		applyAll(t, r, n, i) {
			for (let s of this.recentChangesets) s.changeTracker.apply(t, r, n, i)
			this.appliedSeq = t
		}
		advanceAll() {
			for (let t of this.recentChangesets) t.changeTracker.advance()
		}
		addChangeset(t) {
			this.recentChangesets.addItem({ initialSeq: t, changeTracker: new OC() })
		}
		purgeChangesets(t) {
			let r = 0
			for (
				;
				!this.recentChangesets.empty && !((this.recentChangesets.at(1)?.initialSeq ?? this.appliedSeq) >= t);

			)
				this.recentChangesets.shiftLeft(1), r++
			return r
		}
	},
	g6 = class extends vN {
		constructor(r, n, i, s, o) {
			super(r, n, i, o)
			this.document = s
		}
		get documentType() {
			return 0
		}
		getText() {
			return this.document.getText()
		}
	},
	p6 = class extends vN {
		constructor(r, n, i, s, o) {
			super(r, n, i, o)
			this.document = s
		}
		get documentType() {
			return 1
		}
		getText() {
			return _G(this.document)
		}
	}
function mCt(e) {
	return e.getCells !== void 0
}
function yCt(e) {
	return mCt(e) ? e : Tbe(e)
}
var EN = class e extends z {
	constructor(r, n, i, s, o, a) {
		super()
		this._apiServer = r
		this._completionServer = n
		this._configListener = i
		this._blobNameCalculator = s
		this._pathMap = o
		this._sequenceGenerator = a
		;(this._logger = X("OpenFileManager")),
			(this._uploadQueue = new Ia(this._upload.bind(this))),
			this.addDisposable(this._uploadQueue),
			(this._verifyWaiters = new Ia(this._enqueueForVerify.bind(this))),
			this.addDisposable(this._verifyWaiters),
			(this._verifyWaitersKicker = new vc(this._verifyWaiters, dCt)),
			this.addDisposable(this._verifyWaitersKicker),
			(this._longWaiters = new Ia(this._enqueueForVerify.bind(this))),
			this.addDisposable(this._longWaiters),
			(this._longWaitersKicker = new vc(this._longWaiters, fCt)),
			this.addDisposable(this._longWaitersKicker),
			(this._verifyQueue = new Ia(this._verify.bind(this))),
			this.addDisposable(this._verifyQueue)
	}
	_trackedFolders = new Map()
	_uploadQueue
	_verifyWaiters
	_longWaiters
	_verifyWaitersKicker
	_longWaitersKicker
	_verifyQueue
	_verifyBatch = new Map()
	_prevUpdatedDocument
	_logger
	openSourceFolder(r) {
		if (this._trackedFolders.has(r)) throw new Error(`Source folder ${r} is already open`)
		return (
			this._trackedFolders.set(r, new Map()),
			this._logger.info(`Opened source folder ${r}`),
			new G_.Disposable(() => {
				this._closeSourceFolder(r)
			})
		)
	}
	_closeSourceFolder(r) {
		this._trackedFolders.delete(r), this._logger.info(`Closed source folder ${r}`)
	}
	startTracking(r, n, i) {
		this._trackDocument(r, n, i)
	}
	stopTracking(r, n, i) {
		let s = this._getFolder(r)
		if (s === void 0) return
		let o = s.get(n)
		o !== void 0 &&
			((i !== void 0 && o.documentType !== i) ||
				(s.delete(n),
				this._prevUpdatedDocument === o && (this._prevUpdatedDocument = void 0),
				this._logger.verbose(`stop tracking ${r}:${n}`)))
	}
	isTracked(r, n) {
		return this._getDocument(r, n) !== void 0
	}
	getTrackedPaths(r) {
		let n = this._getFolder(r)
		return n === void 0 ? new Array() : Array.from(n.keys())
	}
	loseFocus() {
		this._setFocus(void 0)
	}
	get _chunkSize() {
		return this._completionServer.completionParams.chunkSize
	}
	_getFolder(r) {
		return this._trackedFolders.get(r)
	}
	_getDocument(r, n, i) {
		let s = typeof r == "number" ? this._getFolder(r) : r
		if (s === void 0) return
		let o = s.get(n)
		if (o !== void 0 && !(i !== void 0 && o.key !== i)) return o
	}
	getBlobName(r, n) {
		return this._getDocument(r, n)?.getBlobName()
	}
	translateRange(r) {
		let n = this._getDocument(r.folderId, r.relPath)
		if (n === void 0 || n.uploadedBlobName === void 0) return
		let i = n.changesSinceUpload
		if (i === void 0) return
		let s = i.translate(r.beginOffset, r.endOffset - r.beginOffset)
		return {
			blobName: n.uploadedBlobName,
			beginOffset: s[0],
			endOffset: s[0] + s[1],
		}
	}
	notifyMissingBlob(r, n, i) {
		let s = this._getDocument(r, n)
		return s === void 0 || s.uploadedBlobName !== i
			? !1
			: (s.invalidateUploadState(), this._tryEnqueueUpload(r, n, "blob name reported missing", s), !0)
	}
	getRecencySummary(r) {
		let n = new Map(),
			i = new Array()
		for (let [s, o] of this._trackedFolders) {
			let a = new Map()
			n.set(s, a)
			for (let [l, c] of o) {
				if (c.embargoed || c.uploadedSeq === void 0) continue
				let u = c.recentChanges(!1)
				if (u === void 0 || u.blobName === void 0) continue
				a.set(l, u.blobName)
				let f = c.getText(),
					p = u.changeTracker.getChunks(r, f.length)
				if (p.length === 0) continue
				let g = this._blobNameCalculator.calculateNoThrow(l, f)
				for (let m of p)
					i.push({
						seq: m.seq,
						uploaded: m.seq <= c.uploadedSeq,
						folderId: s,
						pathName: l,
						blobName: u.blobName,
						text: f.slice(m.start, m.end),
						origStart: m.origStart,
						origLength: m.origLength,
						expectedBlobName: g,
					})
			}
		}
		return i.sort(e._compareChunks), { folderMap: n, recentChunks: i }
	}
	getRecentChunkInfo(r, n = !1) {
		let i = new Array()
		for (let [s, o] of this._trackedFolders)
			for (let [a, l] of o) {
				if (l.embargoed || l.uploadedSeq === void 0) continue
				let c = l.recentChanges(n)
				if (c === void 0) continue
				let u = c.changeTracker.getChunks(r, l.getText().length)
				if (u.length !== 0)
					for (let f of u)
						i.push({
							seq: f.seq,
							uploaded: f.seq <= l.uploadedSeq,
							folderId: s,
							pathName: a,
							blobName: c.blobName,
						})
			}
		return i.sort(e._compareChunks), i
	}
	static _compareChunks(r, n) {
		return r.uploaded === n.uploaded ? n.seq - r.seq : r.uploaded ? 1 : -1
	}
	applyTextDocumentChange(r, n, i) {
		let s = this._getDocument(r, n)
		if (s === void 0) {
			this._trackDocument(r, n, i.document)
			return
		}
		if (!this._prepareForUpdate(s) || i.contentChanges.length === 0) return
		let o = i.contentChanges.map((a) => [a.rangeOffset, a.rangeLength, a.text.length])
		this._applyChangedRanges(r, n, s, o)
	}
	applyNotebookChange(r, n, i) {
		let s = this._getDocument(r, n)
		if (s === void 0) {
			this._trackDocument(r, n, i.notebook)
			return
		}
		if (!this._prepareForUpdate(s) || i.contentChanges.length === 0) return
		let o = i.notebook.getCells().slice(),
			a = new Array()
		i.contentChanges
			.slice()
			.reverse()
			.forEach((l) => {
				o.splice(l.range.start, l.addedCells.length), o.splice(l.range.start, 0, ...l.removedCells)
				let c = o.slice(0, l.range.start).every((y) => y.kind === G_.NotebookCellKind.Markup),
					u = o.slice(l.range.end).every((y) => y.kind === G_.NotebookCellKind.Markup),
					f = Gy(o.slice(0, l.range.start)).length
				f > 0 && !c && !u && (f += l_.length)
				let p = !c || !u ? l_.length : 0,
					g = Gy(l.addedCells).length
				g > 0 && (g += p)
				let m = Gy(l.removedCells).length
				m > 0 && (m += p), (g > 0 || m > 0) && a.push([f, m, g])
			}),
			a.reverse(),
			this._applyChangedRanges(r, n, s, a)
	}
	_setFocus(r) {
		this._prevUpdatedDocument !== void 0 &&
			r !== this._prevUpdatedDocument &&
			(this._tryEnqueueUpload(
				this._prevUpdatedDocument.folderId,
				this._prevUpdatedDocument.pathName,
				"document lost focus",
			),
			this._purgeUnneededChangesets()),
			(this._prevUpdatedDocument = r)
	}
	_trackDocument(r, n, i) {
		let s = this._getFolder(r)
		if (s === void 0) throw new Error(`Source folder ${r} is not open`)
		let o = this._getDocument(s, n)
		if ((this._setFocus(o), o !== void 0)) return
		let a = this._sequenceGenerator.next(),
			l = yCt(i)
		if (l === void 0) {
			let p = i
			o = new g6(r, n, a, p, a)
		} else o = new p6(r, n, a, l, a)
		s.set(n, o)
		let c = o.getText(),
			u = this._blobNameCalculator.calculate(n, c)
		if (u === void 0) {
			this._embargo(r, n, o, "blob name calculation failed")
			return
		}
		this._pathMap.getAnyPathName(u) === void 0
			? this._tryEnqueueUpload(r, n, "new document has no blob name", o)
			: ((o.uploadedBlobName = u), (o.uploadedSeq = o.appliedSeq)),
			this._logger.verbose(`start tracking ${r}:${n}`)
	}
	_prepareForUpdate(r) {
		return this._setFocus(r), !r.embargoed
	}
	_applyChangedRanges(r, n, i, s) {
		let o = this._sequenceGenerator.next()
		i.recentChangesets.empty &&
			(i.addChangeset(o),
			this._logger.verbose(`apply: new changeset for ${r}:${n}; total = ${i.recentChangesets.length}`))
		let a = i.inProgressUpload
		for (let u of s) {
			let [f, p, g] = u
			a !== void 0 &&
				(a.savedChangeset !== void 0 && a.savedChangeset.changeTracker.apply(o, f, p, g),
				a.changesSinceUpload.apply(o, f, p, g)),
				i.applyAll(o, f, p, g),
				i.changesSinceUpload?.apply(o, f, p, g)
		}
		if (((i.appliedSeq = o), a !== void 0)) {
			let u = a.changesSinceUpload.length >= hCt
			u || (u = a.changesSinceUpload.countChunks(this._chunkSize) >= W_),
				u && this._cancelInProgressUpload(r, n, i)
		}
		if (i.changesSinceUpload !== void 0) {
			let u = i.changesSinceUpload.countChunks(this._chunkSize)
			u > 1 && this._tryEnqueueUpload(r, n, "multiple non-uploaded chunks", i),
				u >= W_ &&
					(this._logger.verbose(`apply: no longer tracking non-uploaded changes for ${r}:${n}`),
					(i.changesSinceUpload = void 0))
		}
		let c = i.recentChangesets.at(-1).changeTracker.countChunks(this._chunkSize)
		c >= Cwe &&
			(i.addChangeset(o),
			this._logger.verbose(
				`apply: new changeset for ${r}:${n}; chunks = ${c}; total = ${i.recentChangesets.length}`,
			))
	}
	_cancelInProgressUpload(r, n, i) {
		this._logger.verbose(`cancel in-progress upload: ${r}:${n}`),
			(i.inProgressUpload = void 0),
			(i.key = this._sequenceGenerator.next())
	}
	_validateInProgressUpload(r, n, i) {
		let s = this._getDocument(r, n, i)
		if (!(s === void 0 || s.inProgressUpload === void 0)) return [s, s.inProgressUpload]
	}
	_tryEnqueueUpload(r, n, i, s) {
		let o = s ?? this._getDocument(r, n)
		o !== void 0 &&
			(o.uploadRequested ||
				(o.appliedSeq !== o.uploadedSeq &&
					o.appliedSeq !== o.inProgressUpload?.uploadSeq &&
					(this._logger.verbose(`upload request: ${r}:${n}; reason = ${i}`),
					(o.uploadRequested = !0),
					o.uploadInProgress
						? this._logger.verbose(`upload request delayed: upload for ${r}:${n} already in progress`)
						: this._enqueueUpload(r, n, o.key))))
	}
	_retryUpload(r, n) {
		this._logger.verbose(`retry upload; ${r}:${n}`)
		let i = this._getDocument(r, n)
		if (i === void 0) {
			this._logger.verbose(`retry upload: document is no longer tracked; ${r}:${n}`)
			return
		}
		if (i.inProgressUpload !== void 0) {
			this._logger.verbose(`retry upload: upload already in progress; ${r}:${n}`)
			return
		}
		;(i.uploadRequested = !0), this._enqueueUpload(r, n, i.key)
	}
	_enqueueUpload(r, n, i) {
		this._uploadQueue.insert([r, n, i]) &&
			(this._logger.verbose(`enqueue upload: ${r}:${n}`), this._uploadQueue.kick())
	}
	async _upload(r) {
		if (r === void 0) return
		let [n, i, s] = r,
			o = this._getDocument(n, i, s)
		if (o === void 0) {
			this._logger.verbose(`upload: upload cancelled or no longer tracking document ${n}:${i}`)
			return
		}
		o.uploadRequested = !1
		let a = o.getText(),
			l = this._blobNameCalculator.calculate(i, a)
		if (l === void 0) {
			this._embargo(n, i, o, "failed to compute blob name")
			return
		}
		let c = o.longestHistory(!1),
			u =
				c === void 0 || c.blobName === void 0
					? void 0
					: {
							changeTracker: (0, ywe.cloneDeep)(c.changeTracker),
							blobName: c.blobName,
						}
		;(o.inProgressUpload = {
			uploadSeq: o.appliedSeq,
			blobName: l,
			savedChangeset: u,
			changesSinceUpload: new OC(),
		}),
			o.advanceAll(),
			(o.uploadedBlobName = void 0)
		let f
		try {
			this._logger.verbose(`upload: begin; ${n}:${i}, ${l}`)
			let g = Date.now()
			f = await xi(async () => {
				if (!(Date.now() - g > gCt) && this._validateInProgressUpload(n, i, s))
					return this._apiServer.memorize(i, a, l, [])
			}, this._logger)
		} catch (g) {
			return (
				this._logger.verbose(`upload: failed; ${n}:${i}, ${l}; ${Ye(g)};`),
				this._embargo(n, i, o, `upload encountered permanent error: ${Ye(g)}`)
			)
		}
		if (!this._validateInProgressUpload(n, i, s))
			return this._logger.verbose(`upload: upload cancelled; pathName = ${n}:${i}`), this._retryUpload(n, i)
		if (f === void 0)
			return (
				this._logger.verbose(`upload: upload timed out, cancelling; pathName = ${n}:${i}`),
				this._cancelInProgressUpload(n, i, o),
				this._retryUpload(n, i)
			)
		let p = f.blobName
		p === l
			? this._logger.verbose(`upload: completed; ${n}:${i}, ${p}`)
			: this._logger.error(
					`upload: completed with mismatched blobName; pathName, received, expected = ${n}:${i}, ${p}, ${l}`,
				),
			(o.inProgressUpload.blobName = p),
			this._enqueueVerifyWaiter({ folderId: n, pathName: i, key: s, startTime: Date.now() }, p)
	}
	_requeueVerifyWaiter(r, n) {
		let i = r.folderId,
			s = r.pathName
		if (!this._validateInProgressUpload(i, s, r.key))
			return (
				this._logger.verbose(`requeue verify-wait: upload cancelled; ${i}:${s}, ${n}`), this._retryUpload(i, s)
			)
		Date.now() - r.startTime > ACt
			? (this._logger.verbose(`verify-wait: enqueue long; pathName = ${i}:${s}`), this._longWaiters.insert(r))
			: this._enqueueVerifyWaiter(r, n)
	}
	_enqueueVerifyWaiter(r, n) {
		this._logger.verbose(`verify-wait: enqueue; ${r.folderId}:${r.pathName}, ${n}`), this._verifyWaiters.insert(r)
	}
	_enqueueForVerify(r) {
		return r === void 0
			? (this._verifyQueue.kick(), Promise.resolve())
			: (this._verifyQueue.insert(r), Promise.resolve())
	}
	_grabVerifyBatch() {
		if (this._verifyBatch.size === 0) return
		let r = this._verifyBatch
		return (this._verifyBatch = new Map()), r
	}
	async _verify(r) {
		if (r !== void 0) {
			let o = this._getDocument(r.folderId, r.pathName, r.key)
			if (o === void 0 || o.inProgressUpload === void 0) return
			let a = this._verifyBatch.get(o.inProgressUpload.blobName)
			if (
				(a === void 0 && ((a = new Array()), this._verifyBatch.set(o.inProgressUpload.blobName, a)),
				a.push(r),
				this._verifyBatch.size < uCt)
			)
				return
		}
		let n = this._grabVerifyBatch()
		if (n === void 0) return
		let i = [...n.keys()]
		this._logger.verbose(`verify batch: blob count = ${i.length}`)
		let s
		try {
			let o = Date.now()
			s = await xi(async () => {
				if (!(Date.now() - o > pCt)) return this._apiServer.findMissing(i)
			}, this._logger)
		} catch {}
		if (s === void 0) {
			this._logger.verbose("verify: timeout exceeded")
			for (let o of i) {
				let a = n.get(o)
				for (let l of a) this._requeueVerifyWaiter(l, o)
			}
		} else {
			this._logVerifyResult(s)
			let o = new Set(s.unknownBlobNames),
				a = new Set(s.nonindexedBlobNames)
			for (let [l, c] of n)
				if (o.has(l)) for (let u of c) this.notifyMissingBlob(u.folderId, u.pathName, l)
				else if (a.has(l)) for (let u of c) this._requeueVerifyWaiter(u, l)
				else for (let u of c) this._commit(u, l)
		}
	}
	_commit(r, n) {
		let i = r.folderId,
			s = r.pathName,
			o = this._validateInProgressUpload(i, s, r.key)
		if (o === void 0) {
			this._logger.verbose(`commit: upload cancelled for ${i}:${s}`)
			return
		}
		let [a, l] = o
		;(a.inProgressUpload = void 0),
			this._logger.verbose(`commit: ${i}:${s}, ${n}; uploadSeq = ${l.uploadSeq}`),
			(a.uploadedBlobName = n),
			(a.uploadedSeq = l.uploadSeq),
			(a.changesSinceUpload = l.changesSinceUpload),
			a.uploadRequested && this._retryUpload(r.folderId, r.pathName)
	}
	_purgeUnneededChangesets() {
		let r = this.getRecentChunkInfo(this._chunkSize, !0)
		if (r.length < W_) return
		let n = r[W_ - 1].seq,
			i = new Set()
		for (let s = W_; s < r.length; s++) {
			let o = this._getDocument(r[s].folderId, r[s].pathName)
			o !== void 0 && i.add(o)
		}
		for (let s of i) {
			if (s === void 0) continue
			let o = s.purgeChangesets(n)
			o > 0 && this._logger.verbose(`purge: removed ${o} changesets from ${s.folderId}:${s.pathName}`)
		}
	}
	_embargo(r, n, i, s) {
		this._logger.info(`embargoing: ${r}:${n} reason = ${s}`), i.embargo()
	}
	_logVerifyResult(r) {
		let n = r.unknownBlobNames.length > 0 ? "error" : "verbose"
		this._logger.log(
			n,
			`find-missing reported ${r.unknownBlobNames.length} unknown blob names and ${r.nonindexedBlobNames.length} nonindexed blob names.`,
		),
			r.unknownBlobNames.length > 0 &&
				(this._logger.log(n, "unknown blob names:"), cg(this._logger, n, r.unknownBlobNames, 5)),
			r.nonindexedBlobNames.length > 0 &&
				(this._logger.log(n, "nonindexed blob names:"), cg(this._logger, n, r.nonindexedBlobNames, 5))
	}
}
var Ewe = require("buffer")
var bN = class {
	constructor(t, r) {
		this._fileReader = r
		this._blobNameCalculator = new Hf(t)
	}
	_blobNameCalculator
	get maxBlobSize() {
		return this._blobNameCalculator.maxBlobSize
	}
	classifyPath(t) {
		let r = this._fileReader.stat(t)
		return r
			? r.type !== "File"
				? { type: "not a file", mtime: r.mtime }
				: r.size > this._blobNameCalculator.maxBlobSize
					? { type: "large file", mtime: r.mtime, size: r.size }
					: { type: "accepted", size: r.size, mtime: r.mtime }
			: { type: "inaccessible" }
	}
	async readText(t) {
		let r
		try {
			if (((r = await this._fileReader.read(t)), r === void 0)) return { type: "inaccessible" }
		} catch {
			return { type: "inaccessible" }
		}
		return (0, Ewe.isUtf8)(r)
			? r.length > this._blobNameCalculator.maxBlobSize
				? { type: "large file", size: r.length }
				: { type: "text", contents: r }
			: { type: "binary" }
	}
	calculateBlobName(t, r) {
		return this._blobNameCalculator.calculateOrThrow(t, r)
	}
}
var xN = W(require("vscode"))
var _N = class {
		_nextFolderId = 100
		_sourceFolders = new Map()
		_blobNameChangedEmitter = new xN.EventEmitter()
		_nextEntryTS = 1e3
		_logger = X("PathMap")
		constructor() {}
		dispose() {
			for (let [t, r] of this._sourceFolders) r.dispose()
		}
		get nextEntryTS() {
			return this._nextEntryTS
		}
		get onDidChangeBlobName() {
			return this._blobNameChangedEmitter.event
		}
		onDidChangePathStatus(t) {
			return this._sourceFolders.get(t)?.onDidChangePathStatus
		}
		openSourceFolder(t, r) {
			for (let [o, a] of this._sourceFolders) {
				if (Iy(a.folderRoot, t)) throw new Error(`Source folder ${t} is already open`)
				if (Ss(t, a.folderRoot)) throw new Error(`Source folder ${t} contains ${a.folderRoot}`)
				if (Ss(a.folderRoot, t)) throw new Error(`Source folder ${a.folderRoot} contains ${t}`)
			}
			let n = this._nextFolderId++,
				i = new A6(t, r)
			this._sourceFolders.set(n, i)
			let s = i.onDidChangeBlobName(this._handleBlobNameChangeEvent.bind(this))
			return i.addDisposable(s), this._logger.info(`Opened source folder ${t} with id ${n}`), n
		}
		closeSourceFolder(t) {
			let r = this._sourceFolders.get(t)
			if (r === void 0) return
			r.clear()
			let n = r.folderRoot
			this._sourceFolders.delete(t), r.dispose(), this._logger.info(`Closed source folder ${n} with id ${t}`)
		}
		_handleBlobNameChangeEvent(t) {
			this._blobNameChangedEmitter.fire(t)
		}
		getRepoRoot(t) {
			return this._sourceFolders.get(t)?.repoRoot
		}
		hasFile(t, r) {
			return this._sourceFolders.get(t)?.hasFile(r) ?? !1
		}
		getBlobName(t, r) {
			return this._sourceFolders.get(t)?.getBlobName(r)
		}
		getBlobInfo(t, r, n) {
			return this._sourceFolders.get(t)?.getBlobInfo(r, n)
		}
		getAnyPathName(t) {
			for (let r of this._sourceFolders.values()) {
				let n = r.getPathName(t)
				if (n !== void 0) return this._makeQualifiedPathName(r, n)
			}
		}
		getAllPathNames(t) {
			let r = new Array()
			for (let n of this._sourceFolders.values()) {
				let i = n.getPathName(t)
				i !== void 0 && r.push(new Je(n.repoRoot, i))
			}
			return r
		}
		getUniquePathCount(t) {
			let r = 0
			for (let n of this._sourceFolders.values()) n.getPathName(t) !== void 0 && r++
			return r
		}
		getAllQualifiedPathNames(t) {
			return this.getAllQualifiedPathInfos(t).map((r) => r.qualifiedPathName)
		}
		getAllQualifiedPathInfos(t) {
			let r = new Array()
			for (let n of this._sourceFolders.values()) {
				let i = n.getPathInfo(t)
				if (i !== void 0) {
					let [s, o] = i
					r.push({
						qualifiedPathName: new Je(n.repoRoot, t),
						fileType: s,
						isAccepted: o.accepted,
					})
				}
			}
			return r
		}
		getAllPathInfo(t) {
			let r = new Array()
			for (let n of this._sourceFolders.values()) {
				let i = n.getPathName(t)
				i !== void 0 && r.push([n.folderRoot, n.repoRoot, i])
			}
			return r
		}
		getPathInfo(t, r) {
			return this._sourceFolders.get(t)?.getPathInfo(r)
		}
		reportMissing(t) {
			for (let r of this._sourceFolders.values()) {
				let n = r.reportMissing(t)
				if (n !== void 0) return this._makeQualifiedPathName(r, n)
			}
		}
		insert(t, r, n, i) {
			let s = this._nextEntryTS++
			this._sourceFolders.get(t)?.insert(r, s, n, i)
		}
		remove(t, r) {
			this._sourceFolders.get(t)?.remove(r)
		}
		shouldTrack(t, r) {
			return this._sourceFolders.get(t)?.shouldTrack(r) ?? !1
		}
		getContentSeq(t, r) {
			return this._sourceFolders.get(t)?.getContentSeq(r)
		}
		update(t, r, n, i, s) {
			this._sourceFolders.get(t)?.update(r, n, i, s)
		}
		markUntrackable(t, r, n, i) {
			this._sourceFolders.get(t)?.markUntrackable(r, n, i)
		}
		purge(t, r) {
			this._sourceFolders.get(t)?.purge(r)
		}
		*pathsWithBlobNames() {
			for (let [t, r] of this._sourceFolders)
				for (let [n, i, s] of r.pathsWithBlobNames()) yield [t, r.repoRoot, n, i, s]
		}
		*pathsInFolder(t) {
			let r = this._sourceFolders.get(t)
			r !== void 0 && (yield* r.allPaths())
		}
		enablePersist(t, r, n) {
			this._sourceFolders.get(t)?.enablePersist(r, n)
		}
		_makeQualifiedPathName(t, r) {
			return new Je(t.repoRoot, r)
		}
		trackedFileCount(t) {
			return this._sourceFolders.get(t)?.trackedFileCount ?? 0
		}
		getFolderIds() {
			return Array.from(this._sourceFolders.keys())
		}
	},
	A6 = class extends z {
		constructor(r, n) {
			super()
			this.folderRoot = r
			this.repoRoot = n
		}
		static defaultPersistThreshold = 100
		_allPathNames = new Map()
		_trackableFilePaths = new Set()
		_blobNameToPathName = new Map()
		_persistState = void 0
		_pathStatusChangedEmitter = new xN.EventEmitter()
		_blobNameChangedEmitter = new xN.EventEmitter()
		get onDidChangePathStatus() {
			return this._pathStatusChangedEmitter.event
		}
		get onDidChangeBlobName() {
			return this._blobNameChangedEmitter.event
		}
		get trackedFileCount() {
			return this._trackableFilePaths.size
		}
		shouldTrack(r) {
			let n = this._allPathNames.get(r)
			return n === void 0 ? !1 : n.fileType === "File" && n.pathAcceptance.accepted
		}
		getContentSeq(r) {
			return this._allPathNames.get(r)?.fileInfo?.contentSeq
		}
		insert(r, n, i, s) {
			let o = this._allPathNames.get(r),
				a = o === void 0 || o.fileType !== i || o.pathAcceptance.format() !== s.format()
			if (o === void 0) (o = { entryTS: n, fileType: i, pathAcceptance: s }), this._allPathNames.set(r, o)
			else {
				let l = o.fileInfo
				;(o.entryTS = n),
					(o.fileType = i),
					(o.pathAcceptance = s),
					s.accepted ||
						((o.fileInfo = void 0),
						l?.trackable &&
							(this._blobNameToPathName.delete(l.blobName),
							this._publishBlobNameChange(r, l.blobName, void 0),
							this._markDirty()))
			}
			o.fileType === "File" && o.pathAcceptance.accepted && o.fileInfo?.trackable !== !1
				? this._trackableFilePaths.add(r)
				: this._trackableFilePaths.delete(r),
				a && this._pathStatusChangedEmitter.fire({ relPath: r })
		}
		remove(r) {
			let n = this._allPathNames.get(r)
			if (n !== void 0) {
				if (
					(this._allPathNames.delete(r),
					this._trackableFilePaths.delete(r),
					n.fileInfo !== void 0 && n.fileInfo.trackable)
				) {
					let i = n.fileInfo.blobName
					this._blobNameToPathName.delete(i), this._publishBlobNameChange(r, i, void 0), this._markDirty()
				}
				this._pathStatusChangedEmitter.fire({ relPath: r })
			}
		}
		clear() {
			for (let [r, n] of this._allPathNames)
				n.fileInfo !== void 0 &&
					n.fileInfo.trackable &&
					this._publishBlobNameChange(r, n.fileInfo.blobName, void 0)
			this._allPathNames.clear(),
				this._trackableFilePaths.clear(),
				this._blobNameToPathName.clear(),
				this._markDirty()
		}
		update(r, n, i, s) {
			let o = this._allPathNames.get(r)
			if (
				o === void 0 ||
				o.fileType !== "File" ||
				!o.pathAcceptance.accepted ||
				(o.fileInfo !== void 0 && o.fileInfo.contentSeq > n)
			)
				return
			let a = o.fileInfo === void 0 ? !0 : o.fileInfo.trackable,
				l
			o.fileInfo?.trackable && (l = o.fileInfo.blobName),
				(o.fileInfo = { trackable: !0, contentSeq: n, blobName: i, mtime: s }),
				this._trackableFilePaths.add(r),
				i !== l &&
					(l !== void 0 && this._blobNameToPathName.delete(l),
					this._blobNameToPathName.set(i, r),
					this._publishBlobNameChange(r, l, i),
					this._markDirty()),
				(!a || l === void 0) && this._pathStatusChangedEmitter.fire({ relPath: r })
		}
		markUntrackable(r, n, i) {
			let s = this._allPathNames.get(r)
			if (
				s === void 0 ||
				s.fileType !== "File" ||
				!s.pathAcceptance.accepted ||
				(s.fileInfo !== void 0 && s.fileInfo.contentSeq > n)
			)
				return
			let o = s.fileInfo
			;(s.fileInfo = { trackable: !1, contentSeq: n, reason: i }), this._trackableFilePaths.delete(r)
			let a = !1
			if (o === void 0) a = !0
			else if (o.trackable === !0) {
				a = !0
				let l = o.blobName
				this._blobNameToPathName.delete(l), this._publishBlobNameChange(r, l, void 0), this._markDirty()
			} else a = i !== o.reason
			a && this._pathStatusChangedEmitter.fire({ relPath: r })
		}
		_makeAbsPath(r) {
			return $t(this.repoRoot, r)
		}
		_publishBlobNameChange(r, n, i) {
			n !== i &&
				this._blobNameChangedEmitter.fire({
					absPath: this._makeAbsPath(r),
					prevBlobName: n,
					newBlobName: i,
				})
		}
		purge(r) {
			let n = new Array()
			for (let [i, s] of this._allPathNames) s.entryTS < r && n.push(i)
			for (let i of n) this.remove(i)
		}
		hasFile(r) {
			return this._trackableFilePaths.has(r)
		}
		getBlobName(r) {
			let n = this._allPathNames.get(r)
			if (n?.fileInfo?.trackable) return n.fileInfo?.blobName
		}
		getBlobInfo(r, n) {
			let i = this._allPathNames.get(r)
			if (i?.fileInfo?.trackable && i.fileInfo.mtime === n) return [i.fileInfo.blobName, i.fileInfo.contentSeq]
		}
		getPathName(r) {
			return this._blobNameToPathName.get(r)
		}
		getPathInfo(r) {
			let n = this._allPathNames.get(r)
			if (n !== void 0) return [n.fileType, n.pathAcceptance]
		}
		reportMissing(r) {
			let n = this._blobNameToPathName.get(r)
			if (n === void 0) return
			let i = this._allPathNames.get(n)
			if (i?.fileInfo?.trackable) return (i.fileInfo.contentSeq = 0), n
		}
		*pathsWithBlobNames() {
			for (let [r, n] of this._allPathNames) {
				let i = n.fileInfo
				i?.trackable && (yield [r, i.mtime, i.blobName, i.contentSeq])
			}
		}
		*allPaths() {
			for (let [r, n] of this._allPathNames) {
				let i = n.pathAcceptance.accepted,
					s = !1,
					o = n.pathAcceptance.format()
				i &&
					(n.fileType === "Other"
						? ((i = !1), (o = "Not a file"))
						: n.fileInfo !== void 0 &&
							(n.fileInfo?.trackable === !0 ? (s = !0) : ((i = !1), (o = n.fileInfo.reason)))),
					yield [r, n.fileType, i, s, o]
			}
		}
		_markDirty() {
			this._persistState !== void 0 && this._persistState.dirtyCount++
		}
		enablePersist(r, n) {
			if (this._persistState) return
			;(this._persistState = {
				dirtyCount: this._trackableFilePaths.size,
				lastPersistDirtyCount: 0,
				mtimeCacheWriter: r,
				persisting: !1,
			}),
				this._maybePersist()
			let i = setInterval(() => void this._maybePersist(), n)
			this.addDisposable({ dispose: () => clearInterval(i) })
		}
		async _maybePersist() {
			if (!(this._persistState === void 0 || this._persistState.persisting)) {
				this._persistState.persisting = !0
				try {
					this._persistState.dirtyCount > this._persistState.lastPersistDirtyCount &&
						(await this._persist(this._persistState))
				} finally {
					this._persistState.persisting = !1
				}
			}
		}
		async _persist(r) {
			let n = function* (o) {
					for (let [a, l] of o) {
						let c = l.fileInfo
						c?.trackable && (yield [a, c.mtime, c.blobName])
					}
				},
				i = r.dirtyCount
			await r.mtimeCacheWriter.write(n(this._allPathNames.entries())), (r.lastPersistDirtyCount = i)
		}
	}
var Pl = W(require("vscode"))
var m6 = class extends ag {
		constructor(r) {
			super()
			this.reason = r
		}
		format() {
			return this.reason
		}
	},
	wN = class extends z {
		constructor(r, n, i, s, o) {
			super()
			this.folderName = r
			this.folderRoot = n
			this.repoRoot = i
			this._pathFilter = s
			this._workspaceFolder = o
			this._logger = X(`PathNotifier[${n}]`)
		}
		_pathFoundEmitter = new Pl.EventEmitter()
		_pathCreatedEmitter = new Pl.EventEmitter()
		_pathChangedEmitter = new Pl.EventEmitter()
		_pathDeletedEmitter = new Pl.EventEmitter()
		_logger
		_filesystemWatcherCreated = !1
		_stopping = !1
		_deletedPaths = void 0
		get onDidFindPath() {
			return this._pathFoundEmitter.event
		}
		get onDidCreatePath() {
			return this._pathCreatedEmitter.event
		}
		get onDidChangePath() {
			return this._pathChangedEmitter.event
		}
		get onDidDeletePath() {
			return this._pathDeletedEmitter.event
		}
		dispose() {
			;(this._stopping = !0), super.dispose()
		}
		async enumeratePaths() {
			if (this._stopping) return
			;(this._deletedPaths = new Set()),
				this._workspaceFolder !== void 0 &&
					!this._filesystemWatcherCreated &&
					(this._createFilesystemWatcher(this._workspaceFolder), (this._filesystemWatcherCreated = !0))
			let r = new PC(this.folderName, Pl.Uri.file(this.folderRoot), Pl.Uri.file(this.repoRoot), this._pathFilter)
			for await (let [i, s, o, a] of r) {
				if (this._stopping) return
				this._pathFoundEmitter.fire({ relPath: s, fileType: o, acceptance: a })
			}
			if (this._stopping) return
			let n = this._deletedPaths
			this._deletedPaths = void 0
			for (let i of n) this._pathDeletedEmitter.fire(i)
			return r.stats
		}
		_handlePathChanged(r, n) {
			let i = this._getRelPath(r)
			if (i === void 0) return
			let s, o
			try {
				;(s = Fh(as(r)).type), (o = this._pathFilter.getPathInfo(i, s))
			} catch (l) {
				;(s = "Other"), (o = new m6(Ye(l)))
			}
			let a = n ? "created" : "changed"
			this._logger.verbose(`${s} ${a}: ${i}, acceptance = ${o.format()}`),
				this._deletedPaths?.delete(i),
				n
					? this._pathCreatedEmitter.fire({
							relPath: i,
							fileType: s,
							acceptance: o,
						})
					: this._pathChangedEmitter.fire({
							relPath: i,
							fileType: s,
							acceptance: o,
						})
		}
		_handlePathDeleted(r) {
			let n = this._getRelPath(r)
			n !== void 0 &&
				(this._logger.verbose(`Path deleted: ${n}`),
				this._deletedPaths !== void 0 ? this._deletedPaths?.add(n) : this._pathDeletedEmitter.fire(n))
		}
		_getRelPath(r) {
			if (this._stopping) return
			let n = hf(r)
			if (n !== void 0) return Nh(this.repoRoot, n)
		}
		_createFilesystemWatcher(r) {
			let n = Pl.workspace.createFileSystemWatcher(new Pl.RelativePattern(r, "**/*"))
			this.addDisposables(
				n,
				n.onDidCreate((i) => this._handlePathChanged(i, !0)),
				n.onDidChange((i) => this._handlePathChanged(i, !1)),
				n.onDidDelete((i) => this._handlePathDeleted(i)),
			)
		}
	}
var $_ = W(require("vscode"))
async function bwe(e, t, r, n) {
	let i = as(e),
		s = as(t),
		o = new Array()
	o.push(i)
	let a = new Array(),
		l = 200,
		c = Date.now(),
		u
	for (; (u = o.pop()) !== void 0 && (n === void 0 || a.length < n); ) {
		Date.now() - c >= l && (await new Promise((y) => setTimeout(y, 0)), (c = Date.now()))
		let p = Yd(s, u),
			g = r.makeLocalPathFilter(p),
			m = bx(u)
		for (let [y, C] of m) {
			if (
				(Date.now() - c >= l && (await new Promise((w) => setTimeout(w, 0)), (c = Date.now())),
				y === "." || y === "..")
			)
				continue
			let b = $t(p, y, C === "Directory")
			g.acceptsPath(b, C) && (C === "File" ? a.push(b) : C === "Directory" && o.push($t(u, y)))
		}
	}
	return Promise.resolve(a)
}
var IN = class e {
	constructor(t, r, n, i) {
		this._apiServer = t
		this._pathHandler = r
		this._fileExtensions = n
		this._maxTrackedFiles = i
	}
	static verifyBatchSize = 1e3
	async describe(t, r, n) {
		let i = await this._getAllPathNames(t, r, n)
		if (i.length > this._maxTrackedFiles) return { trackable: !1 }
		let s = i.length,
			o = await this._chooseBlobNameSample(r, i)
		if (o.length === 0) return { trackable: !0, trackableFiles: 0, uploadedFraction: 1 }
		let a = await this._apiServer.findMissing(o),
			l = o.length,
			c = Math.min(a.unknownBlobNames.length, l)
		return { trackable: !0, trackableFiles: s, uploadedFraction: (l - c) / l }
	}
	async _getAllPathNames(t, r, n) {
		let i = await ZQ($_.Uri.file(t), $_.Uri.file(r), new QC(n), this._fileExtensions)
		return await bwe($_.Uri.file(t), $_.Uri.file(r), i, this._maxTrackedFiles + 1)
	}
	async _chooseBlobNameSample(t, r) {
		let n = new Array()
		for (; n.length < e.verifyBatchSize && r.length > 0; ) {
			let i = Math.floor(Math.random() * r.length),
				s = r[i]
			;(r[i] = r[r.length - 1]), r.pop()
			let o = $t(t, s),
				a = await this._pathHandler.readText(o)
			if (a.type !== "text") continue
			let l = this._pathHandler.calculateBlobName(s, a.contents)
			n.push(l)
		}
		return n
	}
}
var xwe = W(require("vscode"))
var SN = class {
	maxSize
	items
	constructor(t) {
		;(this.maxSize = t), (this.items = [])
	}
	add(t) {
		let r = this.items.indexOf(t)
		r !== -1 ? this.items.splice(r, 1) : this.items.length >= this.maxSize && this.items.shift(), this.items.push(t)
	}
	clear() {
		this.items = []
	}
	size() {
		return this.items.length
	}
	toArray() {
		return this.items.slice()
	}
}
var BN = class extends z {
	constructor(r) {
		super()
		this._workspaceManager = r
		this.addDisposable(xwe.window.onDidChangeActiveTextEditor(this._notifyActiveEditorChanged.bind(this)))
	}
	_tabSwitchHistory = new SN(20)
	_logger = X("TabWatcher")
	_notifyActiveEditorChanged(r) {
		if (r === void 0) return
		let n = r.document.uri
		this._workspaceManager.resolvePathName(n.fsPath) !== void 0 && this._tabSwitchHistory.add(n.fsPath)
	}
	getTabSwitchEvents() {
		let r = []
		for (let n of this._tabSwitchHistory.toArray()) {
			let i = this._workspaceManager.resolvePathName(n)
			if (i === void 0) continue
			let s = this._workspaceManager.getBlobName(i)
			s !== void 0 && r.push({ relPathName: i.relPath, blobName: s })
		}
		return r
	}
}
var DN = class e extends z {
	constructor(r, n) {
		super()
		this._apiServer = r
		this._workspaceManager = n
		;(this._logger = X("UnknownBlobHandler")),
			(this._toProbe = new $o(this._probe.bind(this))),
			this.addDisposable(this._toProbe),
			(this._probeWaiters = new $o(this._enqueueForProbe.bind(this))),
			this.addDisposable(this._probeWaiters),
			(this._probeWaitersKicker = new vc(this._probeWaiters, e.probeRetryWaitMs)),
			this.addDisposable(this._probeWaitersKicker),
			(this._longWaiters = new $o(this._enqueueForProbe.bind(this))),
			this.addDisposable(this._longWaiters),
			(this._longWaitersKicker = new vc(this._longWaiters, e.longRetryWaitMs)),
			this.addDisposable(this._longWaitersKicker)
	}
	static probeBatchSize = 1e3
	static probeRetryWaitMs = 5 * 1e3
	static probePatienceMs = 2 * 60 * 1e3
	static longRetryWaitMs = 60 * 1e3
	_toProbe
	_currentBatch = new Map()
	_probeWaiters
	_probeWaitersKicker
	_longWaiters
	_longWaitersKicker
	_logger
	enqueue(r) {
		for (let [n, i] of r)
			this._logger.verbose(`enqueue: ${i.rootPath}:${i.relPath}`),
				this._toProbe.insert(n, { qualifiedPath: i, startTime: Date.now() })
		this._toProbe.kick()
	}
	_grabCurrentBatch() {
		if (this._currentBatch.size === 0) return
		let r = this._currentBatch
		return (this._currentBatch = new Map()), r
	}
	async _probe(r) {
		if (r !== void 0) {
			let [o, a] = r
			if (
				this._workspaceManager.getBlobName(a.qualifiedPath) !== o ||
				(this._currentBatch.set(o, a), this._currentBatch.size < e.probeBatchSize)
			)
				return
		}
		let n = this._grabCurrentBatch()
		if (n === void 0) return
		let i = [...n.keys()],
			s
		try {
			s = await xi(async () => this._apiServer.findMissing(i), this._logger)
		} catch {}
		if (s === void 0) for (let [o, a] of n) this._addRetryWaiter(o, a)
		else {
			this._logger.verbose(`find-missing reported ${s.nonindexedBlobNames.length} nonindexed blob names`),
				s.nonindexedBlobNames.length > 0 && cg(this._logger, "verbose", s.nonindexedBlobNames, 5)
			let o = new Set(s.unknownBlobNames),
				a = new Set(s.nonindexedBlobNames)
			for (let [l, c] of n)
				o.has(l)
					? this._workspaceManager.notifyBlobMissing(c.qualifiedPath, l)
					: a.has(l) && this._addRetryWaiter(l, c)
		}
	}
	_enqueueForProbe(r) {
		if (r === void 0) this._toProbe.kick()
		else {
			let [n, i] = r
			this._logger.verbose(`probe enqueue: ${i.qualifiedPath.rootPath}:${i.qualifiedPath.relPath}: ${n}`),
				this._toProbe.insert(n, i)
		}
		return Promise.resolve()
	}
	_addRetryWaiter(r, n) {
		Date.now() - n.startTime < e.probePatienceMs
			? (this._logger.verbose(`retry enqueue: ${n.qualifiedPath.rootPath}:${n.qualifiedPath.relPath}: ${r}`),
				this._probeWaiters.insert(r, n))
			: (this._logger.verbose(`long retry enqueue: ${n.qualifiedPath.rootPath}:${n.qualifiedPath.relPath}: ${r}`),
				this._longWaiters.insert(r, n))
	}
}
var qC = class e {
	constructor(t, r, n, i = [], s = [], o, a) {
		this.blobs = t
		this.recentChunks = r
		this.trackedPaths = n
		this.unindexedEditEvents = i
		this.unindexedEditEventsBaseBlobNames = s
		this.lastChatResponse = o
		this.blobNames = a
	}
	static empty() {
		return new e(
			{ checkpointId: void 0, addedBlobs: [], deletedBlobs: [] },
			new Array(),
			new Map(),
			[],
			[],
			void 0,
			[],
		)
	}
}
function y6(e) {
	return wy(as(e))
}
function Y_(e) {
	if (e.scheme === "file") return y6(e)
}
var C6 = class extends z {
		constructor(r, n, i, s, o, a, l, c, u, f, p) {
			super(u, f)
			this.folderName = r
			this.folderRoot = n
			this.repoRoot = i
			this.workspaceFolder = s
			this.vcsDetails = o
			this.folderId = a
			this.diskFileManager = l
			this.cacheDirPath = c
			this.logger = p
			;(this._operationQueue = new Ia(async (g) => await this._runSerializedOperation(g))),
				this.addDisposables(this._operationQueue, {
					dispose: () => this._disposeTracker(),
				})
		}
		_operationQueue
		_tracker
		_newlyTracked = !1
		_initialEnumerationComplete = !1
		_initialSyncComplete = !1
		_stopped = !1
		dispose() {
			;(this._stopped = !0), super.dispose()
		}
		get stopped() {
			return this._stopped
		}
		get type() {
			return this.workspaceFolder === void 0 ? 1 : 0
		}
		_disposeTracker() {
			this._tracker?.dispose(), (this._tracker = void 0)
		}
		setTracker(r) {
			if (this.stopped) throw new Error("Source folder has been disposed")
			this._disposeTracker(), (this._tracker = r)
		}
		get tracker() {
			return this._tracker
		}
		get initialEnumerationComplete() {
			return this._initialEnumerationComplete
		}
		setInitialEnumerationComplete() {
			this._initialEnumerationComplete = !0
		}
		get initialSyncComplete() {
			return this._initialSyncComplete
		}
		setInitialSyncComplete() {
			this._initialSyncComplete = !0
		}
		relativePathName(r) {
			if (Ss(this.folderRoot, r)) return vl(this.repoRoot, r)
		}
		acceptsPath(r) {
			return this._tracker === void 0 ? !1 : this._tracker.pathFilter.acceptsPath(r)
		}
		async enqueueSerializedOperation(r) {
			this._operationQueue.insert(r), await this._operationQueue.kick()
		}
		async _runSerializedOperation(r) {
			r !== void 0 && (!this._initialEnumerationComplete || this._stopped || (await r()))
		}
	},
	v6 = class extends z {
		constructor(r, n, i) {
			super(i)
			this.pathFilter = r
			this.pathNotifier = n
		}
	}
var CCt = new Set(["home directory", "too large"]),
	vCt = new Set(["nested"])
function K_(e) {
	return CCt.has(e)
}
function _we(e) {
	return vCt.has(e)
}
function Pa(e) {
	return e.containingFolderRoot !== void 0
		? "nested"
		: e.isHomeDir
			? "home directory"
			: e.folderQualification !== void 0 && !e.folderQualification.trackable
				? "too large"
				: e.syncingPermission === "denied"
					? "permission denied"
					: e.syncingPermission === "granted"
						? "trackable"
						: e.folderQualification === void 0
							? "qualifying"
							: "permission needed"
}
var TN = class e extends z {
	constructor(r, n, i, s, o, a, l, c, u, f, p, g, m, y = new Array(), C) {
		super()
		this._actionsModel = r
		this._externalSourceFolderRecorder = n
		this._syncingPermissionTracker = i
		this._storageUriProvider = s
		this._apiServer = o
		this._configListener = a
		this._featureFlagManager = l
		this._clientMetricsReporter = c
		this._completionServer = u
		this._blobNameCalculator = f
		this._maxUploadSizeBytes = p
		this._syncingEnabledTracker = g
		this._onboardingSessionEventReporter = m
		;(this._enableFileLimitsForSyncingPermission =
			this._featureFlagManager.currentFlags.enableFileLimitsForSyncingPermission),
			(this._maxTrackableFiles = this._featureFlagManager.currentFlags.maxTrackableFileCount),
			(this._maxTrackableFilesWithoutPermission = Math.min(
				this._featureFlagManager.currentFlags.maxTrackableFileCountWithoutPermission,
				this._maxTrackableFiles,
			))
		let v = Math.min(this._featureFlagManager.currentFlags.minUploadedPercentageWithoutPermission, 100)
		if (
			((this._verifyFolderIsSourceRepo = this._featureFlagManager.currentFlags.verifyFolderIsSourceRepo),
			(this._minUploadedFractionWithoutPermission = v * 0.01),
			(this._refuseToSyncHomeDirectories = this._featureFlagManager.currentFlags.refuseToSyncHomeDirectories),
			(this._useCheckpointManagerContext =
				C?.useCheckpointManagerContext ??
				Gr(this._featureFlagManager.currentFlags.useCheckpointManagerContextMinVersion)),
			(this._validateCheckpointManagerContext =
				this._featureFlagManager.currentFlags.validateCheckpointManagerContext),
			(this._folderEnumeratedEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._folderSyncedEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._syncingProgressEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._syncingStateEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._sourceFoldersChangedEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._sourceFolderContentsChangedEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._sourceFolderContentsChangedEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._fileChangedEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._textDocumentOpenedEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._textDocumentClosedEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._textDocumentChangedEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._fileDeletedEmitter = this.addDisposable(new Ot.EventEmitter())),
			(this._fileWillRenameEmitter = this.addDisposable(new Ot.EventEmitter())),
			this._featureFlagManager.currentFlags.bypassLanguageFilter)
		)
			this._fileExtensions = void 0
		else {
			let M = new Set()
			for (let Q of y) for (let O of Q.extensions) M.add(O)
			this._fileExtensions = M
		}
		;(this._pathHandler = new bN(this._maxUploadSizeBytes, H_e())), (this._pathMap = this.addDisposable(new _N()))
		let b
		if (this._configListener.config.openFileManager.v2Enabled) {
			let M = new dN(this._blobNameCalculator, this._apiServer)
			this.addDisposable(M), (b = new hN(M, this._blobNameCalculator))
		}
		let w = new EN(
			this._apiServer,
			this._completionServer,
			this._configListener,
			this._blobNameCalculator,
			this._pathMap,
			this._sequenceGenerator,
		)
		this.addDisposable(w), (this._openFileManager = new oN(this._configListener, w, b))
		let B = C?.blobsCheckpointThreshold
		;(this._blobsCheckpointManager = this.addDisposable(
			new AN(this._apiServer, this._featureFlagManager, this._pathMap.onDidChangeBlobName, B),
		)),
			(this._unknownBlobHandler = this.addDisposable(new DN(this._apiServer, this))),
			(this._sourceFolderReconciler = this.addDisposable(new Ku(() => this._reconcileSourceFolders()))),
			(this._sourceFolderDescriber = new IN(
				this._apiServer,
				this._pathHandler,
				this._fileExtensions,
				this._maxTrackableFiles,
			)),
			this.addDisposable(
				Ot.workspace.onDidChangeWorkspaceFolders(this._handleWorkspaceFolderChangeEvent.bind(this)),
			),
			this.addDisposable(Ot.workspace.onDidChangeTextDocument(this._notifyTextDocumentChanged.bind(this))),
			this.addDisposable(Ot.workspace.onDidOpenTextDocument(this._notifyTextDocumentOpened.bind(this))),
			this.addDisposable(Ot.workspace.onDidCloseTextDocument(this._notifyTextDocumentClosed.bind(this))),
			this.addDisposable(
				Ot.workspace.onDidChangeNotebookDocument(this._notifyNotebookDocumentChanged.bind(this)),
			),
			this.addDisposable(Ot.window.onDidChangeActiveTextEditor(this._notifyActiveEditorChanged.bind(this))),
			this.addDisposable(
				Ot.workspace.onDidCloseTextDocument((M) => {
					this._notifyDocumentClosed(M)
				}),
			),
			this.addDisposable(
				Ot.workspace.onDidCloseNotebookDocument((M) => {
					this._notifyDocumentClosed(M)
				}),
			),
			this.addDisposable(
				Ot.workspace.onWillRenameFiles((M) => {
					this._notifyWillRenameFile(M)
				}),
			),
			this.addDisposable(this._configListener.onDidChange(this._notifyConfigChange.bind(this))),
			this._notifyConfigChange(),
			this.addDisposable(new Ot.Disposable(() => this._disposeSourceFolders())),
			this.addDisposable(new Ot.Disposable(() => this._disposeTabWatcher())),
			this._actionsModel.setSystemStateStatus("syncingPermitted", "complete"),
			this._actionsModel.setSystemStateStatus("workspaceTooLarge", "initializing"),
			this._actionsModel.setSystemStateStatus("uploadingHomeDir", "initializing"),
			this._registerInitialSourceFolders(),
			this._awaitInitialSourceFolders()
	}
	static augmentRootName = ".augmentroot"
	static ignoreSources(r) {
		return [new L_(".gitignore"), new KQ(r), new L_(".augmentignore")]
	}
	static pathMapPersistFrequencyMs = 6e4
	static defaultPathAccept = new lg()
	static _textEncoder = new TextEncoder()
	_initialSourceFolders = new Set()
	_registeredSourceFolders = new Map()
	_trackedSourceFolders = new Map()
	_fileExtensions
	_pathMap
	_sequenceGenerator = new XQ()
	_pathHandler
	_openFileManager
	_blobsCheckpointManager
	_unknownBlobHandler
	_sourceFolderDescriber
	_logger = X("WorkspaceManager")
	_tabWatcher
	_vcsWatcher
	_fileEditManager
	_folderEnumeratedEmitter
	_folderSyncedEmitter
	_syncingProgressEmitter
	_syncingPermissionInitialized = !1
	_sourceFolderReconciler
	_syncingStateEmitter
	_sourceFoldersChangedEmitter
	_sourceFolderContentsChangedEmitter
	_fileChangedEmitter
	_textDocumentOpenedEmitter
	_textDocumentClosedEmitter
	_textDocumentChangedEmitter
	_fileDeletedEmitter
	_fileWillRenameEmitter
	_lastChatResponse = void 0
	_enableFileLimitsForSyncingPermission
	_maxTrackableFiles
	_maxTrackableFilesWithoutPermission
	_verifyFolderIsSourceRepo
	_minUploadedFractionWithoutPermission
	_refuseToSyncHomeDirectories
	_useCheckpointManagerContext
	_validateCheckpointManagerContext
	_stopping = !1
	dispose() {
		;(this._stopping = !0), super.dispose()
	}
	get enableFileLimitsForSyncingPermission() {
		return this._enableFileLimitsForSyncingPermission
	}
	get maxTrackableFiles() {
		return this._maxTrackableFiles
	}
	get maxTrackableFilesWithoutPermission() {
		return this._maxTrackableFilesWithoutPermission
	}
	get verifyFolderIsSourceRepo() {
		return this._verifyFolderIsSourceRepo
	}
	get minUploadedFractionWithoutPermission() {
		return this._minUploadedFractionWithoutPermission
	}
	get refuseToSyncHomeDirectories() {
		return this._refuseToSyncHomeDirectories
	}
	get initialFoldersEnumerated() {
		return Array.from(this._initialSourceFolders).every((r) => {
			let n = this._registeredSourceFolders.get(r)
			if (n === void 0) return !0
			let i = Pa(n)
			return K_(i) || _we(i) || i === "permission denied"
				? !0
				: this._trackedSourceFolders.get(r)?.sourceFolder?.initialEnumerationComplete
		})
	}
	async awaitInitialFoldersEnumerated() {
		for (; !this.initialFoldersEnumerated; ) await $p(this._folderEnumeratedEmitter.event)
	}
	get onDidEnumerateFolder() {
		return this._folderEnumeratedEmitter.event
	}
	get initialFoldersSynced() {
		return Array.from(this._initialSourceFolders).every((r) => {
			let n = this._registeredSourceFolders.get(r)
			if (n === void 0) return !0
			let i = Pa(n)
			return K_(i) || _we(i) || i === "permission denied"
				? !0
				: this._trackedSourceFolders.get(r)?.sourceFolder?.initialSyncComplete
		})
	}
	async awaitInitialFoldersSynced() {
		for (; !this.initialFoldersSynced; ) await $p(this._folderSyncedEmitter.event)
	}
	get onDidChangeSyncingProgress() {
		return this._syncingProgressEmitter.event
	}
	get syncingEnabledState() {
		if (!this._syncingPermissionInitialized) return "initializing"
		if (this._syncingPermissionTracker.syncingPermissionDenied) return "disabled"
		let r = 0
		for (let [n, i] of this._registeredSourceFolders) {
			let s = Pa(i)
			if (K_(s) || s === "permission denied") return "disabled"
			s === "permission needed" && r++
		}
		return r > 0 ? "partial" : "enabled"
	}
	get onDidChangeSyncingState() {
		return this._syncingStateEmitter.event
	}
	get onDidChangeSourceFolders() {
		return this._sourceFoldersChangedEmitter.event
	}
	get onDidChangeSourceFolderContents() {
		return this._sourceFolderContentsChangedEmitter.event
	}
	get onDidChangeFile() {
		return this._fileChangedEmitter.event
	}
	get completionServer() {
		return this._completionServer
	}
	_disposeSourceFolders() {
		this._registeredSourceFolders.forEach((r) => {
			r.cancel?.cancel(), r.cancel?.dispose(), (r.cancel = void 0)
		}),
			this._trackedSourceFolders.forEach((r) => r.sourceFolder?.dispose()),
			this._trackedSourceFolders.clear(),
			this._vcsWatcher?.dispose(),
			this._fileEditManager?.dispose()
	}
	_disposeTabWatcher() {
		this._tabWatcher?.dispose(), (this._tabWatcher = void 0)
	}
	_disposeVCSWatcher() {
		this._vcsWatcher?.dispose(), (this._vcsWatcher = void 0)
	}
	_disposeEditFileManager() {
		this._fileEditManager?.dispose(), (this._fileEditManager = void 0)
	}
	_notifyConfigChange() {
		this._stopping ||
			(this._configListener.config.recencySignalManager.collectTabSwitchEvents
				? this._tabWatcher === void 0 && (this._tabWatcher = new BN(this))
				: this._disposeTabWatcher(),
			this._configListener.config.vcs.watcherEnabled
				? this._vcsWatcher === void 0 &&
					(this._vcsWatcher = new sN(
						new _A.FileUploaderImpl(this._blobNameCalculator, this._apiServer),
						this._configListener,
					))
				: this._disposeVCSWatcher(),
			Rl(this._configListener.config, this._featureFlagManager.currentFlags.vscodeNextEditMinVersion) ||
			this.getEnableCompletionFileEditEvents()
				? this._fileEditManager === void 0 &&
					((this._fileEditManager = new Q_(
						this._blobNameCalculator,
						this._maxUploadSizeBytes,
						this._textDocumentChangedEmitter.event,
						this._textDocumentOpenedEmitter.event,
						this._textDocumentClosedEmitter.event,
						this._fileDeletedEmitter.event,
						this._fileWillRenameEmitter.event,
						this._configListener.config.enableDebugFeatures,
					)),
					this._fileEditManager.listenToEvents(),
					this._trackedSourceFolders.forEach((r) => {
						r.sourceFolder !== void 0 &&
							this._fileEditManager?.startTracking(r.sourceFolder.folderId, r.sourceFolder.folderName, {
								directory: this._computeCacheDirPath(r.sourceFolder.folderRoot),
							})
					}))
				: this._disposeEditFileManager())
	}
	getSyncingProgress() {
		let r = new Array()
		return (
			this._trackedSourceFolders.forEach((n, i) => {
				r.push(this._getSyncingProgress(i, n.sourceFolder))
			}),
			r
		)
	}
	_reportSyncingProgress(r) {
		this._syncingProgressEmitter.fire(this._getSyncingProgress(r.folderRoot, r))
	}
	_getSyncingProgress(r, n) {
		let i = n?.initialEnumerationComplete
			? {
					newlyTracked: n._newlyTracked,
					trackedFiles: this._pathMap.trackedFileCount(n.folderId),
					backlogSize: n.diskFileManager.itemsInFlight,
				}
			: void 0
		return { folderRoot: r, progress: i }
	}
	_isHomeDir(r) {
		return this._featureFlagManager.currentFlags.refuseToSyncHomeDirectories ? swe(r) : !1
	}
	_registerInitialSourceFolders() {
		let r = new Array()
		Ot.workspace.workspaceFolders?.forEach((i) => {
			let s = Y_(i.uri)
			s !== void 0 && this._mtimeCacheExists(s) && r.push(s)
		}),
			this._syncingPermissionTracker.setDefaultPermissions(r),
			this._externalSourceFolderRecorder.getFolders().forEach((i, s) => {
				if (this._isHomeDir(s)) {
					this._logger.info(`Rejecting external source folder ${s}: home directory`)
					return
				}
				this._logger.info(`Adding external source folder ${s}`),
					this._initialSourceFolders.add(s),
					this._registeredSourceFolders.set(s, {
						folderName: i,
						isHomeDir: !1,
						folderType: 1,
						syncingPermission: this._syncingPermissionTracker.syncingPermissionDenied
							? "denied"
							: "granted",
					})
			})
		let n = new Array()
		Ot.workspace.workspaceFolders?.forEach((i) => {
			let s = i.name,
				o = Y_(i.uri)
			if (o === void 0) return
			let a = this._syncingPermissionTracker.getFolderSyncingPermission(o)
			this._logger.info(`Adding workspace folder ${s}; folderRoot = ${o}; syncingPermission = ${a}`),
				this._initialSourceFolders.add(o),
				this._registeredSourceFolders.set(o, {
					folderName: s,
					isHomeDir: this._isHomeDir(o),
					folderType: 0,
					syncingPermission: a,
					workspaceFolder: i,
				}),
				a === "granted" && n.push(o)
		}),
			this._syncingPermissionTracker.dropStaleFolders(n),
			this._setSyncingPermissionInitialized()
	}
	_mtimeCacheExists(r) {
		let n = this._computeCacheDirPath(r)
		return CN(n)
	}
	_setSyncingPermissionInitialized() {
		;(this._syncingPermissionInitialized = !0), (this._syncingEnabledTracker.workspaceManager = this)
	}
	async _awaitInitialSourceFolders() {
		let r = Date.now()
		this._kickSourceFolderReconciler(),
			await this.awaitInitialFoldersSynced(),
			this._reportWorkspaceStartup(Date.now() - r),
			this._folderSyncedEmitter.fire()
	}
	_handleWorkspaceFolderChangeEvent(r) {
		for (let i of r.added) {
			let s = i.name,
				o = Y_(i.uri)
			if (o === void 0) continue
			let a = this._syncingPermissionTracker.getFolderSyncingPermission(o)
			this._logger.info(`Adding workspace folder ${s}; folderRoot = ${o}; syncingPermission = ${a}`),
				this._registeredSourceFolders.set(o, {
					folderName: s,
					isHomeDir: this._isHomeDir(o),
					folderType: 0,
					syncingPermission: a,
					workspaceFolder: i,
				})
		}
		let n = new Array()
		for (let i of r.removed) {
			let s = Y_(i.uri)
			if (s === void 0) continue
			this._logger.info(`Removing workspace folder ${s}`)
			let o = this._registeredSourceFolders.get(s)
			o !== void 0 &&
				(o.cancel?.cancel(),
				o.cancel?.dispose(),
				(o.cancel = void 0),
				this._registeredSourceFolders.delete(s),
				n.push(s))
		}
		this._syncingPermissionTracker.dropPermission(n), this._kickSourceFolderReconciler()
	}
	addExternalSourceFolder(r) {
		let n = Y_(r)
		if (n === void 0) throw new aM()
		if (this._registeredSourceFolders.has(n)) throw new uM()
		try {
			if (Fh(n).type !== "Directory") throw new cM()
		} catch (i) {
			throw new lM(Ye(i))
		}
		if (this._isHomeDir(n)) throw new dM()
		this._logger.info(`Adding external source folder ${z1(r)}`),
			this._registeredSourceFolders.set(n, {
				folderName: dme(n),
				isHomeDir: !1,
				folderType: 1,
				syncingPermission: this._syncingPermissionTracker.syncingPermissionDenied ? "denied" : "granted",
			}),
			this._kickSourceFolderReconciler()
	}
	removeExternalSourceFolder(r) {
		let n = this._registeredSourceFolders.get(r)
		if (n !== void 0) {
			if (n.folderType !== 1) throw new fM()
			this._logger.info(`Removing external source folder ${r}`),
				this._registeredSourceFolders.delete(r),
				this._kickSourceFolderReconciler()
		}
	}
	enableSyncing() {
		this._logger.info("Enabling syncing for all trackable source folders")
		let r = new Array()
		this._registeredSourceFolders.forEach((n, i) => {
			let s = Pa(n)
			K_(s) || s === "qualifying" || ((n.syncingPermission = "granted"), r.push(i))
		}),
			this._syncingPermissionTracker.setPermittedFolders(r),
			this._kickSourceFolderReconciler()
	}
	disableSyncing() {
		this._logger.info("Disabling syncing for all trackable source folders"),
			this._registeredSourceFolders.forEach((r) => {
				let n = Pa(r)
				K_(n) || (r.syncingPermission = "denied")
			}),
			this._syncingPermissionTracker.denyPermission(),
			this._kickSourceFolderReconciler()
	}
	requalifyLargeFolders() {
		this._registeredSourceFolders.forEach((r) => {
			r.folderQualification = void 0
		}),
			this._kickSourceFolderReconciler()
	}
	async _kickSourceFolderReconciler() {
		await this._updateStoredExternalSourceFolders()
		let r = new Set()
		for (let [n, i] of this._registeredSourceFolders)
			if (Pa(i) === "trackable") {
				for (let [o, a] of this._registeredSourceFolders)
					if (Pa(a) === "trackable" && n !== o && Ss(o, n)) {
						r.add(n)
						break
					}
			}
		for (let [n, i] of this._registeredSourceFolders) {
			if (!r.has(n)) {
				i.containingFolderRoot = void 0
				continue
			}
			for (let s of this._registeredSourceFolders.keys())
				if (!(n === s || r.has(s)) && Ss(s, n)) {
					i.containingFolderRoot !== s &&
						this._logger.info(`Source folder ${n} will not be tracked. Containing folder: ${s}`),
						(i.containingFolderRoot = s)
					break
				}
		}
		this._updateActionsModelState()
		for (let [n, i] of this._registeredSourceFolders)
			Pa(i) === "qualifying" && i.cancel === void 0 && this._qualifySourceFolder(n, i)
		this._syncingStateEmitter.fire(this.syncingEnabledState),
			this._sourceFoldersChangedEmitter.fire(),
			this._sourceFolderReconciler.kick()
	}
	async _updateStoredExternalSourceFolders() {
		let r = new Map()
		for (let [n, i] of this._registeredSourceFolders) i.folderType === 1 && r.set(n, i.folderName)
		await this._externalSourceFolderRecorder.setFolders(r)
	}
	_updateActionsModelState() {
		if (this._syncingPermissionTracker.syncingPermissionDenied) {
			this._actionsModel.setSystemStateStatus("syncingPermitted", "incomplete")
			return
		}
		let r = !1,
			n = !1,
			i = !1
		for (let [l, c] of this._registeredSourceFolders) {
			let u = Pa(c)
			if (u === "permission needed") {
				r = !0
				break
			} else if (u === "home directory") {
				n = !0
				break
			} else if (u === "too large") {
				i = !0
				break
			}
		}
		let s = r ? "initializing" : "complete"
		this._actionsModel.setSystemStateStatus("syncingPermitted", s)
		let o = n ? "complete" : "initializing"
		this._actionsModel.setSystemStateStatus("uploadingHomeDir", o)
		let a = i ? "complete" : "initializing"
		this._actionsModel.setSystemStateStatus("workspaceTooLarge", a)
	}
	async _qualifySourceFolder(r, n) {
		let [i, s] = await this._findRepoRoot(r),
			o,
			a
		if (this._enableFileLimitsForSyncingPermission) {
			;(a = "full"), this._logger.info(`Beginning ${a} qualification of source folder ${r}`)
			let c = new Ot.CancellationTokenSource()
			if (
				((n.cancel = c),
				(o = await this._sourceFolderDescriber.describe(r, i, e.ignoreSources(r))),
				c.token.isCancellationRequested)
			) {
				this._logger.info(`Cancelled qualification of source folder ${r}`)
				return
			}
			;(n.cancel = void 0), c.dispose()
		} else
			(a = "phony"),
				this._logger.info(`Beginning ${a} qualification of source folder ${r} per feature flag`),
				(o = { trackable: !0, trackableFiles: 0, uploadedFraction: 1 })
		let l = { ...o, repoRoot: i, isRepo: s }
		;(n.folderQualification = l),
			this._syncingPermissionTracker.syncingPermissionDenied
				? this._logger.info(`Finished ${a} qualification of source folder ${r}: syncing disabled for workspace`)
				: l.trackable
					? (this._logger.info(
							`Finished ${a} qualification of source folder ${r}: trackable files: ${l.trackableFiles}, uploaded fraction: ${l.uploadedFraction}, is repo: ${l.isRepo}`,
						),
						l.trackableFiles > this._maxTrackableFilesWithoutPermission
							? this._logger.info(
									`Requesting syncing permission because source folder has more than ${this._maxTrackableFilesWithoutPermission} files`,
								)
							: this._verifyFolderIsSourceRepo && !l.isRepo
								? this._logger.info(
										"Requesting syncing permission because source folder does not appear to be a source repo",
									)
								: l.uploadedFraction < this._minUploadedFractionWithoutPermission
									? this._logger.info(
											`Requesting syncing permission because source folder has less than ${
												this._minUploadedFractionWithoutPermission * 100
											}% of files uploaded`,
										)
									: ((n.syncingPermission = "granted"),
										this._syncingPermissionTracker.addImplicitlyPermittedFolder(r)))
					: this._logger.info(
							`Finished ${a} qualification of source folder ${r}: folder not trackable; too large`,
						),
			this._kickSourceFolderReconciler()
	}
	async _reconcileSourceFolders() {
		await this._syncingPermissionTracker.persistCurrentPermission()
		let r = this.syncingEnabledState === "disabled",
			n = new Map()
		for (let [s, o] of this._trackedSourceFolders) {
			let a = this._registeredSourceFolders.get(s),
				l
			if (a === void 0) l = "source folder has been removed"
			else if (r) l = "syncing is disabled"
			else if (a.containingFolderRoot !== void 0)
				l = `source folder is nested inside folder ${a.containingFolderRoot}`
			else if (a.isHomeDir) l = "source folder is a home directory"
			else if (a.folderQualification?.trackable === !1) l = "source folder is too large"
			else {
				let c = Pa(a)
				c === "permission denied"
					? (l = "syncing permission denied for this source folder")
					: c === "permission needed"
						? (l = "syncing permission not yet granted for this source folder")
						: c === "qualifying" && (l = "source folder is being qualified")
			}
			l !== void 0 && n.set(s, [o, l])
		}
		let i = new Map()
		for (let [s, o] of this._registeredSourceFolders) {
			if (Pa(o) !== "trackable") continue
			let l = this._trackedSourceFolders.get(s)
			l === void 0 &&
				((l = {
					folderName: o.folderName,
					folderSpec: (0, Ll.cloneDeep)(o),
					cancel: new Ot.CancellationTokenSource(),
					sourceFolder: void 0,
					logger: X(`WorkspaceManager[${o.folderName}]`),
				}),
				i.set(s, l))
		}
		for (let [s, [o, a]] of n)
			o.logger.info(`Stop tracking: ${a}`), this._trackedSourceFolders.delete(s), this._stopTracking(o)
		for (let [s, o] of i)
			o.logger.info("Start tracking"), this._trackedSourceFolders.set(s, o), this._startTracking(s, o)
		return Promise.resolve()
	}
	async _startTracking(r, n) {
		let i = new JQ("Startup metrics"),
			s = n.cancel,
			o = await this._createSourceFolder(r, n, s.token)
		if (s.token.isCancellationRequested) {
			n.logger.info("Cancelled in-progress creation of source folder"), o?.dispose()
			return
		}
		if ((i.charge("create SourceFolder"), s.dispose(), o === void 0 || this._stopping)) {
			n.logger.info("Stopped tracking source folder")
			return
		}
		n.sourceFolder = o
		let a = n.folderName,
			l = o.folderId,
			c = await Awe(a, o.cacheDirPath)
		if ((i.charge("read MtimeCache"), o.stopped)) {
			n.logger.info("Stopped tracking source folder")
			return
		}
		for (let [f, p] of c)
			this._pathMap.insert(l, f, "File", e.defaultPathAccept), this._pathMap.update(l, f, 0, p.name, p.mtime)
		i.charge("pre-populate PathMap")
		let u = new Cc()
		try {
			;(o._newlyTracked = c.size === 0), u.add({ dispose: () => (o._newlyTracked = !1) })
			let f = await this._refreshSourceFolder(o, i)
			if (f === void 0 || o.stopped) return
			i.charge("enumerate"), o.setInitialEnumerationComplete(), this._folderEnumeratedEmitter.fire()
			let p = this._pathMap.onDidChangePathStatus(l)
			if (p === void 0) return
			o.addDisposable(
				p((m) => {
					this._sourceFolderContentsChangedEmitter.fire(r)
				}),
				!0,
			),
				o.addDisposable(
					p((m) => {
						this._reportSyncingProgress(o)
					}),
				),
				o.addDisposable(o.diskFileManager.onDidChangeInProgressItemCount(() => this._reportSyncingProgress(o))),
				this._reportSyncingProgress(o),
				this._sourceFoldersChangedEmitter.fire(),
				await o.diskFileManager.awaitQuiesced(),
				o.setInitialSyncComplete(),
				this._folderSyncedEmitter.fire(),
				i?.charge("await DiskFileManager quiesced")
			let g = new yN(a, o.cacheDirPath)
			this._pathMap.enablePersist(l, g, e.pathMapPersistFrequencyMs),
				i.charge("enable persist"),
				this._reportSourceFolderStartup(n.logger, o, i, f),
				this._onboardingSessionEventReporter.reportEvent("finished-syncing")
		} finally {
			u.dispose(), this._reportSyncingProgress(o)
		}
	}
	async _createSourceFolder(r, n, i) {
		let s = n.folderName,
			o = new Cc(),
			a = new Cc(),
			l = n.folderSpec.folderType === 1 ? void 0 : n.folderSpec.workspaceFolder,
			[c, u] = await this._findRepoRoot(r)
		if (i.isCancellationRequested) return
		let f = this._pathMap.openSourceFolder(r, c)
		o.add(new Ot.Disposable(() => this._pathMap.closeSourceFolder(f))),
			o.addAll(...this._openFileManager.startTrackingFolder(s, f))
		let p = new mN(s, this._apiServer, this._pathHandler, this._pathMap)
		o.add(p)
		let g = n.folderSpec.folderType === 0 && this._vcsWatcher !== void 0 ? await E_(r) : void 0,
			m = await this._migrateMtimeCache(r, n)
		return new C6(s, r, c, l, g, f, p, m, o, a, n.logger)
	}
	async _migrateMtimeCache(r, n) {
		let i = this._computeCacheDirPath(r)
		if (CN(i)) return i
		let s = this._computeCacheDirPath(n.folderName)
		if (!CN(s)) return i
		try {
			n.logger.info(`Migrating mtime cache for ${n.folderName} from "${s}" to "${i}"`), await pwe(s, i)
		} catch (o) {
			n.logger.error(`Failed to migrate mtime cache for ${n.folderName} from "${s}" to "${i}": ${Ye(o)}`)
		}
		return i
	}
	_computeCacheDirPath(r) {
		return e.computeCacheDirPath(r, this._storageUriProvider.storageUri)
	}
	static computeCacheDirPath(r, n) {
		let i = as(n),
			s = CC(e._textEncoder.encode(r))
		return $t(i, s)
	}
	async refreshSourceFolders() {
		this.requalifyLargeFolders()
		let r = Array.from(this._trackedSourceFolders.values())
			.map((n) => n.sourceFolder)
			.filter((n) => n !== void 0)
			.map((n) =>
				n.enqueueSerializedOperation(async () => {
					await this._refreshSourceFolder(n)
				}),
			)
		try {
			await Promise.allSettled(r)
		} catch (n) {
			this._logger.info(`One or more source folders failed to refresh: ${Ye(n)}`)
		}
	}
	async _refreshSourceFolder(r, n) {
		r.logger.debug(`Refreshing source folder ${r.folderName}`)
		let i = await this._createSourceFolderTracker(r, n)
		try {
			r.setTracker(i)
		} catch (l) {
			r.logger.info(`Failed to install SourceFolderTracker for ${r.folderName}: ${Ye(l)}`), i.dispose()
			return
		}
		let s = this._trackVcsRepo(r, i.pathFilter)
		s !== void 0 && r.addDisposable(s)
		let o = this._trackFileEdits(r)
		return o !== void 0 && r.addDisposable(o), this._trackOpenDocuments(r), await this._enumerateSourceFolder(r, n)
	}
	async _enumerateSourceFolder(r, n) {
		let i = r.tracker
		if (i === void 0) return
		let s = this._pathMap.nextEntryTS,
			o = await i.pathNotifier.enumeratePaths()
		if (!r.stopped)
			return (
				n?.charge("enumerate paths"),
				this._pathMap.purge(r.folderId, s),
				n?.charge("purge stale PathMap entries"),
				o
			)
	}
	async _createSourceFolderTracker(r, n) {
		let i = new Cc(),
			s = await ZQ(
				Ot.Uri.file(r.folderRoot),
				Ot.Uri.file(r.repoRoot),
				new QC(e.ignoreSources(r.folderRoot)),
				this._fileExtensions,
			)
		n?.charge("create PathFilter")
		let o = this._createPathNotifier(r, s)
		if ((i.add(o), n?.charge("create PathNotifier"), this._configListener.config.enableDebugFeatures)) {
			let a = new iQ(Ot.Uri.file(r.repoRoot), r.folderName, r.folderId)
			if ((i.add(a), a.listenForChanges(), this._vcsWatcher === void 0 && r.vcsDetails !== void 0)) {
				let l = new S_(r.folderName, r.folderId, r.vcsDetails)
				i.add(l), l.listenForChanges()
			}
		}
		return new v6(s, o, i)
	}
	_createPathNotifier(r, n) {
		let i = new wN(r.folderName, r.folderRoot, r.repoRoot, n, r.workspaceFolder)
		return (
			i.addDisposables(
				i.onDidFindPath((s) => {
					this._handlePathFound(r, s.relPath, s.fileType, s.acceptance)
				}),
				i.onDidCreatePath((s) => {
					this._handlePathCreated(r, s.relPath, s.fileType, s.acceptance)
				}),
				i.onDidChangePath((s) => {
					s.fileType === "File" && this._handleFileChanged(r, s.relPath, s.acceptance)
				}),
				i.onDidDeletePath((s) => {
					this._handlePathDeleted(r, s)
				}),
			),
			i
		)
	}
	_trackFileEdits(r) {
		if ((r.logger.debug(`_trackFileEdits was called on ${r.folderName}`), this._fileEditManager === void 0)) {
			r.logger.debug("_fileEditManager is undefined")
			return
		}
		return (
			r.logger.debug("_fileEditManager tracking the folder"),
			this._fileEditManager.startTracking(r.folderId, r.folderName, {
				directory: this._computeCacheDirPath(r.folderRoot),
			})
		)
	}
	_trackVcsRepo(r, n) {
		if ((r.logger.debug(`_trackVcsRepo was called on ${r.folderName}`), this._vcsWatcher === void 0)) {
			r.logger.debug("_vcsWatcher is undefined")
			return
		}
		let i = r.vcsDetails
		if (i === void 0) {
			r.logger.debug("vcsDetails is undefined")
			return
		}
		if (!Iy(y6(i.root), r.repoRoot)) {
			r.logger.info(`Not creating VCSRepoWatcher: vcs root ${as(i.root)} !== repo root ${r.repoRoot}`)
			return
		}
		return (
			r.logger.debug("_vcsWatcher tracking the folder"),
			this._vcsWatcher.startTracking(
				r.folderName,
				r.folderId,
				i,
				new _A.FileChangeWatcherImpl(i.root, this.onDidChangeFile),
				new _A.BlobNameRetrieverImpl(r.repoRoot, this, this._blobNameCalculator),
				new _A.FileUtilsImpl(n),
			)
		)
	}
	async _findRepoRoot(r) {
		let n
		return (
			(n = await yk(r, e.augmentRootName)),
			n === void 0 && (n = (await E_(r))?.root),
			n !== void 0 ? [y6(n), !0] : [r, !1]
		)
	}
	_trackOpenDocuments(r) {
		let n = this._openFileManager.getTrackedPaths(r.folderId)
		for (let i of n) r.acceptsPath(i) || this._openFileManager.stopTracking(r.folderId, i)
		Ot.workspace.textDocuments.forEach((i) => {
			this._trackDocument(r, i) !== void 0 &&
				this._fileEditManager?.addInitialDocument({
					folderId: r.folderId,
					relPath: r.relativePathName(i.uri.fsPath),
					document: i,
				})
		}),
			Ot.workspace.notebookDocuments.forEach((i) => {
				this._trackDocument(r, i)
			})
	}
	_trackDocument(r, n) {
		let i = hf(n.uri)
		if (i === void 0) return
		let s = r.relativePathName(i)
		if (s === void 0 || !r.acceptsPath(s)) return
		let o = this._pathMap.getBlobName(r.folderId, s)
		return this._openFileManager.addOpenedDocument({ folderId: r.folderId, relPath: s, document: n }, o), s
	}
	_stopTracking(r) {
		if (r.sourceFolder === void 0) {
			let n = r.cancel
			n.cancel(), n.dispose(), r.logger.info("Cancelled in-progress tracking of source folder")
		} else {
			let n = r.sourceFolder
			;(r.sourceFolder = void 0), n.dispose(), r.logger.info("Stopped tracking source folder")
		}
		this._folderSyncedEmitter.fire(), this._folderEnumeratedEmitter.fire()
	}
	translateRange(r, n, i) {
		let s = this._resolveAbsPath(r.absPath)
		if (s === void 0) return
		let [o, a] = s
		return this._openFileManager.translateRange(o.folderId, a, n, i)
	}
	getContext() {
		if (this._openFileManager === void 0 || this._pathMap === void 0) return qC.empty()
		let r = this._openFileManager.getRecencySummary(this._completionServer.completionParams.chunkSize),
			n = new Set(),
			i = new Map(),
			s = new Map()
		for (let [y, C] of r.folderMap) {
			let v = this._pathMap.getRepoRoot(y)
			v !== void 0 && s.set(v, C)
			for (let [b, w] of C) {
				n.add(w)
				let B = this._pathMap.getBlobName(y, b)
				B !== void 0 && B !== w && i.set(B, (i.get(B) ?? 0) + 1)
			}
		}
		let o = new Set()
		for (let [y, C] of i) n.has(y) || (C === this._pathMap.getUniquePathCount(y) && o.add(y))
		let a = new Array()
		for (let y of r.recentChunks) {
			let C = this._pathMap.getRepoRoot(y.folderId)
			C !== void 0 &&
				a.push({
					seq: y.seq,
					uploaded: y.uploaded,
					repoRoot: C,
					pathName: y.pathName,
					blobName: y.blobName,
					text: y.text,
					origStart: y.origStart,
					origLength: y.origLength,
					expectedBlobName: y.expectedBlobName,
				})
		}
		let l = [],
			c = []
		if (this._configListener.config.openFileManager.v2Enabled) {
			let y = this._openFileManager.getAllEditEvents()
			for (let v of y.values()) l.push(...v)
			let C = this._openFileManager.getAllPathToIndexedBlob()
			c = []
			for (let v of C.values()) for (let b of v.values()) c.push(b)
		}
		let u = this._blobsCheckpointManager,
			f = u !== void 0 && this._useCheckpointManagerContext,
			p = f && this._validateCheckpointManagerContext,
			g
		if (!f || p) {
			let y = new Set(n)
			for (let [b, w, B, M, Q] of this._pathMap.pathsWithBlobNames()) r.folderMap.get(b)?.has(B) || y.add(Q)
			let C = Array.from(y),
				v = this._blobNamesToBlobs(C)
			if (((g = new qC(v, a, s, l, c, this._lastChatResponse, C)), !f)) return g
		}
		let m = u.getContextAdjusted(n, o)
		return (
			g !== void 0 &&
				(u.validateMatching(g.blobs, m) ||
					this._clientMetricsReporter.report({
						client_metric: "blob_context_mismatch",
						value: 1,
					})),
			new qC(m, a, s, l, c, this._lastChatResponse)
		)
	}
	getContextWithBlobNames() {
		let r = this.getContext()
		return r.blobNames !== void 0 ? r : { ...r, blobNames: this._blobsCheckpointManager.expandBlobs(r.blobs) }
	}
	recordChatReponse(r) {
		this._lastChatResponse = { seq: this._sequenceGenerator.next(), text: r }
	}
	_blobNamesToBlobs(r) {
		return this._blobsCheckpointManager === void 0
			? { checkpointId: void 0, addedBlobs: r, deletedBlobs: [] }
			: this._blobsCheckpointManager.blobsPayload(r)
	}
	handleUnknownBlobs(r, n) {
		if (n.length === 0) return
		let i = new Set(n),
			s = new Array()
		for (let [o, a] of r.trackedPaths)
			if (o !== void 0) for (let [l, c] of a) i.has(c) && (s.push([c, new Je(o, l)]), i.delete(c))
		for (let o of i) {
			let a = this._pathMap.getAnyPathName(o)
			a !== void 0 && s.push([o, a])
		}
		this._unknownBlobHandler.enqueue(s), this._vcsWatcher?.handleUnknownBlobs(n)
	}
	handleUnknownCheckpoint(r, n) {
		this._logger.info(`received checkpoint not found for request id ${r}`),
			this._blobsCheckpointManager.resetCheckpoint(),
			this._blobsCheckpointManager.updateBlob("")
	}
	notifyBlobMissing(r, n) {
		let i = this._pathMap.reportMissing(n)
		if (i !== void 0) {
			let o = this._getSourceFolder(i.rootPath)
			if (o !== void 0) {
				o.diskFileManager.ingestPath(o.folderId, r.relPath)
				return
			}
		}
		let s = this._getSourceFolder(r.rootPath)
		s !== void 0 && this._openFileManager.handleMissingBlob(s.folderId, r.relPath, n)
	}
	_getSourceFolder(r) {
		return this._trackedSourceFolders.get(r)?.sourceFolder
	}
	resolvePathName(r) {
		let n = typeof r == "string" ? r : hf(r)
		if (n === void 0) return
		let i = this._resolveAbsPath(n)
		if (i === void 0) return
		let [s, o] = i
		return new Je(s.repoRoot, o)
	}
	getFolderRoot(r) {
		let n = typeof r == "string" ? r : hf(r)
		if (n === void 0) return
		let i = this._resolveAbsPath(n)
		if (i === void 0) return
		let [s, o] = i
		return s.folderRoot
	}
	safeResolvePathName(r) {
		let n = typeof r == "string" ? r : hf(r)
		if (n === void 0) return
		let i = this._resolveAbsPath(n)
		if (i === void 0) return new Je("", n)
		let [s, o] = i
		return new Je(s.repoRoot, o)
	}
	_resolveAbsPath(r) {
		for (let [n, i] of this._trackedSourceFolders) {
			if (i.sourceFolder === void 0) continue
			let s = i.sourceFolder.relativePathName(r)
			if (s !== void 0) return [i.sourceFolder, s]
		}
	}
	hasFile(r) {
		let [n, i] = this._resolveAbsPath(r.absPath) ?? [void 0, void 0]
		return n === void 0 || i === void 0 ? !1 : this._pathMap.hasFile(n.folderId, r.relPath)
	}
	getBlobName(r) {
		let [n, i] = this._resolveAbsPath(r.absPath) ?? [void 0, void 0]
		if (!(n === void 0 || i === void 0))
			return (
				this._openFileManager.getBlobName(n.folderId, r.relPath) ??
				this._pathMap.getBlobName(n.folderId, r.relPath)
			)
	}
	getAllPathNames(r) {
		return this._pathMap.getAllPathNames(r)
	}
	getAllQualifiedPathInfos(r) {
		return this._pathMap.getAllQualifiedPathInfos(r)
	}
	getAllQualifiedPathNames(r) {
		return this._pathMap.getAllQualifiedPathNames(r)
	}
	getAllPathInfo(r) {
		return this._pathMap.getAllPathInfo(r)
	}
	_handlePathFound(r, n, i, s) {
		let o = r.folderId
		this._pathMap.insert(o, n, i, s), i === "File" && s.accepted && r.diskFileManager.ingestPath(o, n)
	}
	_handlePathCreated(r, n, i, s) {
		let o = r.folderId
		if ((this._pathMap.insert(o, n, i, s), !!s.accepted)) {
			if (i === "File") r.diskFileManager.ingestPath(r.folderId, n), this._emitFileNotification(o, n, "disk")
			else if (i === "Directory") {
				let a = r.tracker?.pathFilter
				if (a === void 0) return
				r.enqueueSerializedOperation(() => this._handleDirectoryCreated(r, n, a))
			}
		}
	}
	_handleFileChanged(r, n, i) {
		let s = r.folderId
		this._pathMap.insert(s, n, "File", i),
			i.accepted && (r.diskFileManager.ingestPath(s, n), this._emitFileNotification(s, n, "disk"))
	}
	_handlePathDeleted(r, n) {
		let i = r.folderId,
			s = this._pathMap.getPathInfo(i, n)
		if (s === void 0) return
		this._deletePath(r.folderId, n)
		let [o, a] = s
		a.accepted &&
			(o === "Directory"
				? this._handleDirectoryRemoved(r, n)
				: o === "File" && this._emitFileNotification(i, n, "disk"),
			this._fileDeletedEmitter.fire({ folderId: i, relPath: n }))
	}
	_deletePath(r, n) {
		this._pathMap.remove(r, n)
	}
	async _handleDirectoryCreated(r, n, i) {
		r.logger.info(`Directory created: ${n}`)
		let s = Ot.Uri.file(r.repoRoot),
			o = new PC(r.folderName, Ot.Uri.joinPath(s, n), s, i)
		for await (let [a, l, c, u] of o) this._handlePathFound(r, l, c, u)
	}
	_handleDirectoryRemoved(r, n) {
		r.logger.info(`Directory removed: ${n}`)
		let i = r.folderId,
			s = new Array()
		for (let [o] of this._pathMap.pathsInFolder(i)) Nh(n, o) !== void 0 && s.push(o)
		for (let o of s) this._deletePath(i, o)
	}
	_notifyActiveEditorChanged(r) {
		let n = r?.document,
			i = this._uriToPathInfo(n?.uri)
		if (i === void 0) {
			this._openFileManager.loseFocus()
			return
		}
		let [s, o] = i,
			a = this._pathMap.getBlobName(s, o)
		this._openFileManager.addOpenedDocument({ folderId: s, relPath: o, document: n }, a)
	}
	_notifyTextDocumentChanged(r) {
		let n = this._uriToPathInfo(r.document.uri)
		if (n === void 0) return
		let [i, s] = n
		this._openFileManager.handleChangedDocument({
			folderId: i,
			relPath: s,
			event: r,
		}),
			this._emitFileNotification(i, s, "buffer"),
			this._textDocumentChangedEmitter.fire({
				folderId: i,
				relPath: s,
				event: r,
			})
	}
	_notifyTextDocumentOpened(r) {
		let n = this._uriToPathInfo(r.uri)
		if (n === void 0) return
		let [i, s] = n
		this._textDocumentOpenedEmitter.fire({
			folderId: i,
			relPath: s,
			document: r,
		})
	}
	_notifyTextDocumentClosed(r) {
		let n = this._uriToPathInfo(r.uri)
		if (n === void 0) return
		let [i, s] = n
		this._textDocumentClosedEmitter.fire({
			folderId: i,
			relPath: s,
			document: r,
		})
	}
	_notifyNotebookDocumentChanged(r) {
		let n = this._uriToPathInfo(r.notebook.uri)
		if (n === void 0) return
		let [i, s] = n
		this._openFileManager.handleChangedDocument({
			folderId: i,
			relPath: s,
			event: r,
		}),
			this._emitFileNotification(i, s, "buffer")
	}
	_uriToPathInfo(r) {
		if (r === void 0) return
		let n = hf(r)
		if (n === void 0) return
		let i = this._resolveAbsPath(n)
		if (i === void 0) return
		let [s, o] = i
		if (s.acceptsPath(o)) return [s.folderId, o]
	}
	_notifyWillRenameFile(r) {
		r.files.forEach((n) => {
			let i = this._resolveAbsPath(n.oldUri.fsPath),
				s = this._resolveAbsPath(n.newUri.fsPath)
			if (i === void 0 || s === void 0) return
			let [o, a] = i,
				[l, c] = s
			if (o.folderId !== l.folderId) {
				this._logger.debug(
					`[WARN] Rename should not cause a file to move between source folders.     old file: ${i[1]}     new file: ${s[1]}    old source folder: ${o.folderName}     new source folder: ${l.folderName}`,
				)
				return
			}
			this._fileWillRenameEmitter.fire({
				folderId: o.folderId,
				oldRelPath: a,
				newRelPath: c,
				type: Fh(n.oldUri.fsPath).type,
			})
		})
	}
	_notifyDocumentClosed(r) {
		let n = r.uri,
			i = hf(n)
		if (i === void 0) return
		let s = this._resolveAbsPath(i)
		if (s === void 0) return
		let [o, a] = s
		this._openFileManager.handleClosedDocument({
			folderId: o.folderId,
			relPath: a,
			document: r,
		})
	}
	_emitFileNotification(r, n, i) {
		this._fileChangedEmitter.fire({ folderId: r, relPath: n, origin: i })
	}
	getTabSwitchEvents() {
		return this._tabWatcher?.getTabSwitchEvents()
	}
	getFileEditEvents(r = void 0) {
		if (this._fileEditManager === void 0) return []
		let n
		if (r !== void 0) {
			let i = this._trackedSourceFolders.get(r)?.sourceFolder
			if (i === void 0) return []
			n = i.folderId
		} else n = this._fileEditManager.findFolderIdWithMostRecentChanges()
		return n === -1 ? [] : this._fileEditManager.findEventsForFolder(n)
	}
	getMostRecentlyChangedFolderRoot() {
		if (this._fileEditManager === void 0) return
		let r = this._fileEditManager.findFolderIdWithMostRecentChanges()
		if (r !== -1) {
			for (let [n, i] of this._trackedSourceFolders) if (i.sourceFolder?.folderId === r) return n
		}
	}
	findBestWorkspaceRootMatch(r) {
		let n = dW(r).slice(0, -1),
			i = "",
			s
		for (let c of n) {
			i = $t(i, c)
			let u = this.getAllQualifiedPathInfos(i).filter((f) => f.isAccepted)
			if (u.length === 0) break
			s = u[0]
		}
		if (s !== void 0) return s
		let o = this.getMostRecentlyChangedFolderRoot(),
			a = o ? this.getRepoRootForFolderRoot(o) : void 0
		if (a !== void 0)
			return {
				qualifiedPathName: new Je(a, ""),
				fileType: "Directory",
				isAccepted: !1,
			}
		let l = this.listSourceFolders().filter((c) => c.type === 0 && c.syncingEnabled)
		if (l.length > 0)
			return {
				qualifiedPathName: new Je(l[0].folderRoot, ""),
				fileType: "Directory",
				isAccepted: !1,
			}
	}
	getRepoRootForFolderRoot(r) {
		return this._trackedSourceFolders.get(r)?.sourceFolder?.repoRoot
	}
	getVCSWatchedFolderIds() {
		return this?._vcsWatcher?.getWatchedFolderIds() ?? []
	}
	async getVCSChange() {
		return this._vcsWatcher === void 0 ? { commits: [], workingDirectory: [] } : await this._vcsWatcher.getChanges()
	}
	getEnableCompletionFileEditEvents() {
		return this._featureFlagManager.currentFlags.enableCompletionFileEditEvents
	}
	async updateStatusTrace(r) {
		r.addSection("Syncing permission parameters"),
			r.addValue("enableFileLimitsForSyncingPermission", this.enableFileLimitsForSyncingPermission),
			r.addValue("maxTrackableFiles", this.maxTrackableFiles),
			r.addValue("maxTrackableFilesWithoutPermission", this.maxTrackableFilesWithoutPermission),
			r.addValue("minUploadedFractionWithoutPermission", this.minUploadedFractionWithoutPermission),
			r.addValue(
				"minUploadedFractionWithoutPermission as a percentage",
				this.minUploadedFractionWithoutPermission * 100,
			),
			r.addValue("verifyFolderIsSourceRepo", this.verifyFolderIsSourceRepo),
			r.addValue("refuseToSyncHomeDirectories", this.refuseToSyncHomeDirectories)
		let n = 0
		for (let [s, o] of this._registeredSourceFolders) {
			if (
				(n++,
				r.addSection(`Source folder: ${s}`),
				o.folderType === 0
					? r.addValue("Folder type", "vscode workspace folder")
					: r.addValue("Folder type", "external folder"),
				o.containingFolderRoot !== void 0)
			) {
				r.addValue("Not tracked: nested folder. Containing folder", o.containingFolderRoot)
				continue
			}
			if (o.isHomeDir) {
				r.addLine("Not tracked: home directory")
				continue
			}
			if (o.folderQualification !== void 0 && !o.folderQualification.trackable) {
				r.addLine("Not tracked: folder is too large")
				continue
			}
			let a = Pa(o)
			if (a === "permission denied") {
				r.addLine("Not tracked: syncing permission denied")
				continue
			}
			if (a === "permission needed") {
				r.addLine("Not tracked: syncing permission not yet granted")
				continue
			}
			let l = this._trackedSourceFolders.get(s)?.sourceFolder
			if (l === void 0) {
				r.addLine("Tracking in progress")
				continue
			}
			r.addValue("Folder root", s),
				r.addValue("Repo root", l.repoRoot),
				r.addValue("Mtime cache dir", l.cacheDirPath),
				l.diskFileManager.itemsInFlight === 0 || r.addValue("Source folder startup", "in progress"),
				r.addValue("Source folder startup", "complete"),
				r.addValue("Tracked files", this._pathMap.trackedFileCount(l.folderId)),
				r.addValue("Syncing backlog size", l.diskFileManager.itemsInFlight)
		}
		if (
			(n === 0 && r.addSection("Source folders: no open source folders"),
			r.addSection("Workspace status"),
			!this.initialFoldersSynced)
		)
			r.addValue("Workspace startup", "in progress")
		else {
			r.addValue("Workspace startup", "complete")
			let s = this.getContextWithBlobNames()
			r.addValue("Blobs in context", s.blobNames.length)
			let o = r.savePoint()
			try {
				let l = 0
				for (let c = 0; c < s.blobNames.length; c += 1e3) {
					r.rollback(o), r.addLine(`Verifying blob names... ${c} / ${s.blobNames.length} `), r.publish()
					let u = await this._apiServer.findMissing(s.blobNames.slice(c, c + 1e3))
					l += u.unknownBlobNames.length
				}
				r.rollback(o), r.addValue("Unknown blob names", l)
			} catch (a) {
				r.rollback(o), r.addError(`Unable to verify blob names: ${a}`)
			}
		}
		n === 0 && r.addLine("No source folders in workspace")
		let i = this._blobsCheckpointManager
		if (i !== void 0) {
			let s = i.getContext(),
				o = i.getCheckpointedBlobNames().length
			r.addValue("Current checkpoint", s.checkpointId),
				r.addValue("Blobs in current checkpoint", o),
				r.addValue("Added blobs not in checkpoint", s.addedBlobs.length),
				r.addValue("Deleted blobs not in checkpoint", s.deletedBlobs.length)
		}
	}
	_reportSourceFolderStartup(r, n, i, s) {
		let o = n.diskFileManager.metrics
		r.info("Tracking enabled"), r.info(s.format()), r.info(o.format()), r.info(i.format())
	}
	_reportWorkspaceStartup(r) {
		this._logger.info(`Workspace startup complete in ${r} ms`)
	}
	trackedSourceFolderNames() {
		return Array.from(this._registeredSourceFolders)
			.filter(([r, n]) => Pa(n) === "trackable")
			.map(([r, n]) => ({ folderRoot: r }))
	}
	getSourceFoldersReportDetails() {
		let r = this.listSourceFolders(),
			n = (0, Ll.mapValues)(
				(0, Ll.groupBy)(r, (f) => Ly[f.type]),
				(f) => f.length,
			),
			i = (0, Ll.mapValues)(
				(0, Ll.groupBy)(r, (f) => Ly[f.type]),
				(f) => (0, Ll.uniq)(f.map((p) => this.getRepoRootForFolderRoot(p.folderRoot))).length,
			),
			s = (f) => f.type === 0 || f.type === 1,
			o = (f) => f.type === 2 || f.type === 3,
			a = (f) => f.type === 4,
			l = r.filter((f) => s(f)).map((f) => f.trackedFileCount),
			c = r.filter((f) => o(f)).length,
			u = (0, Ll.mapValues)(
				(0, Ll.groupBy)(
					r.filter((f) => a(f)),
					(f) => f.reason,
				),
				(f) => f.length,
			)
		return {
			workspaceStorageUri: this._storageUriProvider.storageUri?.toString(),
			folderCountByType: n,
			repoRootCountByType: i,
			trackedFileCount: l,
			nestedFolderCount: c,
			untrackedCountByReason: u,
		}
	}
	listSourceFolders() {
		if (this._syncingPermissionTracker.syncingPermissionDenied) return []
		let r = this.syncingEnabledState === "disabled",
			n = new Array()
		for (let [i, s] of this._registeredSourceFolders) {
			if (s.containingFolderRoot !== void 0) {
				let f = s.folderType === 0 ? 2 : 3
				n.push({
					type: f,
					name: s.folderName,
					syncingEnabled: !1,
					folderRoot: i,
					containingFolderRoot: s.containingFolderRoot,
				})
				continue
			}
			if (s.isHomeDir) {
				n.push({
					type: 4,
					name: s.folderName,
					syncingEnabled: !1,
					folderRoot: i,
					reason: "home directory",
				})
				continue
			}
			if (s.folderQualification !== void 0 && !s.folderQualification.trackable) {
				n.push({
					type: 4,
					name: s.folderName,
					syncingEnabled: !1,
					folderRoot: i,
					reason: "too large",
				})
				continue
			}
			if (s.syncingPermission === "denied") {
				n.push({
					type: 4,
					name: s.folderName,
					syncingEnabled: !1,
					folderRoot: i,
					reason: "permission not granted",
				})
				continue
			}
			let o = s.folderType === 0 ? 0 : 1,
				a = this._trackedSourceFolders.get(i)?.sourceFolder
			if (!a?.initialEnumerationComplete) {
				let f = !r && s.syncingPermission === "granted"
				n.push({
					name: s.folderName,
					type: o,
					folderRoot: i,
					syncingEnabled: f,
					trackedFileCount: 0,
					containsExcludedItems: !1,
					containsUnindexedItems: !1,
					enumerationState: 0,
				})
				continue
			}
			let l = !r && s.syncingPermission === "granted",
				c = !1,
				u = !1
			for (let [f, p, g, m] of this._pathMap.pathsInFolder(a.folderId))
				g || (c = !0), p === "File" && g && !m && (u = !0)
			n.push({
				name: s.folderName,
				type: o,
				folderRoot: i,
				syncingEnabled: l,
				trackedFileCount: this._pathMap.trackedFileCount(a.folderId),
				containsExcludedItems: c,
				containsUnindexedItems: u,
				enumerationState: 1,
			})
		}
		return n
	}
	listChildren(r, n) {
		if (this._syncingPermissionTracker.syncingPermissionDenied) return []
		let s = this._trackedSourceFolders.get(r)?.sourceFolder
		if (s === void 0) throw new hM()
		if (!s.initialEnumerationComplete) throw new gM()
		let o = $t(r, n),
			a = vl(s.repoRoot, o),
			l = new Map(),
			c = new Map(),
			u = new Set(),
			f = new Set(),
			p = s.folderId
		for (let [g, m, y, C, v] of this._pathMap.pathsInFolder(p)) {
			let b = Nh(a, g)
			if (b === void 0) continue
			let w = dW(b)
			if (!(w.length === 0 || w[0].length === 0))
				if (w.length === 1) l.set(w[0], { type: m, included: y, indexed: C, reason: v })
				else {
					let B = w[0]
					if (!y) u.add(B)
					else if (m === "File") {
						let M = c.get(B) ?? 0
						c.set(B, M + 1), C || f.add(B)
					}
				}
		}
		return Array.from(l.entries()).map(([g, m]) => {
			let y = {
				name: g,
				folderRoot: r,
				relPath: $t(n, g),
				included: m.included,
				reason: m.reason,
			}
			return m.type === "File"
				? { ...y, type: "File", indexed: m.indexed }
				: m.type === "Directory"
					? {
							...y,
							type: "Directory",
							trackedFileCount: c.get(g) ?? 0,
							containsExcludedItems: u.has(g),
							containsUnindexedItems: f.has(g),
						}
					: { ...y, type: "Other" }
		})
	}
	clearFileEdits() {
		this._fileEditManager?.clearAll({ clearLastKnown: !1 })
	}
	unitTestOnlyGetRepoRoot(r) {
		let n = this._trackedSourceFolders.get(r)
		if (n !== void 0) return n.sourceFolder?.repoRoot
	}
	unitTestOnlySourceFolderBacklog(r) {
		let n = this._trackedSourceFolders.get(r)
		if (n === void 0) return
		let i = n.sourceFolder
		if (i !== void 0 && i.initialEnumerationComplete) return i.diskFileManager.itemsInFlight
	}
}
var wwe = W(require("vscode"))
var RN = class extends z {
	constructor(r, n) {
		super()
		this.actionsModel = r
		this.workspaceManager = n
		this.setInitializing(), this.addDisposable(n), this.checkWorkspaceSelected(), this.checkWorkspacePopulated()
	}
	checkWorkspaceSelected() {
		!!wwe.workspace.workspaceFolders?.length ? this._setWorkspaceSelected() : this._setWorkspaceNotSelected()
	}
	async checkWorkspacePopulated() {
		if ((await this.workspaceManager.awaitInitialFoldersEnumerated(), this._anyFilesExist())) {
			this._setWorkspacePopulated()
			return
		}
		for (this._setWorkspaceEmpty(); !this._anyFilesExist(); )
			await $p(this.workspaceManager.onDidChangeSyncingProgress)
		this._setWorkspacePopulated()
	}
	_anyFilesExist() {
		return !!this.workspaceManager
			.getSyncingProgress()
			.some((n) => n.progress?.trackedFiles !== void 0 && n.progress.trackedFiles > 0)
	}
	setInitializing() {
		this.actionsModel.setSystemStateStatus("workspacePopulated", "initializing"),
			this.actionsModel.setSystemStateStatus("workspaceSelected", "initializing")
	}
	_setWorkspaceEmpty() {
		this.actionsModel.setSystemStateStatus("workspacePopulated", "incomplete")
	}
	_setWorkspacePopulated() {
		this.actionsModel.setSystemStateStatus("workspacePopulated", "complete")
	}
	_setWorkspaceSelected() {
		this.actionsModel.setSystemStateStatus("workspaceSelected", "complete")
	}
	_setWorkspaceNotSelected() {
		this.actionsModel.setSystemStateStatus("workspaceSelected", "incomplete")
	}
}
var AA = class e extends z {
	constructor(r, n, i, s, o, a, l, c, u, f, p, g, m, y, C, v, b, w) {
		super()
		this._extensionContext = r
		this._globalState = n
		this._augmentConfigListener = i
		this._apiServer = s
		this._auth = o
		this._recentCompletions = a
		this._recentInstructions = l
		this._recentNextEditResults = c
		this._recentChats = u
		this._nextEditWebViewEvent = f
		this._onExtensionUpdateEvent = p
		this._mainPanelProvider = g
		this._changeWebviewAppEvent = m
		this._actionsModel = y
		this._syncingEnabledTracker = C
		this._chatExtensionEvent = v
		this._onboardingSessionEventReporter = b
		this._assetManager = w
		if (
			((this._statusBar = new DQ()),
			r.subscriptions.push(this._statusBar),
			(this.featureFlagManager = new jR(
				{
					fetcher: this._fetchFeatureFlags.bind(this),
					refreshIntervalMSec: 30 * 60 * 1e3,
				},
				this._augmentConfigListener,
			)),
			(this._completionAcceptanceReporter = new H1(s, this._onboardingSessionEventReporter)),
			(this._codeEditReporter = new V1(s)),
			(this._nextEditResolutionReporter = new $1(s)),
			(this._nextEditSessionEventReporter = new Y1(s)),
			(this.nextEditConfigManager = new pF(
				this._augmentConfigListener,
				this.featureFlagManager,
				this._globalState,
			)),
			(this._clientMetricsReporter = new q1(s)),
			(this._completionTimelineReporter = new W1(s)),
			(this._agentSessionEventReporter = new bI(new Gx(this.featureFlagManager))),
			(this._agentRequestEventReporter = new O1(s)),
			(this._extensionEventReporter = new G1(s)),
			(this.guidelinesWatcher = new kk(
				this._augmentConfigListener,
				this.featureFlagManager,
				this._clientMetricsReporter,
			)),
			(this._toolUseRequestEventReporter = new xI()),
			this.disposeOnDisable.push(this.guidelinesWatcher),
			this.addDisposable(new je.Disposable(() => this.disable())),
			(this._completionsModel = new E1(this, this._augmentConfigListener, this._clientMetricsReporter)),
			!Ko("1.96.0"))
		)
			try {
				this._logger.info("Starting macCA"), (0, Twe.addToGlobalAgent)(), this._logger.info("macCa Done")
			} catch (B) {
				this._logger.error("Exception loading mac-ca certs:", B)
			}
	}
	static augmentRootName = ".augmentroot"
	static contentScheme = "augment"
	static displayStatusUri = je.Uri.from({
		scheme: this.contentScheme,
		path: "Augment Extension Status",
	})
	static modelConfigBackoffMsecMax = 3e4
	keybindingWatcher = void 0
	_completionServer = void 0
	workspaceManager = void 0
	syncingStatusReporter = void 0
	fuzzyFsSearcher = void 0
	fuzzySymbolSearcher = void 0
	_toolsModel = void 0
	get toolsModel() {
		return this._toolsModel
	}
	_toolConfigStore = void 0
	get toolConfigStore() {
		return this._toolConfigStore
	}
	_agentCheckpointManager = void 0
	guidelinesWatcher
	_statusBar
	_initState
	_enableCancel
	_defaultModel
	_modelInfo
	_blobNameCalculator
	_nextEditRequestManager
	_suggestionManager
	get modelInfo() {
		return this._modelInfo
	}
	userTier = "unknown"
	_availableModels = []
	_languages = []
	get languages() {
		return this._languages
	}
	featureFlagManager
	_onTextDocumentDidChange = new je.EventEmitter()
	_statusTrace
	_completionDisposables = []
	_completionAcceptanceReporter
	_codeEditReporter
	_nextEditResolutionReporter
	_nextEditSessionEventReporter
	nextEditConfigManager
	_clientMetricsReporter
	_completionTimelineReporter
	_extensionEventReporter
	_agentSessionEventReporter
	_agentRequestEventReporter
	_dataCollector
	_editorNextEdit
	_backgroundNextEdit
	_globalNextEdit
	_diagnosticsManager
	_nextEditVSCodeToWebviewMessage = new je.EventEmitter()
	_openChatHintManager
	enabled = !1
	_enableState
	disposeOnDisable = []
	_inlineCompletionProvider
	_completionsModel
	_logger = X("AugmentExtension")
	_chatModel
	_currentChatExtensionEventDisposable
	_toolUseRequestEventReporter
	get sessionId() {
		return this._apiServer.sessionId
	}
	get chatModel() {
		return this._chatModel
	}
	get editorNextEdit() {
		return this._editorNextEdit
	}
	get agentSessionEventReporter() {
		return this._agentSessionEventReporter
	}
	get completionServer() {
		return this._completionServer
	}
	get completionsModel() {
		return this._completionsModel
	}
	get agentCheckpointManager() {
		return this._agentCheckpointManager
	}
	get enableInProgress() {
		return this._enableCancel !== void 0
	}
	get ready() {
		return this.enabled && !this.enableInProgress
	}
	async enable() {
		if (this.enabled || this.enableInProgress) return
		let r = new je.CancellationTokenSource()
		this._enableCancel = r
		try {
			await this._enable(r.token)
		} catch (n) {
			if ((this._logger.info(`Unable to enable extension: ${Ye(n)}`), process.env.JEST_WORKER_ID)) throw n
		} finally {
			r.dispose(), (this._enableCancel = void 0)
		}
	}
	_syncLastEnabledExtensionVersion() {
		if (this._extensionContext.extensionMode === je.ExtensionMode.Development) return !1
		let r = this._extensionContext.extension.packageJSON.version
		return this._extensionVersion === r
			? !1
			: (this._globalState.update("lastEnabledExtensionVersion", r), this._onExtensionUpdateEvent.fire(), !0)
	}
	get _extensionVersion() {
		return this._globalState.get("lastEnabledExtensionVersion") || ""
	}
	async _enable(r) {
		if (
			((0, Swe.assert)(!this.enabled),
			this._initState?.dispose(),
			this._enableState?.dispose(),
			this.disposeOnDisable.push(
				new J1(this._clientMetricsReporter, {
					periodMs: 100,
					debugThresholdMs: 50,
					infoThresholdMs: 2e3,
				}),
			),
			this._auth.useOAuth)
		) {
			if (!(await this._auth.getSession())) {
				this._enableState = this._statusBar.setState(Qxe)
				return
			}
		} else {
			if (!this._augmentConfigListener.config.apiToken) {
				this._logger.warn("No API token is configured"), (this._enableState = this._statusBar.setState(Pxe))
				return
			}
			if (!this._augmentConfigListener.config.completionURL) {
				this._logger.warn("No completion URL is configured"),
					(this._enableState = this._statusBar.setState(Lxe))
				return
			}
		}
		let n = this._statusBar.setState(Uxe),
			i,
			s = new Map()
		try {
			if (((i = await this._getModelConfig(r)), i.models.length === 0)) throw new LT()
			;(this.userTier = i.userTier),
				je.commands.executeCommand("setContext", "augment.userTier", this.userTier),
				(this._defaultModel = i.defaultModel),
				(this._languages = i.languages),
				(this._availableModels = i.models.map((j) => `${j.name} - ${j.internalName}`))
			let Y = this._augmentConfigListener.config.modelName || i.defaultModel
			if (
				((this._modelInfo = i.models.find(
					(j) =>
						[j.name, j.internalName].includes(Y) ||
						j.name === (0, Bwe.createHash)("sha256").update(Y).digest("hex"),
				)),
				this._modelInfo === void 0)
			)
				throw new Ob(Y)
			this.featureFlagManager.update(i.featureFlags)
			for (let j of i.models) s.set(j.name, j)
			this._initState?.dispose()
		} catch (O) {
			if (kr.isAPIErrorWithStatus(O, He.unauthenticated)) {
				this._auth.useOAuth
					? (this._enableState = this._statusBar.setState(Oxe))
					: (this._enableState = this._statusBar.setState(qxe))
				return
			} else if (O instanceof Yp) {
				this._enableState = this._statusBar.setState(Vxe)
				return
			} else if (O instanceof je.CancellationError) return
			let Y = Ye(O)
			throw (
				(this._logger.error(`Failed to get model config: ${Y}`),
				(this._initState = this._statusBar.setState(t8)),
				O)
			)
		} finally {
			n.dispose()
		}
		this.featureFlagManager.currentFlags.enableViewTextDocument &&
			(this._logger.debug("Enabling viewTextDocument background file scheme"), this.disposeOnDisable.push(pme()))
		let o = new VQ(this._extensionContext.workspaceState)
		this.disposeOnDisable.push(o),
			(this._completionServer = new y1(
				this._apiServer,
				this._modelInfo.completionTimeoutMs,
				this._modelInfo.suggestedPrefixCharCount,
				this._modelInfo.suggestedSuffixCharCount,
			))
		let a = this.featureFlagManager.currentFlags.maxUploadSizeBytes
		;(this._blobNameCalculator = new Hf(a)),
			(this.workspaceManager = new TN(
				this._actionsModel,
				new QQ(this._extensionContext.workspaceState),
				o,
				this._extensionContext,
				this._apiServer,
				this._augmentConfigListener,
				this.featureFlagManager,
				this._clientMetricsReporter,
				this._completionServer,
				this._blobNameCalculator,
				a,
				this._syncingEnabledTracker,
				this._onboardingSessionEventReporter,
				i.languages,
			)),
			this.disposeOnDisable.push(this.workspaceManager)
		let l = (0, Dwe.debounce)(() => {
			let O = this.workspaceManager?.getSourceFoldersReportDetails()
			O !== void 0 && this._extensionEventReporter.reportSourceFolders(O)
		}, 5e3)
		this.disposeOnDisable.push(this.workspaceManager.onDidEnumerateFolder(() => l())),
			this.disposeOnDisable.push(this.workspaceManager.onDidChangeSourceFolders(() => l())),
			(this.syncingStatusReporter = new HQ(this.featureFlagManager, this.workspaceManager)),
			this.disposeOnDisable.push(this.syncingStatusReporter),
			this.disposeOnDisable.push(new PQ(this._statusBar, this.syncingStatusReporter.onDidChangeSyncingStatus)),
			(this.keybindingWatcher = new kc(this._globalState)),
			this.disposeOnDisable.push(this.keybindingWatcher),
			(this._diagnosticsManager = new R1()),
			this.disposeOnDisable.push(this._diagnosticsManager)
		let c = new yA(this._statusBar)
		this.disposeOnDisable.push(c)
		let u = new EA()
		this.disposeOnDisable.push(
			hxe((O) => {
				O.acceptedIdx >= 0 && u.set(!0, O.document)
			}),
		),
			this.disposeOnDisable.push(u)
		let f = new tQ()
		this.disposeOnDisable.push(f),
			(this._suggestionManager = new xQ(this.workspaceManager, this._nextEditSessionEventReporter)),
			this.disposeOnDisable.push(this._suggestionManager),
			(this._nextEditRequestManager = new EQ(
				this._apiServer,
				this._augmentConfigListener,
				this.workspaceManager,
				this._diagnosticsManager,
				this._nextEditSessionEventReporter,
				this._clientMetricsReporter,
				this._blobNameCalculator,
				this._suggestionManager,
				this._recentNextEditResults,
				c,
				u,
				this.featureFlagManager,
			)),
			this.disposeOnDisable.push(this._nextEditRequestManager),
			(this._editorNextEdit = new mQ(
				this._extensionContext,
				this.workspaceManager,
				this._nextEditSessionEventReporter,
				this.keybindingWatcher,
				this._augmentConfigListener,
				this._suggestionManager,
				this._nextEditRequestManager,
				this._globalState,
				this.nextEditConfigManager,
				f,
				(O) => {
					this._nextEditWebViewEvent.fire({
						type: "next-edit-active-suggestion",
						data: O,
					})
				},
			)),
			this.disposeOnDisable.push(this._editorNextEdit),
			(this._globalNextEdit = new vQ(
				this.workspaceManager,
				this._nextEditRequestManager,
				this._suggestionManager,
				this._augmentConfigListener,
				this._nextEditSessionEventReporter,
			)),
			this.disposeOnDisable.push(this._globalNextEdit)
		let p = [
			{
				text: this.featureFlagManager.currentFlags.enableInstructions ? "Chat" : "Open in Augment Chat",
				keyBindingId: Hi.commandID,
			},
		]
		this.featureFlagManager.currentFlags.enableInstructions &&
			p.push({ text: "Instruct", keyBindingId: $y.commandID }),
			(this._openChatHintManager = new kC(
				this._augmentConfigListener,
				this._extensionContext,
				this.keybindingWatcher,
				this.featureFlagManager,
				p,
			)),
			this._openChatHintManager.enable(),
			this.disposeOnDisable.push(this._openChatHintManager),
			(this.fuzzyFsSearcher = new Dk(
				this._globalState,
				this.workspaceManager,
				this.syncingStatusReporter.onDidChangeSyncingStatus,
			)),
			(this.fuzzySymbolSearcher = new Tk(
				this._globalState,
				this._augmentConfigListener,
				this.fuzzyFsSearcher,
				this.workspaceManager,
			)),
			this.disposeOnDisable.push(this.fuzzyFsSearcher),
			this.disposeOnDisable.push(this.fuzzySymbolSearcher),
			await yme(this._extensionContext.storageUri, this._logger)
		let g = () => {
			let O = this._extensionContext.storageUri
			if (O) return je.Uri.joinPath(O, "Augment-Memories").fsPath
		}
		b$(new rM(this.workspaceManager)),
			this.disposeOnDisable.push(new je.Disposable(() => x$())),
			cY(new nM(this._apiServer, this.workspaceManager)),
			this.disposeOnDisable.push(new je.Disposable(() => uY())),
			p$(this._assetManager),
			this.disposeOnDisable.push(new je.Disposable(() => A$())),
			(this._agentCheckpointManager = new EI(new cI(), g, (O) =>
				je.workspace.onDidChangeTextDocument((Y) => {
					let j = this.workspaceManager?.safeResolvePathName(Y.document.uri)
					if (!j) return
					let ne = {
						document: {
							qualifiedPathName: j,
							getText: () => Y.document.getText(),
						},
						contentChanges: Y.contentChanges.map((q) => ({
							text: q.text,
							range: q.range
								? {
										start: {
											line: q.range.start.line,
											character: q.range.start.character,
										},
										end: {
											line: q.range.end.line,
											character: q.range.end.character,
										},
									}
								: void 0,
						})),
					}
					O(ne)
				}),
			)),
			this.disposeOnDisable.push(this._agentCheckpointManager),
			(this._toolsModel = new GS(
				[],
				sCe(
					this._apiServer,
					this.workspaceManager,
					this._agentCheckpointManager,
					this.featureFlagManager,
					this._extensionContext.extensionUri,
					this._agentSessionEventReporter,
				),
				new Xk(this._apiServer, this._augmentConfigListener),
				(O) => {
					je.window.showErrorMessage("Failed to start the MCP server. " + JSON.stringify(O))
				},
				new Gx(this.featureFlagManager),
				this._agentCheckpointManager,
				g,
				() => this._augmentConfigListener.config.agent,
				() => this._toolUseRequestEventReporter,
				{ unsupportedTools: new Set([]) },
				"Augment-VSCode/1.0",
			)),
			dY(new JS(this._agentCheckpointManager, this._toolsModel)),
			this.disposeOnDisable.push(new je.Disposable(() => fY())),
			(this._toolConfigStore = new RQ(
				this._globalState,
				this._toolsModel,
				() => this._augmentConfigListener.config.mcpServers,
			)),
			this.disposeOnDisable.push(
				new je.Disposable(() => {
					this._toolConfigStore = void 0
				}),
			),
			this._toolConfigStore.updateSidecarMCPServers(),
			(async (O) => {
				let Y = O.memoriesAbsPath
				if (Y) {
					let j = je.Uri.file(Y)
					try {
						await xy(j.fsPath)
					} catch {
						await Bu(j.fsPath, "")
					}
				}
				this.addDisposable(
					je.window.onDidChangeActiveTextEditor(async (j) => {
						await Eme(j, g, this._globalState), await CW(j, g, this._globalState)
					}),
				),
					this.addDisposable(
						je.workspace.onDidChangeTextDocument((j) => {
							xme(j, je.window.activeTextEditor, g, this._globalState)
						}),
					),
					this.addDisposable(vme())
			})(this._toolsModel),
			this.addDisposable(
				this._augmentConfigListener.onDidChange(({ newConfig: O, previousConfig: Y }) => {
					this._toolsModel &&
						((0, E6.default)(O.mcpServers, Y.mcpServers) ||
							this._toolConfigStore?.updateSidecarMCPServers(),
						O.agent.disableRetrievalTool !== Y.agent.disableRetrievalTool &&
							this._toolsModel.restartHosts())
				}),
			)
		let y = new ky(
			this._globalState,
			this._apiServer,
			this.workspaceManager,
			this._recentChats,
			this.fuzzySymbolSearcher,
			this._assetManager,
		)
		this._chatModel = y
		let C = new NQ(this._globalState, this.syncingStatusReporter),
			v = new wQ(),
			b = new u_(
				y,
				s,
				this._apiServer,
				this.workspaceManager,
				this.keybindingWatcher,
				this._augmentConfigListener,
				this._extensionContext.extensionUri,
				this.featureFlagManager,
				this._clientMetricsReporter,
				this._actionsModel,
				this._syncingEnabledTracker,
				C,
				this.syncingStatusReporter,
				this._onboardingSessionEventReporter,
				this.fuzzyFsSearcher,
				this.fuzzySymbolSearcher,
				this._toolsModel,
				v,
				this._agentCheckpointManager,
				this.guidelinesWatcher,
				this._assetManager,
				this._agentSessionEventReporter,
				this._agentRequestEventReporter,
				this._globalState,
			)
		;(this._currentChatExtensionEventDisposable = this._chatExtensionEvent.event(b.onChatExtensionMessage)),
			this.disposeOnDisable.push(this._currentChatExtensionEventDisposable),
			this._mainPanelProvider.changeApp(b)
		let w = this.workspaceManager,
			B = this.keybindingWatcher
		this.disposeOnDisable.push(
			this._changeWebviewAppEvent.event((O) => {
				let Y, j
				switch ((this._currentChatExtensionEventDisposable?.dispose(), O)) {
					case "chat":
						;(Y = new u_(
							y,
							s,
							this._apiServer,
							w,
							B,
							this._augmentConfigListener,
							this._extensionContext.extensionUri,
							this.featureFlagManager,
							this._clientMetricsReporter,
							this._actionsModel,
							this._syncingEnabledTracker,
							C,
							this.syncingStatusReporter,
							this._onboardingSessionEventReporter,
							this.fuzzyFsSearcher,
							this.fuzzySymbolSearcher,
							this._toolsModel,
							v,
							this._agentCheckpointManager,
							this.guidelinesWatcher,
							this._assetManager,
							this._agentSessionEventReporter,
							this._agentRequestEventReporter,
							this._globalState,
						)),
							this._mainPanelProvider.changeApp(Y),
							(j = this._chatExtensionEvent.event(Y.onChatExtensionMessage)),
							(this._currentChatExtensionEventDisposable = j),
							this.disposeOnDisable.push(this._currentChatExtensionEventDisposable)
						break
					case "sign-in":
						break
					case "workspace-context":
						this._mainPanelProvider.changeApp(new U1(w, this.featureFlagManager))
						break
					case "awaiting-syncing-permission":
						this._mainPanelProvider.changeApp(
							new Q1(
								this._actionsModel,
								this._apiServer,
								this._augmentConfigListener,
								this._syncingEnabledTracker,
								this._changeWebviewAppEvent,
								this.featureFlagManager,
								i.userTier,
							),
						)
						break
					case "folder-selection":
						this._mainPanelProvider.changeApp(new P1())
						break
					default: {
						let ne = O
						throw new Error(`Unhandled app case: ${ne}`)
					}
				}
			}),
		),
			this.disposeOnDisable.push(
				this._augmentConfigListener.onDidChange(this._checkInlineCompletionsEnabled.bind(this)),
			),
			this._checkInlineCompletionsEnabled(),
			this.disposeOnDisable.push(new je.Disposable(() => this._disableInlineCompletions.bind(this)))
		{
			let O,
				Y,
				j,
				ne,
				q,
				me,
				Qe,
				N = (re, K) => {
					O?.dispose(),
						Y?.dispose(),
						j?.dispose(),
						q?.dispose(),
						ne?.dispose(),
						me?.dispose(),
						Qe?.dispose(),
						re.completions.enableAutomaticCompletions || (Y = this._statusBar.setState(Hxe)),
						re.enableDebugFeatures && this.keybindingWatcher
							? ((q = new M1(this.keybindingWatcher, this._inlineCompletionProvider)),
								this.disposeOnDisable.push(q))
							: re.completions.enableAutomaticCompletions &&
								this.keybindingWatcher &&
								((ne = new k1(this.keybindingWatcher, this._inlineCompletionProvider)),
								this.disposeOnDisable.push(ne)),
						(me = je.languages.registerCodeActionsProvider("*", new dF())),
						this.disposeOnDisable.push(me),
						re.enableUpload || (O = this._statusBar.setState(Wxe))
					let se = re.enableDataCollection || i.featureFlags.enableHindsight
					this._dataCollector && !se
						? (this._logger.debug("Disabling Hindsight Data"),
							this._dataCollector.dispose(),
							(this._dataCollector = void 0))
						: !this._dataCollector &&
							se &&
							this.workspaceManager !== void 0 &&
							(this._logger.debug("Enabling Hindsight Data"),
							(this._dataCollector = new D1(
								this._apiServer,
								this.workspaceManager,
								this._recentInstructions,
								this._recentCompletions,
								this._recentNextEditResults,
							)))
					let Ze = y_(re, this.featureFlagManager.currentFlags.vscodeNextEditMinVersion),
						It = K && y_(K, this.featureFlagManager.currentFlags.vscodeNextEditMinVersion)
					if (Ze && !It)
						if (
							this.workspaceManager &&
							this.keybindingWatcher &&
							this._suggestionManager &&
							this._nextEditRequestManager
						)
							try {
								;(this._backgroundNextEdit = new eQ(
									this.workspaceManager,
									this._nextEditSessionEventReporter,
									this.keybindingWatcher,
									this._augmentConfigListener,
									this._suggestionManager,
									this._nextEditRequestManager,
									this._globalState,
									this.nextEditConfigManager,
									f,
								)),
									this.disposeOnDisable.push(this._backgroundNextEdit),
									this._nextEditSessionEventReporter.reportEventWithoutIds(
										"initialization-success",
										"validation-expected",
									)
							} catch (Et) {
								this._logger.error("Error initializing background next edit: ", Et),
									this._nextEditSessionEventReporter.reportEventWithoutIds(
										"initialization-failure",
										"error",
									),
									this._apiServer.reportError(
										null,
										"background_next_edit_initialization_failure",
										Et instanceof Error ? Et.stack || Et.message : String(Et),
										[],
									)
							}
						else {
							this._logger.error("Failed to enable background next edit generation"),
								this._nextEditSessionEventReporter.reportEventWithoutIds(
									"initialization-skip",
									"validation-unexpected",
								)
							let Et = [
								["this.workspaceManager", this.workspaceManager],
								["this.keybindingWatcher", this.keybindingWatcher],
								["this._suggestionManager", this._suggestionManager],
								["this._nextEditRequestManager", this._nextEditRequestManager],
							]
								.map((jt) => jt.join("="))
								.join(", ")
							this._apiServer.reportError(
								null,
								"background_next_edit_initialization_failure",
								`Background next edit initialization failed because ${Et}`,
								[],
							)
						}
					else
						this._backgroundNextEdit && !Ze
							? (this._backgroundNextEdit.dispose(),
								(this._backgroundNextEdit = void 0),
								this._nextEditSessionEventReporter.reportEventWithoutIds(
									"disposed",
									"validation-expected",
								))
							: !Ze &&
								!It &&
								this._nextEditSessionEventReporter.reportEventWithoutIds(
									"initialization-skip",
									"validation-expected",
								)
					let Ce = Rl(re, this.featureFlagManager.currentFlags.vscodeNextEditMinVersion ?? "")
					Ce &&
						K &&
						re.nextEdit.enableBackgroundSuggestions !== K.nextEdit.enableBackgroundSuggestions &&
						this._nextEditSessionEventReporter.reportEventWithoutIds(
							re.nextEdit.enableBackgroundSuggestions
								? "background-suggestions-enabled"
								: "background-suggestions-disabled",
							"unknown",
						),
						Ce &&
							K &&
							re.nextEdit.highlightSuggestionsInTheEditor !==
								K.nextEdit.highlightSuggestionsInTheEditor &&
							this._nextEditSessionEventReporter.reportEventWithoutIds(
								re.nextEdit.highlightSuggestionsInTheEditor
									? "highlights-enabled"
									: "highlights-disabled",
								"unknown",
							)
				}
			this.disposeOnDisable.push(
				this._augmentConfigListener.onDidChange((re) => {
					N(re.newConfig, re.previousConfig)
				}),
			),
				N(this._augmentConfigListener.config)
		}
		{
			let O = [
				this._completionAcceptanceReporter,
				this._codeEditReporter,
				this._nextEditResolutionReporter,
				this._nextEditSessionEventReporter,
				this._onboardingSessionEventReporter,
				this._clientMetricsReporter,
				this._completionTimelineReporter,
				this._agentSessionEventReporter,
				this._agentRequestEventReporter,
				this._extensionEventReporter,
				this._toolUseRequestEventReporter,
			]
			for (let Y of O) Y.enableUpload(), this.disposeOnDisable.push(Y)
		}
		this.disposeOnDisable.push(
			je.window.registerWebviewViewProvider(
				"augment-next-edit",
				new FQ(
					this._augmentConfigListener,
					this.featureFlagManager,
					(O) =>
						new TQ(
							this._extensionContext.extensionUri,
							O,
							O.webview,
							this._suggestionManager,
							this._globalNextEdit,
							this._editorNextEdit,
							this._nextEditSessionEventReporter,
							v,
							this._nextEditVSCodeToWebviewMessage,
						),
				),
				{ webviewOptions: { retainContextWhenHidden: !0 } },
			),
		),
			(this.enabled = !0),
			this._statusBar.setState(Fxe),
			this.disposeOnDisable.push(new UQ(this._statusBar, this._syncingEnabledTracker))
		let M = new Xp(this._augmentConfigListener, this._actionsModel)
		this.addDisposable(M), M.checkAndUpdateState()
		let Q = new RN(this._actionsModel, this.workspaceManager)
		this.disposeOnDisable.push(Q),
			this._syncLastEnabledExtensionVersion(),
			this._extensionEventReporter.reportConfiguration(
				"configuration-snapshot",
				this._augmentConfigListener.config,
				this.featureFlagManager.currentFlags,
			)
	}
	async _fetchFeatureFlags(r) {
		try {
			return (await this._getModelConfig(r)).featureFlags
		} catch (n) {
			this._logger.error("Failed to fetch feature flags: ", n)
			return
		}
	}
	updateModelInfo(r) {
		if (!this._modelInfo) throw new Error("Model info not set")
		r.suggestedPrefixCharCount !== void 0 &&
			(this._modelInfo.suggestedPrefixCharCount = r.suggestedPrefixCharCount),
			r.suggestedSuffixCharCount !== void 0 &&
				(this._modelInfo.suggestedSuffixCharCount = r.suggestedSuffixCharCount),
			(this._modelInfo.completionTimeoutMs = r.completionTimeoutMs)
	}
	async _getModelConfig(r) {
		let n = 1e3,
			i,
			s = 0,
			o = 6,
			a = new yA(this._statusBar)
		try {
			for (;;) {
				if (r.isCancellationRequested) throw new je.CancellationError()
				try {
					this._logger.info("Retrieving model config"),
						(i = await this._apiServer.getModelConfig()),
						this._logger.info("Retrieved model config")
				} catch (l) {
					if (
						(this._logger.error("Failed to retrieve model config: ", l),
						kr.isAPIErrorWithStatus(l, He.unauthenticated))
					)
						throw l
					if (l instanceof Yp) throw l
					s++
				}
				if (r.isCancellationRequested)
					throw (this._logger.info("Model config retrieval cancelled"), new je.CancellationError())
				if (i !== void 0) return this._logger.info("Returning model config"), i
				s >= o && a.setState(t8),
					this._logger.info(`Retrying model config retrieval in ${n} msec`),
					await Kl(n),
					(n = Math.min(n * 2, e.modelConfigBackoffMsecMax))
			}
		} finally {
			a.dispose()
		}
	}
	disable() {
		for (this.enabled = !1; this.disposeOnDisable.length; ) this.disposeOnDisable.pop().dispose()
		;(this._currentChatExtensionEventDisposable = void 0), this.reset()
	}
	reset() {
		this._enableCancel?.cancel(),
			this._enableCancel?.dispose(),
			(this._enableCancel = void 0),
			this._statusBar.reset(),
			this.workspaceManager?.dispose(),
			(this.workspaceManager = void 0),
			this._disableDataCollection()
	}
	_checkInlineCompletionsEnabled(r) {
		;(r &&
			r.previousConfig.completions.addIntelliSenseSuggestions ===
				r.newConfig.completions.addIntelliSenseSuggestions) ||
			this._enableInlineCompletions()
	}
	_enableInlineCompletions() {
		if (
			(this._disableInlineCompletions(),
			this._logger.debug("Registering inline completions  provider."),
			(this._inlineCompletionProvider = new S1(
				this._completionsModel,
				this._completionAcceptanceReporter,
				this._statusBar,
				this._augmentConfigListener,
				this._completionTimelineReporter,
			)),
			this._completionDisposables.push(this._inlineCompletionProvider),
			Mc((r) => {
				r && this._recentCompletions.addItem(r)
			}),
			this._completionDisposables.push(
				je.languages.registerInlineCompletionItemProvider("*", this._inlineCompletionProvider),
			),
			this._augmentConfigListener.config.completions.addIntelliSenseSuggestions)
		) {
			this._logger.debug("Registering completion items provider.")
			let r = new mC(this._augmentConfigListener)
			this._completionDisposables.push(
				je.languages.registerCompletionItemProvider(mC.languageSelector, r, ...mC.triggerCharacters),
			)
		}
	}
	_disableInlineCompletions() {
		for (let r of this._completionDisposables) r.dispose()
		this._completionDisposables = []
	}
	_disableDataCollection() {
		this._dataCollector?.dispose(), (this._dataCollector = void 0)
	}
	getRecencyInfo() {
		let r = {},
			n = this.workspaceManager.getTabSwitchEvents()
		return (
			n !== void 0 &&
				(r.tab_switch_events = n.map((i) => ({
					path: i.relPathName,
					file_blob_name: i.blobName,
				}))),
			r
		)
	}
	forceNextEditSuggestion(r) {
		let n = je.window.activeTextEditor
		if (!n || !this.workspaceManager) return
		let i = this.workspaceManager.safeResolvePathName(n.document.uri)
		i &&
			(this._nextEditSessionEventReporter.reportEventWithoutIds("suggestion-forced", r ?? "command"),
			this._nextEditRequestManager?.enqueueRequest(i, "FORCED", "CURSOR", $u(n.selection)))
	}
	nextEditUpdate(r) {
		this._globalNextEdit?.startGlobalQuery(r)
	}
	nextEditBackgroundSuggestionsEnabled() {
		return y_(
			this._augmentConfigListener.config,
			this.featureFlagManager.currentFlags.vscodeNextEditMinVersion ?? "",
		)
	}
	noopClicked() {
		this._nextEditSessionEventReporter.reportEventWithoutIds("noop-clicked", "command")
	}
	nextEditTogglePanelHorizontalSplit(r) {
		this._nextEditVSCodeToWebviewMessage.fire({
			type: "next-edit-toggle-suggestion-tree",
		}),
			this._nextEditSessionEventReporter.reportEventWithoutIds("toggle-panel-horizontal-split", r ?? "command")
	}
	openNextEditPanel(r) {
		this._nextEditSessionEventReporter.reportEventWithoutIds("panel-focus-executed", r ?? "command"),
			je.commands.executeCommand("augment-next-edit.focus"),
			this._nextEditVSCodeToWebviewMessage.fire({
				type: "next-edit-panel-focus",
			})
	}
	nextEditLearnMore(r) {
		this._nextEditSessionEventReporter.reportEventWithoutIds("learn-more-clicked", r ?? "command"),
			je.env.openExternal(je.Uri.parse("https://docs.augmentcode.com/using-augment/next-edit"))
	}
	async updateStatusTrace() {
		this._statusTrace?.dispose()
		let r = new IQ(() => this._onTextDocumentDidChange.fire(e.displayStatusUri))
		this._statusTrace = r
		let n = 0
		if (this.enableInProgress) {
			r.addLine("Augment extension is initializing"), r.publish()
			return
		}
		if (!this.enabled) {
			r.addLine("Augment is not enabled in this workspace"), r.publish()
			return
		}
		r.addSection("Extension version")
		let i = je.extensions.getExtension("augment.vscode-augment")
		i ? r.addValue("Extension version", i.packageJSON.version) : r.addLine("Cannot retrieve extension version"),
			r.addSection("Session ID"),
			r.addValue("Session ID", this._apiServer.sessionId),
			r.addSection("Recent Completion Requests (oldest to newest)")
		let s = this._recentCompletions.items.sort((l, c) => l.occuredAt.getTime() - c.occuredAt.getTime()).slice(0, 10)
		for (let { requestId: l } of s) r.addLine(`${l}`)
		s.length === 0 && r.addLine("No recent completion requests"),
			r.addSection("Recent Instruction Requests (oldest to newest)")
		for (let { requestId: l } of this._recentInstructions.items) r.addLine(`${l}`)
		this._recentInstructions.items.length === 0 && r.addLine("No recent instruction requests"),
			r.addSection("Recent Chat Requests (oldest to newest)")
		for (let { requestId: l } of this._recentChats.items) r.addLine(`${l}`)
		this._recentChats.items.length === 0 && r.addLine("No recent chat requests"),
			r.addSection("Extension configuration")
		let o = this._augmentConfigListener.config
		r.addObject(o), r.addValue("Using API token", !this._auth.useOAuth)
		let a = ""
		if (this._auth.useOAuth) {
			let l = await this._auth.getSession()
			r.addValue("Tenant URL", l?.tenantURL), (a = l?.tenantURL || "")
		} else a = o.completionURL
		if (!this.ready) {
			r.addLine("Augment extension is initializing"), r.publish()
			return
		}
		r.addSection("Back-end Configuration"),
			r.addValue("MaxUploadSizeBytes", this.featureFlagManager.currentFlags.maxUploadSizeBytes),
			r.addValue(
				"enableCompletionFileEditEvents",
				this.featureFlagManager.currentFlags.enableCompletionFileEditEvents,
			),
			r.addSection("Supported languages (Augment name / VSCode name):")
		for (let l of this._languages) r.addLine(`${l.name} / ${l.vscodeName}`)
		r.addSection("Available Models")
		for (let l of this._availableModels) {
			let c = this._defaultModel && l.startsWith(this._defaultModel),
				u = (!o.modelName && c) || l === o.modelName,
				f = l + (c ? " (default)" : "") + (u ? " (current)" : "")
			r.addLine(f)
		}
		this._availableModels.length === 0 && r.addLine("No models available"),
			r.addSection("Current Model"),
			(n = r.savePoint()),
			r.addLine("Querying current model"),
			r.addLine("(in progress...)")
		try {
			r.publish(), r.rollback(n), o.modelName || r.addLine("(Using default model)"), r.addObject(this.modelInfo)
		} catch (l) {
			r.rollback(n),
				l instanceof Ob
					? r.addLine(`Model "${o.modelName}" not known.`)
					: r.addError(`Unable to query info about model "${o.modelName}": ${Ye(l)}`)
		}
		if (
			(r.addSection("Blob upload"),
			o.enableUpload
				? r.addLine("Blob upload enabled in configuration settings")
				: r.addLine("Blob upload disabled in configuration settings"),
			this.workspaceManager !== void 0 && (await this.workspaceManager.updateStatusTrace(r)),
			a !== "")
		) {
			r.addSection("Completion status"), r.addLine(`Attempting completion from ${a}`)
			let l = this._apiServer.createRequestId()
			r.addValue("Request ID", l), (n = r.savePoint()), r.addLine("(in progress...)")
			try {
				r.publish()
				let c = Date.now(),
					u = await this._apiServer.complete(
						l,
						"this is the prefix",
						"this is the suffix",
						"/this/is/the/path",
						void 0,
						{ prefixBegin: 0, cursorPosition: 0, suffixEnd: 0 },
						"python",
						{ checkpointId: void 0, addedBlobs: [], deletedBlobs: [] },
						[],
					)
				r.rollback(n),
					r.addLine(`Response received in ${Date.now() - c} ms`),
					u.completionItems.length === 0
						? r.addLine("No completion received")
						: r.addLine(`${u.completionItems.length} completion(s) received`)
			} catch (c) {
				r.rollback(n), r.addError(`Completion request failed: ${c}`)
			}
		}
		r.addSection("Feature Flags"), r.addObject(this.featureFlagManager.currentFlags), r.publish()
	}
	async provideTextDocumentContent(r) {
		return r.toString() === e.displayStatusUri.toString()
			? this._statusTrace === void 0
				? "Internal error. Cannot get Augment extension status."
				: this._statusTrace.content
			: ""
	}
	get onDidChange() {
		return this._onTextDocumentDidChange.event
	}
	clearFileEdits() {
		this.workspaceManager?.clearFileEdits()
	}
}
function Rwe(e) {
	let t = e.get("sessionId")
	return (t === void 0 || !d3(t)) && ((t = Eh()), e.update("sessionId", t)), t
}
function ECt(e) {
	let t = X("activate()")
	t.debug("======== Activating extension ========")
	let r
	function n(K) {
		K.enable()
	}
	function i(K) {
		K.disable()
	}
	function s() {
		r && (t.debug("======== Deactivating extension ========"), i(r)), (r = void 0)
	}
	function o() {
		t.info("======== Reloading extension ========"), i(r), n(r)
	}
	e.subscriptions.push(
		new je.Disposable(() => {
			s()
		}),
	),
		e.subscriptions.push(
			je.window.registerUriHandler({
				handleUri(K) {
					if (K.authority.toLowerCase() !== e.extension.id.toLowerCase()) {
						t.warn(`Ignoring URI ${K.toString()}`)
						return
					}
					switch (K.path) {
						case q.authRedirectURI.path:
							q.handleAuthURI(K)
							break
						default:
							t.error(
								`Unhandled URI ${je.Uri.from({
									scheme: K.scheme,
									authority: K.authority,
									path: K.path,
								}).toString()}`,
							)
					}
				},
			}),
		)
	let a = `${kN.default.platform()}; ${kN.default.arch()}; ${kN.default.release()}`,
		l = `${e.extension.id}/${e.extension.packageJSON.version} (${a}) ${je.env.uriScheme}/${je.version}`,
		c = new mk(e),
		u = Rwe(c),
		f = new sk()
	f.migrateLegacyConfig()
	let p = new lk(e, f)
	e.subscriptions.push(p)
	let g = new OQ()
	e.subscriptions.push(g)
	let m = new ik(f, p, u, l, global.fetch),
		y = new B1(),
		C = new eg(10),
		v = new eg(10),
		b = new eg(10),
		w = new je.EventEmitter(),
		B = new je.EventEmitter(),
		M = new je.EventEmitter(),
		Q = new je.EventEmitter(),
		O = new eM(e),
		Y = new MQ(e.extensionUri)
	Y.onVisibilityChange((K) => {
		K || eC.currentPanel?.dispose()
	})
	let j = new F1(c)
	e.subscriptions.push(j)
	let ne = new K1(m),
		q = new uk(e, f, m, p, ne),
		me = new L1(m, f, q, j)
	function Qe(K) {
		e: for (let se of K)
			switch (se.name) {
				case "UserShouldSignIn": {
					Y.changeApp(me), N()
					break e
				}
				case "WorkspaceNotSelected": {
					j.isSystemStateComplete("authenticated") && (M.fire("folder-selection"), N())
					break e
				}
				case "ShouldDisableCopilot":
				case "ShouldDisableCodeium":
				case "SyncingPermissionNeeded":
				case "uploadingHomeDir":
				case "workspaceTooLarge":
					N()
					break e
			}
		;(j.isDerivedStateSatisfied("SyncingPermissionNeeded") ||
			j.isDerivedStateSatisfied("uploadingHomeDir") ||
			j.isDerivedStateSatisfied("workspaceTooLarge")) &&
			M.fire("awaiting-syncing-permission")
	}
	e.subscriptions.push(
		p.onDidChangeSession(() => {
			o()
		}),
	),
		e.subscriptions.push(new ok(j, p, f)),
		e.subscriptions.push(
			je.window.registerWebviewViewProvider("augment-chat", Y, {
				webviewOptions: { retainContextWhenHidden: !0 },
			}),
		),
		(r = new AA(e, c, f, m, p, y, C, b, v, w, Q, Y, M, j, g, B, ne, O))
	function N() {
		Y.isVisible() || je.commands.executeCommand(Hi.commandID)
	}
	e.subscriptions.push(j.onDerivedStatesSatisfied(Qe)),
		Qe(j.satisfiedStates),
		f.onDidChange((K) => {
			K.newConfig.enableDebugFeatures, K.previousConfig.enableDebugFeatures
		}),
		e.subscriptions.push(
			f.onDidChange((K) => {
				let se = !1,
					Ze = ["apiToken", "completionURL", "oauth", "modelName"]
				for (let It of Ze)
					if (!(0, E6.default)(K.previousConfig[It], K.newConfig[It])) {
						se = !0
						break
					}
				se && (t.info("Reloading extension due to config change"), o())
			}),
		),
		e.subscriptions.push(je.workspace.registerTextDocumentContentProvider(AA.contentScheme, r)),
		kwe(r, f, e)
	let re = Bxe(e, r, f, p, q, m, y, C, b, M, B, g, c)
	e.subscriptions.push(re), e.subscriptions.push(Q), n(r)
}
function Iwe(e) {
	for (let [t, r] of Object.entries(e)) je.commands.executeCommand("setContext", t, r)
}
function kwe(e, t, r) {
	let n = () => {
		let o = t.config
		Iwe({
			"vscode-augment.enableDebugFeatures": o.enableDebugFeatures,
			"vscode-augment.enableReviewerWorkflows": o.enableReviewerWorkflows,
			"vscode-augment.enableNextEdit": Rl(
				t.config,
				e?.featureFlagManager.currentFlags.vscodeNextEditMinVersion ?? "",
			),
			"vscode-augment.enableNextEditBackgroundSuggestions": y_(
				t.config,
				e?.featureFlagManager.currentFlags.vscodeNextEditMinVersion ?? "",
			),
			"vscode-augment.nextEdit.enableGotoHinting": t.config.nextEdit.enableGotoHinting ?? !1,
			"vscode-augment.nextEdit.enablePanel": e.nextEditConfigManager.config.enablePanel,
		})
	}
	n(), r.subscriptions.push(t.onDidChange(n))
	let i = [
			"enableWorkspaceManagerUi",
			"enableSmartPaste",
			"enableSmartPasteMinVersion",
			"enableInstructions",
			"vscodeSourcesMinVersion",
			"vscodeChatHintDecorationMinVersion",
			"vscodeEnableCpuProfile",
			"vscodeNextEditMinVersion",
		],
		s = () => {
			if (!e) return
			let o = e.featureFlagManager.currentFlags
			Iwe({
				"vscode-augment.workspace-manager-ui.enabled": o.enableWorkspaceManagerUi,
				"vscode-augment.internal-new-instructions.enabled": o.enableInstructions,
				"vscode-augment.internal-dv.enabled": Gr(o.enableSmartPasteMinVersion) || o.enableInstructions,
				"vscode-augment.sources-enabled": Gr(o.vscodeSourcesMinVersion) ?? !1,
				"vscode-augment.chat-hint.decoration": Gr(o.vscodeChatHintDecorationMinVersion) ?? !1,
				"vscode-augment.cpu-profile.enabled": o.vscodeEnableCpuProfile,
				"vscode-augment.nextEdit.enablePanel": e.nextEditConfigManager.config.enablePanel,
			})
		}
	s(),
		r.subscriptions.push(e.featureFlagManager.subscribe(i, s)),
		r.subscriptions.push(e.featureFlagManager.subscribe(i, n))
}
var bCt = { setupContextKeySync: kwe }
0 &&
	(module.exports = {
		AugmentExtension,
		_exportedForTesting,
		activate,
		getSessionId,
	})
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@mixmark-io/domino/lib/style_parser.js:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

undici/lib/web/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

undici/lib/web/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
