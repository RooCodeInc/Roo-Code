<common_patterns>
  <pattern name="checking_pr_status">
    <usage>A set of commands to quickly assess the state of a Pull Request.</usage>
    <template>
      <command tool="gh">
        gh pr status --json number,title,state,conflict,reviewDecision,headRefName,headRepositoryOwner
      </command>
      <command tool="gh">
        gh pr checks
      </command>
      <command tool="gh">
        gh pr view --comments
      </command>
    </template>
  </pattern>
  <pattern name="analyzing_failing_tests">
    <usage>Commands to investigate why a specific test is failing.</usage>
    <template>
      <command tool="gh">
        gh run list --workflow=<workflow_id> --branch=<branch_name> --json databaseId,name,status,conclusion
      </command>
      <command tool="gh">
        gh run view --log-failed <run_id>
      </command>
    </template>
  </pattern>
  <pattern name="detecting_conflicts">
    <usage>Commands to detect merge conflicts without interactive operations.</usage>
    <template>
      <command tool="git">git checkout main</command>
      <command tool="git">git pull origin main</command>
      <command tool="git">git checkout <pr_branch></command>
      <command tool="git">git merge-base main HEAD</command>
      <command tool="git">git diff --name-only main...HEAD</command>
      <comment>Check if rebase would create conflicts (dry run)</comment>
      <command tool="git">git rebase --dry-run main</command>
    </template>
  </pattern>
  
  <pattern name="non_interactive_rebase">
    <usage>Non-interactive rebase operations for when no conflicts are detected.</usage>
    <template>
      <command tool="git">git checkout <pr_branch></command>
      <command tool="git">git rebase main</command>
      <comment>Only proceed if rebase succeeds without conflicts</comment>
      <command tool="git">git push --force-with-lease origin <pr_branch></command>
    </template>
  </pattern>
  
  <pattern name="conflict_status_check">
    <usage>Check current conflict status without interactive input.</usage>
    <template>
      <command tool="git">git status --porcelain</command>
      <command tool="git">git diff --name-only --diff-filter=U</command>
      <comment>List files with unresolved conflicts</comment>
      <command tool="git">git ls-files --unmerged</command>
    </template>
  </pattern>
  <pattern name="checking_out_pr">
    <usage>Command to check out a pull request branch locally without interactive prompts.</usage>
    <template>
      <command tool="gh">gh pr checkout <pr_number_or_url> --force</command>
      <comment>Alternative: Use git commands if gh checkout fails</comment>
      <command tool="git">git fetch origin pull/<pr_number>/head:<branch_name></command>
      <command tool="git">git checkout <branch_name></command>
    </template>
  </pattern>
  
  <pattern name="real_time_monitoring">
    <usage>Monitor PR checks in real-time as they run.</usage>
    <template>
      <command tool="gh">gh pr checks <pr_number> --watch</command>
      <comment>Continuously monitor check status with automatic updates</comment>
      <alternative>For one-time status check: gh pr checks <pr_number> --json state,conclusion,name,detailsUrl</alternative>
      <command tool="gh">gh run list --pr <pr_number> --json databaseId,status,conclusion</command>
    </template>
  </pattern>
  
  <pattern name="safe_push_operations">
    <usage>Push operations that avoid interactive prompts and credential issues.</usage>
    <template>
      <command tool="git">git push --force-with-lease origin <branch_name></command>
      <comment>If force-with-lease fails, check remote state first</comment>
      <command tool="git">git fetch origin <branch_name></command>
      <command tool="git">git status --porcelain</command>
      <command tool="git">git push --force origin <branch_name></command>
    </template>
  </pattern>

  <pattern name="automated_commit_operations">
    <usage>Commit operations that work in automated environments.</usage>
    <template>
      <command tool="git">git add .</command>
      <command tool="git">git commit -m "<commit_message>"</command>
    </template>
  </pattern>
</common_patterns>
