# å¤šä»£ç†åä½œç³»ç»Ÿéœ€æ±‚åˆ†æä¸æŠ€æœ¯è®¾è®¡

## æ–‡æ¡£ç‰ˆæœ¬

- **åˆ›å»ºæ—¶é—´**: 2025-10-10
- **æœ€åæ›´æ–°**: 2025-10-10
- **çŠ¶æ€**: è‰æ¡ˆ

---

## 1. ç³»ç»Ÿæ¦‚è¿°

### 1.1 è®¾è®¡ç†å¿µ

å¤šä»£ç†åä½œç³»ç»Ÿï¼ˆMulti-Agent Collaboration Systemï¼‰æ˜¯ Roo-Code çš„é«˜çº§åŠŸèƒ½ï¼Œæ—¨åœ¨é€šè¿‡å¤šä¸ªä¸“èŒ AI ä»£ç†çš„ååŒå·¥ä½œï¼Œè§£å†³å¤æ‚çš„ã€å¤šæ–¹é¢çš„è½¯ä»¶å·¥ç¨‹ä»»åŠ¡ã€‚

**æ ¸å¿ƒç†å¿µ**ï¼š

> "å°†å¤æ‚ä»»åŠ¡åˆ†è§£ä¸ºä¸“ä¸šå­ä»»åŠ¡ï¼Œç”±å…·æœ‰ç‰¹å®šæŠ€èƒ½çš„ä»£ç†å¹¶å‘æ‰§è¡Œï¼Œé€šè¿‡åè°ƒå’Œæ•´åˆå®ç°æ¯”å•ä¸€ä»£ç†æ›´é«˜çš„æ•ˆç‡å’Œè´¨é‡ã€‚"

### 1.2 ä¸ç°æœ‰ç³»ç»Ÿçš„å…³ç³»

æœ¬è®¾è®¡åŸºäº Roo-Code ç°æœ‰çš„ä¸‰ä¸ªæ ¸å¿ƒåŠŸèƒ½è¿›è¡Œæ•´åˆå’Œæ‰©å±•ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å¤šä»£ç†åä½œç³»ç»Ÿ (Multi-Agent System)             â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ å­ä»»åŠ¡æœºåˆ¶   â”‚  â”‚ æ‰¹é‡æ¨¡å¼     â”‚  â”‚ è£åˆ¤æ¨¡å¼     â”‚      â”‚
â”‚  â”‚ (Subtask)    â”‚  â”‚ (Batch)      â”‚  â”‚ (Judge)      â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚         â”‚                  â”‚                  â”‚              â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                            â”‚                                 â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚                   â”‚  åè°ƒå±‚ (Core)   â”‚                        â”‚
â”‚                   â”‚  - ä»»åŠ¡åˆ†å‘      â”‚                        â”‚
â”‚                   â”‚  - ç»“æœæ•´åˆ      â”‚                        â”‚
â”‚                   â”‚  - å†²çªè§£å†³      â”‚                        â”‚
â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç»§æ‰¿çš„èƒ½åŠ›**ï¼š

- **å­ä»»åŠ¡æœºåˆ¶**ï¼šæä¾›ä»»åŠ¡åˆ†è§£å’Œçˆ¶å­å…³ç³»ç®¡ç†
- **æ‰¹é‡æ¨¡å¼**ï¼šæä¾›å¹¶å‘æ‰§è¡Œå’Œè¿›åº¦è¿½è¸ª
- **è£åˆ¤æ¨¡å¼**ï¼šæä¾›è´¨é‡å®¡æŸ¥å’Œåé¦ˆæœºåˆ¶

**æ–°å¢çš„èƒ½åŠ›**ï¼š

- **ä¸“èŒä»£ç†**ï¼šå®šä¹‰å…·æœ‰ç‰¹å®šæŠ€èƒ½çš„ä»£ç†ç±»å‹
- **æ™ºèƒ½åˆ†å‘**ï¼šæ ¹æ®ä»»åŠ¡ç‰¹å¾è‡ªåŠ¨é€‰æ‹©åˆé€‚çš„ä»£ç†
- **åä½œåè®®**ï¼šå®šä¹‰ä»£ç†é—´çš„é€šä¿¡å’Œåä½œè§„èŒƒ
- **ç»“æœæ•´åˆ**ï¼šæ™ºèƒ½åˆå¹¶å¤šä¸ªä»£ç†çš„è¾“å‡º

### 1.3 æ ¸å¿ƒä»·å€¼

1. **æ•ˆç‡æå‡**ï¼šå¹¶å‘æ‰§è¡Œ â†’ 3-5å€é€Ÿåº¦æå‡
2. **è´¨é‡ä¿è¯**ï¼šä¸“ä¸šåˆ†å·¥ â†’ æ¯ä¸ªæ–¹é¢éƒ½ç”±ä¸“å®¶å¤„ç†
3. **å¯æ‰©å±•æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ â†’ è½»æ¾æ·»åŠ æ–°ç±»å‹ä»£ç†
4. **æ™ºèƒ½åè°ƒ**ï¼šè‡ªåŠ¨è°ƒåº¦ â†’ å‡å°‘äººå·¥å¹²é¢„
5. **é”™è¯¯éš”ç¦»**ï¼šç‹¬ç«‹æ‰§è¡Œ â†’ å•ä¸ªä»£ç†å¤±è´¥ä¸å½±å“æ•´ä½“

---

## 2. ä¸“èŒä»£ç†ä½“ç³»

### 2.1 ä»£ç†åˆ†ç±»

#### 2.1.1 ä»£ç†ç±»å‹å®šä¹‰

```typescript
interface AgentProfile {
	// åŸºæœ¬ä¿¡æ¯
	id: string // ä»£ç†å”¯ä¸€æ ‡è¯†
	type: AgentType // ä»£ç†ç±»å‹
	name: string // ä»£ç†åç§°
	description: string // ä»£ç†æè¿°

	// èƒ½åŠ›å®šä¹‰
	skills: AgentSkill[] // ä¸“ä¸šæŠ€èƒ½åˆ—è¡¨
	toolGroups: ToolGroup[] // å¯ç”¨å·¥å…·ç»„
	promptTemplate: string // ä¸“ç”¨æç¤ºè¯æ¨¡æ¿

	// æ€§èƒ½å‚æ•°
	maxConcurrency: number // æœ€å¤§å¹¶å‘ä»»åŠ¡æ•°
	averageExecutionTime: number // å¹³å‡æ‰§è¡Œæ—¶é—´ï¼ˆç§’ï¼‰
	successRate: number // å†å²æˆåŠŸç‡

	// åä½œè®¾ç½®
	canCooperate: boolean // æ˜¯å¦æ”¯æŒä¸å…¶ä»–ä»£ç†åä½œ
	preferredPartners: AgentType[] // åå¥½çš„åä½œä¼™ä¼´
	communicationProtocol: Protocol // é€šä¿¡åè®®
}

type AgentType =
	| "architect" // æ¶æ„å¸ˆä»£ç†
	| "code-writer" // ä»£ç ç¼–å†™ä»£ç†
	| "test-writer" // æµ‹è¯•ç¼–å†™ä»£ç†
	| "documentation" // æ–‡æ¡£ç¼–å†™ä»£ç†
	| "refactor" // é‡æ„ä»£ç†
	| "debug" // è°ƒè¯•ä»£ç†
	| "review" // ä»£ç å®¡æŸ¥ä»£ç†ï¼ˆåŸºäº Judge Modeï¼‰
	| "translator" // å›½é™…åŒ–ç¿»è¯‘ä»£ç†
	| "optimizer" // æ€§èƒ½ä¼˜åŒ–ä»£ç†
	| "security" // å®‰å…¨å®¡è®¡ä»£ç†

type AgentSkill =
	| "code-generation"
	| "test-generation"
	| "documentation"
	| "refactoring"
	| "debugging"
	| "code-review"
	| "translation"
	| "optimization"
	| "security-analysis"
	| "architecture-design"
```

#### 2.1.2 é¢„å®šä¹‰ä»£ç†

**1. ArchitectAgentï¼ˆæ¶æ„å¸ˆä»£ç†ï¼‰**

```typescript
const ARCHITECT_AGENT: AgentProfile = {
	id: "architect-001",
	type: "architect",
	name: "ğŸ—ï¸ Architect",
	description: "ä¸“æ³¨äºç³»ç»Ÿæ¶æ„è®¾è®¡ã€æŠ€æœ¯é€‰å‹å’Œè®¾è®¡æ–‡æ¡£ç¼–å†™",

	skills: ["architecture-design", "documentation"],
	toolGroups: ["read", "command"], // åªè¯»æƒé™ï¼Œé¿å…ç›´æ¥ä¿®æ”¹ä»£ç 

	promptTemplate: `You are an experienced software architect. Your role is to:
- Analyze system requirements and design overall architecture
- Make technology stack decisions
- Create design documents and diagrams
- Define interfaces and contracts between components
- Ensure scalability and maintainability

Key principles:
- Focus on high-level design, not implementation details
- Consider non-functional requirements (performance, security, scalability)
- Document decisions and trade-offs clearly`,

	maxConcurrency: 1,
	averageExecutionTime: 300,
	successRate: 0.92,

	canCooperate: true,
	preferredPartners: ["code-writer", "documentation"],
	communicationProtocol: "design-handoff",
}
```

**2. CodeWriterAgentï¼ˆä»£ç ç¼–å†™ä»£ç†ï¼‰**

```typescript
const CODE_WRITER_AGENT: AgentProfile = {
	id: "code-writer-001",
	type: "code-writer",
	name: "ğŸ’» Code Writer",
	description: "ä¸“æ³¨äºé«˜è´¨é‡ä»£ç å®ç°ï¼Œéµå¾ªæœ€ä½³å®è·µå’Œç¼–ç è§„èŒƒ",

	skills: ["code-generation"],
	toolGroups: ["read", "edit", "command"],

	promptTemplate: `You are an expert code writer. Your role is to:
- Implement features based on specifications
- Write clean, maintainable, and well-documented code
- Follow coding standards and best practices
- Ensure code is testable and modular

Key principles:
- ALWAYS write complete code (no truncation or placeholders)
- Follow SOLID principles and design patterns
- Write self-documenting code with clear naming
- Consider edge cases and error handling`,

	maxConcurrency: 4,
	averageExecutionTime: 180,
	successRate: 0.88,

	canCooperate: true,
	preferredPartners: ["test-writer", "review"],
	communicationProtocol: "code-handoff",
}
```

**3. TestWriterAgentï¼ˆæµ‹è¯•ç¼–å†™ä»£ç†ï¼‰**

```typescript
const TEST_WRITER_AGENT: AgentProfile = {
	id: "test-writer-001",
	type: "test-writer",
	name: "ğŸ§ª Test Writer",
	description: "ä¸“æ³¨äºç¼–å†™å…¨é¢çš„å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•å’ŒE2Eæµ‹è¯•",

	skills: ["test-generation"],
	toolGroups: ["read", "edit", "command"],

	promptTemplate: `You are a test automation expert. Your role is to:
- Write comprehensive test suites (unit, integration, E2E)
- Ensure high code coverage (>80%)
- Test edge cases and error scenarios
- Create test fixtures and mocks

Key principles:
- Follow AAA pattern (Arrange, Act, Assert)
- Write descriptive test names
- Keep tests independent and isolated
- Use appropriate test doubles (mocks, stubs, spies)`,

	maxConcurrency: 4,
	averageExecutionTime: 150,
	successRate: 0.9,

	canCooperate: true,
	preferredPartners: ["code-writer", "debug"],
	communicationProtocol: "test-coverage-report",
}
```

**4. DocumentationAgentï¼ˆæ–‡æ¡£ç¼–å†™ä»£ç†ï¼‰**

```typescript
const DOCUMENTATION_AGENT: AgentProfile = {
	id: "documentation-001",
	type: "documentation",
	name: "ğŸ“š Documentation",
	description: "ä¸“æ³¨äºç¼–å†™æ¸…æ™°ã€å…¨é¢çš„æŠ€æœ¯æ–‡æ¡£å’ŒAPIæ–‡æ¡£",

	skills: ["documentation"],
	toolGroups: ["read", "edit"],

	promptTemplate: `You are a technical writer. Your role is to:
- Write clear and comprehensive documentation
- Create API documentation with examples
- Generate user guides and tutorials
- Maintain README and CHANGELOG

Key principles:
- Write for your audience (developers, users, etc.)
- Provide code examples and use cases
- Keep documentation up-to-date with code
- Use clear structure and formatting`,

	maxConcurrency: 3,
	averageExecutionTime: 120,
	successRate: 0.93,

	canCooperate: true,
	preferredPartners: ["architect", "code-writer"],
	communicationProtocol: "doc-review",
}
```

**5. RefactorAgentï¼ˆé‡æ„ä»£ç†ï¼‰**

```typescript
const REFACTOR_AGENT: AgentProfile = {
	id: "refactor-001",
	type: "refactor",
	name: "ğŸ”§ Refactor",
	description: "ä¸“æ³¨äºä»£ç é‡æ„ã€æ€§èƒ½ä¼˜åŒ–å’Œä»£ç è´¨é‡æå‡",

	skills: ["refactoring", "optimization"],
	toolGroups: ["read", "edit", "command"],

	promptTemplate: `You are a refactoring specialist. Your role is to:
- Improve code structure without changing behavior
- Eliminate code smells and anti-patterns
- Optimize performance bottlenecks
- Reduce technical debt

Key principles:
- Preserve existing functionality (ensure tests pass)
- Make small, incremental changes
- Improve readability and maintainability
- Use automated refactoring tools when possible`,

	maxConcurrency: 3,
	averageExecutionTime: 200,
	successRate: 0.85,

	canCooperate: true,
	preferredPartners: ["test-writer", "review"],
	communicationProtocol: "refactor-report",
}
```

**6. ReviewAgentï¼ˆä»£ç å®¡æŸ¥ä»£ç† - åŸºäº Judge Modeï¼‰**

```typescript
const REVIEW_AGENT: AgentProfile = {
	id: "review-001",
	type: "review",
	name: "ğŸ‘ï¸ Reviewer",
	description: "ä¸“æ³¨äºä»£ç å®¡æŸ¥ã€è´¨é‡æ£€æŸ¥å’Œæ”¹è¿›å»ºè®®",

	skills: ["code-review"],
	toolGroups: ["read"], // åªè¯»ï¼Œä¸ç›´æ¥ä¿®æ”¹

	promptTemplate: `You are a senior code reviewer. Your role is to:
- Review code for quality, correctness, and best practices
- Identify bugs, security issues, and performance problems
- Provide constructive feedback and improvement suggestions
- Ensure code meets team standards

Key principles:
- Be constructive and specific in feedback
- Prioritize issues (critical, major, minor)
- Suggest concrete improvements
- Consider maintainability and readability

This is based on Judge Mode design with specialized review criteria.`,

	maxConcurrency: 2,
	averageExecutionTime: 240,
	successRate: 0.91,

	canCooperate: true,
	preferredPartners: ["code-writer", "refactor"],
	communicationProtocol: "review-feedback",
}
```

### 2.2 ä»£ç†æ³¨å†Œè¡¨

```typescript
class AgentRegistry {
	private agents: Map<AgentType, AgentProfile>
	private instances: Map<string, AgentInstance>

	// æ³¨å†Œæ–°ä»£ç†ç±»å‹
	register(profile: AgentProfile): void {
		this.agents.set(profile.type, profile)
	}

	// è·å–ä»£ç†é…ç½®
	getProfile(type: AgentType): AgentProfile | undefined {
		return this.agents.get(type)
	}

	// åˆ›å»ºä»£ç†å®ä¾‹
	createInstance(type: AgentType, taskId: string): AgentInstance {
		const profile = this.getProfile(type)
		if (!profile) {
			throw new Error(`Agent type ${type} not registered`)
		}

		const instance: AgentInstance = {
			instanceId: `${type}-${taskId}-${Date.now()}`,
			profile,
			status: "idle",
			currentTask: null,
			history: [],
			metrics: {
				tasksCompleted: 0,
				tasksFailed: 0,
				averageExecutionTime: profile.averageExecutionTime,
				successRate: profile.successRate,
			},
		}

		this.instances.set(instance.instanceId, instance)
		return instance
	}

	// åˆ—å‡ºæ‰€æœ‰å·²æ³¨å†Œä»£ç†
	listAgents(): AgentProfile[] {
		return Array.from(this.agents.values())
	}

	// æ ¹æ®æŠ€èƒ½æŸ¥æ‰¾ä»£ç†
	findBySkill(skill: AgentSkill): AgentProfile[] {
		return this.listAgents().filter((agent) => agent.skills.includes(skill))
	}
}

interface AgentInstance {
	instanceId: string
	profile: AgentProfile
	status: AgentStatus
	currentTask: TaskAssignment | null
	history: TaskHistory[]
	metrics: AgentMetrics
}

type AgentStatus = "idle" | "busy" | "paused" | "error"

interface AgentMetrics {
	tasksCompleted: number
	tasksFailed: number
	averageExecutionTime: number
	successRate: number
}
```

---

## 3. ä»»åŠ¡åˆ†å‘ä¸åè°ƒ

### 3.1 ä»»åŠ¡åˆ†è§£ç­–ç•¥

#### 3.1.1 ä»»åŠ¡åˆ†æå™¨

```typescript
class TaskAnalyzer {
	// åˆ†æä»»åŠ¡å¹¶æ¨èä»£
	ç†æ¨èä»£ç†
	analyzeTask(description: string): TaskAnalysis {
		// 1. æå–ä»»åŠ¡å…³é”®è¯
		const keywords = this.extractKeywords(description)

		// 2. è¯†åˆ«ä»»åŠ¡ç±»å‹
		const taskTypes = this.identifyTaskTypes(keywords, description)

		// 3. æ¨èä»£ç†ç»„åˆ
		const recommendedAgents = this.recommendAgents(taskTypes)

		// 4. ä¼°ç®—æ‰§è¡Œæ—¶é—´å’Œèµ„æº
		const estimation = this.estimateResources(taskTypes, recommendedAgents)

		return {
			taskTypes,
			recommendedAgents,
			estimation,
			canParallelize: this.checkParallelizability(taskTypes),
			dependencies: this.analyzeDependencies(taskTypes),
		}
	}

	private identifyTaskTypes(keywords: string[], description: string): TaskType[] {
		const types: TaskType[] = []

		// ç‰¹å¾åŒ¹é…
		if (this.matchesPattern(description, FEATURE_PATTERNS)) {
			types.push("feature-development")
		}
		if (this.matchesPattern(description, REFACTOR_PATTERNS)) {
			types.push("refactoring")
		}
		if (this.matchesPattern(description, BUG_PATTERNS)) {
			types.push("bug-fix")
		}
		if (this.matchesPattern(description, TEST_PATTERNS)) {
			types.push("testing")
		}
		if (this.matchesPattern(description, DOC_PATTERNS)) {
			types.push("documentation")
		}

		return types
	}

	private recommendAgents(taskTypes: TaskType[]): AgentRecommendation[] {
		const recommendations: AgentRecommendation[] = []

		// æ ¹æ®ä»»åŠ¡ç±»å‹æ¨èä»£ç†
		for (const taskType of taskTypes) {
			switch (taskType) {
				case "feature-development":
					recommendations.push(
						{ type: "architect", priority: "required", reason: "Design architecture" },
						{ type: "code-writer", priority: "required", reason: "Implement feature" },
						{ type: "test-writer", priority: "required", reason: "Write tests" },
						{ type: "documentation", priority: "recommended", reason: "Document feature" },
					)
					break

				case "refactoring":
					recommendations.push(
						{ type: "refactor", priority: "required", reason: "Perform refactoring" },
						{ type: "test-writer", priority: "required", reason: "Ensure tests pass" },
						{ type: "review", priority: "recommended", reason: "Review changes" },
					)
					break

				case "bug-fix":
					recommendations.push(
						{ type: "debug", priority: "required", reason: "Identify root cause" },
						{ type: "code-writer", priority: "required", reason: "Fix bug" },
						{ type: "test-writer", priority: "required", reason: "Add regression test" },
					)
					break

				case "testing":
					recommendations.push({
						type: "test-writer",
						priority: "required",
						reason: "Write comprehensive tests",
					})
					break

				case "documentation":
					recommendations.push({
						type: "documentation",
						priority: "required",
						reason: "Create documentation",
					})
					break
			}
		}

		// å»é‡å¹¶æ’åº
		return this.deduplicateAndSort(recommendations)
	}
}

interface TaskAnalysis {
	taskTypes: TaskType[]
	recommendedAgents: AgentRecommendation[]
	estimation: ResourceEstimation
	canParallelize: boolean
	dependencies: TaskDependency[]
}

interface AgentRecommendation {
	type: AgentType
	priority: "required" | "recommended" | "optional"
	reason: string
}

interface ResourceEstimation {
	estimatedDuration: number // æ€»é¢„è®¡æ—¶é•¿ï¼ˆç§’ï¼‰
	estimatedTokens: number // é¢„è®¡ Token æ¶ˆè€—
	requiredAgents: number // éœ€è¦çš„ä»£ç†æ•°é‡
	parallelizableRatio: number // å¯å¹¶è¡ŒåŒ–æ¯”ä¾‹ (0-1)
}
```

#### 3.1.2 ä»»åŠ¡åˆ†è§£å¼•æ“

```typescript
class TaskDecompositionEngine {
	// å°†å¤æ‚ä»»åŠ¡åˆ†è§£ä¸ºå­ä»»åŠ¡
	decompose(task: ComplexTask, analysis: TaskAnalysis): DecomposedTask {
		const subtasks: Subtask[] = []

		// 1. åˆ›å»ºæ¶æ„è®¾è®¡å­ä»»åŠ¡ï¼ˆå¦‚æœéœ€è¦ï¼‰
		if (analysis.recommendedAgents.some((a) => a.type === "architect")) {
			subtasks.push({
				id: `${task.id}-architect`,
				name: "Architecture Design",
				agent: "architect",
				description: "Design overall system architecture and technical specifications",
				dependencies: [],
				priority: 1,
				estimatedDuration: 300,
			})
		}

		// 2. åˆ›å»ºä»£ç å®ç°å­ä»»åŠ¡
		if (analysis.recommendedAgents.some((a) => a.type === "code-writer")) {
			const codeTask: Subtask = {
				id: `${task.id}-code`,
				name: "Code Implementation",
				agent: "code-writer",
				description: task.description,
				dependencies: subtasks.filter((t) => t.agent === "architect").map((t) => t.id),
				priority: 2,
				estimatedDuration: 180,
			}

			// å¦‚æœå¯ä»¥å¹¶è¡ŒåŒ–ï¼Œåˆ†è§£ä¸ºå¤šä¸ªä»£ç ä»»åŠ¡
			if (analysis.canParallelize && this.canSplitCode(task)) {
				const splitTasks = this.splitCodeTask(codeTask, task)
				subtasks.push(...splitTasks)
			} else {
				subtasks.push(codeTask)
			}
		}

		// 3. åˆ›å»ºæµ‹è¯•ç¼–å†™å­ä»»åŠ¡
		if (analysis.recommendedAgents.some((a) => a.type === "test-writer")) {
			const codeTasks = subtasks.filter((t) => t.agent === "code-writer")

			subtasks.push({
				id: `${task.id}-test`,
				name: "Test Writing",
				agent: "test-writer",
				description: "Write comprehensive test suites",
				dependencies: codeTasks.map((t) => t.id),
				priority: 3,
				estimatedDuration: 150,
			})
		}

		// 4. åˆ›å»ºæ–‡æ¡£ç¼–å†™å­ä»»åŠ¡
		if (analysis.recommendedAgents.some((a) => a.type === "documentation")) {
			subtasks.push({
				id: `${task.id}-doc`,
				name: "Documentation",
				agent: "documentation",
				description: "Create comprehensive documentation",
				dependencies: [], // å¯ä»¥ä¸ä»£ç ç¼–å†™å¹¶è¡Œ
				priority: 2,
				estimatedDuration: 120,
			})
		}

		// 5. åˆ›å»ºå®¡æŸ¥å­ä»»åŠ¡ï¼ˆæœ€åæ‰§è¡Œï¼‰
		if (analysis.recommendedAgents.some((a) => a.type === "review")) {
			subtasks.push({
				id: `${task.id}-review`,
				name: "Code Review",
				agent: "review",
				description: "Review all changes and provide feedback",
				dependencies: subtasks.filter((t) => t.agent !== "review").map((t) => t.id),
				priority: 4,
				estimatedDuration: 240,
			})
		}

		return {
			originalTask: task,
			subtasks,
			executionPlan: this.createExecutionPlan(subtasks),
		}
	}

	// åˆ›å»ºæ‰§è¡Œè®¡åˆ’ï¼ˆè€ƒè™‘ä¾èµ–å…³ç³»ï¼‰
	private createExecutionPlan(subtasks: Subtask[]): ExecutionPhase[] {
		const phases: ExecutionPhase[] = []
		const completed = new Set<string>()

		// æŒ‰ä¼˜å…ˆçº§å’Œä¾èµ–å…³ç³»åˆ†ç»„
		while (completed.size < subtasks.length) {
			const ready = subtasks.filter(
				(task) => !completed.has(task.id) && task.dependencies.every((dep) => completed.has(dep)),
			)

			if (ready.length === 0) {
				throw new Error("Circular dependency detected")
			}

			// åˆ›å»ºæ–°é˜¶æ®µ
			phases.push({
				phaseNumber: phases.length + 1,
				tasks: ready,
				canParallelize: ready.length > 1,
				estimatedDuration: Math.max(...ready.map((t) => t.estimatedDuration)),
			})

			// æ ‡è®°ä¸ºå·²å®Œæˆ
			ready.forEach((task) => completed.add(task.id))
		}

		return phases
	}
}

interface DecomposedTask {
	originalTask: ComplexTask
	subtasks: Subtask[]
	executionPlan: ExecutionPhase[]
}

interface Subtask {
	id: string
	name: string
	agent: AgentType
	description: string
	dependencies: string[]
	priority: number
	estimatedDuration: number
}

interface ExecutionPhase {
	phaseNumber: number
	tasks: Subtask[]
	canParallelize: boolean
	estimatedDuration: number
}
```

### 3.2 ä»»åŠ¡è°ƒåº¦å™¨

```typescript
class MultiAgentScheduler {
	private registry: AgentRegistry
	private decomposer: TaskDecompositionEngine
	private coordinator: AgentCoordinator

	// è°ƒåº¦å¤æ‚ä»»åŠ¡
	async schedule(task: ComplexTask): Promise<ScheduledExecution> {
		// 1. åˆ†æä»»åŠ¡
		const analysis = await this.analyzeTask(task)

		// 2. åˆ†è§£ä»»åŠ¡
		const decomposed = this.decomposer.decompose(task, analysis)

		// 3. åˆ†é…ä»£ç†
		const assignments = await this.assignAgents(decomposed)

		// 4. åˆ›å»ºæ‰§è¡Œè®¡åˆ’
		const execution: ScheduledExecution = {
			executionId: this.generateExecutionId(),
			originalTask: task,
			decomposed,
			assignments,
			status: "scheduled",
			startTime: null,
			endTime: null,
			phases: [],
		}

		return execution
	}

	// æ‰§è¡Œè°ƒåº¦è®¡åˆ’
	async execute(execution: ScheduledExecution): Promise<ExecutionResult> {
		execution.status = "running"
		execution.startTime = Date.now()

		try {
			// æŒ‰é˜¶æ®µæ‰§è¡Œ
			for (const phase of execution.decomposed.executionPlan) {
				const phaseResult = await this.executePhase(phase, execution.assignments)
				execution.phases.push(phaseResult)

				// å¦‚æœé˜¶æ®µå¤±è´¥ï¼Œå†³å®šæ˜¯å¦ç»§ç»­
				if (phaseResult.status === "failed" && !this.canContinue(phaseResult)) {
					throw new Error(`Phase ${phase.phaseNumber} failed: ${phaseResult.error}`)
				}
			}

			// æ•´åˆç»“æœ
			const result = await this.integrateResults(execution)

			execution.status = "completed"
			execution.endTime = Date.now()

			return result
		} catch (error) {
			execution.status = "failed"
			execution.endTime = Date.now()
			throw error
		}
	}

	// æ‰§è¡Œå•ä¸ªé˜¶æ®µ
	private async executePhase(phase: ExecutionPhase, assignments: Map<string, AgentInstance>): Promise<PhaseResult> {
		const results: SubtaskResult[] = []

		if (phase.canParallelize) {
			// å¹¶è¡Œæ‰§è¡Œ
			const promises = phase.tasks.map((task) => this.executeSubtask(task, assignments.get(task.id)!))
			results.push(
				...(await Promise.allSettled(promises).then((settled) =>
					settled.map((result, index) => ({
						subtask: phase.tasks[index],
						status: result.status === "fulfilled" ? "completed" : "failed",
						output: result.status === "fulfilled" ? result.value : null,
						error: result.status === "rejected" ? result.reason : null,
					})),
				)),
			)
		} else {
			// é¡ºåºæ‰§è¡Œ
			for (const task of phase.tasks) {
				try {
					const output = await this.executeSubtask(task, assignments.get(task.id)!)
					results.push({
						subtask: task,
						status: "completed",
						output,
						error: null,
					})
				} catch (error) {
					results.push({
						subtask: task,
						status: "failed",
						output: null,
						error: error instanceof Error ? error.message : String(error),
					})
					break // é¡ºåºæ‰§è¡Œæ—¶ï¼Œå¤±è´¥åˆ™åœæ­¢
				}
			}
		}

		return {
			phase,
			results,
			status: results.every((r) => r.status === "completed") ? "completed" : "failed",
			startTime: Date.now(),
			endTime: Date.now() + phase.estimatedDuration * 1000,
		}
	}

	// æ‰§è¡Œå•ä¸ªå­ä»»åŠ¡
	private async executeSubtask(subtask: Subtask, agent: AgentInstance): Promise<SubtaskOutput> {
		// æ›´æ–°ä»£ç†çŠ¶æ€
		agent.status = "busy"
		agent.currentTask = {
			subtaskId: subtask.id,
			startTime: Date.now(),
		}

		try {
			// è°ƒç”¨ä»£ç†æ‰§è¡Œä»»åŠ¡
			const output = await this.coordinator.delegateTask(agent, subtask)

			// æ›´æ–°ä»£ç†æŒ‡æ ‡
			agent.metrics.tasksCompleted++
			agent.history.push({
				subtaskId: subtask.id,
				status: "completed",
				duration: Date.now() - agent.currentTask.startTime,
				timestamp: Date.now(),
			})

			agent.status = "idle"
			agent.currentTask = null

			return output
		} catch (error) {
			// æ›´æ–°å¤±è´¥æŒ‡æ ‡
			agent.metrics.tasksFailed++
			agent.history.push({
				subtaskId: subtask.id,
				status: "failed",
				duration: Date.now() - agent.currentTask.startTime,
				timestamp: Date.now(),
				error: error instanceof Error ? error.message : String(error),
			})

			agent.status = "error"
			agent.currentTask = null

			throw error
		}
	}
}

interface ScheduledExecution {
	executionId: string
	originalTask: ComplexTask
	decomposed: DecomposedTask
	assignments: Map<string, AgentInstance>
	status: ExecutionStatus
	startTime: number | null
	endTime: number | null
	phases: PhaseResult[]
}

type ExecutionStatus = "scheduled" | "running" | "completed" | "failed" | "cancelled"

interface PhaseResult {
	phase: ExecutionPhase
	results: SubtaskResult[]
	status: "completed" | "failed"

	startTime: number
	endTime: number
}

interface SubtaskResult {
	subtask: Subtask
	status: "completed" | "failed"
	output: SubtaskOutput | null
	error: string | null
}
```

### 3.3 ä»£ç†åè°ƒå™¨

```typescript
class AgentCoordinator {
	private communicationHub: CommunicationHub
	private conflictResolver: ConflictResolver

	// å°†ä»»åŠ¡å§”æ‰˜ç»™ä»£ç†
	async delegateTask(agent: AgentInstance, subtask: Subtask): Promise<SubtaskOutput> {
		// 1. å‡†å¤‡ä¸Šä¸‹æ–‡
		const context = await this.prepareContext(subtask, agent)

		// 2. æ„å»ºæç¤ºè¯
		const prompt = this.buildPrompt(agent.profile, subtask, context)

		// 3. åˆ›å»º Task å®ä¾‹ï¼ˆå¤ç”¨ç°æœ‰ Task ç±»ï¼‰
		const task = new Task({
			provider: this.provider,
			apiConfiguration: this.apiConfiguration,
			customInstructions: agent.profile.promptTemplate,
			alwaysAllowReadOnly: agent.profile.toolGroups.includes("read"),
			// ... å…¶ä»–é…ç½®
		})

		// 4. æ‰§è¡Œä»»åŠ¡
		const result = await task.startTask(prompt)

		// 5. éªŒè¯è¾“å‡º
		const validated = await this.validateOutput(result, subtask, agent)

		return validated
	}

	// å‡†å¤‡ä¸Šä¸‹æ–‡ï¼ˆåŒ…å«ä¾èµ–ä»»åŠ¡çš„è¾“å‡ºï¼‰
	private async prepareContext(subtask: Subtask, agent: AgentInstance): Promise<AgentContext> {
		const context: AgentContext = {
			subtaskId: subtask.id,
			dependencies: [],
			sharedKnowledge: new Map(),
			collaborators: [],
		}

		// è·å–ä¾èµ–ä»»åŠ¡çš„è¾“å‡º
		for (const depId of subtask.dependencies) {
			const depOutput = await this.getDependencyOutput(depId)
			if (depOutput) {
				context.dependencies.push(depOutput)
			}
		}

		// è·å–å…±äº«çŸ¥è¯†åº“
		context.sharedKnowledge = await this.getSharedKnowledge(subtask.id)

		return context
	}

	// ä»£ç†é—´é€šä¿¡
	async communicate(from: AgentInstance, to: AgentInstance, message: AgentMessage): Promise<void> {
		await this.communicationHub.send({
			from: from.instanceId,
			to: to.instanceId,
			message,
			timestamp: Date.now(),
		})
	}
}

interface AgentContext {
	subtaskId: string
	dependencies: SubtaskOutput[]
	sharedKnowledge: Map<string, any>
	collaborators: AgentInstance[]
}

interface AgentMessage {
	type: "request" | "response" | "notification" | "handoff"
	content: string
	data?: any
}
```

---

## 4. åä½œåè®®

### 4.1 é€šä¿¡åè®®

#### 4.1.1 è®¾è®¡äº¤æ¥åè®®ï¼ˆDesign Handoffï¼‰

```typescript
interface DesignHandoff {
	type: "design-handoff"
	from: "architect"
	to: "code-writer" | "documentation"

	content: {
		// æ¶æ„è®¾è®¡æ–‡æ¡£
		architectureOverview: string

		// ç»„ä»¶å®šä¹‰
		components: ComponentSpec[]

		// æ¥å£å®šä¹‰
		interfaces: InterfaceSpec[]

		// æŠ€æœ¯æ ˆé€‰æ‹©
		techStack: TechStackDecision[]

		// éåŠŸèƒ½éœ€æ±‚
		nonFunctionalRequirements: NFR[]
	}
}

interface ComponentSpec {
	name: string
	purpose: string
	responsibilities: string[]
	interfaces: string[]
	dependencies: string[]
}

interface InterfaceSpec {
	name: string
	methods: MethodSpec[]
	properties: PropertySpec[]
}
```

#### 4.1.2 ä»£ç äº¤æ¥åè®®ï¼ˆCode Handoffï¼‰

```typescript
interface CodeHandoff {
	type: "code-handoff"
	from: "code-writer"
	to: "test-writer" | "review" | "documentation"

	content: {
		// ä¿®æ”¹çš„æ–‡ä»¶åˆ—è¡¨
		modifiedFiles: FileChange[]

		// æ–°å¢çš„åŠŸèƒ½
		newFeatures: FeatureDescription[]

		// éœ€è¦æµ‹è¯•çš„åœºæ™¯
		testScenarios: TestScenario[]

		// å·²çŸ¥é™åˆ¶
		limitations: string[]

		// ä¾èµ–æ›´æ–°
		dependencyChanges: DependencyChange[]
	}
}

interface FileChange {
	path: string
	changeType: "created" | "modified" | "deleted"
	linesAdded: number
	linesRemoved: number
	purpose: string
}
```

#### 4.1.3 å®¡æŸ¥åé¦ˆåè®®ï¼ˆReview Feedbackï¼‰

```typescript
interface ReviewFeedback {
	type: "review-feedback"
	from: "review"
	to: "code-writer" | "refactor"

	content: {
		// æ€»ä½“è¯„åˆ†
		overallScore: number // 0-100

		// åˆ†ç±»é—®é¢˜
		issues: ReviewIssue[]

		// æ”¹è¿›å»ºè®®
		suggestions: Suggestion[]

		// ä¼˜ç‚¹
		strengths: string[]

		// æ˜¯å¦éœ€è¦ä¿®æ”¹
		requiresChanges: boolean
	}
}

interface ReviewIssue {
	severity: "critical" | "major" | "minor"
	category: "correctness" | "performance" | "security" | "maintainability" | "style"
	location: FileLocation
	description: string
	suggestion: string
}

interface Suggestion {
	priority: "high" | "medium" | "low"
	description: string
	example?: string
}
```

### 4.2 å†²çªè§£å†³æœºåˆ¶

```typescript
class ConflictResolver {
	// æ£€æµ‹ä»£ç†é—´çš„å†²çª
	detectConflicts(outputs: SubtaskOutput[]): Conflict[] {
		const conflicts: Conflict[] = []

		// 1. æ–‡ä»¶ä¿®æ”¹å†²çª
		const fileConflicts = this.detectFileConflicts(outputs)
		conflicts.push(...fileConflicts)

		// 2. API ä¸ä¸€è‡´
		const apiConflicts = this.detectAPIConflicts(outputs)
		conflicts.push(...apiConflicts)

		// 3. å‘½åå†²çª
		const namingConflicts = this.detectNamingConflicts(outputs)
		conflicts.push(...namingConflicts)

		return conflicts
	}

	// è§£å†³å†²çª
	async resolve(conflict: Conflict): Promise<ConflictResolution> {
		switch (conflict.type) {
			case "file-modification":
				return this.resolveFileConflict(conflict)

			case "api-inconsistency":
				return this.resolveAPIConflict(conflict)

			case "naming-conflict":
				return this.resolveNamingConflict(conflict)

			default:
				throw new Error(`Unknown conflict type: ${conflict.type}`)
		}
	}

	// è§£å†³æ–‡ä»¶ä¿®æ”¹å†²çª
	private async resolveFileConflict(conflict: Conflict): Promise<ConflictResolution> {
		// ç­–ç•¥ 1ï¼šæ—¶é—´æˆ³ä¼˜å…ˆ
		if (this.config.strategy === "timestamp") {
			return this.resolveByTimestamp(conflict)
		}

		// ç­–ç•¥ 2ï¼šä¼˜å…ˆçº§ä¼˜å…ˆ
		if (this.config.strategy === "priority") {
			return this.resolveByPriority(conflict)
		}

		// ç­–ç•¥ 3ï¼šåˆå¹¶ç­–ç•¥
		if (this.config.strategy === "merge") {
			return this.resolveByMerge(conflict)
		}

		// ç­–ç•¥ 4ï¼šäººå·¥ä»‹å…¥
		return this.requestHumanIntervention(conflict)
	}

	// ä¸‰æ–¹åˆå¹¶
	private async resolveByMerge(conflict: Conflict): Promise<ConflictResolution> {
		const { original, versions } = conflict

		// ä½¿ç”¨ git çš„ä¸‰æ–¹åˆå¹¶ç®—æ³•
		const merged = await this.threeWayMerge(original, versions)

		if (merged.hasConflicts) {
			// å¦‚æœä»æœ‰å†²çªï¼Œè¯·æ±‚äººå·¥ä»‹å…¥
			return this.requestHumanIntervention(conflict)
		}

		return {
			resolved: true,
			strategy: "merge",
			result: merged.content,
			message: "Successfully merged conflicting changes",
		}
	}
}

interface Conflict {
	type: "file-modification" | "api-inconsistency" | "naming-conflict"
	involvedAgents: AgentInstance[]
	description: string
	severity: "low" | "medium" | "high"
	original?: any
	versions: any[]
}

interface ConflictResolution {
	resolved: boolean
	strategy: string
	result: any
	message: string
	requiresHumanReview?: boolean
}
```

---

## 5. ç»“æœæ•´åˆç­–ç•¥

### 5.1 æ•´åˆå¼•æ“

```typescript
class ResultIntegrationEngine {
  // æ•´åˆæ‰€æœ‰ä»£ç†çš„è¾“å‡º
  async integrate(execution: ScheduledExecution): Promise<IntegratedResult> {
    const outputs = this.collectOutputs(execution)

    // 1. æ£€æµ‹å†²çª
    const conflicts = await this.conflictResolver.detectConflicts(outputs)

    // 2. è§£å†³å†²çª
    const resolutions = await Promise.all(
      conflicts.map(c => this.conflictResolver.resolve(c))
    )

    // 3. åˆå¹¶è¾“å‡º
    const merged = await this.mergeOutputs(outputs, resolutions)

    // 4. éªŒè¯å®Œæ•´æ€§
    const validation = await this.validateIntegrity(merged)

    // 5. ç”ŸæˆæŠ¥å‘Š
    const report = this.generateIntegrationReport(execution, merged, validation)

    return {
      merged,
      validation,
      report,
      conflicts: conflicts.length,
      resolutions
    }
  }

  // åˆå¹¶è¾“å‡º
  private async mergeOutputs(
    outputs: SubtaskOutput[],
    resolutions: ConflictResolution[]
  ): Promise<MergedOutput> {
    const merged: MergedOutput = {
      files: new Map(),
      documentation: [],
      testResults: [],
      metrics: {
        totalFiles: 0,
        linesAdded: 0,
        linesRemoved: 0,
        testsAdded: 0,
        coverage: 0
      }
    }

    // åˆå¹¶æ–‡ä»¶æ›´æ”¹
    for (const output of outputs) {
      if (output.type === 'code-change') {
        for (const [path, content] of output.files) {
          // åº”ç”¨å†²çªè§£å†³æ–¹æ¡ˆ
          const resolved = this.applyResolution(path, content, resolutions)
          merged.files.set(path, resolved)
          merged.metrics.totalFiles++
        }
      }

      // åˆå¹¶æ–‡æ¡£
      if (output.type === 'documentation') {
        merged.documentation.push(...output.documents)
      }

      // åˆå¹¶æµ‹è¯•ç»“æœ
      if (output.type === 'test-results') {
        merged.testResults.push(output.results)
        merged.metrics.testsAdded += output.results.testsCount
        merged.metrics.coverage = output.results.coverage
      }
    }

    return merged
  }

  // éªŒè¯å®Œæ•´æ€§
  private async validateIntegrity(merged: MergedOutput): Promise<ValidationResult> {
    const issues: ValidationIssue[] = []

    // 1. è¯­æ³•æ£€æŸ¥
    for (const [path, content] of merged.files) {
      const syntaxCheck = await this.checkSyntax(path, content)
      if (!syntaxCheck.valid) {
        issues.push({
          severity: 'error',
          file: path,
          message: 'Syntax error detected',
          details: syntaxCheck.error
        })
      }
    }

    // 2. ç±»å‹æ£€æŸ¥ï¼ˆTypeScriptï¼‰
    const typeCheck = await this.checkTypes(merged.files)
    if (!typeCheck.valid) {
      issues.push(...typeCheck.issues)
    }

    // 3. æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥
    if (merged.metrics.coverage < this.config.minCoverage) {
      issues.push({
        severity: 'warning',
        message: `Test coverage (${merged.metrics.coverage}%) below minimum (${this.config.minCoverage}%)`,
        suggestion: 'Add more tests'
      })
    }

    // 4. æ–‡æ¡£å®Œæ•´æ€§æ£€æŸ¥
    if (merged.documentation.length === 0 && this.config.requireDocumentation) {
      issues.push({
        severity: 'warning',
        message: 'No documentation generated',
        suggestion: 'Consider adding documentation'
      })
    }

    return {
      valid: issues.filter(i => i.severity === 'error').length === 0,
      issues,
      score: this.calculateQualityScore(merged, issues)
    }
  }

  // ç”Ÿæˆæ•´åˆæŠ¥å‘Š
  private generateIntegrationReport(
    execution: ScheduledExecution,
    merged: MergedOutput,
    validation: ValidationResult
  ): IntegrationReport {
    return {
      executionId: execution.executionId,
      summary: {
        totalAgents: execution.assignments.size,
        totalSubtasks: execution.decomposed.subtasks.length,
        completedSubtasks: execution.phases.flatMap(p => p.results).filter(r => r.status === 'completed').length,
        failedSubtasks: execution.phases.flatMap(p => p.results).filter(r => r.status === 'failed').length,
        totalDuration: execution.endTime! - execution.startTime!,
        filesModified: merged.metrics.totalFiles,
        linesChanged: merged.metrics.linesAdded + merged.metrics.linesRemoved,
        testsAdded: merged.metrics.testsAdded,
        coverage: merged.metrics.coverage
      },
      agentContributions: this.summarizeContributions(execution),
      validationResult: validation,
      recommendations: this.generateRecommendations(validation)
    }
  }
}

interface IntegratedResult {
  merged: MergedOutput
  validation: ValidationResult
  report: IntegrationReport
  conflicts: number
  resolutions: ConflictResolution[]
}

interface MergedOutput {
  files: Map<string, string>
  documentation: Document[]
  testResults: TestResult[]
  metrics: OutputMetrics
}

interface OutputMetrics {
  totalFiles: number
  linesAdded: number
  linesRemoved: number
  testsAdded: number
  coverage: number
}

interface Integration
Report {
  executionId: string
  summary: ExecutionSummary
  agentContributions: Map<AgentType, ContributionSummary>
  validationResult: ValidationResult
  recommendations: string[]
}
```

---

## 6. ä½¿ç”¨ç¤ºä¾‹

### 6.1 å®Œæ•´åŠŸèƒ½å¼€å‘

```
ç”¨æˆ·: @multi-agent å®ç°ä¸€ä¸ªç”¨æˆ·è®¤è¯ç³»ç»Ÿï¼ŒåŒ…æ‹¬æ³¨å†Œã€ç™»å½•ã€JWTéªŒè¯

ç³»ç»Ÿåˆ†æ:
ğŸ“Š ä»»åŠ¡åˆ†æå®Œæˆ
- ä»»åŠ¡ç±»å‹: Feature Development
- æ¨èä»£ç†: Architect, CodeWriter, TestWriter, Documentation, Review
- é¢„è®¡è€—æ—¶: 25-30 åˆ†é’Ÿ
- å¯å¹¶è¡ŒåŒ–: æ˜¯

æ‰§è¡Œè®¡åˆ’:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 1: Architecture Design (å¹¶å‘: å¦)                      â”‚
â”‚   ğŸ—ï¸ Architect â†’ è®¾è®¡ç³»ç»Ÿæ¶æ„å’ŒAPIæ¥å£                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Phase 2: Implementation (å¹¶å‘: æ˜¯)                           â”‚
â”‚   ğŸ’» CodeWriter-1 â†’ å®ç°ç”¨æˆ·æ³¨å†ŒåŠŸèƒ½                         â”‚
â”‚   ğŸ’» CodeWriter-2 â†’ å®ç°ç™»å½•å’ŒJWTéªŒè¯                        â”‚
â”‚   ğŸ“š Documentation â†’ ç¼–å†™APIæ–‡æ¡£                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Phase 3: Testing (å¹¶å‘: å¦)                                  â”‚
â”‚   ğŸ§ª TestWriter â†’ ç¼–å†™å…¨é¢çš„æµ‹è¯•å¥—ä»¶                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Phase 4: Review (å¹¶å‘: å¦)                                   â”‚
â”‚   ğŸ‘ï¸ Reviewer â†’ ä»£ç å®¡æŸ¥å’Œè´¨é‡æ£€æŸ¥                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ˜¯å¦å¼€å§‹æ‰§è¡Œï¼Ÿ [ç¡®è®¤] [ä¿®æ”¹] [å–æ¶ˆ]

ç”¨æˆ·: ç¡®è®¤

æ‰§è¡Œä¸­...
[Phase 1/4] ğŸ—ï¸ Architect æ­£åœ¨è®¾è®¡æ¶æ„... âœ“ å®Œæˆ (5åˆ†é’Ÿ)
[Phase 2/4] å¹¶è¡Œæ‰§è¡Œä¸­...
  ğŸ’» CodeWriter-1: ç”¨æˆ·æ³¨å†Œ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 80%
  ğŸ’» CodeWriter-2: ç™»å½•JWT â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 75%
  ğŸ“š Documentation: APIæ–‡æ¡£ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100% âœ“

... (ç»§ç»­æ‰§è¡Œ) ...

å®ŒæˆæŠ¥å‘Š:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ‰ å¤šä»£ç†ä»»åŠ¡å®Œæˆ                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ä»£ç†è´¡çŒ®:                                                    â”‚
â”‚   ğŸ—ï¸ Architect: æ¶æ„è®¾è®¡æ–‡æ¡£                                â”‚
â”‚   ğŸ’» CodeWriter-1: src/auth/register.ts (+150è¡Œ)            â”‚
â”‚   ğŸ’» CodeWriter-2: src/auth/login.ts (+120è¡Œ)               â”‚
â”‚   ğŸ“š Documentation: docs/auth-api.md                         â”‚
â”‚   ğŸ§ª TestWriter: tests/auth/*.test.ts (+200è¡Œ, 95%è¦†ç›–ç‡)   â”‚
â”‚   ğŸ‘ï¸ Reviewer: å®¡æŸ¥é€šè¿‡ï¼Œ2ä¸ªå°å»ºè®®                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ è´¨é‡æŒ‡æ ‡:                                                    â”‚
â”‚   âœ“ æ‰€æœ‰æµ‹è¯•é€šè¿‡ (18/18)                                    â”‚
â”‚   âœ“ æµ‹è¯•è¦†ç›–ç‡: 95%                                         â”‚
â”‚   âœ“ ä»£ç å®¡æŸ¥è¯„åˆ†: 88/100                                    â”‚
â”‚   âš  2ä¸ªæ”¹è¿›å»ºè®®                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[æŸ¥çœ‹è¯¦ç»†æŠ¥å‘Š] [åº”ç”¨å®¡æŸ¥å»ºè®®] [å…³é—­]
```

### 6.2 ä»£ç é‡æ„é¡¹ç›®

```
ç”¨æˆ·: @multi-agent é‡æ„ src/legacy/ ç›®å½•ä¸‹çš„æ‰€æœ‰ä»£ç ï¼Œæå‡å¯ç»´æŠ¤æ€§

ç³»ç»Ÿ:
æ£€æµ‹åˆ° 23 ä¸ªæ–‡ä»¶éœ€è¦é‡æ„
æ¨èç­–ç•¥: Refactor + Review åä½œ

æ‰§è¡Œè®¡åˆ’:
- Phase 1: åˆ†æç°æœ‰ä»£ç  (Debug Agent)
- Phase 2: æ‰¹é‡é‡æ„ (3ä¸ª Refactor Agents å¹¶å‘)
- Phase 3: æµ‹è¯•éªŒè¯ (TestWriter Agent)
- Phase 4: è´¨é‡å®¡æŸ¥ (Review Agent)

é¢„è®¡: 35-40 åˆ†é’Ÿ
```

---

## 7. å¼€å‘è®¡åˆ’

### 7.1 å®æ–½è·¯çº¿å›¾

**ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€è®¾æ–½ (3å‘¨)**

- [ ] ä»£ç†æ³¨å†Œè¡¨å®ç°
- [ ] ä»»åŠ¡åˆ†æå™¨
- [ ] ä»»åŠ¡åˆ†è§£å¼•æ“
- [ ] åŸºæœ¬è°ƒåº¦å™¨

**ç¬¬äºŒé˜¶æ®µï¼šæ ¸å¿ƒä»£ç† (4å‘¨)**

- [ ] ArchitectAgent
- [ ] CodeWriterAgent
- [ ] TestWriterAgent
- [ ] DocumentationAgent
- [ ] RefactorAgent
- [ ] ReviewAgent

**ç¬¬ä¸‰é˜¶æ®µï¼šåä½œæœºåˆ¶ (3å‘¨)**

- [ ] é€šä¿¡åè®®å®ç°
- [ ] å†²çªæ£€æµ‹
- [ ] å†²çªè§£å†³
- [ ] ç»“æœæ•´åˆ

**ç¬¬å››é˜¶æ®µï¼šUI/ç›‘æ§ (2å‘¨)**

- [ ] å¤šä»£ç†æ‰§è¡Œé¢æ¿
- [ ] å®æ—¶è¿›åº¦å¯è§†åŒ–
- [ ] ä»£ç†æ€§èƒ½ç›‘æ§
- [ ] æ•´åˆæŠ¥å‘Šç”Ÿæˆ

**æ€»è®¡ï¼š12å‘¨ (3ä¸ªæœˆ)**

---

## 8. æˆåŠŸæŒ‡æ ‡

### åŠŸèƒ½æŒ‡æ ‡

- âœ… æ”¯æŒ 6+ ç§ä¸“èŒä»£ç†
- âœ… ä»»åŠ¡åˆ†è§£å‡†ç¡®ç‡ > 90%
- âœ… å¹¶å‘æ‰§è¡Œæ•ˆç‡æå‡ 3-5å€
- âœ… å†²çªè‡ªåŠ¨è§£å†³ç‡ > 80%

### è´¨é‡æŒ‡æ ‡

- âœ… æ•´åˆç»“æœè´¨é‡è¯„åˆ† > 85/100
- âœ… ä»£ç†é—´é€šä¿¡æˆåŠŸç‡ > 95%
- âœ… ç³»ç»Ÿç¨³å®šæ€§ï¼ˆæ— å´©æºƒï¼‰
- âœ… ä»£ç è¦†ç›–ç‡ > 85%

### ç”¨æˆ·ä½“éªŒæŒ‡æ ‡

- âœ… ä»»åŠ¡é…ç½®æ—¶é—´ < 2åˆ†é’Ÿ
- âœ… æ‰§è¡Œç›‘æ§æ¸…æ™°ç›´è§‚
- âœ… é”™è¯¯ä¿¡æ¯å‡†ç¡®æœ‰ç”¨
- âœ… ç”¨æˆ·æ»¡æ„åº¦ > 4.2/5.0

---

## 9. æ€»ç»“

### 9.1 æ ¸å¿ƒä¼˜åŠ¿

1. **ä¸“ä¸šåˆ†å·¥**ï¼šæ¯ä¸ªä»£ç†ä¸“æ³¨äºç‰¹å®šé¢†åŸŸï¼Œæé«˜è¾“å‡ºè´¨é‡
2. **å¹¶å‘æ‰§è¡Œ**ï¼šå¤šä»£ç†å¹¶è¡Œå·¥ä½œï¼Œå¤§å¹…ç¼©çŸ­äº¤ä»˜æ—¶é—´
3. **æ™ºèƒ½åè°ƒ**ï¼šè‡ªåŠ¨ä»»åŠ¡åˆ†è§£å’Œå†²çªè§£å†³ï¼Œå‡å°‘äººå·¥å¹²é¢„
4. **è´¨é‡ä¿è¯**ï¼šå†…ç½®å®¡æŸ¥æœºåˆ¶ï¼Œç¡®ä¿è¾“å‡ºç¬¦åˆæ ‡å‡†
5. **å¯æ‰©å±•æ€§**ï¼šè½»æ¾æ·»åŠ æ–°ç±»å‹çš„ä¸“èŒä»£ç†

### 9.2 ä¸ç°æœ‰åŠŸèƒ½çš„ååŒ

```
å¤šä»£ç†åä½œç³»ç»Ÿ = å­ä»»åŠ¡æœºåˆ¶ + æ‰¹é‡æ¨¡å¼ + è£åˆ¤æ¨¡å¼ + æ™ºèƒ½åè°ƒ

- å­ä»»åŠ¡æœºåˆ¶ â†’ æä¾›ä»»åŠ¡åˆ†è§£åŸºç¡€
- æ‰¹é‡æ¨¡å¼ â†’ æä¾›å¹¶å‘æ‰§è¡Œèƒ½åŠ›
- è£åˆ¤æ¨¡å¼ â†’ æä¾›è´¨é‡å®¡æŸ¥æœºåˆ¶
- æ™ºèƒ½åè°ƒ â†’ ç²˜åˆä»¥ä¸ŠåŠŸèƒ½ï¼Œå½¢æˆå®Œæ•´ç³»ç»Ÿ
```

### 9.3 æœªæ¥æ„¿æ™¯

**çŸ­æœŸ (6ä¸ªæœˆ)**

- æ”¯æŒ 10+ ç§ä¸“èŒä»£ç†
- è‡ªå­¦ä¹ çš„ä»»åŠ¡åˆ†è§£å™¨
- æ›´æ™ºèƒ½çš„å†²çªè§£å†³

**ä¸­æœŸ (12ä¸ªæœˆ)**

- ä»£ç†å¸‚åœºï¼ˆç¤¾åŒºè´¡çŒ®ä»£ç†ï¼‰
- è·¨é¡¹ç›®çŸ¥è¯†å…±äº«
- ä»£ç†æ€§èƒ½ä¼˜åŒ–å™¨

**é•¿æœŸ (18+ ä¸ªæœˆ)**

- è‡ªä¸»å­¦ä¹ å‹ä»£ç†
- ä»£ç†é—´çš„æ·±åº¦åä½œ
- ä¼ä¸šçº§å¤šä»£ç†ç¼–æ’å¹³å°

---

## é™„å½• Aï¼šä»£ç†æ¨¡æ¿

### è‡ªå®šä¹‰ä»£ç†æ¨¡æ¿

```typescript
// ç”¨æˆ·å¯ä»¥åˆ›å»ºè‡ªå®šä¹‰ä»£ç†
const CUSTOM_AGENT_TEMPLATE: AgentProfile = {
	id: "custom-translator-001",
	type: "translator", // è‡ªå®šä¹‰ç±»å‹
	name: "ğŸŒ i18n Translator",
	description: "ä¸“æ³¨äºå›½é™…åŒ–å’Œæœ¬åœ°åŒ–ç¿»è¯‘",

	skills: ["translation"],
	toolGroups: ["read", "edit"],

	promptTemplate: `You are an i18n specialist. Your role is to:
- Extract translatable strings from code
- Translate strings to target languages
- Maintain translation consistency
- Follow i18n best practices

Key principles:
- Preserve placeholders and formatting
- Consider cultural context
- Use appropriate tone and terminology
- Maintain consistency across translations`,

	maxConcurrency: 3,
	averageExecutionTime: 180,
	successRate: 0.9,

	canCooperate: true,
	preferredPartners: ["documentation", "review"],
	communicationProtocol: "translation-review",
}
```

---

## é™„å½• Bï¼šé…ç½®ç¤ºä¾‹

### å®Œæ•´ç³»ç»Ÿé…ç½®

```json
{
	"multiAgent": {
		"enabled": true,
		"maxConcurrentAgents": 8,
		"defaultAgents": ["architect", "code-writer", "test-writer", "review"],

		"taskAnalysis": {
			"autoDecompose": true,
			"minSubtasks": 2,
			"maxSubtasks": 10,
			"parallelizationThreshold": 0.3
		},

		"scheduling": {
			"strategy": "priority-based",
			"considerDependencies": true,
			"optimizeForSpeed": true
		},

		"conflictResolution": {
			"strategy": "merge",
			"fallbackToHuman": true,
			"autoResolveThreshold": 0.8
		},

		"integration": {
			"validateSyntax": true,
			"validateTypes": true,
			"minCoverage": 80,
			"requireDocumentation": false
		},

		"monitoring": {
			"realTimeProgress": true,
			"detailedLogs": true,
			"performanceMetrics": true
		}
	}
}
```

---

## é™„å½• Cï¼šAPIå‚è€ƒ

### å¯åŠ¨å¤šä»£ç†ä»»åŠ¡

```typescript
// API: å¯åŠ¨å¤šä»£ç†åä½œä»»åŠ¡
interface MultiAgentAPI {
	// åˆ†æä»»åŠ¡
	analyzeTask(description: string): Promise<TaskAnalysis>

	// åˆ›å»ºæ‰§è¡Œè®¡åˆ’
	createExecutionPlan(task: ComplexTask, options?: ExecutionOptions): Promise<ScheduledExecution>

	// æ‰§è¡Œä»»åŠ¡
	execute(execution: ScheduledExecution): Promise<ExecutionResult>

	// è·å–æ‰§è¡ŒçŠ¶æ€
	getStatus(executionId: string): Promise<ExecutionStatus>

	// æš‚åœ/æ¢å¤/å–æ¶ˆ
	pause(executionId: string): Promise<void>
	resume(executionId: string): Promise<void>
	cancel(executionId: string): Promise<void>

	// æ³¨å†Œè‡ªå®šä¹‰ä»£ç†
	registerAgent(profile: AgentProfile): Promise<void>

	// åˆ—å‡ºå¯ç”¨ä»£ç†
	listAgents(): Promise<AgentProfile[]>
}
```

---

## æ–‡æ¡£ç»“æŸ

**ç¼–å†™è€…**: Roo AI Assistant  
**ç‰ˆæœ¬**: 1.0.0  
**æœ€åæ›´æ–°**: 2025-10-10

æ­¤æ–‡æ¡£å®šä¹‰äº† Roo-Code å¤šä»£ç†åä½œç³»ç»Ÿçš„å®Œæ•´æ¶æ„å’Œå®æ–½æ–¹æ¡ˆï¼Œæ•´åˆäº†ç°æœ‰çš„å­ä»»åŠ¡æœºåˆ¶ã€æ‰¹é‡æ¨¡å¼å’Œè£åˆ¤æ¨¡å¼ï¼Œå½¢æˆäº†ä¸€ä¸ªå¼ºå¤§è€Œçµæ´»çš„å¤šä»£ç†ç¼–æ’å¹³å°ã€‚
